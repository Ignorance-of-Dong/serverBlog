{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/headers.png","path":"images/headers.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/crash_cheat.js","path":"js/src/crash_cheat.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1548503139647},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1548503139647},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1548503139648},{"_id":"themes/next/.gitignore","hash":"ee0b13c268cc8695d3883a5da84930af02d4ed08","modified":1548503139653},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1548503139653},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1548503139654},{"_id":"themes/next/.javascript_ignore","hash":"cd250ad74ca22bd2c054476456a73d9687f05f87","modified":1548503139654},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1548503139654},{"_id":"themes/next/.travis.yml","hash":"6674fbdfe0d0c03b8a04527ffb8ab66a94253acd","modified":1548503139655},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1548503139655},{"_id":"themes/next/README.cn.md","hash":"23e92a2599725db2f8dbd524fbef2087c6d11c7b","modified":1548503139656},{"_id":"themes/next/README.md","hash":"50abff86ffe4113051a409c1ed9261195d2aead0","modified":1548503139657},{"_id":"themes/next/_config.yml","hash":"65ef66e7e355d7a2b4dc2bceb9a0b107ec335728","modified":1569551189026},{"_id":"themes/next/bower.json","hash":"486ebd72068848c97def75f36b71cbec9bb359c5","modified":1548503139658},{"_id":"themes/next/package.json","hash":"3963ad558a24c78a3fd4ef23cf5f73f421854627","modified":1548503139764},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1548503139659},{"_id":"source/_posts/CreatObject.md","hash":"f2f467fba0367410f0000be92c2908608794028d","modified":1553862610179},{"_id":"source/_posts/Downgrade.md","hash":"c4ec003a951747701ebb443e1618c44c10dd00d7","modified":1553863481777},{"_id":"source/_posts/JSevent.md","hash":"cd0f6ba66a3ac35317dda59d3baa7cc0e71e5d8d","modified":1553862599445},{"_id":"source/_posts/Hooks.md","hash":"cbe715b6dc6c4a7b35970e75549799e0e2fae025","modified":1565231508097},{"_id":"source/_posts/Linux.md","hash":"3ca0535eff68b56a58c2d1ce7e03c5b7f8aecce1","modified":1553736324227},{"_id":"source/_posts/MVVM.md","hash":"a371575455cfa0e1625b63e27c599c2d95a73b00","modified":1562659849999},{"_id":"source/_posts/New Router.md","hash":"a482fb0873806933790e002e7226222ea63c8f67","modified":1548678785442},{"_id":"source/_posts/Sortt.md","hash":"1efc905131d0974f96b23cf4e3e303aaa36d3326","modified":1554081294634},{"_id":"source/_posts/PureComponent.md","hash":"25243468403d43dca28ca815649d53d8f973f266","modified":1554257107536},{"_id":"source/_posts/ajax-task.md","hash":"4541a643ae8ca3082d1f671182f0ef9c26b9a464","modified":1554470900952},{"_id":"source/_posts/all.md","hash":"bdb4054f08051a293a753f42271cb6bed86bea43","modified":1562659571886},{"_id":"source/_posts/axios.md","hash":"5f2b94bc01b0e5f8e8c7a88831e62e356b90ec42","modified":1550644078338},{"_id":"source/_posts/clone.md","hash":"ff454b985debd49e7e4f98b0a5452dd914fe9617","modified":1553850026640},{"_id":"source/_posts/cors.md","hash":"d975318390d08f13458e1ab4d21b276f02b62d5e","modified":1550468630669},{"_id":"source/_posts/debouce.md","hash":"1bdb779762c5613e81f5e33c4d7d98164465a00f","modified":1550737174305},{"_id":"source/_posts/extend.md","hash":"01aead24057f466370ebcc4c286e86790209155a","modified":1553862605956},{"_id":"source/_posts/fetch.md","hash":"15762b93ba9f43d81fbd1e08b5cb69830d50e731","modified":1553137866945},{"_id":"source/_posts/gao de map.md","hash":"8fe7242b0f85c27758016579dc3c90829a5f4135","modified":1551013205924},{"_id":"source/_posts/gzipmd.md","hash":"ad56a77ad2fde6ecd0fcfc6c7d65e290224322a8","modified":1553742230036},{"_id":"source/_posts/index.md","hash":"41bfeb8a4e3df99b1d8e784313e2f2268aa9911a","modified":1548588617005},{"_id":"source/_posts/json web token.md","hash":"75bc06a489728297fe811b93835330992269af69","modified":1551066584591},{"_id":"source/_posts/koa.md","hash":"195aaf68ae6166f677a848765448404b963f9528","modified":1569548147259},{"_id":"source/_posts/minxins.md","hash":"ebd6e7cc8243c7a23bbff84fa310e3d2e748e474","modified":1554172985716},{"_id":"source/_posts/mvc.md","hash":"37e8330ec1c9d0e6067566fb0dca53322f0d45fc","modified":1550468597468},{"_id":"source/_posts/mysql.md","hash":"09bb9d26bcbf23bfd93dabc909909702a0d80d0d","modified":1553736190405},{"_id":"source/_posts/ngsinx.md","hash":"4d943530830e52cd6cd0a03c43ad9d875b1d1ae6","modified":1553736174976},{"_id":"source/_posts/node_zip.md","hash":"cb334325c914f27a60c4382e8af58fba86a3edea","modified":1569548125554},{"_id":"source/_posts/nodemd.md","hash":"c162161d93cf21eedf222ce49d0cf2fc2bee6f9b","modified":1553736156586},{"_id":"source/_posts/optimization.md","hash":"67565b60944c5352cd5867e860555e5f1245296b","modified":1553862603144},{"_id":"source/_posts/px2rem.md","hash":"35893a7dbe3d60630faa4a801dbf1094313ecdcc","modified":1548499944692},{"_id":"source/_posts/react-native unlink.md","hash":"5bc7b7f84d24387318f003257468ffd1c5cd5f0c","modified":1558692436623},{"_id":"source/_posts/react-native-windows.md","hash":"7e68fb7c966f69a3471eac9f9a74061a3a1d7e60","modified":1562661589153},{"_id":"source/_posts/react-optimization.md","hash":"cdf233a132fcb906942ba6c5670957125052a857","modified":1554281219491},{"_id":"source/_posts/react-question.md","hash":"1d0c480f10a9d11ea4b78588d41350ddcbb70c62","modified":1554271956154},{"_id":"source/_posts/react-router.md","hash":"c7a20a73b6cfb7ff4c2d706d1e01a015f1780ec8","modified":1554289801553},{"_id":"source/_posts/react-task.md","hash":"c63ddde60f0284eeec7877df8caf07d395700c00","modified":1554254115195},{"_id":"source/_posts/sass.md","hash":"10b66087d36ef8787a5ee810c16f0a1890753558","modified":1548483088195},{"_id":"source/_posts/session.md","hash":"5c744c0550976ac803379309cd489cb4ee9dcf64","modified":1550462407802},{"_id":"source/_posts/redux.md","hash":"548fb3c37c6fffabe8551e840490796207fe9350","modified":1554467023906},{"_id":"source/_posts/stack heap.md","hash":"5dc99c32856593348e6ec05d50838e13448dcec3","modified":1562662344887},{"_id":"source/_posts/setState.md","hash":"f9e993b1d26c186d8c372ff77dd184a0b2d49d1a","modified":1562662254881},{"_id":"source/_posts/transition.md","hash":"755db058160fa717283c402dc0a8b6951ee04b93","modified":1548567666535},{"_id":"source/_posts/ts-01.md","hash":"224fba0de66159b37482b1e6c3a010571bf5c7fc","modified":1557999387642},{"_id":"source/_posts/ts-02.md","hash":"05e97ce68fc7a5b57b31329f49544690d1daa47e","modified":1557999407159},{"_id":"source/_posts/virtualDom1 .md","hash":"c951f380f7eeaf1c0da2b0740cc8120aca68546f","modified":1554275382574},{"_id":"source/_posts/vue block.md","hash":"8317d25fef148e2a831a1228f7f75f03612aadad","modified":1548679588506},{"_id":"source/_posts/vue extend.md","hash":"d97c5d7a23bf77a378190a8d0842eb845a2f9e59","modified":1548732610135},{"_id":"source/_posts/vue slot-scope.md","hash":"a680518e800664b4fd91705f62353ab1d9d65e80","modified":1548485917138},{"_id":"source/_posts/vue-directive.md","hash":"8a6b34672f3c5a163326974aa66f71902758dd87","modified":1554172978879},{"_id":"source/_posts/vue-dom.md","hash":"348696cbe528319eb604b47dd41a46edea243733","modified":1548567660239},{"_id":"source/_posts/vue-react-diff.md","hash":"e34cbe3241fe8a5b1f81f9eb922a0029e30b18b6","modified":1554176882046},{"_id":"source/_posts/vue-router-beforeEach.md","hash":"493391470d2b9ad94e87837026187c82aa146d2d","modified":1554168412783},{"_id":"source/_posts/vue-router-left.md","hash":"7ab1376c8d1626a6254f041648dbe1926b6bc4a6","modified":1554173111240},{"_id":"source/_posts/vue.md","hash":"93296392a1c80135142c74c3731b3c509ebb8709","modified":1554191315373},{"_id":"source/_posts/vuex.md","hash":"ff8ce514cb8c7ad962b6c1897095cf28c0e0fac3","modified":1548849019114},{"_id":"source/_posts/web server.md","hash":"73aaf181b62fa872bb7e13eb8bab46ae5f293f4f","modified":1550468612829},{"_id":"source/_posts/wpy-cascade.md","hash":"0931e8a94196d12a7f3500abe3ed6fe75ee14485","modified":1553493190676},{"_id":"source/categories/index-1.md","hash":"24e2568260d68c6a034b76603c7c6d322a45c1e5","modified":1553740323609},{"_id":"source/categories/index.md","hash":"af1d537ae9a24f6f5de80f17347318774c3adfe4","modified":1548503843148},{"_id":"source/about/index.md","hash":"ecd1a6e7d35c5dd3ad21ae4f4704f3821359d49b","modified":1548567955905},{"_id":"source/guestbook/index.md","hash":"c1569acc6733bf9fc79f3fe1537c4e34c477a2f4","modified":1553497112426},{"_id":"source/tags/index.md","hash":"383e66fa73153610af29dfb6ee4b59e106c9ec62","modified":1548503825070},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5adfad3ef1b870063e621bc0838268eb2c7c697a","modified":1548503139650},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"a0a82dbfabdef9a9d7c17a08ceebfb4052d98d81","modified":1548503139650},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1228506a940114288d61812bfe60c045a0abeac1","modified":1548503139651},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1548503139652},{"_id":"themes/next/languages/de.yml","hash":"fd02d9c2035798d5dc7c1a96b4c3e24b05b31a47","modified":1548503139661},{"_id":"themes/next/languages/en.yml","hash":"2f4b4776ca1a08cc266a19afb0d1350a3926f42c","modified":1548503139662},{"_id":"themes/next/languages/default.yml","hash":"1c95eebc227b67c6bcb49bcf327a4f61ace2bfae","modified":1548568777591},{"_id":"themes/next/languages/fr-FR.yml","hash":"efeeb55d5c4add54ad59a612fc0630ee1300388c","modified":1548503139663},{"_id":"themes/next/languages/id.yml","hash":"dccae33e2a5b3c9f11c0e05ec4a7201af1b25745","modified":1548503139663},{"_id":"themes/next/languages/it.yml","hash":"a215d016146b1bd92cef046042081cbe0c7f976f","modified":1548503139664},{"_id":"themes/next/languages/ko.yml","hash":"dc8f3e8c64eb7c4bb2385025b3006b8efec8b31d","modified":1548503139666},{"_id":"themes/next/languages/ja.yml","hash":"37f954e47a3bc669620ca559e3edb3b0072a4be5","modified":1548503139665},{"_id":"themes/next/languages/nl-NL.yml","hash":"213e7a002b82fb265f69dabafbbc382cfd460030","modified":1548503139666},{"_id":"themes/next/languages/pt-BR.yml","hash":"568d494a1f37726a5375b11452a45c71c3e2852d","modified":1548503139667},{"_id":"themes/next/languages/pt.yml","hash":"2efcd240c66ab1a122f061505ca0fb1e8819877b","modified":1548503139668},{"_id":"themes/next/languages/ru.yml","hash":"e33ee44e80f82e329900fc41eb0bb6823397a4d6","modified":1548503139669},{"_id":"themes/next/languages/zh-Hans.yml","hash":"66b9b42f143c3cb2f782a94abd4c4cbd5fd7f55f","modified":1553497582248},{"_id":"themes/next/languages/vi.yml","hash":"a9b89ebd3e5933033d1386c7c56b66c44aca299a","modified":1548503139669},{"_id":"themes/next/languages/zh-hk.yml","hash":"fe0d45807d015082049f05b54714988c244888da","modified":1548503139672},{"_id":"themes/next/languages/zh-tw.yml","hash":"432463b481e105073accda16c3e590e54c8e7b74","modified":1548503139672},{"_id":"themes/next/layout/_layout.swig","hash":"9135eb99b6dd75ebc54b6b2d08e7dbf97e5cde77","modified":1558920344217},{"_id":"themes/next/layout/archive.swig","hash":"9a2c14874a75c7085d2bada5e39201d3fc4fd2b4","modified":1548503139760},{"_id":"themes/next/layout/category.swig","hash":"3cbb3f72429647411f9e85f2544bdf0e3ad2e6b2","modified":1548503139761},{"_id":"themes/next/layout/index.swig","hash":"d5e103b115dc3730a0be9fd18f1d269e23445865","modified":1548728255868},{"_id":"themes/next/layout/page.swig","hash":"e8fcaa641d46930237675d2ad4b56964d9e262e9","modified":1548503139762},{"_id":"themes/next/layout/post.swig","hash":"7a6ce102ca82c3a80f776e555dddae1a9981e1ed","modified":1548503139762},{"_id":"themes/next/layout/schedule.swig","hash":"87ad6055df01fa2e63e51887d34a2d8f0fbd2f5a","modified":1548503139763},{"_id":"themes/next/layout/tag.swig","hash":"34e1c016cbdf94a31f9c5d494854ff46b2a182e9","modified":1548503139764},{"_id":"themes/next/scripts/merge-configs.js","hash":"38d86aab4fc12fb741ae52099be475196b9db972","modified":1548503139766},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1548503139767},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1548503139968},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1548503139969},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1548503139970},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1548503139856},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1548503139674},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1548503139673},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1548503139676},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"c5df31993b5ad23c91110f2ed0e16c5659c4e0bc","modified":1569550687182},{"_id":"themes/next/layout/_macro/post.swig","hash":"510120481258abfff33a2d77b809378229b0313e","modified":1548679888297},{"_id":"themes/next/layout/_macro/reward.swig","hash":"357d86ec9586705bfbb2c40a8c7d247a407db21a","modified":1548503139716},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"9c7343fd470e0943ebd75f227a083a980816290b","modified":1548503139717},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"e2e4eae391476da994045ed4c7faf5e05aca2cd7","modified":1548503139717},{"_id":"themes/next/layout/_partials/footer.swig","hash":"a772c1dba09f792d6dad2059a2a58c9bfab0fdb6","modified":1569549351814},{"_id":"themes/next/layout/_partials/head.swig","hash":"1bc2dc897b334c3350cea71e0c37cf97ae112d7b","modified":1548850276947},{"_id":"themes/next/layout/_partials/comments.swig","hash":"1abe9d288c1010556a3ccf8507c47edcca32eb9d","modified":1548759139400},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1548503139722},{"_id":"themes/next/layout/_partials/header.swig","hash":"c54b32263bc8d75918688fb21f795103b3f57f03","modified":1548503139721},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1548503139722},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1548503139723},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1548503139729},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1548503139730},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9be624634703be496a5d2535228bc568a8373af9","modified":1548503139734},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1548503139750},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1548503139750},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1548503139751},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"fa882641da3bd83d9a58a8a97f9d4c62a9ee7b5c","modified":1548503139751},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1548503139752},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1548503139752},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1548503139753},{"_id":"themes/next/scripts/tags/button.js","hash":"eddbb612c15ac27faf11c59c019ce188f33dec2c","modified":1548503139769},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1548503139769},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1548503139770},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1548503139771},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1548503139772},{"_id":"themes/next/scripts/tags/label.js","hash":"6f00952d70aadece844ce7fd27adc52816cc7374","modified":1548503139772},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1548503139773},{"_id":"themes/next/scripts/tags/note.js","hash":"f7eae135f35cdab23728e9d0d88b76e00715faa0","modified":1548503139773},{"_id":"themes/next/scripts/tags/tabs.js","hash":"aa7fc94a5ec27737458d9fe1a75c0db7593352fd","modified":1548503139774},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1548503139855},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1548503139857},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1548503139857},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1548503139858},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1548503139859},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1548503139861},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1548503139862},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1548503139862},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1548503139863},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1548503139863},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1548503139864},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1548503139864},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1548503139865},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1548503139865},{"_id":"themes/next/source/images/headers.png","hash":"4f3fd302f674ce41654dcb59360b19f98abe057d","modified":1569302337352},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1548503139866},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1548503139866},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1548503139867},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1548503139868},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1548503139867},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1548503139732},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1548503139732},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1548503139833},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1548503139832},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1548503139835},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1548503139853},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1548503139854},{"_id":"themes/next/layout/_partials/comments/livere.ejs","hash":"415c922ef5ab108a283aa79f80da965d855090a2","modified":1548758987803},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1548503139720},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"ff7b230fd8184dbcc7e55a65e831353e6944bed2","modified":1548741064253},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1548503139724},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1548503139725},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1548503139726},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1548503139724},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1548503139727},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1548503139727},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"0a9cdd6958395fcdffc80ab60f0c6301b63664a5","modified":1548503139728},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1548503139731},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1548503139732},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1548503139733},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1548503139735},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1548503139737},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1548503139736},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"7b11eac3a0685fa1ab2ab6ecff60afc4f15f0d16","modified":1548503139737},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1548503139738},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1548503139738},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"ccc443b22bd4f8c7ac4145664686c756395b90e0","modified":1548503139739},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1548503139739},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1548503139740},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e6d10ee4fb70b3ae1cd37e9e36e000306734aa2e","modified":1548503139741},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1548503139742},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1548503139743},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1548503139742},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1548503139744},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1548503139745},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1548503139745},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"4dcc3213c033994d342d02b800b6229295433d30","modified":1548503139746},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1548503139747},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"493bd5999a1061b981922be92d8277a0f9152447","modified":1548503139747},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"9246162d4bc7e949ce1d12d135cbbaf5dc3024ec","modified":1548503139748},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"4aa36a48d25aaa92325eabde8892935b931d655f","modified":1548741042385},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"7e65ff8fe586cd655b0e9d1ad2912663ff9bd36c","modified":1548503139749},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1548503139759},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1548503139756},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1548503139758},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"93479642fd076a1257fecc25fcf5d20ccdefe509","modified":1548503139757},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1548503139832},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"7896c3ee107e1a8b9108b6019f1c070600a1e8cc","modified":1548503139834},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0e55cbd93852dc3f8ccb44df74d35d9918f847e0","modified":1548503139834},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"5c5686b1abf65d198a663493f71480b9d690711c","modified":1548552015264},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"58e7dd5947817d9fc30770712fc39b2f52230d1e","modified":1548503139852},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1548503139852},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4069f918ccc312da86db6c51205fc6c6eaabb116","modified":1548503139853},{"_id":"themes/next/source/css/_variables/base.styl","hash":"b1f6ea881a4938a54603d68282b0f8efb4d7915d","modified":1548503139854},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1548503139869},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1548503139869},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1548503139870},{"_id":"themes/next/source/js/src/crash_cheat.js","hash":"6f591d464f9c633b486bcb88bf66f31356b1f7d9","modified":1558920351486},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"0289031200c3d4c2bdd801ee10fff13bb2c353e4","modified":1548503139870},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1548503139871},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1548503139872},{"_id":"themes/next/source/js/src/motion.js","hash":"885176ed51d468f662fbf0fc09611f45c7e5a3b1","modified":1548503139872},{"_id":"themes/next/source/js/src/post-details.js","hash":"93a18271b4123dd8f94f09d1439b47c3c19a8712","modified":1548503139873},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1548503139874},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1548503139875},{"_id":"themes/next/source/js/src/utils.js","hash":"b3e9eca64aba59403334f3fa821f100d98d40337","modified":1548503139876},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1548503139886},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1548503139890},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"9be892a4e14e0da18ff9cb962c9ef71f163b1b22","modified":1548503139893},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"672d3b5767e0eacd83bb41b188c913f2cf754793","modified":1548503139894},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"b02737510e9b89aeed6b54f89f602a9c24b06ff2","modified":1548503139891},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1548503139909},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1548503139910},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1548503139911},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1548503139911},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1548503139912},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1548503139904},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1548503139905},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1548503139905},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1548503139906},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1548503139932},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1548503139932},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1548503139933},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1548503139933},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1548503139934},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1548503139934},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1548503139930},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"14264a210bf94232d58d7599ea2ba93bfa4fb458","modified":1548503139936},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"e33aa8fa48b6639d8d8b937d13261597dd473b3a","modified":1548503139936},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"2ce5f3bf15c523b9bfc97720d8884bb22602a454","modified":1548503139937},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"2d9a9f38c493fdf7c0b833bb9184b6a1645c11b2","modified":1548503139948},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"46a50b91c98b639c9a2b9265c5a1e66a5c656881","modified":1548503139949},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1548503139950},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1548503139938},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1548503139938},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1548503139939},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1548503139940},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1548503139940},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1548503139941},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1548503139941},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1548503139943},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1548503139944},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1548503139945},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1548503139946},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1548503139946},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"8aaa675f577d5501f5f22d5ccb07c2b76310b690","modified":1548503139947},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1548503139947},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1548503139960},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1548503139961},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1548503139965},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1548503139966},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1548503139967},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1548503139931},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1548503139754},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1548503139755},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1548503139777},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1548503139777},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1548503139779},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1548503139778},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1548503139780},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1548503139792},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1548503139811},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"24ee4b356ff55fc6e58f26a929fa07750002cf29","modified":1548503139826},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1548503139824},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1548503139827},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"91ca75492cd51f2553f4d294ed2f48239fcd55eb","modified":1548503139828},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1548503139829},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1548503139829},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1548503139830},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"60fa84aa7731760f05f52dd7d8f79b5f74ac478d","modified":1548503139836},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1548503139837},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1548503139837},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1548503139839},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1548503139838},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"9c99034f8e00d47e978b3959f51eb4a9ded0fcc8","modified":1548503139839},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1548503139839},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1548503139840},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1548503139848},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"416988dca389e6e2fdfa51fa7f4ee07eb53f82fb","modified":1548503139849},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1548503139850},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1548503139849},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"ad2dcedf393ed1f3f5afd2508d24969c916d02fc","modified":1548503139850},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1548503139843},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1548503139844},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1548503139851},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"e695e58f714129ca292c2e54cd62c251aca7f7fe","modified":1548503139844},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1548503139845},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1548503139846},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"f1d0b5d7af32c423eaa8bb93ab6a0b45655645dc","modified":1548503139874},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"6d586bfcfb7ae48f1b12f76eec82d3ad31947501","modified":1548503139885},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"16b03db23a52623348f37c04544f2792032c1fb6","modified":1548503139886},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1548503139895},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1548503139895},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1548503139897},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1548503139897},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1548503139896},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1548503139898},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1548503139902},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1548503139903},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1548503139904},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1548503139913},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1548503139914},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1548503139915},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1548503139907},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1548503139908},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1548503139958},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1548503139959},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"6c26cdb36687d4f0a11dabf5290a909c3506be5c","modified":1548503139883},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"4ac683b2bc8531c84d98f51b86957be0e6f830f3","modified":1548503139884},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1548503139928},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1548503139929},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1548503139964},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1548503139782},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"9f73c4696f0907aa451a855444f88fc0698fa472","modified":1548503139781},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1548503139783},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1548503139783},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1548503139784},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1548503139785},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1548503139786},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"50450d9fdc8a2b2be8cfca51e3e1a01ffd636c0b","modified":1548503139786},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1548503139788},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1548503139787},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1548503139789},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1548503139789},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1548503139790},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1548503139791},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1548503139794},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1548503139794},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1548503139795},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1548503139796},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"a6c6eb8adba0a090ad1f4b9124e866887f20d10d","modified":1548503139797},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d0d7a5c90d62b685520d2b47fea8ba6019ff5402","modified":1548503139798},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1548503139797},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"ca88ea6999a61fb905eb6e72eba5f92d4ee31e6e","modified":1548503139800},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1548503139799},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1548503139800},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1548503139801},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"ccb34c52be8adba5996c6b94f9e723bd07d34c16","modified":1548503139802},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1548503139802},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"7968343e41f8b94b318c36289dff1196c3eb1791","modified":1548503139803},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"89d6c3b697efc63de42afd2e89194b1be14152af","modified":1548503139803},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"39f04c4c7237a4e10acd3002331992b79945d241","modified":1548503139804},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1548503139805},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1548503139806},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"e4f05358d3de51f845c08fe39febe40a2aed3a5a","modified":1548585866494},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1548503139807},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1548503139807},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"c8fe49a4bc014c24dead05b782a7082411a4abc5","modified":1548503139808},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1548503139808},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1548503139810},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"5ef6343835f484a2c0770bd1eb9cc443609e4c39","modified":1548503139809},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1548503139812},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1548503139812},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"f825da191816eef69ea8efb498a7f756d5ebb498","modified":1548503139813},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1548503139813},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1548503139814},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1548503139814},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1548503139815},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1548503139816},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1548503139817},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"b80604868e4f5cf20fccafd7ee415c20c804f700","modified":1548503139816},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1548503139818},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1548503139818},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1548503139820},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1548503139819},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1548503139821},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1548503139821},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1548503139822},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1548503139823},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9c8196394a89dfa40b87bf0019e80144365a9c93","modified":1548503139823},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1548503139841},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1548503139842},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1548503139847},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1548503139879},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1548503139879},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1548503139880},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1548503139881},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1548503139882},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1548503139899},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1548503139900},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1548503139901},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1548503139900},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1548503139902},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1548503139918},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1548503139899},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1548503139920},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1548503139927},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1548503139889},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1548503139924},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1548503139956},{"_id":"public/baidusitemap.xml","hash":"fc9a6297f08b81ec918745fc8595aea474f527c4","modified":1569551260644},{"_id":"public/sitemap.xml","hash":"017af09f7b9ae24a827639f3929f3903ba17b119","modified":1569551260644},{"_id":"public/search.xml","hash":"84ad2ad5de5ff1c9a8d4065d2128f4c8d0afb166","modified":1569551260649},{"_id":"public/categories/index-1.html","hash":"7d925383409ae1ffd88d93e913cb073233924f9f","modified":1569551267608},{"_id":"public/categories/index.html","hash":"85900cf6ce906bc3ce8ab1ea1d379313be5c5cbd","modified":1569551267608},{"_id":"public/guestbook/index.html","hash":"fde7a2c468d043ba71e8590ff1d2a967237f08a9","modified":1569551267649},{"_id":"public/tags/index.html","hash":"9a2209db05b83f792d50810f03dc2dbd2a4fd60c","modified":1569551267649},{"_id":"public/2019/09/26/koa/index.html","hash":"1cb55e0d63d2fd249d019d543945398ce5f9670c","modified":1569551267649},{"_id":"public/about/index.html","hash":"ec67d0cfb6cd5913ec12eb3b14b91ff64b4636e2","modified":1569551267649},{"_id":"public/2019/08/10/node_zip/index.html","hash":"e395652a4057fbba045e697453e817e127e2cbc7","modified":1569551267649},{"_id":"public/2019/08/08/Hooks/index.html","hash":"158e717d9dfc8b4512bc2818a5e8f30a4159925f","modified":1569551267649},{"_id":"public/2019/05/24/react-native unlink/index.html","hash":"19a465efc179fc05f8127c453e0eb0d8982a8003","modified":1569551267649},{"_id":"public/2019/05/22/react-native-windows/index.html","hash":"bf4b6cba171932c2e9b856f2f9e894579a7387c9","modified":1569551267649},{"_id":"public/2019/05/16/ts-02/index.html","hash":"672f5337e0acbb201b3fbc2e4f24dae048b1a623","modified":1569551267649},{"_id":"public/2019/05/10/ts-01/index.html","hash":"9f1355c7c3a6c4d2b93b994d9f9284f5c67813c2","modified":1569551267649},{"_id":"public/2019/04/05/ajax-task/index.html","hash":"0a2d9c320e848a8f6704c69d5c0349ddb61cb4d3","modified":1569551267662},{"_id":"public/2019/04/05/redux/index.html","hash":"6a797b3d9bb89ebdc7d9584fb8cd43fce326fda0","modified":1569551267662},{"_id":"public/2019/04/03/react-task/index.html","hash":"d9ce2325d9549a44ec297f812688a3e467edb221","modified":1569551267662},{"_id":"public/2019/04/03/react-router/index.html","hash":"7290774363166ccecff55f7ed98175f09bed5098","modified":1569551267662},{"_id":"public/2019/04/03/react-optimization/index.html","hash":"1f15789e40cf8369cbc2cdd97eb16e7773295d9c","modified":1569551267662},{"_id":"public/2019/04/03/virtualDom1 /index.html","hash":"faa02239e4bc853f7c5c242d557c665a0b3a0270","modified":1569551267662},{"_id":"public/2019/04/03/react-question/index.html","hash":"0b7cf76270be9699ad11140c0c44692a47c84660","modified":1569551267662},{"_id":"public/2019/04/03/setState/index.html","hash":"421f42df89a85a18e9d9cd81625699b240ecf16e","modified":1569551267663},{"_id":"public/2019/04/03/PureComponent/index.html","hash":"9f73c7a8dc3667523ef290ccd04ce66dd2f4fc6f","modified":1569551267663},{"_id":"public/2019/04/02/minxins/index.html","hash":"ef82180be517c540af6c5fc2c166bf2337d84436","modified":1569551267663},{"_id":"public/2019/04/02/vue-directive/index.html","hash":"df09b66bbd99281bc9c2baf64dd0bc9cc79e2715","modified":1569551267663},{"_id":"public/2019/04/02/vue-router-beforeEach/index.html","hash":"142b0b08a810f121e32869419601a11ac2dbeb5c","modified":1569551267663},{"_id":"public/2019/04/01/vue-react-diff/index.html","hash":"12f75c0a64d8d841babf1d8ccb688585ed309b40","modified":1569551267663},{"_id":"public/2019/04/01/vue-router-left/index.html","hash":"831bed9be5019279eadb1a962cedbe160daadce2","modified":1569551267663},{"_id":"public/2019/04/01/Sortt/index.html","hash":"41b9203a00294f34b2b9d0bb6ea9a104ae987cf8","modified":1569551267663},{"_id":"public/2019/03/29/Downgrade/index.html","hash":"9bc5e23c23abe449c7c6f63f3adcf8141c39eb47","modified":1569551267663},{"_id":"public/2019/03/29/optimization/index.html","hash":"1e908462949a442498b05a5d23b8c15ca1f59977","modified":1569551267663},{"_id":"public/2019/03/29/CreatObject/index.html","hash":"2203ef33899cabd3d8c7e8004f8a70a13a59ad0c","modified":1569551267663},{"_id":"public/2019/03/29/extend/index.html","hash":"9058e5d903b5102bdb0a8d1a4c14eb0788a2dbf0","modified":1569551267663},{"_id":"public/2019/03/29/JSevent/index.html","hash":"2892b3e0a14ed05b19db5c2e9ad6fa3fec8a7794","modified":1569551267663},{"_id":"public/2019/03/29/clone/index.html","hash":"69346468494d44d0c23d4eef5f9b1ee6f609a820","modified":1569551267663},{"_id":"public/2019/03/28/gzipmd/index.html","hash":"0ca05e6b2228e2dee73cc51f9139ef21d6c6e299","modified":1569551267663},{"_id":"public/2019/03/28/ngsinx/index.html","hash":"b23c9d652ffb21d735c46de4d493d57b52c6b484","modified":1569551267663},{"_id":"public/2019/03/28/mysql/index.html","hash":"036b807fc5202ab9df82c05c3879b265bcbfd52d","modified":1569551267663},{"_id":"public/2019/03/28/nodemd/index.html","hash":"8d0f940a87c9b34737b369f1762070a9f386702e","modified":1569551267663},{"_id":"public/2019/03/27/Linux/index.html","hash":"86d1f70af7f64d218476866782d3b25d8a9efab5","modified":1569551267663},{"_id":"public/2019/03/24/wpy-cascade/index.html","hash":"a15339fd748444e005198712a7e430dd216ca528","modified":1569551267664},{"_id":"public/2019/03/14/fetch/index.html","hash":"e446ce66368c5e4eb2d37f937ce02fd4d9eb4355","modified":1569551267664},{"_id":"public/2019/03/04/stack heap/index.html","hash":"bdd2d9361ce202ab67ca1759a0952f381c9abbe0","modified":1569551267664},{"_id":"public/2019/03/03/MVVM/index.html","hash":"44aeab2473bbcbc3b2f9c354c80734fbc1a77863","modified":1569551267664},{"_id":"public/2019/02/25/json web token/index.html","hash":"19f98e7f78480f90a89035d1daadbe271eb5baa6","modified":1569551267664},{"_id":"public/2019/02/22/gao de map/index.html","hash":"e83ecd965553ea53cb4dfe34a4f1512bf6391ffb","modified":1569551267664},{"_id":"public/2019/02/21/debouce/index.html","hash":"d36a065d6053e79b2f5e0ddbb8bb24562e724426","modified":1569551267664},{"_id":"public/2019/02/20/axios/index.html","hash":"afb06b9bd0b19b900c451e7eceea9f96c84f918a","modified":1569551267664},{"_id":"public/2019/02/18/session/index.html","hash":"65b8d0c0f7b10521b873b5a6c2a1bc5f075d5927","modified":1569551267664},{"_id":"public/2019/02/17/mvc/index.html","hash":"c5c660e4c2cb622265929134138d8b5dc76b72da","modified":1569551267664},{"_id":"public/2019/02/13/cors/index.html","hash":"518a4de36a0907dbdf3b52a894e07a5eb9f6a8cb","modified":1569551267664},{"_id":"public/2019/02/12/web server/index.html","hash":"b78b761b03f90e3c45c104a767f2e55e49ad0854","modified":1569551267664},{"_id":"public/2019/01/30/vuex/index.html","hash":"a939880dd2a2b4d56291d86f98fdc8f4a44d3d86","modified":1569551267664},{"_id":"public/2019/01/28/New Router/index.html","hash":"6befe567490c4c68b8778b4c2c86dd38f145bcc6","modified":1569551267664},{"_id":"public/2019/01/28/vue extend/index.html","hash":"b31a004205e0139b98043220dab655adbc6b031c","modified":1569551267664},{"_id":"public/2019/01/28/vue block/index.html","hash":"8182f2c6883bcea27901887f950d5558447f199c","modified":1569551267664},{"_id":"public/2019/01/27/vue-dom/index.html","hash":"84aca4bf624a9196a39b78ce59f4382f0b1c2281","modified":1569551267664},{"_id":"public/2019/01/27/transition/index.html","hash":"5ea9bace0e0d08104637698d14e919c2b3d2af9b","modified":1569551267664},{"_id":"public/2019/01/25/all/index.html","hash":"2fb77a5a466b21b4f918f3ed6fb6c0cdc4ce03a4","modified":1569551267665},{"_id":"public/2019/01/25/index/index.html","hash":"79540d72db10ffb54e59797f8954b69dd2708ab8","modified":1569551267665},{"_id":"public/2019/01/25/px2rem/index.html","hash":"4774cb32c5d4d4d165c0cf7e544827b427df6744","modified":1569551267665},{"_id":"public/2019/01/25/vue/index.html","hash":"3ad453bb218fdf49b5e10f3ef0e629fcd683e129","modified":1569551267665},{"_id":"public/2018/08/04/vue slot-scope/index.html","hash":"dab7a7c236b1c39fff52770c1ff2175ecd7c9bdb","modified":1569551267665},{"_id":"public/2018/08/04/sass/index.html","hash":"e3bb3f54e217a4c8ce490941d8f172d07cf8bb5a","modified":1569551267665},{"_id":"public/archives/index.html","hash":"1dc437ba62511a1cb5ac45079f04e5d900bf94c8","modified":1569551267665},{"_id":"public/archives/page/2/index.html","hash":"8670eb88590669c85d0993a801184be22c98c774","modified":1569551267665},{"_id":"public/archives/page/3/index.html","hash":"f5b4ccfb7785c53d029576e8244e175e824f0b43","modified":1569551267665},{"_id":"public/archives/page/4/index.html","hash":"a5b4bce0c2724052858b7df727280c2247d66fd6","modified":1569551267665},{"_id":"public/archives/page/5/index.html","hash":"bc30a5085bb78e7ed163e71dc3e6d1c8924f0a1d","modified":1569551267665},{"_id":"public/archives/page/6/index.html","hash":"b17fac23d79978567de4388813d5658474ab6315","modified":1569551267665},{"_id":"public/archives/2018/index.html","hash":"23a4bd5cfe39094af9d799970c0c26e76fbececa","modified":1569551267665},{"_id":"public/archives/2018/08/index.html","hash":"971ad736bf794e132f0c72ba0170a8d807283b9d","modified":1569551267665},{"_id":"public/archives/2019/index.html","hash":"24118aac93722dfb539e25869aaee4390a10a6fa","modified":1569551267665},{"_id":"public/archives/2019/page/2/index.html","hash":"645a0612a6d21324af5d22c7ec23f051a975def4","modified":1569551267665},{"_id":"public/archives/2019/page/3/index.html","hash":"869e1202f734f73cac7f80825939d620347208c6","modified":1569551267665},{"_id":"public/archives/2019/page/4/index.html","hash":"63900295a9878429dafe5bf854e5103076537fa6","modified":1569551267665},{"_id":"public/archives/2019/page/5/index.html","hash":"69a6a86c3853d0355c6d7304ce35dca2042c52cd","modified":1569551267665},{"_id":"public/archives/2019/page/6/index.html","hash":"5bec176cc007eb0c5ec2f2c9171e1c3bd5327f0a","modified":1569551267666},{"_id":"public/archives/2019/01/index.html","hash":"3f8e7d7bc32da24a6b2b9aab764720195254b8cf","modified":1569551267666},{"_id":"public/archives/2019/02/index.html","hash":"b8bd02f5d6a258b5869a46515d802eac15d1d6d4","modified":1569551267666},{"_id":"public/archives/2019/03/index.html","hash":"976271f32a243f573042f81039c5e0599be489eb","modified":1569551267666},{"_id":"public/archives/2019/03/page/2/index.html","hash":"06cdb6eb34922faae103c5f51b25174484131a67","modified":1569551267666},{"_id":"public/archives/2019/04/index.html","hash":"3f028e92453e2a510f9b9afca357980fd80dd289","modified":1569551267666},{"_id":"public/archives/2019/04/page/2/index.html","hash":"cdfa52fa9bc8adf4d5d21924e7b46820aceba7d8","modified":1569551267666},{"_id":"public/archives/2019/05/index.html","hash":"ebf4ed707c7e7bb90b3681ef887933170ac36199","modified":1569551267666},{"_id":"public/archives/2019/08/index.html","hash":"ab2738a3ddff68618a497bd073c3829a6568cc5c","modified":1569551267666},{"_id":"public/index.html","hash":"4b685c8f2421390ff60e4321f41eaf8f2007533b","modified":1569551267666},{"_id":"public/archives/2019/09/index.html","hash":"d5a4397e0f3fc404b64d85a13c8e06c9c7c251e1","modified":1569551267666},{"_id":"public/page/3/index.html","hash":"e9410f2897ea5503b20e9b790ebd8c7d1ff326d9","modified":1569551267666},{"_id":"public/page/2/index.html","hash":"0e1e1e5529725dec82405c96a6c6918cf8275701","modified":1569551267666},{"_id":"public/page/4/index.html","hash":"c5d6cf567dc05dfc0d07b4ef1d2d4e222a005e54","modified":1569551267666},{"_id":"public/page/5/index.html","hash":"22db42f3c9d9a86175cb239d9c428f4cbaa509a1","modified":1569551267666},{"_id":"public/page/6/index.html","hash":"a44073bec04e674536f2b586b4db4816ba6c1911","modified":1569551267666},{"_id":"public/tags/js/index.html","hash":"783672f8ccc48e3e12edcbe9d75b204bfed49985","modified":1569551267666},{"_id":"public/tags/js/page/2/index.html","hash":"a90fdfef04b5a6dc01c026fb504d506d13beb2b5","modified":1569551267666},{"_id":"public/tags/js/page/3/index.html","hash":"c39af17f5377ead216bded45a4264a950172445d","modified":1569551267666},{"_id":"public/tags/js/page/4/index.html","hash":"0560f0774dfe2afc0ab823cf5c475501b3ab1e4c","modified":1569551267667},{"_id":"public/tags/object/index.html","hash":"a3279b5db6e625f7b8243b1cc93216af2950b1c9","modified":1569551267667},{"_id":"public/tags/兼容与优化/index.html","hash":"3a24c4a9b057c22e5aea8c1e7ba22c5e4da17e58","modified":1569551267667},{"_id":"public/tags/Event/index.html","hash":"3e0617bd9c492e86346601d70aed8f2b9626d83a","modified":1569551267667},{"_id":"public/tags/mvvm/index.html","hash":"e6e8f59fc94e86fa73f226eaa209be5cc30e1f8d","modified":1569551267667},{"_id":"public/tags/Linux/index.html","hash":"e31501e169935c51eaef049768b8bd04c88a0538","modified":1569551267667},{"_id":"public/tags/vue-router/index.html","hash":"90259da9c2e829679c8f8f901255510d6b56a29d","modified":1569551267667},{"_id":"public/tags/vue/index.html","hash":"4747beb0bcbb1d197ef2adc318fa86c385c077e9","modified":1569551267667},{"_id":"public/tags/vue/page/2/index.html","hash":"bc10f3786ed0d97d52110ee67991f3e5b1d2e712","modified":1569551267667},{"_id":"public/tags/sort/index.html","hash":"eaacac177081734619ce52e58830f3f6ec1204de","modified":1569551267667},{"_id":"public/tags/排序/index.html","hash":"cd4fb7742e4b0b59624d919fe2a274903e785c21","modified":1569551267667},{"_id":"public/tags/react/index.html","hash":"5571fe4aa83a05d8a8a38023ecfafedc3d07e5bc","modified":1569551267667},{"_id":"public/tags/ajax/index.html","hash":"bc36c6d7f3839d607f18c05c35812c6d416a2391","modified":1569551267667},{"_id":"public/tags/拷贝/index.html","hash":"71d2984705ccc417fd88a3a254783295222a1f92","modified":1569551267667},{"_id":"public/tags/axios/index.html","hash":"a0cb25a28c777f122f28233ccc9e8e514e8f298d","modified":1569551267667},{"_id":"public/tags/debouce/index.html","hash":"3ad4460809c313e704cb02add657c9c78d24616e","modified":1569551267667},{"_id":"public/tags/throttle/index.html","hash":"045a914d127e98ddbbfc7d88faa26a353a0194fd","modified":1569551267667},{"_id":"public/tags/cors/index.html","hash":"0adb54de506e9854739021a911998c13809bc859","modified":1569551267667},{"_id":"public/tags/跨域/index.html","hash":"90f0656500424c26f3b4f721fc727c6e8dd79759","modified":1569551267667},{"_id":"public/tags/jsonp/index.html","hash":"a3a217c26dd17893f996dfe066a9f28d3d65e7d7","modified":1569551267668},{"_id":"public/tags/定位/index.html","hash":"ef2dc87813a1eba6ffaddb574158b97129c7149f","modified":1569551267668},{"_id":"public/tags/fetch/index.html","hash":"b5b4ee5b058e5e873f2d459db561f9a2f26f2530","modified":1569551267668},{"_id":"public/tags/extend/index.html","hash":"40abf2da5fc709fbcd0d063a89c17f80ea6becfe","modified":1569551267668},{"_id":"public/tags/nginx/index.html","hash":"c987939135474cb0e04330772f5d30b153ace0fb","modified":1569551267668},{"_id":"public/tags/gzip/index.html","hash":"7fc798c5107120f5d1d8b9d8ab0949134e21e013","modified":1569551267668},{"_id":"public/tags/node/index.html","hash":"926276ba6baaf2698dfe88120e0bd9d6b5d81333","modified":1569551267668},{"_id":"public/tags/koa/index.html","hash":"c0f8db1a76bfdea671409f44db81cbd3182ebf25","modified":1569551267668},{"_id":"public/tags/json-web-token/index.html","hash":"9d7254b139d20f14b21c4e624ba84412a616151b","modified":1569551267668},{"_id":"public/tags/mysql/index.html","hash":"86ea899fe413db75aab5e2c576111ad76d39dc10","modified":1569551267668},{"_id":"public/tags/linux服务器配置/index.html","hash":"a20ff98a643da4f5bf0832b63c5385b0125fa3d2","modified":1569551267668},{"_id":"public/tags/mvc/index.html","hash":"f0283a9d86ec31a8382e31b33b8f503ba64e73ee","modified":1569551267668},{"_id":"public/tags/vue-cli/index.html","hash":"ea7374cddf87380d0ff8d3dbdf878f8f04eda49b","modified":1569551267668},{"_id":"public/tags/px2rem/index.html","hash":"680baa0d228b9e19c640f44f086560b94f332228","modified":1569551267668},{"_id":"public/tags/react-native/index.html","hash":"5bc321238799f54f5b6746df651be54f2d6c9065","modified":1569551267668},{"_id":"public/tags/session/index.html","hash":"5702387923a968e4e7993d1be2937f26a4d5e8ad","modified":1569551267668},{"_id":"public/tags/cookie/index.html","hash":"46272b95ffea1084e16eb3f031a96ae267272683","modified":1569551267668},{"_id":"public/tags/堆-栈/index.html","hash":"d16a2bcfad3ba55c795e646e97d15e488793cec8","modified":1569551267668},{"_id":"public/tags/transfrom/index.html","hash":"bfdcbf1af28646d8209cae6e3418aaddcce68618","modified":1569551267668},{"_id":"public/tags/scss/index.html","hash":"239609ed935064005a0859d923b2cddaa1c68bae","modified":1569551267668},{"_id":"public/tags/css/index.html","hash":"a4967169e7e868462fcce7caa0277ad439f72952","modified":1569551267668},{"_id":"public/tags/sass/index.html","hash":"b4f91709f07eccd0422db33051ce4c25a0e5f0b3","modified":1569551267669},{"_id":"public/tags/ts/index.html","hash":"8fcbea15df3df5641a3c8985e4a5f105f05b1bd7","modified":1569551267669},{"_id":"public/tags/vue全局组件/index.html","hash":"cb203ddd26d072ee4ae7d4787893f3d179a980e2","modified":1569551267669},{"_id":"public/tags/vue指令/index.html","hash":"45338d9f62b85992d6e9785ceaa7f463691ce12d","modified":1569551267669},{"_id":"public/tags/vue过滤器/index.html","hash":"00fef565db638fad39f4b703a1607a41e633eb03","modified":1569551267669},{"_id":"public/tags/vue构造器/index.html","hash":"0bc48a4e473a99856890c91970c856edd9cc4b65","modified":1569551267669},{"_id":"public/tags/directive/index.html","hash":"bd22cef4f068c571e420f92e20f48945a37e80fa","modified":1569551267669},{"_id":"public/tags/dom/index.html","hash":"c0dcd9a48577ac6615f6a39122db8377570d7d17","modified":1569551267669},{"_id":"public/tags/slot/index.html","hash":"19026c3b05d06080671d3ce82d1ba27a4033e2b8","modified":1569551267669},{"_id":"public/tags/vue-extend/index.html","hash":"22b96e2dab7f6586af6901ae435da38782ee6ed8","modified":1569551267669},{"_id":"public/tags/前后端交互/index.html","hash":"00fef6313238a75b07e8332cb9309db0f4768ca2","modified":1569551267669},{"_id":"public/tags/Restful/index.html","hash":"6e55d6d100899452e83fcdde172145568e1e8d23","modified":1569551267669},{"_id":"public/tags/瀑布流/index.html","hash":"10328e01e54449d88bb4290d41be0ba91f08e809","modified":1569551267669},{"_id":"public/tags/wx/index.html","hash":"94ab181eb30889f8424eb5542cdca26531af2ec4","modified":1569551267669},{"_id":"public/tags/vuex/index.html","hash":"852ba6ad1fb9234dd5351386765107ea307fe208","modified":1569551267669},{"_id":"public/tags/hooks/index.html","hash":"27b41f7bc391126e02165de41a3cde3cc993e724","modified":1569551267669},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1569551267669},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1569551267669},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1569551267669},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1569551267669},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1569551267669},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1569551267670},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1569551267670},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1569551267670},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1569551267670},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1569551267670},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1569551267670},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1569551267670},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1569551267670},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1569551267670},{"_id":"public/images/headers.png","hash":"4f3fd302f674ce41654dcb59360b19f98abe057d","modified":1569551267670},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1569551267670},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1569551267670},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1569551267670},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1569551267670},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1569551267670},{"_id":"public/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1569551267670},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1569551267670},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1569551267670},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1569551267670},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1569551267670},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1569551267670},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1569551267670},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1569551267670},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1569551267670},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1569551267670},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1569551267670},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1569551267670},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1569551267670},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1569551267670},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1569551268194},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1569551268198},{"_id":"public/js/src/crash_cheat.js","hash":"24c91c354dc3613704d24c2acac7e97488ba71f2","modified":1569551268209},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1569551268209},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1569551268210},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1569551268210},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1569551268210},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1569551268210},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1569551268211},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1569551268211},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1569551268211},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1569551268211},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1569551268211},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1569551268211},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1569551268211},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1569551268211},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1569551268211},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1569551268211},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1569551268211},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1569551268211},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1569551268211},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1569551268212},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1569551268212},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1569551268212},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1569551268212},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1569551268212},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1569551268212},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1569551268212},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1569551268212},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1569551268212},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1569551268212},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1569551268213},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1569551268213},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1569551268213},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1569551268213},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1569551268213},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1569551268213},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1569551268213},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1569551268213},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1569551268213},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1569551268213},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1569551268213},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1569551268213},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1569551268213},{"_id":"public/css/main.css","hash":"4b55a93846a5347c54d320bc0e84d3921f36c2d1","modified":1569551268213},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1569551268220},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1569551268220},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1569551268221},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1569551268221},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1569551268221},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1569551268221},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1569551268221},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1569551268222},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1569551268222},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1569551268222},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1569551268239},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1569551268239},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1569551268240},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1569551268282},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1569551268282},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1569551268390},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1569551268390},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1569551268392},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1569551268392},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1569551268392},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1569551268392},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1569551268392},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1569551268428},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1569551268428},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1569551268436},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1569551268436},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1569551269469},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1569551269700},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1569551269700},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1569551271243},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1569551271250},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1569551271287}],"Category":[],"Data":[],"Page":[{"title":"categories","date":"2019-03-28T02:32:03.000Z","_content":"","source":"categories/index-1.md","raw":"---\ntitle: categories\ndate: 2019-03-28 10:32:03\n---\n","updated":"2019-03-28T02:32:03.609Z","path":"categories/index-1.html","comments":1,"layout":"page","_id":"ck11iam600001n4wd2ovwzmoj","content":"","site":{"data":{}},"excerpt":"","more":""},{"date":"2018-03-11T08:17:14.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ndate: 2018-03-11 16:17:14\ntype: \"categories\"\ncomments: false\n---","updated":"2019-01-26T11:57:23.148Z","path":"categories/index.html","title":"","layout":"page","_id":"ck11iam630003n4wdt6cyodfm","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"guestbook","date":"2019-03-25T06:58:32.000Z","_content":"","source":"guestbook/index.md","raw":"---\ntitle: guestbook\ndate: 2019-03-25 14:58:32\n---\n","updated":"2019-03-25T06:58:32.426Z","path":"guestbook/index.html","comments":1,"layout":"page","_id":"ck11iam670006n4wdu6ujlf0e","content":"","site":{"data":{}},"excerpt":"","more":""},{"date":"2017-07-10T08:36:26.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ndate: 2017-07-10 16:36:26\ntype: \"tags\"\ncomments: false\n---","updated":"2019-01-26T11:57:05.070Z","path":"tags/index.html","title":"","layout":"page","_id":"ck11iam6a0008n4wdawlesfkc","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"关于我","type":"about","date":"2019-01-25T08:36:42.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"----------\n## 生活总是需要加油\n\n## 世界上有一群逆境中的人，他们充满自信，自强不息，努力进步，最终取得辉煌的成就。\n\n## 当一个人不再珍贵时，过去那种朋友聚集在一起，车水马龙的繁华景象突然消失，门前变得又冷又冷。\n\n## 对自己的不满是任何真正有才能的人的基本特征之一。\n\n## 不要害怕遇到风险。只有冒险，我们才能学会勇敢。\n\n## 只有出汗，我们才能享受财富；只有拒绝付出，我们才能变穷。\n\n## 有了自信和意志力，一个人有能力挑战自己，并且能够在世界上做任何他能做的事。人生最大的挑战是挑战自己，因为其他的敌人很容易克服，而自己最难克服。\n\n## 只有全力以赴，才能发挥最大的潜能。\n\n## 生活必须有一个计划，这样你的生活将永远不会偏离。\n\n## 要想成为一个世界上的奇迹，你必须在世界上走上几千英里。","source":"about/index.md","raw":"---\ntitle: 关于我\ntype: \"about\"\ndate: ' 1/25/2019 4:36:42 PM '\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n----------\n## 生活总是需要加油\n\n## 世界上有一群逆境中的人，他们充满自信，自强不息，努力进步，最终取得辉煌的成就。\n\n## 当一个人不再珍贵时，过去那种朋友聚集在一起，车水马龙的繁华景象突然消失，门前变得又冷又冷。\n\n## 对自己的不满是任何真正有才能的人的基本特征之一。\n\n## 不要害怕遇到风险。只有冒险，我们才能学会勇敢。\n\n## 只有出汗，我们才能享受财富；只有拒绝付出，我们才能变穷。\n\n## 有了自信和意志力，一个人有能力挑战自己，并且能够在世界上做任何他能做的事。人生最大的挑战是挑战自己，因为其他的敌人很容易克服，而自己最难克服。\n\n## 只有全力以赴，才能发挥最大的潜能。\n\n## 生活必须有一个计划，这样你的生活将永远不会偏离。\n\n## 要想成为一个世界上的奇迹，你必须在世界上走上几千英里。","updated":"2019-01-27T05:45:55.905Z","path":"about/index.html","comments":1,"layout":"page","_id":"ck11iam6d000bn4wdenkgapkt","content":"<hr>\n<h2 id=\"生活总是需要加油\"><a href=\"#生活总是需要加油\" class=\"headerlink\" title=\"生活总是需要加油\"></a>生活总是需要加油</h2><h2 id=\"世界上有一群逆境中的人，他们充满自信，自强不息，努力进步，最终取得辉煌的成就。\"><a href=\"#世界上有一群逆境中的人，他们充满自信，自强不息，努力进步，最终取得辉煌的成就。\" class=\"headerlink\" title=\"世界上有一群逆境中的人，他们充满自信，自强不息，努力进步，最终取得辉煌的成就。\"></a>世界上有一群逆境中的人，他们充满自信，自强不息，努力进步，最终取得辉煌的成就。</h2><h2 id=\"当一个人不再珍贵时，过去那种朋友聚集在一起，车水马龙的繁华景象突然消失，门前变得又冷又冷。\"><a href=\"#当一个人不再珍贵时，过去那种朋友聚集在一起，车水马龙的繁华景象突然消失，门前变得又冷又冷。\" class=\"headerlink\" title=\"当一个人不再珍贵时，过去那种朋友聚集在一起，车水马龙的繁华景象突然消失，门前变得又冷又冷。\"></a>当一个人不再珍贵时，过去那种朋友聚集在一起，车水马龙的繁华景象突然消失，门前变得又冷又冷。</h2><h2 id=\"对自己的不满是任何真正有才能的人的基本特征之一。\"><a href=\"#对自己的不满是任何真正有才能的人的基本特征之一。\" class=\"headerlink\" title=\"对自己的不满是任何真正有才能的人的基本特征之一。\"></a>对自己的不满是任何真正有才能的人的基本特征之一。</h2><h2 id=\"不要害怕遇到风险。只有冒险，我们才能学会勇敢。\"><a href=\"#不要害怕遇到风险。只有冒险，我们才能学会勇敢。\" class=\"headerlink\" title=\"不要害怕遇到风险。只有冒险，我们才能学会勇敢。\"></a>不要害怕遇到风险。只有冒险，我们才能学会勇敢。</h2><h2 id=\"只有出汗，我们才能享受财富；只有拒绝付出，我们才能变穷。\"><a href=\"#只有出汗，我们才能享受财富；只有拒绝付出，我们才能变穷。\" class=\"headerlink\" title=\"只有出汗，我们才能享受财富；只有拒绝付出，我们才能变穷。\"></a>只有出汗，我们才能享受财富；只有拒绝付出，我们才能变穷。</h2><h2 id=\"有了自信和意志力，一个人有能力挑战自己，并且能够在世界上做任何他能做的事。人生最大的挑战是挑战自己，因为其他的敌人很容易克服，而自己最难克服。\"><a href=\"#有了自信和意志力，一个人有能力挑战自己，并且能够在世界上做任何他能做的事。人生最大的挑战是挑战自己，因为其他的敌人很容易克服，而自己最难克服。\" class=\"headerlink\" title=\"有了自信和意志力，一个人有能力挑战自己，并且能够在世界上做任何他能做的事。人生最大的挑战是挑战自己，因为其他的敌人很容易克服，而自己最难克服。\"></a>有了自信和意志力，一个人有能力挑战自己，并且能够在世界上做任何他能做的事。人生最大的挑战是挑战自己，因为其他的敌人很容易克服，而自己最难克服。</h2><h2 id=\"只有全力以赴，才能发挥最大的潜能。\"><a href=\"#只有全力以赴，才能发挥最大的潜能。\" class=\"headerlink\" title=\"只有全力以赴，才能发挥最大的潜能。\"></a>只有全力以赴，才能发挥最大的潜能。</h2><h2 id=\"生活必须有一个计划，这样你的生活将永远不会偏离。\"><a href=\"#生活必须有一个计划，这样你的生活将永远不会偏离。\" class=\"headerlink\" title=\"生活必须有一个计划，这样你的生活将永远不会偏离。\"></a>生活必须有一个计划，这样你的生活将永远不会偏离。</h2><h2 id=\"要想成为一个世界上的奇迹，你必须在世界上走上几千英里。\"><a href=\"#要想成为一个世界上的奇迹，你必须在世界上走上几千英里。\" class=\"headerlink\" title=\"要想成为一个世界上的奇迹，你必须在世界上走上几千英里。\"></a>要想成为一个世界上的奇迹，你必须在世界上走上几千英里。</h2>","site":{"data":{}},"excerpt":"","more":"<hr>\n<h2 id=\"生活总是需要加油\"><a href=\"#生活总是需要加油\" class=\"headerlink\" title=\"生活总是需要加油\"></a>生活总是需要加油</h2><h2 id=\"世界上有一群逆境中的人，他们充满自信，自强不息，努力进步，最终取得辉煌的成就。\"><a href=\"#世界上有一群逆境中的人，他们充满自信，自强不息，努力进步，最终取得辉煌的成就。\" class=\"headerlink\" title=\"世界上有一群逆境中的人，他们充满自信，自强不息，努力进步，最终取得辉煌的成就。\"></a>世界上有一群逆境中的人，他们充满自信，自强不息，努力进步，最终取得辉煌的成就。</h2><h2 id=\"当一个人不再珍贵时，过去那种朋友聚集在一起，车水马龙的繁华景象突然消失，门前变得又冷又冷。\"><a href=\"#当一个人不再珍贵时，过去那种朋友聚集在一起，车水马龙的繁华景象突然消失，门前变得又冷又冷。\" class=\"headerlink\" title=\"当一个人不再珍贵时，过去那种朋友聚集在一起，车水马龙的繁华景象突然消失，门前变得又冷又冷。\"></a>当一个人不再珍贵时，过去那种朋友聚集在一起，车水马龙的繁华景象突然消失，门前变得又冷又冷。</h2><h2 id=\"对自己的不满是任何真正有才能的人的基本特征之一。\"><a href=\"#对自己的不满是任何真正有才能的人的基本特征之一。\" class=\"headerlink\" title=\"对自己的不满是任何真正有才能的人的基本特征之一。\"></a>对自己的不满是任何真正有才能的人的基本特征之一。</h2><h2 id=\"不要害怕遇到风险。只有冒险，我们才能学会勇敢。\"><a href=\"#不要害怕遇到风险。只有冒险，我们才能学会勇敢。\" class=\"headerlink\" title=\"不要害怕遇到风险。只有冒险，我们才能学会勇敢。\"></a>不要害怕遇到风险。只有冒险，我们才能学会勇敢。</h2><h2 id=\"只有出汗，我们才能享受财富；只有拒绝付出，我们才能变穷。\"><a href=\"#只有出汗，我们才能享受财富；只有拒绝付出，我们才能变穷。\" class=\"headerlink\" title=\"只有出汗，我们才能享受财富；只有拒绝付出，我们才能变穷。\"></a>只有出汗，我们才能享受财富；只有拒绝付出，我们才能变穷。</h2><h2 id=\"有了自信和意志力，一个人有能力挑战自己，并且能够在世界上做任何他能做的事。人生最大的挑战是挑战自己，因为其他的敌人很容易克服，而自己最难克服。\"><a href=\"#有了自信和意志力，一个人有能力挑战自己，并且能够在世界上做任何他能做的事。人生最大的挑战是挑战自己，因为其他的敌人很容易克服，而自己最难克服。\" class=\"headerlink\" title=\"有了自信和意志力，一个人有能力挑战自己，并且能够在世界上做任何他能做的事。人生最大的挑战是挑战自己，因为其他的敌人很容易克服，而自己最难克服。\"></a>有了自信和意志力，一个人有能力挑战自己，并且能够在世界上做任何他能做的事。人生最大的挑战是挑战自己，因为其他的敌人很容易克服，而自己最难克服。</h2><h2 id=\"只有全力以赴，才能发挥最大的潜能。\"><a href=\"#只有全力以赴，才能发挥最大的潜能。\" class=\"headerlink\" title=\"只有全力以赴，才能发挥最大的潜能。\"></a>只有全力以赴，才能发挥最大的潜能。</h2><h2 id=\"生活必须有一个计划，这样你的生活将永远不会偏离。\"><a href=\"#生活必须有一个计划，这样你的生活将永远不会偏离。\" class=\"headerlink\" title=\"生活必须有一个计划，这样你的生活将永远不会偏离。\"></a>生活必须有一个计划，这样你的生活将永远不会偏离。</h2><h2 id=\"要想成为一个世界上的奇迹，你必须在世界上走上几千英里。\"><a href=\"#要想成为一个世界上的奇迹，你必须在世界上走上几千英里。\" class=\"headerlink\" title=\"要想成为一个世界上的奇迹，你必须在世界上走上几千英里。\"></a>要想成为一个世界上的奇迹，你必须在世界上走上几千英里。</h2>"}],"Post":[{"title":"js创建对象的几种方式","date":"2019-03-29T12:27:10.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"## js创建对象的几种方式\n\n### 对象字面两的方式\n\n\tperson = {\n\t\tfirstname:\"Mark\",\n\t\tlastname:\"Yun\",\n\t\tage:25,\n\t\teyecolor:\"black\"\n\t}\n\n### 用function来模拟无参的构造函数 \n\n\tfunction Person () {} \n\t\t//定义一个function，如果使用new\"实例化\",该function可以看作是一个Class \n       var person=new Person();\n       person.name=“Mark\"; \n       person.age=\"25\"; \n       person.work = function () { \n       \talert(person.name+\" hello...\"); \n      } \n   \tperson.work(); \n\n### 用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性） \n\n\tfunction Pet(name,age,hobby){ \n       this.name=name; // this作用域：当前对象 \n       this.age=age; \n       this.hobby=hobby; \n       this.eat=function(){ \n           alert(\"我叫\"+this.name+\",我喜欢\"+this.hobby+\",是个程序员\"); \n        } \n    } \n\tvar maidou =new Pet(\"麦兜\",25,\"coding\"); // 实例化、创建对象 \n\tmaidou.eat();//调用eat方法 \n\n### 用工厂方式来创建（内置对象） \n\n\tvar wcDog =new Object(); \n      wcDog.name=\"旺财\"; \n      wcDog.age=3; \n      wcDog.work=function(){ \n       \talert(\"我是\"+wcDog.name+\",汪汪汪......\"); \n      } \n\twcDog.work(); \n\n### 用原型方式来创建 \n\n\tfunction Dog(){ } \n    Dog.prototype.name=\"旺财\"; \n    Dog.prototype.eat=function(){alert(this.name+\"是个吃货\");} \n    var wangcai =new Dog(); \n    wangcai.eat(); \n\n### 用混合方式来创建 \n\n\tfunction Car(name,price){ \n       this.name=name; \n       this.price=price; \n    } \n    Car.prototype.sell=function(){ \n       alert(\"我是\"+this.name+\"，我现在卖\"+this.price+\"万元\"); \n    } \n    var camry =new Car(\"凯美瑞\",27); \n    camry.sell(); \n\n\n\n\n","source":"_posts/CreatObject.md","raw":"---\ntitle: js创建对象的几种方式\ndate: '3/29/2019 8:27:10 PM '\ntag: ['js', 'object']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n## js创建对象的几种方式\n\n### 对象字面两的方式\n\n\tperson = {\n\t\tfirstname:\"Mark\",\n\t\tlastname:\"Yun\",\n\t\tage:25,\n\t\teyecolor:\"black\"\n\t}\n\n### 用function来模拟无参的构造函数 \n\n\tfunction Person () {} \n\t\t//定义一个function，如果使用new\"实例化\",该function可以看作是一个Class \n       var person=new Person();\n       person.name=“Mark\"; \n       person.age=\"25\"; \n       person.work = function () { \n       \talert(person.name+\" hello...\"); \n      } \n   \tperson.work(); \n\n### 用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性） \n\n\tfunction Pet(name,age,hobby){ \n       this.name=name; // this作用域：当前对象 \n       this.age=age; \n       this.hobby=hobby; \n       this.eat=function(){ \n           alert(\"我叫\"+this.name+\",我喜欢\"+this.hobby+\",是个程序员\"); \n        } \n    } \n\tvar maidou =new Pet(\"麦兜\",25,\"coding\"); // 实例化、创建对象 \n\tmaidou.eat();//调用eat方法 \n\n### 用工厂方式来创建（内置对象） \n\n\tvar wcDog =new Object(); \n      wcDog.name=\"旺财\"; \n      wcDog.age=3; \n      wcDog.work=function(){ \n       \talert(\"我是\"+wcDog.name+\",汪汪汪......\"); \n      } \n\twcDog.work(); \n\n### 用原型方式来创建 \n\n\tfunction Dog(){ } \n    Dog.prototype.name=\"旺财\"; \n    Dog.prototype.eat=function(){alert(this.name+\"是个吃货\");} \n    var wangcai =new Dog(); \n    wangcai.eat(); \n\n### 用混合方式来创建 \n\n\tfunction Car(name,price){ \n       this.name=name; \n       this.price=price; \n    } \n    Car.prototype.sell=function(){ \n       alert(\"我是\"+this.name+\"，我现在卖\"+this.price+\"万元\"); \n    } \n    var camry =new Car(\"凯美瑞\",27); \n    camry.sell(); \n\n\n\n\n","slug":"CreatObject","published":1,"updated":"2019-03-29T12:30:10.179Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam5v0000n4wd8olrrnji","content":"<h2 id=\"js创建对象的几种方式\"><a href=\"#js创建对象的几种方式\" class=\"headerlink\" title=\"js创建对象的几种方式\"></a>js创建对象的几种方式</h2><h3 id=\"对象字面两的方式\"><a href=\"#对象字面两的方式\" class=\"headerlink\" title=\"对象字面两的方式\"></a>对象字面两的方式</h3><pre><code>person = {\n    firstname:&quot;Mark&quot;,\n    lastname:&quot;Yun&quot;,\n    age:25,\n    eyecolor:&quot;black&quot;\n}\n</code></pre><h3 id=\"用function来模拟无参的构造函数\"><a href=\"#用function来模拟无参的构造函数\" class=\"headerlink\" title=\"用function来模拟无参的构造函数\"></a>用function来模拟无参的构造函数</h3><pre><code>function Person () {} \n    //定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Class \n   var person=new Person();\n   person.name=“Mark&quot;; \n   person.age=&quot;25&quot;; \n   person.work = function () { \n       alert(person.name+&quot; hello...&quot;); \n  } \n   person.work(); \n</code></pre><h3 id=\"用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）\"><a href=\"#用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）\" class=\"headerlink\" title=\"用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）\"></a>用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）</h3><pre><code>function Pet(name,age,hobby){ \n   this.name=name; // this作用域：当前对象 \n   this.age=age; \n   this.hobby=hobby; \n   this.eat=function(){ \n       alert(&quot;我叫&quot;+this.name+&quot;,我喜欢&quot;+this.hobby+&quot;,是个程序员&quot;); \n    } \n} \nvar maidou =new Pet(&quot;麦兜&quot;,25,&quot;coding&quot;); // 实例化、创建对象 \nmaidou.eat();//调用eat方法 \n</code></pre><h3 id=\"用工厂方式来创建（内置对象）\"><a href=\"#用工厂方式来创建（内置对象）\" class=\"headerlink\" title=\"用工厂方式来创建（内置对象）\"></a>用工厂方式来创建（内置对象）</h3><pre><code>var wcDog =new Object(); \n  wcDog.name=&quot;旺财&quot;; \n  wcDog.age=3; \n  wcDog.work=function(){ \n       alert(&quot;我是&quot;+wcDog.name+&quot;,汪汪汪......&quot;); \n  } \nwcDog.work(); \n</code></pre><h3 id=\"用原型方式来创建\"><a href=\"#用原型方式来创建\" class=\"headerlink\" title=\"用原型方式来创建\"></a>用原型方式来创建</h3><pre><code>function Dog(){ } \nDog.prototype.name=&quot;旺财&quot;; \nDog.prototype.eat=function(){alert(this.name+&quot;是个吃货&quot;);} \nvar wangcai =new Dog(); \nwangcai.eat(); \n</code></pre><h3 id=\"用混合方式来创建\"><a href=\"#用混合方式来创建\" class=\"headerlink\" title=\"用混合方式来创建\"></a>用混合方式来创建</h3><pre><code>function Car(name,price){ \n   this.name=name; \n   this.price=price; \n} \nCar.prototype.sell=function(){ \n   alert(&quot;我是&quot;+this.name+&quot;，我现在卖&quot;+this.price+&quot;万元&quot;); \n} \nvar camry =new Car(&quot;凯美瑞&quot;,27); \ncamry.sell(); \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"js创建对象的几种方式\"><a href=\"#js创建对象的几种方式\" class=\"headerlink\" title=\"js创建对象的几种方式\"></a>js创建对象的几种方式</h2><h3 id=\"对象字面两的方式\"><a href=\"#对象字面两的方式\" class=\"headerlink\" title=\"对象字面两的方式\"></a>对象字面两的方式</h3><pre><code>person = {\n    firstname:&quot;Mark&quot;,\n    lastname:&quot;Yun&quot;,\n    age:25,\n    eyecolor:&quot;black&quot;\n}\n</code></pre><h3 id=\"用function来模拟无参的构造函数\"><a href=\"#用function来模拟无参的构造函数\" class=\"headerlink\" title=\"用function来模拟无参的构造函数\"></a>用function来模拟无参的构造函数</h3><pre><code>function Person () {} \n    //定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Class \n   var person=new Person();\n   person.name=“Mark&quot;; \n   person.age=&quot;25&quot;; \n   person.work = function () { \n       alert(person.name+&quot; hello...&quot;); \n  } \n   person.work(); \n</code></pre><h3 id=\"用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）\"><a href=\"#用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）\" class=\"headerlink\" title=\"用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）\"></a>用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）</h3><pre><code>function Pet(name,age,hobby){ \n   this.name=name; // this作用域：当前对象 \n   this.age=age; \n   this.hobby=hobby; \n   this.eat=function(){ \n       alert(&quot;我叫&quot;+this.name+&quot;,我喜欢&quot;+this.hobby+&quot;,是个程序员&quot;); \n    } \n} \nvar maidou =new Pet(&quot;麦兜&quot;,25,&quot;coding&quot;); // 实例化、创建对象 \nmaidou.eat();//调用eat方法 \n</code></pre><h3 id=\"用工厂方式来创建（内置对象）\"><a href=\"#用工厂方式来创建（内置对象）\" class=\"headerlink\" title=\"用工厂方式来创建（内置对象）\"></a>用工厂方式来创建（内置对象）</h3><pre><code>var wcDog =new Object(); \n  wcDog.name=&quot;旺财&quot;; \n  wcDog.age=3; \n  wcDog.work=function(){ \n       alert(&quot;我是&quot;+wcDog.name+&quot;,汪汪汪......&quot;); \n  } \nwcDog.work(); \n</code></pre><h3 id=\"用原型方式来创建\"><a href=\"#用原型方式来创建\" class=\"headerlink\" title=\"用原型方式来创建\"></a>用原型方式来创建</h3><pre><code>function Dog(){ } \nDog.prototype.name=&quot;旺财&quot;; \nDog.prototype.eat=function(){alert(this.name+&quot;是个吃货&quot;);} \nvar wangcai =new Dog(); \nwangcai.eat(); \n</code></pre><h3 id=\"用混合方式来创建\"><a href=\"#用混合方式来创建\" class=\"headerlink\" title=\"用混合方式来创建\"></a>用混合方式来创建</h3><pre><code>function Car(name,price){ \n   this.name=name; \n   this.price=price; \n} \nCar.prototype.sell=function(){ \n   alert(&quot;我是&quot;+this.name+&quot;，我现在卖&quot;+this.price+&quot;万元&quot;); \n} \nvar camry =new Car(&quot;凯美瑞&quot;,27); \ncamry.sell(); \n</code></pre>"},{"title":"什么叫优雅降级和渐进增强？","date":"2019-03-29T15:44:33.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"## 什么叫优雅降级和渐进增强？\n\n### 优雅降级: \n\n> Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。 \n> \n> 如：border-shadow \n\n**优雅降级写法**\n\n\t.transition {\n\t          transition: all .5s;\n\t       -o-transition: all .5s;\n\t     -moz-transition: all .5s;\n\t  -webkit-transition: all .5s;\n\t}\n\n\n### 渐进增强:\n\n> 从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 \n> \n> 如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验；\n\n**渐进增强写法**\n\n\t.transition {\n\t  -webkit-transition: all .5s;\n\t     -moz-transition: all .5s;\n\t       -o-transition: all .5s;\n\t          transition: all .5s;\n\t}\n\n\n### 前缀CSS3（-webkit- / -moz- / -o-）和正常CSS3在浏览器中的支持情况是这样的：\n\n> - 很久以前：浏览器前缀CSS3和正常CSS3都不支持；\n> \n> - 不久之前：浏览器只支持前缀CSS3，不支持正常CSS3；\n> \n> - 现在：浏览器既支持前缀CSS3，又支持正常CSS3；\n> \n> - 未来：浏览器不支持前缀CSS3，仅支持正常CSS3.\n> \n\n----------\n\n\n> **ps：从这里可以引申到其他有前缀的css3的属性，不要局限在这个属性里。**\n\n**优雅降级的例子：**\n\n> 假如你写了一个表单，没有用到input type=\"submit\"表单元素，用了一个a标签的click事件做提交，但如果Javascript被禁用了怎么办？\n使用如下的文档结构，就可以在javascript被禁用时，依然可以提交。\n\n\t<form>\n\t    <input type=\"text\">\n\t    <input type=\"submit\">\n\t</form>\n\n> 优雅降级需要正确地体现HTML标签的语义，符合“浏览器的预期”。让你的网页在各种情况—下——包括降级（javascript被禁用，css传输失败等等）的情形都可以运作良好。这是我理解的优雅降级的意义。\n\n### 在网页布局中如何选择？\n\n > 如果软件开发的预算和时间充足，就不存在抉择的问题，可以两者都调整到一个最佳状态，而不用权衡，做选择题了。然而现实很残酷，要么开发周期短，要么开发预算少，或者二者兼而有之，这个时候该如何抉择？就我个人而言，讲讲我的观点。\n\n### 分析使用你客户端程序的版本比例。\n> \n> 如果低版本用户居多，当然优先采用渐进增强的开发流程；\n> \n> 如果高版本用户居多，为了提高大多数用户的使用体验，那当然优先采用优雅降级的开发流程。\n\n### 大多数公司是怎么处理这个问题的：\n\n\n> - 绝大多数的大公司都是采用渐进增强的方式，因为业务优先，提升用户体验永远不会排在最前面。\n> \n> - 例如：新浪微博网站前端的更新，拥有这种亿级用户的网站，绝对不可能追求某个特效而不考虑低版本用户可不可用，一定是确保低版本到高版本的可访问性，再去渐进增强，采用新功能给高版本用户提供更好的用户体验。\n> \n> - 但也不是没有反例。如果你开发的是一款面向青少年的软件（或网站）\n> \n> - 你知道这个群体的人总是喜欢尝试新事物，总是喜欢酷炫的特效，总是喜欢把它们的软件更新到最新版本。面对这种情况，渐进增强的开发流程实为上选。\n\n","source":"_posts/Downgrade.md","raw":"---\ntitle: 什么叫优雅降级和渐进增强？\ndate: '3/29/2019 11:44:33 PM '\ntag: ['js', '兼容与优化']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n## 什么叫优雅降级和渐进增强？\n\n### 优雅降级: \n\n> Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。 \n> \n> 如：border-shadow \n\n**优雅降级写法**\n\n\t.transition {\n\t          transition: all .5s;\n\t       -o-transition: all .5s;\n\t     -moz-transition: all .5s;\n\t  -webkit-transition: all .5s;\n\t}\n\n\n### 渐进增强:\n\n> 从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 \n> \n> 如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验；\n\n**渐进增强写法**\n\n\t.transition {\n\t  -webkit-transition: all .5s;\n\t     -moz-transition: all .5s;\n\t       -o-transition: all .5s;\n\t          transition: all .5s;\n\t}\n\n\n### 前缀CSS3（-webkit- / -moz- / -o-）和正常CSS3在浏览器中的支持情况是这样的：\n\n> - 很久以前：浏览器前缀CSS3和正常CSS3都不支持；\n> \n> - 不久之前：浏览器只支持前缀CSS3，不支持正常CSS3；\n> \n> - 现在：浏览器既支持前缀CSS3，又支持正常CSS3；\n> \n> - 未来：浏览器不支持前缀CSS3，仅支持正常CSS3.\n> \n\n----------\n\n\n> **ps：从这里可以引申到其他有前缀的css3的属性，不要局限在这个属性里。**\n\n**优雅降级的例子：**\n\n> 假如你写了一个表单，没有用到input type=\"submit\"表单元素，用了一个a标签的click事件做提交，但如果Javascript被禁用了怎么办？\n使用如下的文档结构，就可以在javascript被禁用时，依然可以提交。\n\n\t<form>\n\t    <input type=\"text\">\n\t    <input type=\"submit\">\n\t</form>\n\n> 优雅降级需要正确地体现HTML标签的语义，符合“浏览器的预期”。让你的网页在各种情况—下——包括降级（javascript被禁用，css传输失败等等）的情形都可以运作良好。这是我理解的优雅降级的意义。\n\n### 在网页布局中如何选择？\n\n > 如果软件开发的预算和时间充足，就不存在抉择的问题，可以两者都调整到一个最佳状态，而不用权衡，做选择题了。然而现实很残酷，要么开发周期短，要么开发预算少，或者二者兼而有之，这个时候该如何抉择？就我个人而言，讲讲我的观点。\n\n### 分析使用你客户端程序的版本比例。\n> \n> 如果低版本用户居多，当然优先采用渐进增强的开发流程；\n> \n> 如果高版本用户居多，为了提高大多数用户的使用体验，那当然优先采用优雅降级的开发流程。\n\n### 大多数公司是怎么处理这个问题的：\n\n\n> - 绝大多数的大公司都是采用渐进增强的方式，因为业务优先，提升用户体验永远不会排在最前面。\n> \n> - 例如：新浪微博网站前端的更新，拥有这种亿级用户的网站，绝对不可能追求某个特效而不考虑低版本用户可不可用，一定是确保低版本到高版本的可访问性，再去渐进增强，采用新功能给高版本用户提供更好的用户体验。\n> \n> - 但也不是没有反例。如果你开发的是一款面向青少年的软件（或网站）\n> \n> - 你知道这个群体的人总是喜欢尝试新事物，总是喜欢酷炫的特效，总是喜欢把它们的软件更新到最新版本。面对这种情况，渐进增强的开发流程实为上选。\n\n","slug":"Downgrade","published":1,"updated":"2019-03-29T12:44:41.777Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam610002n4wdb0vf89x0","content":"<h2 id=\"什么叫优雅降级和渐进增强？\"><a href=\"#什么叫优雅降级和渐进增强？\" class=\"headerlink\" title=\"什么叫优雅降级和渐进增强？\"></a>什么叫优雅降级和渐进增强？</h2><h3 id=\"优雅降级\"><a href=\"#优雅降级\" class=\"headerlink\" title=\"优雅降级:\"></a>优雅降级:</h3><blockquote>\n<p>Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。 </p>\n<p>如：border-shadow </p>\n</blockquote>\n<p><strong>优雅降级写法</strong></p>\n<pre><code>.transition {\n          transition: all .5s;\n       -o-transition: all .5s;\n     -moz-transition: all .5s;\n  -webkit-transition: all .5s;\n}\n</code></pre><h3 id=\"渐进增强\"><a href=\"#渐进增强\" class=\"headerlink\" title=\"渐进增强:\"></a>渐进增强:</h3><blockquote>\n<p>从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 </p>\n<p>如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验；</p>\n</blockquote>\n<p><strong>渐进增强写法</strong></p>\n<pre><code>.transition {\n  -webkit-transition: all .5s;\n     -moz-transition: all .5s;\n       -o-transition: all .5s;\n          transition: all .5s;\n}\n</code></pre><h3 id=\"前缀CSS3（-webkit-moz-o-）和正常CSS3在浏览器中的支持情况是这样的：\"><a href=\"#前缀CSS3（-webkit-moz-o-）和正常CSS3在浏览器中的支持情况是这样的：\" class=\"headerlink\" title=\"前缀CSS3（-webkit- / -moz- / -o-）和正常CSS3在浏览器中的支持情况是这样的：\"></a>前缀CSS3（-webkit- / -moz- / -o-）和正常CSS3在浏览器中的支持情况是这样的：</h3><blockquote>\n<ul>\n<li><p>很久以前：浏览器前缀CSS3和正常CSS3都不支持；</p>\n</li>\n<li><p>不久之前：浏览器只支持前缀CSS3，不支持正常CSS3；</p>\n</li>\n<li><p>现在：浏览器既支持前缀CSS3，又支持正常CSS3；</p>\n</li>\n<li><p>未来：浏览器不支持前缀CSS3，仅支持正常CSS3.</p>\n</li>\n</ul>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>ps：从这里可以引申到其他有前缀的css3的属性，不要局限在这个属性里。</strong></p>\n</blockquote>\n<p><strong>优雅降级的例子：</strong></p>\n<blockquote>\n<p>假如你写了一个表单，没有用到input type=”submit”表单元素，用了一个a标签的click事件做提交，但如果Javascript被禁用了怎么办？<br>使用如下的文档结构，就可以在javascript被禁用时，依然可以提交。</p>\n</blockquote>\n<pre><code>&lt;form&gt;\n    &lt;input type=&quot;text&quot;&gt;\n    &lt;input type=&quot;submit&quot;&gt;\n&lt;/form&gt;\n</code></pre><blockquote>\n<p>优雅降级需要正确地体现HTML标签的语义，符合“浏览器的预期”。让你的网页在各种情况—下——包括降级（javascript被禁用，css传输失败等等）的情形都可以运作良好。这是我理解的优雅降级的意义。</p>\n</blockquote>\n<h3 id=\"在网页布局中如何选择？\"><a href=\"#在网页布局中如何选择？\" class=\"headerlink\" title=\"在网页布局中如何选择？\"></a>在网页布局中如何选择？</h3><blockquote>\n<p>如果软件开发的预算和时间充足，就不存在抉择的问题，可以两者都调整到一个最佳状态，而不用权衡，做选择题了。然而现实很残酷，要么开发周期短，要么开发预算少，或者二者兼而有之，这个时候该如何抉择？就我个人而言，讲讲我的观点。</p>\n</blockquote>\n<h3 id=\"分析使用你客户端程序的版本比例。\"><a href=\"#分析使用你客户端程序的版本比例。\" class=\"headerlink\" title=\"分析使用你客户端程序的版本比例。\"></a>分析使用你客户端程序的版本比例。</h3><blockquote>\n<p>如果低版本用户居多，当然优先采用渐进增强的开发流程；</p>\n<p>如果高版本用户居多，为了提高大多数用户的使用体验，那当然优先采用优雅降级的开发流程。</p>\n</blockquote>\n<h3 id=\"大多数公司是怎么处理这个问题的：\"><a href=\"#大多数公司是怎么处理这个问题的：\" class=\"headerlink\" title=\"大多数公司是怎么处理这个问题的：\"></a>大多数公司是怎么处理这个问题的：</h3><blockquote>\n<ul>\n<li><p>绝大多数的大公司都是采用渐进增强的方式，因为业务优先，提升用户体验永远不会排在最前面。</p>\n</li>\n<li><p>例如：新浪微博网站前端的更新，拥有这种亿级用户的网站，绝对不可能追求某个特效而不考虑低版本用户可不可用，一定是确保低版本到高版本的可访问性，再去渐进增强，采用新功能给高版本用户提供更好的用户体验。</p>\n</li>\n<li><p>但也不是没有反例。如果你开发的是一款面向青少年的软件（或网站）</p>\n</li>\n<li><p>你知道这个群体的人总是喜欢尝试新事物，总是喜欢酷炫的特效，总是喜欢把它们的软件更新到最新版本。面对这种情况，渐进增强的开发流程实为上选。</p>\n</li>\n</ul>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么叫优雅降级和渐进增强？\"><a href=\"#什么叫优雅降级和渐进增强？\" class=\"headerlink\" title=\"什么叫优雅降级和渐进增强？\"></a>什么叫优雅降级和渐进增强？</h2><h3 id=\"优雅降级\"><a href=\"#优雅降级\" class=\"headerlink\" title=\"优雅降级:\"></a>优雅降级:</h3><blockquote>\n<p>Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。 </p>\n<p>如：border-shadow </p>\n</blockquote>\n<p><strong>优雅降级写法</strong></p>\n<pre><code>.transition {\n          transition: all .5s;\n       -o-transition: all .5s;\n     -moz-transition: all .5s;\n  -webkit-transition: all .5s;\n}\n</code></pre><h3 id=\"渐进增强\"><a href=\"#渐进增强\" class=\"headerlink\" title=\"渐进增强:\"></a>渐进增强:</h3><blockquote>\n<p>从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 </p>\n<p>如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验；</p>\n</blockquote>\n<p><strong>渐进增强写法</strong></p>\n<pre><code>.transition {\n  -webkit-transition: all .5s;\n     -moz-transition: all .5s;\n       -o-transition: all .5s;\n          transition: all .5s;\n}\n</code></pre><h3 id=\"前缀CSS3（-webkit-moz-o-）和正常CSS3在浏览器中的支持情况是这样的：\"><a href=\"#前缀CSS3（-webkit-moz-o-）和正常CSS3在浏览器中的支持情况是这样的：\" class=\"headerlink\" title=\"前缀CSS3（-webkit- / -moz- / -o-）和正常CSS3在浏览器中的支持情况是这样的：\"></a>前缀CSS3（-webkit- / -moz- / -o-）和正常CSS3在浏览器中的支持情况是这样的：</h3><blockquote>\n<ul>\n<li><p>很久以前：浏览器前缀CSS3和正常CSS3都不支持；</p>\n</li>\n<li><p>不久之前：浏览器只支持前缀CSS3，不支持正常CSS3；</p>\n</li>\n<li><p>现在：浏览器既支持前缀CSS3，又支持正常CSS3；</p>\n</li>\n<li><p>未来：浏览器不支持前缀CSS3，仅支持正常CSS3.</p>\n</li>\n</ul>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>ps：从这里可以引申到其他有前缀的css3的属性，不要局限在这个属性里。</strong></p>\n</blockquote>\n<p><strong>优雅降级的例子：</strong></p>\n<blockquote>\n<p>假如你写了一个表单，没有用到input type=”submit”表单元素，用了一个a标签的click事件做提交，但如果Javascript被禁用了怎么办？<br>使用如下的文档结构，就可以在javascript被禁用时，依然可以提交。</p>\n</blockquote>\n<pre><code>&lt;form&gt;\n    &lt;input type=&quot;text&quot;&gt;\n    &lt;input type=&quot;submit&quot;&gt;\n&lt;/form&gt;\n</code></pre><blockquote>\n<p>优雅降级需要正确地体现HTML标签的语义，符合“浏览器的预期”。让你的网页在各种情况—下——包括降级（javascript被禁用，css传输失败等等）的情形都可以运作良好。这是我理解的优雅降级的意义。</p>\n</blockquote>\n<h3 id=\"在网页布局中如何选择？\"><a href=\"#在网页布局中如何选择？\" class=\"headerlink\" title=\"在网页布局中如何选择？\"></a>在网页布局中如何选择？</h3><blockquote>\n<p>如果软件开发的预算和时间充足，就不存在抉择的问题，可以两者都调整到一个最佳状态，而不用权衡，做选择题了。然而现实很残酷，要么开发周期短，要么开发预算少，或者二者兼而有之，这个时候该如何抉择？就我个人而言，讲讲我的观点。</p>\n</blockquote>\n<h3 id=\"分析使用你客户端程序的版本比例。\"><a href=\"#分析使用你客户端程序的版本比例。\" class=\"headerlink\" title=\"分析使用你客户端程序的版本比例。\"></a>分析使用你客户端程序的版本比例。</h3><blockquote>\n<p>如果低版本用户居多，当然优先采用渐进增强的开发流程；</p>\n<p>如果高版本用户居多，为了提高大多数用户的使用体验，那当然优先采用优雅降级的开发流程。</p>\n</blockquote>\n<h3 id=\"大多数公司是怎么处理这个问题的：\"><a href=\"#大多数公司是怎么处理这个问题的：\" class=\"headerlink\" title=\"大多数公司是怎么处理这个问题的：\"></a>大多数公司是怎么处理这个问题的：</h3><blockquote>\n<ul>\n<li><p>绝大多数的大公司都是采用渐进增强的方式，因为业务优先，提升用户体验永远不会排在最前面。</p>\n</li>\n<li><p>例如：新浪微博网站前端的更新，拥有这种亿级用户的网站，绝对不可能追求某个特效而不考虑低版本用户可不可用，一定是确保低版本到高版本的可访问性，再去渐进增强，采用新功能给高版本用户提供更好的用户体验。</p>\n</li>\n<li><p>但也不是没有反例。如果你开发的是一款面向青少年的软件（或网站）</p>\n</li>\n<li><p>你知道这个群体的人总是喜欢尝试新事物，总是喜欢酷炫的特效，总是喜欢把它们的软件更新到最新版本。面对这种情况，渐进增强的开发流程实为上选。</p>\n</li>\n</ul>\n</blockquote>\n"},{"title":"js事件机制","date":"2019-03-29T11:22:50.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"## js事件机制\n\n**、主要分为Dom0级事件和Dom2事件**\n\n> Dom0级事件处理方式： \n\n\tbtn.onclick = func; \n   \tbtn.onclick = null; \n\n> Dom2级事件处理方式：\n\t\n\t// 非IE\n\tbtn.addEventListener('click', func, false); \n    btn.removeEventListener('click', func, false); \n\t// IE\n    btn.attachEvent(\"onclick\", func); \n    btn.detachEvent(\"onclick\", func); \n\n## 事件的三个阶段\n\n- 捕获\n- 目标\n- 冒泡\n\n> **js冒泡和捕获的的区别**\n\n**冒泡型事件：**\n\n> 事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。 \n\n**捕获型事件:**\n\n> 事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)。 \n\n**DOM事件流:**\n\n> 同时支持两种事件模型：捕获型事件和冒泡型事件，但是，捕获型事件先发生。两种事件流会触及DOM中的所有对象，从document对象开始，也在document对象结束。 \n\n**事件捕获:**\n\n> 当你使用事件捕获时，父级元素先触发，子级元素后触发，即div先触发，p后触发。 \n\n**事件冒泡:**\n\n> 当你使用事件冒泡时，子级元素先触发，父级元素后触发，即p先触发，div后触发。 \n\n## 阻止冒泡\n\n> 非IE\n\n\te.stopPropagation()\n\n> IE\n\n\tcancelBubble = true\n\n## 阻止捕获\n\n> 非IE\n\n\te.preventDefault()\n\n> IE\n\n\treturnValue = false\n\n## 事件“捕获”和“冒泡”执行顺序和事件的执行次数？\n\n**按照W3C标准流程如下：**\n\n> 进入捕获阶段 →→→ 到达目标元素 →→→ 进入到冒泡阶段\n\n**事件执行次数**\n\n> 元素上绑定事件的个数\n\n### 在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？ \n\n> 该DOM上的事件如果被触发，会执行两次（执行次数等于绑定次数）\n>  \n> 如果该DOM是目标元素，则按事件绑定顺序执行，不区分冒泡/捕获\n> \n> 如果该DOM是处于事件流中的非目标元素，则先执行捕获，后执行冒泡 \n\n\n","source":"_posts/JSevent.md","raw":"---\ntitle: js事件机制\ndate: '3/29/2019 7:22:50 PM '\ntag: ['js', 'Event']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n## js事件机制\n\n**、主要分为Dom0级事件和Dom2事件**\n\n> Dom0级事件处理方式： \n\n\tbtn.onclick = func; \n   \tbtn.onclick = null; \n\n> Dom2级事件处理方式：\n\t\n\t// 非IE\n\tbtn.addEventListener('click', func, false); \n    btn.removeEventListener('click', func, false); \n\t// IE\n    btn.attachEvent(\"onclick\", func); \n    btn.detachEvent(\"onclick\", func); \n\n## 事件的三个阶段\n\n- 捕获\n- 目标\n- 冒泡\n\n> **js冒泡和捕获的的区别**\n\n**冒泡型事件：**\n\n> 事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。 \n\n**捕获型事件:**\n\n> 事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)。 \n\n**DOM事件流:**\n\n> 同时支持两种事件模型：捕获型事件和冒泡型事件，但是，捕获型事件先发生。两种事件流会触及DOM中的所有对象，从document对象开始，也在document对象结束。 \n\n**事件捕获:**\n\n> 当你使用事件捕获时，父级元素先触发，子级元素后触发，即div先触发，p后触发。 \n\n**事件冒泡:**\n\n> 当你使用事件冒泡时，子级元素先触发，父级元素后触发，即p先触发，div后触发。 \n\n## 阻止冒泡\n\n> 非IE\n\n\te.stopPropagation()\n\n> IE\n\n\tcancelBubble = true\n\n## 阻止捕获\n\n> 非IE\n\n\te.preventDefault()\n\n> IE\n\n\treturnValue = false\n\n## 事件“捕获”和“冒泡”执行顺序和事件的执行次数？\n\n**按照W3C标准流程如下：**\n\n> 进入捕获阶段 →→→ 到达目标元素 →→→ 进入到冒泡阶段\n\n**事件执行次数**\n\n> 元素上绑定事件的个数\n\n### 在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？ \n\n> 该DOM上的事件如果被触发，会执行两次（执行次数等于绑定次数）\n>  \n> 如果该DOM是目标元素，则按事件绑定顺序执行，不区分冒泡/捕获\n> \n> 如果该DOM是处于事件流中的非目标元素，则先执行捕获，后执行冒泡 \n\n\n","slug":"JSevent","published":1,"updated":"2019-03-29T12:29:59.445Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam660005n4wdcqebd1xp","content":"<h2 id=\"js事件机制\"><a href=\"#js事件机制\" class=\"headerlink\" title=\"js事件机制\"></a>js事件机制</h2><p><strong>、主要分为Dom0级事件和Dom2事件</strong></p>\n<blockquote>\n<p>Dom0级事件处理方式： </p>\n</blockquote>\n<pre><code>btn.onclick = func; \n   btn.onclick = null; \n</code></pre><blockquote>\n<p>Dom2级事件处理方式：</p>\n</blockquote>\n<pre><code>// 非IE\nbtn.addEventListener(&#39;click&#39;, func, false); \nbtn.removeEventListener(&#39;click&#39;, func, false); \n// IE\nbtn.attachEvent(&quot;onclick&quot;, func); \nbtn.detachEvent(&quot;onclick&quot;, func); \n</code></pre><h2 id=\"事件的三个阶段\"><a href=\"#事件的三个阶段\" class=\"headerlink\" title=\"事件的三个阶段\"></a>事件的三个阶段</h2><ul>\n<li>捕获</li>\n<li>目标</li>\n<li>冒泡</li>\n</ul>\n<blockquote>\n<p><strong>js冒泡和捕获的的区别</strong></p>\n</blockquote>\n<p><strong>冒泡型事件：</strong></p>\n<blockquote>\n<p>事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。 </p>\n</blockquote>\n<p><strong>捕获型事件:</strong></p>\n<blockquote>\n<p>事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)。 </p>\n</blockquote>\n<p><strong>DOM事件流:</strong></p>\n<blockquote>\n<p>同时支持两种事件模型：捕获型事件和冒泡型事件，但是，捕获型事件先发生。两种事件流会触及DOM中的所有对象，从document对象开始，也在document对象结束。 </p>\n</blockquote>\n<p><strong>事件捕获:</strong></p>\n<blockquote>\n<p>当你使用事件捕获时，父级元素先触发，子级元素后触发，即div先触发，p后触发。 </p>\n</blockquote>\n<p><strong>事件冒泡:</strong></p>\n<blockquote>\n<p>当你使用事件冒泡时，子级元素先触发，父级元素后触发，即p先触发，div后触发。 </p>\n</blockquote>\n<h2 id=\"阻止冒泡\"><a href=\"#阻止冒泡\" class=\"headerlink\" title=\"阻止冒泡\"></a>阻止冒泡</h2><blockquote>\n<p>非IE</p>\n</blockquote>\n<pre><code>e.stopPropagation()\n</code></pre><blockquote>\n<p>IE</p>\n</blockquote>\n<pre><code>cancelBubble = true\n</code></pre><h2 id=\"阻止捕获\"><a href=\"#阻止捕获\" class=\"headerlink\" title=\"阻止捕获\"></a>阻止捕获</h2><blockquote>\n<p>非IE</p>\n</blockquote>\n<pre><code>e.preventDefault()\n</code></pre><blockquote>\n<p>IE</p>\n</blockquote>\n<pre><code>returnValue = false\n</code></pre><h2 id=\"事件“捕获”和“冒泡”执行顺序和事件的执行次数？\"><a href=\"#事件“捕获”和“冒泡”执行顺序和事件的执行次数？\" class=\"headerlink\" title=\"事件“捕获”和“冒泡”执行顺序和事件的执行次数？\"></a>事件“捕获”和“冒泡”执行顺序和事件的执行次数？</h2><p><strong>按照W3C标准流程如下：</strong></p>\n<blockquote>\n<p>进入捕获阶段 →→→ 到达目标元素 →→→ 进入到冒泡阶段</p>\n</blockquote>\n<p><strong>事件执行次数</strong></p>\n<blockquote>\n<p>元素上绑定事件的个数</p>\n</blockquote>\n<h3 id=\"在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？\"><a href=\"#在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？\" class=\"headerlink\" title=\"在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？\"></a>在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？</h3><blockquote>\n<p>该DOM上的事件如果被触发，会执行两次（执行次数等于绑定次数）</p>\n<p>如果该DOM是目标元素，则按事件绑定顺序执行，不区分冒泡/捕获</p>\n<p>如果该DOM是处于事件流中的非目标元素，则先执行捕获，后执行冒泡 </p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"js事件机制\"><a href=\"#js事件机制\" class=\"headerlink\" title=\"js事件机制\"></a>js事件机制</h2><p><strong>、主要分为Dom0级事件和Dom2事件</strong></p>\n<blockquote>\n<p>Dom0级事件处理方式： </p>\n</blockquote>\n<pre><code>btn.onclick = func; \n   btn.onclick = null; \n</code></pre><blockquote>\n<p>Dom2级事件处理方式：</p>\n</blockquote>\n<pre><code>// 非IE\nbtn.addEventListener(&#39;click&#39;, func, false); \nbtn.removeEventListener(&#39;click&#39;, func, false); \n// IE\nbtn.attachEvent(&quot;onclick&quot;, func); \nbtn.detachEvent(&quot;onclick&quot;, func); \n</code></pre><h2 id=\"事件的三个阶段\"><a href=\"#事件的三个阶段\" class=\"headerlink\" title=\"事件的三个阶段\"></a>事件的三个阶段</h2><ul>\n<li>捕获</li>\n<li>目标</li>\n<li>冒泡</li>\n</ul>\n<blockquote>\n<p><strong>js冒泡和捕获的的区别</strong></p>\n</blockquote>\n<p><strong>冒泡型事件：</strong></p>\n<blockquote>\n<p>事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。 </p>\n</blockquote>\n<p><strong>捕获型事件:</strong></p>\n<blockquote>\n<p>事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)。 </p>\n</blockquote>\n<p><strong>DOM事件流:</strong></p>\n<blockquote>\n<p>同时支持两种事件模型：捕获型事件和冒泡型事件，但是，捕获型事件先发生。两种事件流会触及DOM中的所有对象，从document对象开始，也在document对象结束。 </p>\n</blockquote>\n<p><strong>事件捕获:</strong></p>\n<blockquote>\n<p>当你使用事件捕获时，父级元素先触发，子级元素后触发，即div先触发，p后触发。 </p>\n</blockquote>\n<p><strong>事件冒泡:</strong></p>\n<blockquote>\n<p>当你使用事件冒泡时，子级元素先触发，父级元素后触发，即p先触发，div后触发。 </p>\n</blockquote>\n<h2 id=\"阻止冒泡\"><a href=\"#阻止冒泡\" class=\"headerlink\" title=\"阻止冒泡\"></a>阻止冒泡</h2><blockquote>\n<p>非IE</p>\n</blockquote>\n<pre><code>e.stopPropagation()\n</code></pre><blockquote>\n<p>IE</p>\n</blockquote>\n<pre><code>cancelBubble = true\n</code></pre><h2 id=\"阻止捕获\"><a href=\"#阻止捕获\" class=\"headerlink\" title=\"阻止捕获\"></a>阻止捕获</h2><blockquote>\n<p>非IE</p>\n</blockquote>\n<pre><code>e.preventDefault()\n</code></pre><blockquote>\n<p>IE</p>\n</blockquote>\n<pre><code>returnValue = false\n</code></pre><h2 id=\"事件“捕获”和“冒泡”执行顺序和事件的执行次数？\"><a href=\"#事件“捕获”和“冒泡”执行顺序和事件的执行次数？\" class=\"headerlink\" title=\"事件“捕获”和“冒泡”执行顺序和事件的执行次数？\"></a>事件“捕获”和“冒泡”执行顺序和事件的执行次数？</h2><p><strong>按照W3C标准流程如下：</strong></p>\n<blockquote>\n<p>进入捕获阶段 →→→ 到达目标元素 →→→ 进入到冒泡阶段</p>\n</blockquote>\n<p><strong>事件执行次数</strong></p>\n<blockquote>\n<p>元素上绑定事件的个数</p>\n</blockquote>\n<h3 id=\"在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？\"><a href=\"#在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？\" class=\"headerlink\" title=\"在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？\"></a>在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？</h3><blockquote>\n<p>该DOM上的事件如果被触发，会执行两次（执行次数等于绑定次数）</p>\n<p>如果该DOM是目标元素，则按事件绑定顺序执行，不区分冒泡/捕获</p>\n<p>如果该DOM是处于事件流中的非目标元素，则先执行捕获，后执行冒泡 </p>\n</blockquote>\n"},{"title":"mvvm原理","date":"2019-03-03T03:18:38.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"\n## mvvm模式\n\n### 　MVVM 是Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式，其核心是提供对View 和 ViewModel 的双向数据绑定，这使得ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定。\n\n> **[mvvm原理源码地址](https://github.com/Ignorance-of-Dong/mvvm)**\n\n> Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。\n\n## 为什么会出现 MVVM 呢？\n\n###MVC 即 Model-View-Controller 的缩写，就是 模型—视图—控制器，也就是说一个标准的Web 应用程式是由这三部分组成的：\n\n> - View ：用来把数据以某种方式呈现给用户\n> - Model ：其实就是数据\n> - Controller ：接收并处理来自用户的请求，并将 Model 返回给用户\n\n### 随着H5 的不断发展，人们更希望使用H5 开发的应用能和Native 媲美，或者接近于原生App 的体验效果，于是前端应用的复杂程度已不同往日，今非昔比。这时前端开发就暴露出了三个**痛点**问题：\n\n> - 开发者在代码中大量调用相同的 DOM API，处理繁琐 ，操作冗余，使得代码难以维护。\n> - 大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。\n> - 当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致 Model 发生变化，开发者同样需要将变化的数据同步到Model 中，这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。\n\n## MVVM 的出现，完美解决了以上三个问题。\n\n### MVVM 由 Model、View、ViewModel 三部分构成，Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。\n\n> 在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。\n\n### 　ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM， 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。\n\n## **Vue.js 的细节**\n\n#### Vue.js 可以说是MVVM 架构的最佳实践，专注于 MVVM 中的 ViewModel，不仅做到了数据双向绑定，而且也是一款相对来比较轻量级的JS 库，API 简洁，很容易上手。Vue的基础知识网上有现成的教程，此处不再赘述， 下面简单了解一下 Vue.js 关于双向绑定的一些实现细节：\n\n\n> Vue.js 是采用 Object.defineProperty 的 getter 和 setter，并结合观察者模式来实现数据绑定的。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/1.0.png)\n\n- Observer ：数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用Object.defineProperty的getter和setter来实现\n- Compile  ：指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数\n- Watcher  ：订阅者，作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数\n- Dep ：消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法\n\n> 从图中可以看出，当执行 new Vue() 时，Vue 就进入了初始化阶段，一方面Vue 会遍历 data 选项中的属性，并用 Object.defineProperty 将它们转为 getter/setter，实现数据变化监听功能；另一方面，Vue 的指令编译器Compile 对元素节点的指令进行扫描和解析，初始化视图，并订阅 Watcher 来更新视图， 此时Wather 会将自己添加到消息订阅器中(Dep)，初始化完毕。\n> \n\n----------\n\n\n> 当数据发生变化时，Observer 中的 setter 方法被触发，setter 会立即调用Dep.notify()，Dep 开始遍历所有的订阅者，并调用订阅者的 update 方法，订阅者收到通知后对视图进行相应的更新。\n\n## MVVM？比之 MVC 有什么区别？\n\n### 首先先来说下 View 和 Model\n\n- View 很简单，就是用户看到的视图\n- Model 同样很简单，一般就是本地数据和数据库中的数据\n\n\n### 基本上，我们写的产品就是通过接口从数据库中读取数据，然后将数据经过处理展现到用户看到的视图上。当然我们还可以从视图上读取用户的输入，然后又将用户的输入通过接口写入到数据库中。但是，如何将数据展示到视图上，然后又如何将用户的输入写入到数据中，不同的人就产生了不同的看法，从此出现了很多种架构设计。\n\n#### 传统的 MVC 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/1.1.png)\n\n####但是 MVC 有一个巨大的缺陷就是控制器承担的责任太大了，随着项目愈加复杂，控制器中的代码会越来越臃肿，导致出现不利于维护的情况。\n\n### 在 MVVM 架构中，引入了 ViewModel 的概念。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。 \n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/1.2.png)\n\n### 以 Vue 框架来举例，ViewModel 就是组件的实例。View 就是模板，Model 的话在引入 Vuex 的情况下是完全可以和组件分离的。\n\n####除了以上三个部分，其实在 MVVM 中还引入了一个隐式的 Binder 层，实现了 View 和 ViewModel 的绑定。\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/1.3.png)\n\n##### 同样以 Vue 框架来举例，这个隐式的 Binder 层就是 Vue 通过解析模板中的插值和指令从而实现 View 与 ViewModel 的绑定。\n\n对于 MVVM 来说，其实最重要的并不是通过双向绑定或者其他的方式将 View 与 ViewModel 绑定起来，**而是通过 ViewModel 将视图中的状态和用户的行为分离出一个抽象，这才是 MVVM 的精髓。**","source":"_posts/MVVM.md","raw":"---\ntitle: mvvm原理\ndate: '3/3/2019 11:18:38 AM '\ntag: ['js', 'mvvm']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n\n## mvvm模式\n\n### 　MVVM 是Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式，其核心是提供对View 和 ViewModel 的双向数据绑定，这使得ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定。\n\n> **[mvvm原理源码地址](https://github.com/Ignorance-of-Dong/mvvm)**\n\n> Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。\n\n## 为什么会出现 MVVM 呢？\n\n###MVC 即 Model-View-Controller 的缩写，就是 模型—视图—控制器，也就是说一个标准的Web 应用程式是由这三部分组成的：\n\n> - View ：用来把数据以某种方式呈现给用户\n> - Model ：其实就是数据\n> - Controller ：接收并处理来自用户的请求，并将 Model 返回给用户\n\n### 随着H5 的不断发展，人们更希望使用H5 开发的应用能和Native 媲美，或者接近于原生App 的体验效果，于是前端应用的复杂程度已不同往日，今非昔比。这时前端开发就暴露出了三个**痛点**问题：\n\n> - 开发者在代码中大量调用相同的 DOM API，处理繁琐 ，操作冗余，使得代码难以维护。\n> - 大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。\n> - 当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致 Model 发生变化，开发者同样需要将变化的数据同步到Model 中，这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。\n\n## MVVM 的出现，完美解决了以上三个问题。\n\n### MVVM 由 Model、View、ViewModel 三部分构成，Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。\n\n> 在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。\n\n### 　ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM， 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。\n\n## **Vue.js 的细节**\n\n#### Vue.js 可以说是MVVM 架构的最佳实践，专注于 MVVM 中的 ViewModel，不仅做到了数据双向绑定，而且也是一款相对来比较轻量级的JS 库，API 简洁，很容易上手。Vue的基础知识网上有现成的教程，此处不再赘述， 下面简单了解一下 Vue.js 关于双向绑定的一些实现细节：\n\n\n> Vue.js 是采用 Object.defineProperty 的 getter 和 setter，并结合观察者模式来实现数据绑定的。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/1.0.png)\n\n- Observer ：数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用Object.defineProperty的getter和setter来实现\n- Compile  ：指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数\n- Watcher  ：订阅者，作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数\n- Dep ：消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法\n\n> 从图中可以看出，当执行 new Vue() 时，Vue 就进入了初始化阶段，一方面Vue 会遍历 data 选项中的属性，并用 Object.defineProperty 将它们转为 getter/setter，实现数据变化监听功能；另一方面，Vue 的指令编译器Compile 对元素节点的指令进行扫描和解析，初始化视图，并订阅 Watcher 来更新视图， 此时Wather 会将自己添加到消息订阅器中(Dep)，初始化完毕。\n> \n\n----------\n\n\n> 当数据发生变化时，Observer 中的 setter 方法被触发，setter 会立即调用Dep.notify()，Dep 开始遍历所有的订阅者，并调用订阅者的 update 方法，订阅者收到通知后对视图进行相应的更新。\n\n## MVVM？比之 MVC 有什么区别？\n\n### 首先先来说下 View 和 Model\n\n- View 很简单，就是用户看到的视图\n- Model 同样很简单，一般就是本地数据和数据库中的数据\n\n\n### 基本上，我们写的产品就是通过接口从数据库中读取数据，然后将数据经过处理展现到用户看到的视图上。当然我们还可以从视图上读取用户的输入，然后又将用户的输入通过接口写入到数据库中。但是，如何将数据展示到视图上，然后又如何将用户的输入写入到数据中，不同的人就产生了不同的看法，从此出现了很多种架构设计。\n\n#### 传统的 MVC 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/1.1.png)\n\n####但是 MVC 有一个巨大的缺陷就是控制器承担的责任太大了，随着项目愈加复杂，控制器中的代码会越来越臃肿，导致出现不利于维护的情况。\n\n### 在 MVVM 架构中，引入了 ViewModel 的概念。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。 \n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/1.2.png)\n\n### 以 Vue 框架来举例，ViewModel 就是组件的实例。View 就是模板，Model 的话在引入 Vuex 的情况下是完全可以和组件分离的。\n\n####除了以上三个部分，其实在 MVVM 中还引入了一个隐式的 Binder 层，实现了 View 和 ViewModel 的绑定。\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/1.3.png)\n\n##### 同样以 Vue 框架来举例，这个隐式的 Binder 层就是 Vue 通过解析模板中的插值和指令从而实现 View 与 ViewModel 的绑定。\n\n对于 MVVM 来说，其实最重要的并不是通过双向绑定或者其他的方式将 View 与 ViewModel 绑定起来，**而是通过 ViewModel 将视图中的状态和用户的行为分离出一个抽象，这才是 MVVM 的精髓。**","slug":"MVVM","published":1,"updated":"2019-07-09T08:10:49.999Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam680007n4wdp6vwyyrj","content":"<h2 id=\"mvvm模式\"><a href=\"#mvvm模式\" class=\"headerlink\" title=\"mvvm模式\"></a>mvvm模式</h2><h3 id=\"MVVM-是Model-View-ViewModel-的缩写，它是一种基于前端开发的架构模式，其核心是提供对View-和-ViewModel-的双向数据绑定，这使得ViewModel-的状态改变可以自动传递给-View，即所谓的数据双向绑定。\"><a href=\"#MVVM-是Model-View-ViewModel-的缩写，它是一种基于前端开发的架构模式，其核心是提供对View-和-ViewModel-的双向数据绑定，这使得ViewModel-的状态改变可以自动传递给-View，即所谓的数据双向绑定。\" class=\"headerlink\" title=\"　MVVM 是Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式，其核心是提供对View 和 ViewModel 的双向数据绑定，这使得ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定。\"></a>　MVVM 是Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式，其核心是提供对View 和 ViewModel 的双向数据绑定，这使得ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定。</h3><blockquote>\n<p><strong><a href=\"https://github.com/Ignorance-of-Dong/mvvm\" target=\"_blank\" rel=\"noopener\">mvvm原理源码地址</a></strong></p>\n</blockquote>\n<blockquote>\n<p>Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。</p>\n</blockquote>\n<h2 id=\"为什么会出现-MVVM-呢？\"><a href=\"#为什么会出现-MVVM-呢？\" class=\"headerlink\" title=\"为什么会出现 MVVM 呢？\"></a>为什么会出现 MVVM 呢？</h2><p>###MVC 即 Model-View-Controller 的缩写，就是 模型—视图—控制器，也就是说一个标准的Web 应用程式是由这三部分组成的：</p>\n<blockquote>\n<ul>\n<li>View ：用来把数据以某种方式呈现给用户</li>\n<li>Model ：其实就是数据</li>\n<li>Controller ：接收并处理来自用户的请求，并将 Model 返回给用户</li>\n</ul>\n</blockquote>\n<h3 id=\"随着H5-的不断发展，人们更希望使用H5-开发的应用能和Native-媲美，或者接近于原生App-的体验效果，于是前端应用的复杂程度已不同往日，今非昔比。这时前端开发就暴露出了三个痛点问题：\"><a href=\"#随着H5-的不断发展，人们更希望使用H5-开发的应用能和Native-媲美，或者接近于原生App-的体验效果，于是前端应用的复杂程度已不同往日，今非昔比。这时前端开发就暴露出了三个痛点问题：\" class=\"headerlink\" title=\"随着H5 的不断发展，人们更希望使用H5 开发的应用能和Native 媲美，或者接近于原生App 的体验效果，于是前端应用的复杂程度已不同往日，今非昔比。这时前端开发就暴露出了三个痛点问题：\"></a>随着H5 的不断发展，人们更希望使用H5 开发的应用能和Native 媲美，或者接近于原生App 的体验效果，于是前端应用的复杂程度已不同往日，今非昔比。这时前端开发就暴露出了三个<strong>痛点</strong>问题：</h3><blockquote>\n<ul>\n<li>开发者在代码中大量调用相同的 DOM API，处理繁琐 ，操作冗余，使得代码难以维护。</li>\n<li>大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。</li>\n<li>当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致 Model 发生变化，开发者同样需要将变化的数据同步到Model 中，这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。</li>\n</ul>\n</blockquote>\n<h2 id=\"MVVM-的出现，完美解决了以上三个问题。\"><a href=\"#MVVM-的出现，完美解决了以上三个问题。\" class=\"headerlink\" title=\"MVVM 的出现，完美解决了以上三个问题。\"></a>MVVM 的出现，完美解决了以上三个问题。</h2><h3 id=\"MVVM-由-Model、View、ViewModel-三部分构成，Model-层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View-代表UI-组件，它负责将数据模型转化成UI-展现出来，ViewModel-是一个同步View-和-Model的对象。\"><a href=\"#MVVM-由-Model、View、ViewModel-三部分构成，Model-层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View-代表UI-组件，它负责将数据模型转化成UI-展现出来，ViewModel-是一个同步View-和-Model的对象。\" class=\"headerlink\" title=\"MVVM 由 Model、View、ViewModel 三部分构成，Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。\"></a>MVVM 由 Model、View、ViewModel 三部分构成，Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。</h3><blockquote>\n<p>在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。</p>\n</blockquote>\n<h3 id=\"ViewModel-通过双向数据绑定把-View-层和-Model-层连接了起来，而View-和-Model-之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM，-不需要关注数据状态的同步问题，复杂的数据状态维护完全由-MVVM-来统一管理。\"><a href=\"#ViewModel-通过双向数据绑定把-View-层和-Model-层连接了起来，而View-和-Model-之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM，-不需要关注数据状态的同步问题，复杂的数据状态维护完全由-MVVM-来统一管理。\" class=\"headerlink\" title=\"　ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM， 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。\"></a>　ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM， 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</h3><h2 id=\"Vue-js-的细节\"><a href=\"#Vue-js-的细节\" class=\"headerlink\" title=\"Vue.js 的细节\"></a><strong>Vue.js 的细节</strong></h2><h4 id=\"Vue-js-可以说是MVVM-架构的最佳实践，专注于-MVVM-中的-ViewModel，不仅做到了数据双向绑定，而且也是一款相对来比较轻量级的JS-库，API-简洁，很容易上手。Vue的基础知识网上有现成的教程，此处不再赘述，-下面简单了解一下-Vue-js-关于双向绑定的一些实现细节：\"><a href=\"#Vue-js-可以说是MVVM-架构的最佳实践，专注于-MVVM-中的-ViewModel，不仅做到了数据双向绑定，而且也是一款相对来比较轻量级的JS-库，API-简洁，很容易上手。Vue的基础知识网上有现成的教程，此处不再赘述，-下面简单了解一下-Vue-js-关于双向绑定的一些实现细节：\" class=\"headerlink\" title=\"Vue.js 可以说是MVVM 架构的最佳实践，专注于 MVVM 中的 ViewModel，不仅做到了数据双向绑定，而且也是一款相对来比较轻量级的JS 库，API 简洁，很容易上手。Vue的基础知识网上有现成的教程，此处不再赘述， 下面简单了解一下 Vue.js 关于双向绑定的一些实现细节：\"></a>Vue.js 可以说是MVVM 架构的最佳实践，专注于 MVVM 中的 ViewModel，不仅做到了数据双向绑定，而且也是一款相对来比较轻量级的JS 库，API 简洁，很容易上手。Vue的基础知识网上有现成的教程，此处不再赘述， 下面简单了解一下 Vue.js 关于双向绑定的一些实现细节：</h4><blockquote>\n<p>Vue.js 是采用 Object.defineProperty 的 getter 和 setter，并结合观察者模式来实现数据绑定的。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/1.0.png\" alt=\"\"></p>\n<ul>\n<li>Observer ：数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用Object.defineProperty的getter和setter来实现</li>\n<li>Compile  ：指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数</li>\n<li>Watcher  ：订阅者，作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数</li>\n<li>Dep ：消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法</li>\n</ul>\n<blockquote>\n<p>从图中可以看出，当执行 new Vue() 时，Vue 就进入了初始化阶段，一方面Vue 会遍历 data 选项中的属性，并用 Object.defineProperty 将它们转为 getter/setter，实现数据变化监听功能；另一方面，Vue 的指令编译器Compile 对元素节点的指令进行扫描和解析，初始化视图，并订阅 Watcher 来更新视图， 此时Wather 会将自己添加到消息订阅器中(Dep)，初始化完毕。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>当数据发生变化时，Observer 中的 setter 方法被触发，setter 会立即调用Dep.notify()，Dep 开始遍历所有的订阅者，并调用订阅者的 update 方法，订阅者收到通知后对视图进行相应的更新。</p>\n</blockquote>\n<h2 id=\"MVVM？比之-MVC-有什么区别？\"><a href=\"#MVVM？比之-MVC-有什么区别？\" class=\"headerlink\" title=\"MVVM？比之 MVC 有什么区别？\"></a>MVVM？比之 MVC 有什么区别？</h2><h3 id=\"首先先来说下-View-和-Model\"><a href=\"#首先先来说下-View-和-Model\" class=\"headerlink\" title=\"首先先来说下 View 和 Model\"></a>首先先来说下 View 和 Model</h3><ul>\n<li>View 很简单，就是用户看到的视图</li>\n<li>Model 同样很简单，一般就是本地数据和数据库中的数据</li>\n</ul>\n<h3 id=\"基本上，我们写的产品就是通过接口从数据库中读取数据，然后将数据经过处理展现到用户看到的视图上。当然我们还可以从视图上读取用户的输入，然后又将用户的输入通过接口写入到数据库中。但是，如何将数据展示到视图上，然后又如何将用户的输入写入到数据中，不同的人就产生了不同的看法，从此出现了很多种架构设计。\"><a href=\"#基本上，我们写的产品就是通过接口从数据库中读取数据，然后将数据经过处理展现到用户看到的视图上。当然我们还可以从视图上读取用户的输入，然后又将用户的输入通过接口写入到数据库中。但是，如何将数据展示到视图上，然后又如何将用户的输入写入到数据中，不同的人就产生了不同的看法，从此出现了很多种架构设计。\" class=\"headerlink\" title=\"基本上，我们写的产品就是通过接口从数据库中读取数据，然后将数据经过处理展现到用户看到的视图上。当然我们还可以从视图上读取用户的输入，然后又将用户的输入通过接口写入到数据库中。但是，如何将数据展示到视图上，然后又如何将用户的输入写入到数据中，不同的人就产生了不同的看法，从此出现了很多种架构设计。\"></a>基本上，我们写的产品就是通过接口从数据库中读取数据，然后将数据经过处理展现到用户看到的视图上。当然我们还可以从视图上读取用户的输入，然后又将用户的输入通过接口写入到数据库中。但是，如何将数据展示到视图上，然后又如何将用户的输入写入到数据中，不同的人就产生了不同的看法，从此出现了很多种架构设计。</h3><h4 id=\"传统的-MVC-架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。\"><a href=\"#传统的-MVC-架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。\" class=\"headerlink\" title=\"传统的 MVC 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。\"></a>传统的 MVC 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。</h4><p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/1.1.png\" alt=\"\"></p>\n<p>####但是 MVC 有一个巨大的缺陷就是控制器承担的责任太大了，随着项目愈加复杂，控制器中的代码会越来越臃肿，导致出现不利于维护的情况。</p>\n<h3 id=\"在-MVVM-架构中，引入了-ViewModel-的概念。ViewModel-只关心数据和业务的处理，不关心-View-如何处理数据，在这种情况下，View-和-Model-都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个-ViewModel-中，让多个-View-复用这个-ViewModel。\"><a href=\"#在-MVVM-架构中，引入了-ViewModel-的概念。ViewModel-只关心数据和业务的处理，不关心-View-如何处理数据，在这种情况下，View-和-Model-都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个-ViewModel-中，让多个-View-复用这个-ViewModel。\" class=\"headerlink\" title=\"在 MVVM 架构中，引入了 ViewModel 的概念。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。\"></a>在 MVVM 架构中，引入了 ViewModel 的概念。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。</h3><p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/1.2.png\" alt=\"\"></p>\n<h3 id=\"以-Vue-框架来举例，ViewModel-就是组件的实例。View-就是模板，Model-的话在引入-Vuex-的情况下是完全可以和组件分离的。\"><a href=\"#以-Vue-框架来举例，ViewModel-就是组件的实例。View-就是模板，Model-的话在引入-Vuex-的情况下是完全可以和组件分离的。\" class=\"headerlink\" title=\"以 Vue 框架来举例，ViewModel 就是组件的实例。View 就是模板，Model 的话在引入 Vuex 的情况下是完全可以和组件分离的。\"></a>以 Vue 框架来举例，ViewModel 就是组件的实例。View 就是模板，Model 的话在引入 Vuex 的情况下是完全可以和组件分离的。</h3><p>####除了以上三个部分，其实在 MVVM 中还引入了一个隐式的 Binder 层，实现了 View 和 ViewModel 的绑定。</p>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/1.3.png\" alt=\"\"></p>\n<h5 id=\"同样以-Vue-框架来举例，这个隐式的-Binder-层就是-Vue-通过解析模板中的插值和指令从而实现-View-与-ViewModel-的绑定。\"><a href=\"#同样以-Vue-框架来举例，这个隐式的-Binder-层就是-Vue-通过解析模板中的插值和指令从而实现-View-与-ViewModel-的绑定。\" class=\"headerlink\" title=\"同样以 Vue 框架来举例，这个隐式的 Binder 层就是 Vue 通过解析模板中的插值和指令从而实现 View 与 ViewModel 的绑定。\"></a>同样以 Vue 框架来举例，这个隐式的 Binder 层就是 Vue 通过解析模板中的插值和指令从而实现 View 与 ViewModel 的绑定。</h5><p>对于 MVVM 来说，其实最重要的并不是通过双向绑定或者其他的方式将 View 与 ViewModel 绑定起来，<strong>而是通过 ViewModel 将视图中的状态和用户的行为分离出一个抽象，这才是 MVVM 的精髓。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"mvvm模式\"><a href=\"#mvvm模式\" class=\"headerlink\" title=\"mvvm模式\"></a>mvvm模式</h2><h3 id=\"MVVM-是Model-View-ViewModel-的缩写，它是一种基于前端开发的架构模式，其核心是提供对View-和-ViewModel-的双向数据绑定，这使得ViewModel-的状态改变可以自动传递给-View，即所谓的数据双向绑定。\"><a href=\"#MVVM-是Model-View-ViewModel-的缩写，它是一种基于前端开发的架构模式，其核心是提供对View-和-ViewModel-的双向数据绑定，这使得ViewModel-的状态改变可以自动传递给-View，即所谓的数据双向绑定。\" class=\"headerlink\" title=\"　MVVM 是Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式，其核心是提供对View 和 ViewModel 的双向数据绑定，这使得ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定。\"></a>　MVVM 是Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式，其核心是提供对View 和 ViewModel 的双向数据绑定，这使得ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定。</h3><blockquote>\n<p><strong><a href=\"https://github.com/Ignorance-of-Dong/mvvm\" target=\"_blank\" rel=\"noopener\">mvvm原理源码地址</a></strong></p>\n</blockquote>\n<blockquote>\n<p>Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。</p>\n</blockquote>\n<h2 id=\"为什么会出现-MVVM-呢？\"><a href=\"#为什么会出现-MVVM-呢？\" class=\"headerlink\" title=\"为什么会出现 MVVM 呢？\"></a>为什么会出现 MVVM 呢？</h2><p>###MVC 即 Model-View-Controller 的缩写，就是 模型—视图—控制器，也就是说一个标准的Web 应用程式是由这三部分组成的：</p>\n<blockquote>\n<ul>\n<li>View ：用来把数据以某种方式呈现给用户</li>\n<li>Model ：其实就是数据</li>\n<li>Controller ：接收并处理来自用户的请求，并将 Model 返回给用户</li>\n</ul>\n</blockquote>\n<h3 id=\"随着H5-的不断发展，人们更希望使用H5-开发的应用能和Native-媲美，或者接近于原生App-的体验效果，于是前端应用的复杂程度已不同往日，今非昔比。这时前端开发就暴露出了三个痛点问题：\"><a href=\"#随着H5-的不断发展，人们更希望使用H5-开发的应用能和Native-媲美，或者接近于原生App-的体验效果，于是前端应用的复杂程度已不同往日，今非昔比。这时前端开发就暴露出了三个痛点问题：\" class=\"headerlink\" title=\"随着H5 的不断发展，人们更希望使用H5 开发的应用能和Native 媲美，或者接近于原生App 的体验效果，于是前端应用的复杂程度已不同往日，今非昔比。这时前端开发就暴露出了三个痛点问题：\"></a>随着H5 的不断发展，人们更希望使用H5 开发的应用能和Native 媲美，或者接近于原生App 的体验效果，于是前端应用的复杂程度已不同往日，今非昔比。这时前端开发就暴露出了三个<strong>痛点</strong>问题：</h3><blockquote>\n<ul>\n<li>开发者在代码中大量调用相同的 DOM API，处理繁琐 ，操作冗余，使得代码难以维护。</li>\n<li>大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。</li>\n<li>当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致 Model 发生变化，开发者同样需要将变化的数据同步到Model 中，这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。</li>\n</ul>\n</blockquote>\n<h2 id=\"MVVM-的出现，完美解决了以上三个问题。\"><a href=\"#MVVM-的出现，完美解决了以上三个问题。\" class=\"headerlink\" title=\"MVVM 的出现，完美解决了以上三个问题。\"></a>MVVM 的出现，完美解决了以上三个问题。</h2><h3 id=\"MVVM-由-Model、View、ViewModel-三部分构成，Model-层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View-代表UI-组件，它负责将数据模型转化成UI-展现出来，ViewModel-是一个同步View-和-Model的对象。\"><a href=\"#MVVM-由-Model、View、ViewModel-三部分构成，Model-层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View-代表UI-组件，它负责将数据模型转化成UI-展现出来，ViewModel-是一个同步View-和-Model的对象。\" class=\"headerlink\" title=\"MVVM 由 Model、View、ViewModel 三部分构成，Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。\"></a>MVVM 由 Model、View、ViewModel 三部分构成，Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。</h3><blockquote>\n<p>在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。</p>\n</blockquote>\n<h3 id=\"ViewModel-通过双向数据绑定把-View-层和-Model-层连接了起来，而View-和-Model-之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM，-不需要关注数据状态的同步问题，复杂的数据状态维护完全由-MVVM-来统一管理。\"><a href=\"#ViewModel-通过双向数据绑定把-View-层和-Model-层连接了起来，而View-和-Model-之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM，-不需要关注数据状态的同步问题，复杂的数据状态维护完全由-MVVM-来统一管理。\" class=\"headerlink\" title=\"　ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM， 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。\"></a>　ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM， 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</h3><h2 id=\"Vue-js-的细节\"><a href=\"#Vue-js-的细节\" class=\"headerlink\" title=\"Vue.js 的细节\"></a><strong>Vue.js 的细节</strong></h2><h4 id=\"Vue-js-可以说是MVVM-架构的最佳实践，专注于-MVVM-中的-ViewModel，不仅做到了数据双向绑定，而且也是一款相对来比较轻量级的JS-库，API-简洁，很容易上手。Vue的基础知识网上有现成的教程，此处不再赘述，-下面简单了解一下-Vue-js-关于双向绑定的一些实现细节：\"><a href=\"#Vue-js-可以说是MVVM-架构的最佳实践，专注于-MVVM-中的-ViewModel，不仅做到了数据双向绑定，而且也是一款相对来比较轻量级的JS-库，API-简洁，很容易上手。Vue的基础知识网上有现成的教程，此处不再赘述，-下面简单了解一下-Vue-js-关于双向绑定的一些实现细节：\" class=\"headerlink\" title=\"Vue.js 可以说是MVVM 架构的最佳实践，专注于 MVVM 中的 ViewModel，不仅做到了数据双向绑定，而且也是一款相对来比较轻量级的JS 库，API 简洁，很容易上手。Vue的基础知识网上有现成的教程，此处不再赘述， 下面简单了解一下 Vue.js 关于双向绑定的一些实现细节：\"></a>Vue.js 可以说是MVVM 架构的最佳实践，专注于 MVVM 中的 ViewModel，不仅做到了数据双向绑定，而且也是一款相对来比较轻量级的JS 库，API 简洁，很容易上手。Vue的基础知识网上有现成的教程，此处不再赘述， 下面简单了解一下 Vue.js 关于双向绑定的一些实现细节：</h4><blockquote>\n<p>Vue.js 是采用 Object.defineProperty 的 getter 和 setter，并结合观察者模式来实现数据绑定的。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/1.0.png\" alt=\"\"></p>\n<ul>\n<li>Observer ：数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用Object.defineProperty的getter和setter来实现</li>\n<li>Compile  ：指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数</li>\n<li>Watcher  ：订阅者，作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数</li>\n<li>Dep ：消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法</li>\n</ul>\n<blockquote>\n<p>从图中可以看出，当执行 new Vue() 时，Vue 就进入了初始化阶段，一方面Vue 会遍历 data 选项中的属性，并用 Object.defineProperty 将它们转为 getter/setter，实现数据变化监听功能；另一方面，Vue 的指令编译器Compile 对元素节点的指令进行扫描和解析，初始化视图，并订阅 Watcher 来更新视图， 此时Wather 会将自己添加到消息订阅器中(Dep)，初始化完毕。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>当数据发生变化时，Observer 中的 setter 方法被触发，setter 会立即调用Dep.notify()，Dep 开始遍历所有的订阅者，并调用订阅者的 update 方法，订阅者收到通知后对视图进行相应的更新。</p>\n</blockquote>\n<h2 id=\"MVVM？比之-MVC-有什么区别？\"><a href=\"#MVVM？比之-MVC-有什么区别？\" class=\"headerlink\" title=\"MVVM？比之 MVC 有什么区别？\"></a>MVVM？比之 MVC 有什么区别？</h2><h3 id=\"首先先来说下-View-和-Model\"><a href=\"#首先先来说下-View-和-Model\" class=\"headerlink\" title=\"首先先来说下 View 和 Model\"></a>首先先来说下 View 和 Model</h3><ul>\n<li>View 很简单，就是用户看到的视图</li>\n<li>Model 同样很简单，一般就是本地数据和数据库中的数据</li>\n</ul>\n<h3 id=\"基本上，我们写的产品就是通过接口从数据库中读取数据，然后将数据经过处理展现到用户看到的视图上。当然我们还可以从视图上读取用户的输入，然后又将用户的输入通过接口写入到数据库中。但是，如何将数据展示到视图上，然后又如何将用户的输入写入到数据中，不同的人就产生了不同的看法，从此出现了很多种架构设计。\"><a href=\"#基本上，我们写的产品就是通过接口从数据库中读取数据，然后将数据经过处理展现到用户看到的视图上。当然我们还可以从视图上读取用户的输入，然后又将用户的输入通过接口写入到数据库中。但是，如何将数据展示到视图上，然后又如何将用户的输入写入到数据中，不同的人就产生了不同的看法，从此出现了很多种架构设计。\" class=\"headerlink\" title=\"基本上，我们写的产品就是通过接口从数据库中读取数据，然后将数据经过处理展现到用户看到的视图上。当然我们还可以从视图上读取用户的输入，然后又将用户的输入通过接口写入到数据库中。但是，如何将数据展示到视图上，然后又如何将用户的输入写入到数据中，不同的人就产生了不同的看法，从此出现了很多种架构设计。\"></a>基本上，我们写的产品就是通过接口从数据库中读取数据，然后将数据经过处理展现到用户看到的视图上。当然我们还可以从视图上读取用户的输入，然后又将用户的输入通过接口写入到数据库中。但是，如何将数据展示到视图上，然后又如何将用户的输入写入到数据中，不同的人就产生了不同的看法，从此出现了很多种架构设计。</h3><h4 id=\"传统的-MVC-架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。\"><a href=\"#传统的-MVC-架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。\" class=\"headerlink\" title=\"传统的 MVC 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。\"></a>传统的 MVC 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。</h4><p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/1.1.png\" alt=\"\"></p>\n<p>####但是 MVC 有一个巨大的缺陷就是控制器承担的责任太大了，随着项目愈加复杂，控制器中的代码会越来越臃肿，导致出现不利于维护的情况。</p>\n<h3 id=\"在-MVVM-架构中，引入了-ViewModel-的概念。ViewModel-只关心数据和业务的处理，不关心-View-如何处理数据，在这种情况下，View-和-Model-都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个-ViewModel-中，让多个-View-复用这个-ViewModel。\"><a href=\"#在-MVVM-架构中，引入了-ViewModel-的概念。ViewModel-只关心数据和业务的处理，不关心-View-如何处理数据，在这种情况下，View-和-Model-都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个-ViewModel-中，让多个-View-复用这个-ViewModel。\" class=\"headerlink\" title=\"在 MVVM 架构中，引入了 ViewModel 的概念。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。\"></a>在 MVVM 架构中，引入了 ViewModel 的概念。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。</h3><p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/1.2.png\" alt=\"\"></p>\n<h3 id=\"以-Vue-框架来举例，ViewModel-就是组件的实例。View-就是模板，Model-的话在引入-Vuex-的情况下是完全可以和组件分离的。\"><a href=\"#以-Vue-框架来举例，ViewModel-就是组件的实例。View-就是模板，Model-的话在引入-Vuex-的情况下是完全可以和组件分离的。\" class=\"headerlink\" title=\"以 Vue 框架来举例，ViewModel 就是组件的实例。View 就是模板，Model 的话在引入 Vuex 的情况下是完全可以和组件分离的。\"></a>以 Vue 框架来举例，ViewModel 就是组件的实例。View 就是模板，Model 的话在引入 Vuex 的情况下是完全可以和组件分离的。</h3><p>####除了以上三个部分，其实在 MVVM 中还引入了一个隐式的 Binder 层，实现了 View 和 ViewModel 的绑定。</p>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/1.3.png\" alt=\"\"></p>\n<h5 id=\"同样以-Vue-框架来举例，这个隐式的-Binder-层就是-Vue-通过解析模板中的插值和指令从而实现-View-与-ViewModel-的绑定。\"><a href=\"#同样以-Vue-框架来举例，这个隐式的-Binder-层就是-Vue-通过解析模板中的插值和指令从而实现-View-与-ViewModel-的绑定。\" class=\"headerlink\" title=\"同样以 Vue 框架来举例，这个隐式的 Binder 层就是 Vue 通过解析模板中的插值和指令从而实现 View 与 ViewModel 的绑定。\"></a>同样以 Vue 框架来举例，这个隐式的 Binder 层就是 Vue 通过解析模板中的插值和指令从而实现 View 与 ViewModel 的绑定。</h5><p>对于 MVVM 来说，其实最重要的并不是通过双向绑定或者其他的方式将 View 与 ViewModel 绑定起来，<strong>而是通过 ViewModel 将视图中的状态和用户的行为分离出一个抽象，这才是 MVVM 的精髓。</strong></p>\n"},{"title":"Linux系统基础命令","date":"2019-03-27T01:22:06.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"# Linux系统基础命令\n\n## 连接远程服务器：ssh root@公网ip\n\n> ls 查看目录\n> cd 切换目录 （用户目录root~ 系统根目录 /）\n\n\n> 创建文件 touch 文件名字\n> 删除文件 rm 文件路径\n> 移动文件 mv 要移动的文件 移动后的路径\n> 创建文件夹 mkdir 目录名称\n> 拷贝文件 cp 文件 目标路径\n\n\n> vim 编辑文件\n> i 开始编辑\n> esc :wq 退出并保存","source":"_posts/Linux.md","raw":"---\ntitle: Linux系统基础命令\ndate: '3/27/2019 9:22:06 AM '\ntag: ['js', 'Linux']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n# Linux系统基础命令\n\n## 连接远程服务器：ssh root@公网ip\n\n> ls 查看目录\n> cd 切换目录 （用户目录root~ 系统根目录 /）\n\n\n> 创建文件 touch 文件名字\n> 删除文件 rm 文件路径\n> 移动文件 mv 要移动的文件 移动后的路径\n> 创建文件夹 mkdir 目录名称\n> 拷贝文件 cp 文件 目标路径\n\n\n> vim 编辑文件\n> i 开始编辑\n> esc :wq 退出并保存","slug":"Linux","published":1,"updated":"2019-03-28T01:25:24.227Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam6b0009n4wd81zym9nj","content":"<h1 id=\"Linux系统基础命令\"><a href=\"#Linux系统基础命令\" class=\"headerlink\" title=\"Linux系统基础命令\"></a>Linux系统基础命令</h1><h2 id=\"连接远程服务器：ssh-root-公网ip\"><a href=\"#连接远程服务器：ssh-root-公网ip\" class=\"headerlink\" title=\"连接远程服务器：ssh root@公网ip\"></a>连接远程服务器：ssh root@公网ip</h2><blockquote>\n<p>ls 查看目录<br>cd 切换目录 （用户目录root~ 系统根目录 /）</p>\n</blockquote>\n<blockquote>\n<p>创建文件 touch 文件名字<br>删除文件 rm 文件路径<br>移动文件 mv 要移动的文件 移动后的路径<br>创建文件夹 mkdir 目录名称<br>拷贝文件 cp 文件 目标路径</p>\n</blockquote>\n<blockquote>\n<p>vim 编辑文件<br>i 开始编辑<br>esc :wq 退出并保存</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Linux系统基础命令\"><a href=\"#Linux系统基础命令\" class=\"headerlink\" title=\"Linux系统基础命令\"></a>Linux系统基础命令</h1><h2 id=\"连接远程服务器：ssh-root-公网ip\"><a href=\"#连接远程服务器：ssh-root-公网ip\" class=\"headerlink\" title=\"连接远程服务器：ssh root@公网ip\"></a>连接远程服务器：ssh root@公网ip</h2><blockquote>\n<p>ls 查看目录<br>cd 切换目录 （用户目录root~ 系统根目录 /）</p>\n</blockquote>\n<blockquote>\n<p>创建文件 touch 文件名字<br>删除文件 rm 文件路径<br>移动文件 mv 要移动的文件 移动后的路径<br>创建文件夹 mkdir 目录名称<br>拷贝文件 cp 文件 目标路径</p>\n</blockquote>\n<blockquote>\n<p>vim 编辑文件<br>i 开始编辑<br>esc :wq 退出并保存</p>\n</blockquote>\n"},{"title":"vue-router路由","date":"2019-01-28T12:31:06.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"# 路由\n\n## 路由传参(query,params)\n\n#### 在单页面应用中路由的传递方式常用的两种方法、(query,params)\n\n> ### query\n\n#### 包含在路径后面以？作为分割符，多参数直接使用&分割开发，名字和值使用=分隔，这种方式适合传递不必须的值，传递和不传递都不会影响页面的加载\n\n> ### params\n\n#### 包含在路由路径之中，这种方式是框架内部的参数传递实现的，这种方式适合传递必须传递的值(/detail/:id) (/detail/11213),可以出现在路径中的任何位置\n\n> ### 如何获取($router)\n\n#### 在vue中路由参数通过，$route获取，$route.params获取params传递的参数，$route.query获取query传递的参数，而$route就是代表的是当前页面的路由信息对象\n\n###而$router是获取的是路由实例，$route只是$router中一个参数的指针而已（）\n\n## 常识：\n\n- **1.router-link组件是用来跳转路由的，to属性是将要跳转的路由页地址。**\n\n- **2.router-view组件是用来展示组件页的。**","source":"_posts/New Router.md","raw":"---\ntitle: vue-router路由\ndate: '1/28/2019 8:31:06 PM  '\ntag: ['vue-router', 'vue']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n# 路由\n\n## 路由传参(query,params)\n\n#### 在单页面应用中路由的传递方式常用的两种方法、(query,params)\n\n> ### query\n\n#### 包含在路径后面以？作为分割符，多参数直接使用&分割开发，名字和值使用=分隔，这种方式适合传递不必须的值，传递和不传递都不会影响页面的加载\n\n> ### params\n\n#### 包含在路由路径之中，这种方式是框架内部的参数传递实现的，这种方式适合传递必须传递的值(/detail/:id) (/detail/11213),可以出现在路径中的任何位置\n\n> ### 如何获取($router)\n\n#### 在vue中路由参数通过，$route获取，$route.params获取params传递的参数，$route.query获取query传递的参数，而$route就是代表的是当前页面的路由信息对象\n\n###而$router是获取的是路由实例，$route只是$router中一个参数的指针而已（）\n\n## 常识：\n\n- **1.router-link组件是用来跳转路由的，to属性是将要跳转的路由页地址。**\n\n- **2.router-view组件是用来展示组件页的。**","slug":"New Router","published":1,"updated":"2019-01-28T12:33:05.442Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam6f000cn4wdjfruu02l","content":"<h1 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h1><h2 id=\"路由传参-query-params\"><a href=\"#路由传参-query-params\" class=\"headerlink\" title=\"路由传参(query,params)\"></a>路由传参(query,params)</h2><h4 id=\"在单页面应用中路由的传递方式常用的两种方法、-query-params\"><a href=\"#在单页面应用中路由的传递方式常用的两种方法、-query-params\" class=\"headerlink\" title=\"在单页面应用中路由的传递方式常用的两种方法、(query,params)\"></a>在单页面应用中路由的传递方式常用的两种方法、(query,params)</h4><blockquote>\n<h3 id=\"query\"><a href=\"#query\" class=\"headerlink\" title=\"query\"></a>query</h3></blockquote>\n<h4 id=\"包含在路径后面以？作为分割符，多参数直接使用-amp-分割开发，名字和值使用-分隔，这种方式适合传递不必须的值，传递和不传递都不会影响页面的加载\"><a href=\"#包含在路径后面以？作为分割符，多参数直接使用-amp-分割开发，名字和值使用-分隔，这种方式适合传递不必须的值，传递和不传递都不会影响页面的加载\" class=\"headerlink\" title=\"包含在路径后面以？作为分割符，多参数直接使用&amp;分割开发，名字和值使用=分隔，这种方式适合传递不必须的值，传递和不传递都不会影响页面的加载\"></a>包含在路径后面以？作为分割符，多参数直接使用&amp;分割开发，名字和值使用=分隔，这种方式适合传递不必须的值，传递和不传递都不会影响页面的加载</h4><blockquote>\n<h3 id=\"params\"><a href=\"#params\" class=\"headerlink\" title=\"params\"></a>params</h3></blockquote>\n<h4 id=\"包含在路由路径之中，这种方式是框架内部的参数传递实现的，这种方式适合传递必须传递的值-detail-id-detail-11213-可以出现在路径中的任何位置\"><a href=\"#包含在路由路径之中，这种方式是框架内部的参数传递实现的，这种方式适合传递必须传递的值-detail-id-detail-11213-可以出现在路径中的任何位置\" class=\"headerlink\" title=\"包含在路由路径之中，这种方式是框架内部的参数传递实现的，这种方式适合传递必须传递的值(/detail/:id) (/detail/11213),可以出现在路径中的任何位置\"></a>包含在路由路径之中，这种方式是框架内部的参数传递实现的，这种方式适合传递必须传递的值(/detail/:id) (/detail/11213),可以出现在路径中的任何位置</h4><blockquote>\n<h3 id=\"如何获取-router\"><a href=\"#如何获取-router\" class=\"headerlink\" title=\"如何获取($router)\"></a>如何获取($router)</h3></blockquote>\n<h4 id=\"在vue中路由参数通过，-route获取，-route-params获取params传递的参数，-route-query获取query传递的参数，而-route就是代表的是当前页面的路由信息对象\"><a href=\"#在vue中路由参数通过，-route获取，-route-params获取params传递的参数，-route-query获取query传递的参数，而-route就是代表的是当前页面的路由信息对象\" class=\"headerlink\" title=\"在vue中路由参数通过，$route获取，$route.params获取params传递的参数，$route.query获取query传递的参数，而$route就是代表的是当前页面的路由信息对象\"></a>在vue中路由参数通过，$route获取，$route.params获取params传递的参数，$route.query获取query传递的参数，而$route就是代表的是当前页面的路由信息对象</h4><p>###而$router是获取的是路由实例，$route只是$router中一个参数的指针而已（）</p>\n<h2 id=\"常识：\"><a href=\"#常识：\" class=\"headerlink\" title=\"常识：\"></a>常识：</h2><ul>\n<li><p><strong>1.router-link组件是用来跳转路由的，to属性是将要跳转的路由页地址。</strong></p>\n</li>\n<li><p><strong>2.router-view组件是用来展示组件页的。</strong></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h1><h2 id=\"路由传参-query-params\"><a href=\"#路由传参-query-params\" class=\"headerlink\" title=\"路由传参(query,params)\"></a>路由传参(query,params)</h2><h4 id=\"在单页面应用中路由的传递方式常用的两种方法、-query-params\"><a href=\"#在单页面应用中路由的传递方式常用的两种方法、-query-params\" class=\"headerlink\" title=\"在单页面应用中路由的传递方式常用的两种方法、(query,params)\"></a>在单页面应用中路由的传递方式常用的两种方法、(query,params)</h4><blockquote>\n<h3 id=\"query\"><a href=\"#query\" class=\"headerlink\" title=\"query\"></a>query</h3></blockquote>\n<h4 id=\"包含在路径后面以？作为分割符，多参数直接使用-amp-分割开发，名字和值使用-分隔，这种方式适合传递不必须的值，传递和不传递都不会影响页面的加载\"><a href=\"#包含在路径后面以？作为分割符，多参数直接使用-amp-分割开发，名字和值使用-分隔，这种方式适合传递不必须的值，传递和不传递都不会影响页面的加载\" class=\"headerlink\" title=\"包含在路径后面以？作为分割符，多参数直接使用&amp;分割开发，名字和值使用=分隔，这种方式适合传递不必须的值，传递和不传递都不会影响页面的加载\"></a>包含在路径后面以？作为分割符，多参数直接使用&amp;分割开发，名字和值使用=分隔，这种方式适合传递不必须的值，传递和不传递都不会影响页面的加载</h4><blockquote>\n<h3 id=\"params\"><a href=\"#params\" class=\"headerlink\" title=\"params\"></a>params</h3></blockquote>\n<h4 id=\"包含在路由路径之中，这种方式是框架内部的参数传递实现的，这种方式适合传递必须传递的值-detail-id-detail-11213-可以出现在路径中的任何位置\"><a href=\"#包含在路由路径之中，这种方式是框架内部的参数传递实现的，这种方式适合传递必须传递的值-detail-id-detail-11213-可以出现在路径中的任何位置\" class=\"headerlink\" title=\"包含在路由路径之中，这种方式是框架内部的参数传递实现的，这种方式适合传递必须传递的值(/detail/:id) (/detail/11213),可以出现在路径中的任何位置\"></a>包含在路由路径之中，这种方式是框架内部的参数传递实现的，这种方式适合传递必须传递的值(/detail/:id) (/detail/11213),可以出现在路径中的任何位置</h4><blockquote>\n<h3 id=\"如何获取-router\"><a href=\"#如何获取-router\" class=\"headerlink\" title=\"如何获取($router)\"></a>如何获取($router)</h3></blockquote>\n<h4 id=\"在vue中路由参数通过，-route获取，-route-params获取params传递的参数，-route-query获取query传递的参数，而-route就是代表的是当前页面的路由信息对象\"><a href=\"#在vue中路由参数通过，-route获取，-route-params获取params传递的参数，-route-query获取query传递的参数，而-route就是代表的是当前页面的路由信息对象\" class=\"headerlink\" title=\"在vue中路由参数通过，$route获取，$route.params获取params传递的参数，$route.query获取query传递的参数，而$route就是代表的是当前页面的路由信息对象\"></a>在vue中路由参数通过，$route获取，$route.params获取params传递的参数，$route.query获取query传递的参数，而$route就是代表的是当前页面的路由信息对象</h4><p>###而$router是获取的是路由实例，$route只是$router中一个参数的指针而已（）</p>\n<h2 id=\"常识：\"><a href=\"#常识：\" class=\"headerlink\" title=\"常识：\"></a>常识：</h2><ul>\n<li><p><strong>1.router-link组件是用来跳转路由的，to属性是将要跳转的路由页地址。</strong></p>\n</li>\n<li><p><strong>2.router-view组件是用来展示组件页的。</strong></p>\n</li>\n</ul>\n"},{"title":"常见的几种数组排序算法JS实现","date":"2019-04-01T01:14:36.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"## 常见的几种数组排序算法JS实现\n\n### 冒泡排序\n\n> 故名思意 ，就是一个个冒泡到最前端或者最后端，主要是通过两两依次比较，以升序为例，如果前一项比后一项大则交换顺序，一直比到最后一对 \n\n\t\tfunction bubbleSort(arr) {\n\t  　　var len = arr.length; // 定义该数组的长度\n\t  　　for (var i = 0; i < len; i++) { // 遍历\n\t        console.log(arr[i], arr[i+1])\n\t  　　　　for (var j = 0; j < len - 1 - i; j++) {\n\t              \n\t  　　　　　　if (arr[j] > arr[j+1]) { //相邻元素两两对比\n\t  　　　　　　　　var temp = arr[j+1]; //元素交换\n\t  　　　　　　　　arr[j+1] = arr[j];\n\t  　　　　　　　　arr[j] = temp;\n\t  　　　　　　}\n\t  　　　　}\n\t  　　}\n\t  　　return arr;\n\t  }\n\t  var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\n\t  console.log(bubbleSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] ；\n\n### 选择排序 \n\n> 获取到数组长度，遍历第一次【不遍历最后一个】，定义变量保存下标，遍历第二次【不遍历第一个】，将数组的第一个与数组的第二个值作比较，如果第二个值小于第一个值，将第一次保存的变量下标进行一个替换【替换成最小数的索引】，如果不小于就不做操作，\n\n\n\t\tfunction selectionSort(arr) {\n\t  　　var len = arr.length;\n\t  　　var minIndex, temp;\n\t  　　console.time('选择排序耗时');\n\t  　　for (var i = 0; i < len - 1; i++) {\n\t  　　　　minIndex = i;\n\t  　　　　for (var j = i + 1; j < len; j++) {\n\t  　　　　　　if (arr[j] < arr[minIndex]) { //寻找最小的数\n\t  　　　　　　　　minIndex = j; //将最小数的索引保存\n\t  　　　　　　}\n\t  　　　　}\n\t  　　　　temp = arr[i];\n\t  　　　　arr[i] = arr[minIndex];\n\t  　　　　arr[minIndex] = temp;\n\t  　　}\n\t  　　console.timeEnd('选择排序耗时');\n\t  　　return arr;\n\t  }\n\t  var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\n\t  console.log(selectionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]；\n\n### 二分法插入排序\n\n> 第一次遍历【不遍历第一个】，将遍历的第一个值保存起来，定义起始点\n\n\n\t\tfunction binaryInsertionSort(array) {\n\t  　　console.time('二分插入排序耗时：');\n\t  　　for (var i = 1; i < array.length; i++) {\n\t  　　　　var key = array[i], left = 0, right = i - 1;\n\t          // key = 3 ,left = 0, right = 0\n\t          // key = 44 ,left = 0, right = 1\n\t  　　　　while (left <= right) { // 0 <= -1   // 0 <= 1\n\t  　　　　　　var middle = parseInt((left + right) / 2); // 0 // 0\n\t  　　　　　　if (key < array[middle]) { // 3 < arr[0] = 44 44 < 44\n\t  　　　　　　　　right = middle - 1; // right = -1\n\t  　　　　　　} else {\n\t  　　　　　　　　left = middle + 1;  // left = 1\n\t  　　　　　　}\n\t  　　　　}\n\t  　　　　for (var j = i - 1; j >= left; j--) { // 循环 \n\t  　　　　　　array[j + 1] = array[j]; // arr[1] = arr[0]  arr [2] = \n\t  　　　　}\n\t  　　　　array[left] = key; // arr[0] = 44\n\t  　　}\n\t  　　console.timeEnd('二分插入排序耗时：');\n\t  　　return array;\n\t  }\n\t  var arr=[44,3,38,5,47,15,36,26,27,2,46,4,19,50,48];\n\t  console.log(binaryInsertionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50];\n\n\n### ","source":"_posts/Sortt.md","raw":"---\ntitle: 常见的几种数组排序算法JS实现\ndate: '4/1/2019 9:14:36 AM '\ntag: ['js', 'sort', '排序']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n## 常见的几种数组排序算法JS实现\n\n### 冒泡排序\n\n> 故名思意 ，就是一个个冒泡到最前端或者最后端，主要是通过两两依次比较，以升序为例，如果前一项比后一项大则交换顺序，一直比到最后一对 \n\n\t\tfunction bubbleSort(arr) {\n\t  　　var len = arr.length; // 定义该数组的长度\n\t  　　for (var i = 0; i < len; i++) { // 遍历\n\t        console.log(arr[i], arr[i+1])\n\t  　　　　for (var j = 0; j < len - 1 - i; j++) {\n\t              \n\t  　　　　　　if (arr[j] > arr[j+1]) { //相邻元素两两对比\n\t  　　　　　　　　var temp = arr[j+1]; //元素交换\n\t  　　　　　　　　arr[j+1] = arr[j];\n\t  　　　　　　　　arr[j] = temp;\n\t  　　　　　　}\n\t  　　　　}\n\t  　　}\n\t  　　return arr;\n\t  }\n\t  var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\n\t  console.log(bubbleSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] ；\n\n### 选择排序 \n\n> 获取到数组长度，遍历第一次【不遍历最后一个】，定义变量保存下标，遍历第二次【不遍历第一个】，将数组的第一个与数组的第二个值作比较，如果第二个值小于第一个值，将第一次保存的变量下标进行一个替换【替换成最小数的索引】，如果不小于就不做操作，\n\n\n\t\tfunction selectionSort(arr) {\n\t  　　var len = arr.length;\n\t  　　var minIndex, temp;\n\t  　　console.time('选择排序耗时');\n\t  　　for (var i = 0; i < len - 1; i++) {\n\t  　　　　minIndex = i;\n\t  　　　　for (var j = i + 1; j < len; j++) {\n\t  　　　　　　if (arr[j] < arr[minIndex]) { //寻找最小的数\n\t  　　　　　　　　minIndex = j; //将最小数的索引保存\n\t  　　　　　　}\n\t  　　　　}\n\t  　　　　temp = arr[i];\n\t  　　　　arr[i] = arr[minIndex];\n\t  　　　　arr[minIndex] = temp;\n\t  　　}\n\t  　　console.timeEnd('选择排序耗时');\n\t  　　return arr;\n\t  }\n\t  var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\n\t  console.log(selectionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]；\n\n### 二分法插入排序\n\n> 第一次遍历【不遍历第一个】，将遍历的第一个值保存起来，定义起始点\n\n\n\t\tfunction binaryInsertionSort(array) {\n\t  　　console.time('二分插入排序耗时：');\n\t  　　for (var i = 1; i < array.length; i++) {\n\t  　　　　var key = array[i], left = 0, right = i - 1;\n\t          // key = 3 ,left = 0, right = 0\n\t          // key = 44 ,left = 0, right = 1\n\t  　　　　while (left <= right) { // 0 <= -1   // 0 <= 1\n\t  　　　　　　var middle = parseInt((left + right) / 2); // 0 // 0\n\t  　　　　　　if (key < array[middle]) { // 3 < arr[0] = 44 44 < 44\n\t  　　　　　　　　right = middle - 1; // right = -1\n\t  　　　　　　} else {\n\t  　　　　　　　　left = middle + 1;  // left = 1\n\t  　　　　　　}\n\t  　　　　}\n\t  　　　　for (var j = i - 1; j >= left; j--) { // 循环 \n\t  　　　　　　array[j + 1] = array[j]; // arr[1] = arr[0]  arr [2] = \n\t  　　　　}\n\t  　　　　array[left] = key; // arr[0] = 44\n\t  　　}\n\t  　　console.timeEnd('二分插入排序耗时：');\n\t  　　return array;\n\t  }\n\t  var arr=[44,3,38,5,47,15,36,26,27,2,46,4,19,50,48];\n\t  console.log(binaryInsertionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50];\n\n\n### ","slug":"Sortt","published":1,"updated":"2019-04-01T01:14:54.634Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam6g000dn4wd5i8ku2on","content":"<h2 id=\"常见的几种数组排序算法JS实现\"><a href=\"#常见的几种数组排序算法JS实现\" class=\"headerlink\" title=\"常见的几种数组排序算法JS实现\"></a>常见的几种数组排序算法JS实现</h2><h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><blockquote>\n<p>故名思意 ，就是一个个冒泡到最前端或者最后端，主要是通过两两依次比较，以升序为例，如果前一项比后一项大则交换顺序，一直比到最后一对 </p>\n</blockquote>\n<pre><code>    function bubbleSort(arr) {\n  　　var len = arr.length; // 定义该数组的长度\n  　　for (var i = 0; i &lt; len; i++) { // 遍历\n        console.log(arr[i], arr[i+1])\n  　　　　for (var j = 0; j &lt; len - 1 - i; j++) {\n\n  　　　　　　if (arr[j] &gt; arr[j+1]) { //相邻元素两两对比\n  　　　　　　　　var temp = arr[j+1]; //元素交换\n  　　　　　　　　arr[j+1] = arr[j];\n  　　　　　　　　arr[j] = temp;\n  　　　　　　}\n  　　　　}\n  　　}\n  　　return arr;\n  }\n  var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\n  console.log(bubbleSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] ；\n</code></pre><h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><blockquote>\n<p>获取到数组长度，遍历第一次【不遍历最后一个】，定义变量保存下标，遍历第二次【不遍历第一个】，将数组的第一个与数组的第二个值作比较，如果第二个值小于第一个值，将第一次保存的变量下标进行一个替换【替换成最小数的索引】，如果不小于就不做操作，</p>\n</blockquote>\n<pre><code>    function selectionSort(arr) {\n  　　var len = arr.length;\n  　　var minIndex, temp;\n  　　console.time(&#39;选择排序耗时&#39;);\n  　　for (var i = 0; i &lt; len - 1; i++) {\n  　　　　minIndex = i;\n  　　　　for (var j = i + 1; j &lt; len; j++) {\n  　　　　　　if (arr[j] &lt; arr[minIndex]) { //寻找最小的数\n  　　　　　　　　minIndex = j; //将最小数的索引保存\n  　　　　　　}\n  　　　　}\n  　　　　temp = arr[i];\n  　　　　arr[i] = arr[minIndex];\n  　　　　arr[minIndex] = temp;\n  　　}\n  　　console.timeEnd(&#39;选择排序耗时&#39;);\n  　　return arr;\n  }\n  var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\n  console.log(selectionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]；\n</code></pre><h3 id=\"二分法插入排序\"><a href=\"#二分法插入排序\" class=\"headerlink\" title=\"二分法插入排序\"></a>二分法插入排序</h3><blockquote>\n<p>第一次遍历【不遍历第一个】，将遍历的第一个值保存起来，定义起始点</p>\n</blockquote>\n<pre><code>    function binaryInsertionSort(array) {\n  　　console.time(&#39;二分插入排序耗时：&#39;);\n  　　for (var i = 1; i &lt; array.length; i++) {\n  　　　　var key = array[i], left = 0, right = i - 1;\n          // key = 3 ,left = 0, right = 0\n          // key = 44 ,left = 0, right = 1\n  　　　　while (left &lt;= right) { // 0 &lt;= -1   // 0 &lt;= 1\n  　　　　　　var middle = parseInt((left + right) / 2); // 0 // 0\n  　　　　　　if (key &lt; array[middle]) { // 3 &lt; arr[0] = 44 44 &lt; 44\n  　　　　　　　　right = middle - 1; // right = -1\n  　　　　　　} else {\n  　　　　　　　　left = middle + 1;  // left = 1\n  　　　　　　}\n  　　　　}\n  　　　　for (var j = i - 1; j &gt;= left; j--) { // 循环 \n  　　　　　　array[j + 1] = array[j]; // arr[1] = arr[0]  arr [2] = \n  　　　　}\n  　　　　array[left] = key; // arr[0] = 44\n  　　}\n  　　console.timeEnd(&#39;二分插入排序耗时：&#39;);\n  　　return array;\n  }\n  var arr=[44,3,38,5,47,15,36,26,27,2,46,4,19,50,48];\n  console.log(binaryInsertionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50];\n</code></pre><p>### </p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"常见的几种数组排序算法JS实现\"><a href=\"#常见的几种数组排序算法JS实现\" class=\"headerlink\" title=\"常见的几种数组排序算法JS实现\"></a>常见的几种数组排序算法JS实现</h2><h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><blockquote>\n<p>故名思意 ，就是一个个冒泡到最前端或者最后端，主要是通过两两依次比较，以升序为例，如果前一项比后一项大则交换顺序，一直比到最后一对 </p>\n</blockquote>\n<pre><code>    function bubbleSort(arr) {\n  　　var len = arr.length; // 定义该数组的长度\n  　　for (var i = 0; i &lt; len; i++) { // 遍历\n        console.log(arr[i], arr[i+1])\n  　　　　for (var j = 0; j &lt; len - 1 - i; j++) {\n\n  　　　　　　if (arr[j] &gt; arr[j+1]) { //相邻元素两两对比\n  　　　　　　　　var temp = arr[j+1]; //元素交换\n  　　　　　　　　arr[j+1] = arr[j];\n  　　　　　　　　arr[j] = temp;\n  　　　　　　}\n  　　　　}\n  　　}\n  　　return arr;\n  }\n  var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\n  console.log(bubbleSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] ；\n</code></pre><h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><blockquote>\n<p>获取到数组长度，遍历第一次【不遍历最后一个】，定义变量保存下标，遍历第二次【不遍历第一个】，将数组的第一个与数组的第二个值作比较，如果第二个值小于第一个值，将第一次保存的变量下标进行一个替换【替换成最小数的索引】，如果不小于就不做操作，</p>\n</blockquote>\n<pre><code>    function selectionSort(arr) {\n  　　var len = arr.length;\n  　　var minIndex, temp;\n  　　console.time(&#39;选择排序耗时&#39;);\n  　　for (var i = 0; i &lt; len - 1; i++) {\n  　　　　minIndex = i;\n  　　　　for (var j = i + 1; j &lt; len; j++) {\n  　　　　　　if (arr[j] &lt; arr[minIndex]) { //寻找最小的数\n  　　　　　　　　minIndex = j; //将最小数的索引保存\n  　　　　　　}\n  　　　　}\n  　　　　temp = arr[i];\n  　　　　arr[i] = arr[minIndex];\n  　　　　arr[minIndex] = temp;\n  　　}\n  　　console.timeEnd(&#39;选择排序耗时&#39;);\n  　　return arr;\n  }\n  var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\n  console.log(selectionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]；\n</code></pre><h3 id=\"二分法插入排序\"><a href=\"#二分法插入排序\" class=\"headerlink\" title=\"二分法插入排序\"></a>二分法插入排序</h3><blockquote>\n<p>第一次遍历【不遍历第一个】，将遍历的第一个值保存起来，定义起始点</p>\n</blockquote>\n<pre><code>    function binaryInsertionSort(array) {\n  　　console.time(&#39;二分插入排序耗时：&#39;);\n  　　for (var i = 1; i &lt; array.length; i++) {\n  　　　　var key = array[i], left = 0, right = i - 1;\n          // key = 3 ,left = 0, right = 0\n          // key = 44 ,left = 0, right = 1\n  　　　　while (left &lt;= right) { // 0 &lt;= -1   // 0 &lt;= 1\n  　　　　　　var middle = parseInt((left + right) / 2); // 0 // 0\n  　　　　　　if (key &lt; array[middle]) { // 3 &lt; arr[0] = 44 44 &lt; 44\n  　　　　　　　　right = middle - 1; // right = -1\n  　　　　　　} else {\n  　　　　　　　　left = middle + 1;  // left = 1\n  　　　　　　}\n  　　　　}\n  　　　　for (var j = i - 1; j &gt;= left; j--) { // 循环 \n  　　　　　　array[j + 1] = array[j]; // arr[1] = arr[0]  arr [2] = \n  　　　　}\n  　　　　array[left] = key; // arr[0] = 44\n  　　}\n  　　console.timeEnd(&#39;二分插入排序耗时：&#39;);\n  　　return array;\n  }\n  var arr=[44,3,38,5,47,15,36,26,27,2,46,4,19,50,48];\n  console.log(binaryInsertionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50];\n</code></pre><p>### </p>\n"},{"title":"React.Component 与 React.PureComponent（React之性能优化）","date":"2019-04-03T02:05:06.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"## React.Component 与 React.PureComponent（React之性能优化）\n\n**提起React.PureComponent，首先要从一个生命周期函数【shouldComponentUpdate】说起，都知道这个函数是用来控制组件是否应该被渲染**\n\n\tshouldComponentUpdate\n\n**这个生命周期返回的是一个布尔值，如果返回为false的，其实就是不执行render函数，不执行就不会重新渲染，返回为true的时候，就会执行，如果不写这个生命周期，默认返回true**\n\n**写入shouldComponentUpdate，可以提高性能，你可以在该函数根据业务需求来判断是否重新渲染**\n\n\tclass CounterButton extends React.Component {\n\t    constructor(props) {\n\t        super(props);\n\t        this.state = {count: 1};\n\t    }\n\t    shouldComponentUpdate(nextProps, nextState) {\n\t        if (this.props.color !== nextProps.color) {\n\t            return true;\n\t        }\n\t        if (this.state.count !== nextState.count) {\n\t            return true;\n\t        }\n\t        return false;\n\t    }\n\t    render() {\n\t        return (\n\t            <button\n\t                color={this.props.color}\n\t                onClick={() => this.setState(state => ({count: state.count + 1}))}\n\t            >\n\t                Count: {this.state.count}\n\t            </button>\n\t        );\n\t    }\n\t}\n\n## React.Component 与 React.PureComponent\n\n**通常情况下，我们会使用ES6的class关键字来创建React组件：**\n\t\n\tclass MyComponent extends React.Component {\n\t    // some codes here ...\n\t}\n\n**但是，你也可以创建一个继承React.PureComponent的React组件，就像这样**\n\n\tclass MyComponent extends React.PureComponent {\n\t    // some codes here\n\t}\n\n### 区别：\n\n- 继承PureComponent时，不能再重写shouldComponentUpdate，否则会引发警告\n\n----------\n\n\n\tWarning: ListOfWords has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.\n\n> 警告：ListOfWords有一个名为ShouldComponentUpdate（）的方法。扩展react.pureComponent时不应使用ShouldComponentUpdate。如果使用shouldComponentUpdate，请扩展react.component。\n\n- 继承PureComponent时，进行的是浅比较，也就是说，如果是引用类型的数据，只会比较是不是同一个地址，而不会比较具体这个地址存的数据是否完全一致\n\n### PureComponent\n\n#### 原理:\n\n**当组件更新时，如果组件的 props 和 state 都没发生改变， render 方法就不会触发，省去 Virtual DOM 的生成和比对过程，达到提升性能的目的。具体就是 React 自动帮我们做了一层浅比较：**\n\n\tif (this._compositeType === CompositeTypes.PureClass) {\n\t    shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);\n\t}\n\n**而 shallowEqual 又做了什么呢？会比较 Object.keys(state | props) 的长度是否一致，每一个 key 是否两者都有，并且是否是一个引用，也就是只比较了第一层的值，确实很浅，所以深层的嵌套数据是对比不出来的。**\n\n#### 问题:\n\n**大部分情况下，你可以使用React.PureComponent而不必写你自己的shouldComponentUpdate，它只做一个浅比较。但是由于浅比较会忽略属性或状态突变的情况，此时你不能使用它。**\n\n\tclass ListOfWords extends React.PureComponent {\n\t  render() {\n\t    return <div>{this.props.words.join(',')}</div>;\n\t  }\n\t}\n\t\n\tclass WordAdder extends React.Component {\n\t  constructor(props) {\n\t    super(props);\n\t    this.state = {\n\t      words: ['marklar']\n\t    };\n\t    this.handleClick = this.handleClick.bind(this);\n\t  }\n\t\n\t  handleClick() {\n\t    // This section is bad style and causes a bug\n\t    const words = this.state.words;\n\t    words.push('marklar');\n\t    this.setState({words: words});\n\t  }\n\t\n\t  render() {\n\t    return (\n\t      <div>\n\t        <button onClick={this.handleClick} />\n\t        <ListOfWords words={this.state.words} />\n\t      </div>\n\t    );\n\t  }\n\t}\n\n**在ListOfWords中，this.props.words是WordAdder中传入的其state的一个引用。虽然在WordAdder的handelClick方法中被改变了，但是对于ListOfWords来说，其引用是不变的，从而导致并没有被更新。**\n\n### 解决方法\n\n**在上面的问题中可以发现，当一个数据是不变数据时，可以使用一个引用。但是对于一个易变数据来说，不能使用引用的方式给到PureComponent。简单来说，就是我们在PureComponent外层来修改其使用的数据时，应该给其赋值一个新的对象或者引用，从而才能确保其能够进行重新渲染。例如上面例子中的handleClick可以通过以下几种来进行修改从而确认正确的渲染：**\n\n\thandleClick() {\n\t  this.setState(prevState => ({\n\t    words: prevState.words.concat(['marklar'])\n\t  }));\n\t}\n\t\n\t或者\n\t\n\thandleClick() {\n\t  this.setState(prevState => ({\n\t    words: [...prevState.words, 'marklar'],\n\t  }));\n\t};\n\t\n\t或者针对对象结构：\n\t\n\tfunction updateColorMap(oldObj) {\n\t  return Object.assign({}, oldObj, {key: new value});\n\t}\n\n#### immutable.js\n\n**是解决这个问题的另一种方法。它通过结构共享提供不可突变的，持久的集合：**\n\n详情参考[immutable.js](https://github.com/immutable-js/immutable-js)\n\n## 总结\n\n> **PureComponent 真正起作用的，只是在一些纯展示组件上，复杂组件使用的话shallowEqual 那一关基本就过不了。另外在使用的过程中为了确保能够正确的渲染，记得 props 和 state 不能使用同一个引用哦。**","source":"_posts/PureComponent.md","raw":"---\ntitle: React.Component 与 React.PureComponent（React之性能优化）\ndate: '4/3/2019 10:05:06 AM '\ntag: ['js', 'react']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n## React.Component 与 React.PureComponent（React之性能优化）\n\n**提起React.PureComponent，首先要从一个生命周期函数【shouldComponentUpdate】说起，都知道这个函数是用来控制组件是否应该被渲染**\n\n\tshouldComponentUpdate\n\n**这个生命周期返回的是一个布尔值，如果返回为false的，其实就是不执行render函数，不执行就不会重新渲染，返回为true的时候，就会执行，如果不写这个生命周期，默认返回true**\n\n**写入shouldComponentUpdate，可以提高性能，你可以在该函数根据业务需求来判断是否重新渲染**\n\n\tclass CounterButton extends React.Component {\n\t    constructor(props) {\n\t        super(props);\n\t        this.state = {count: 1};\n\t    }\n\t    shouldComponentUpdate(nextProps, nextState) {\n\t        if (this.props.color !== nextProps.color) {\n\t            return true;\n\t        }\n\t        if (this.state.count !== nextState.count) {\n\t            return true;\n\t        }\n\t        return false;\n\t    }\n\t    render() {\n\t        return (\n\t            <button\n\t                color={this.props.color}\n\t                onClick={() => this.setState(state => ({count: state.count + 1}))}\n\t            >\n\t                Count: {this.state.count}\n\t            </button>\n\t        );\n\t    }\n\t}\n\n## React.Component 与 React.PureComponent\n\n**通常情况下，我们会使用ES6的class关键字来创建React组件：**\n\t\n\tclass MyComponent extends React.Component {\n\t    // some codes here ...\n\t}\n\n**但是，你也可以创建一个继承React.PureComponent的React组件，就像这样**\n\n\tclass MyComponent extends React.PureComponent {\n\t    // some codes here\n\t}\n\n### 区别：\n\n- 继承PureComponent时，不能再重写shouldComponentUpdate，否则会引发警告\n\n----------\n\n\n\tWarning: ListOfWords has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.\n\n> 警告：ListOfWords有一个名为ShouldComponentUpdate（）的方法。扩展react.pureComponent时不应使用ShouldComponentUpdate。如果使用shouldComponentUpdate，请扩展react.component。\n\n- 继承PureComponent时，进行的是浅比较，也就是说，如果是引用类型的数据，只会比较是不是同一个地址，而不会比较具体这个地址存的数据是否完全一致\n\n### PureComponent\n\n#### 原理:\n\n**当组件更新时，如果组件的 props 和 state 都没发生改变， render 方法就不会触发，省去 Virtual DOM 的生成和比对过程，达到提升性能的目的。具体就是 React 自动帮我们做了一层浅比较：**\n\n\tif (this._compositeType === CompositeTypes.PureClass) {\n\t    shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);\n\t}\n\n**而 shallowEqual 又做了什么呢？会比较 Object.keys(state | props) 的长度是否一致，每一个 key 是否两者都有，并且是否是一个引用，也就是只比较了第一层的值，确实很浅，所以深层的嵌套数据是对比不出来的。**\n\n#### 问题:\n\n**大部分情况下，你可以使用React.PureComponent而不必写你自己的shouldComponentUpdate，它只做一个浅比较。但是由于浅比较会忽略属性或状态突变的情况，此时你不能使用它。**\n\n\tclass ListOfWords extends React.PureComponent {\n\t  render() {\n\t    return <div>{this.props.words.join(',')}</div>;\n\t  }\n\t}\n\t\n\tclass WordAdder extends React.Component {\n\t  constructor(props) {\n\t    super(props);\n\t    this.state = {\n\t      words: ['marklar']\n\t    };\n\t    this.handleClick = this.handleClick.bind(this);\n\t  }\n\t\n\t  handleClick() {\n\t    // This section is bad style and causes a bug\n\t    const words = this.state.words;\n\t    words.push('marklar');\n\t    this.setState({words: words});\n\t  }\n\t\n\t  render() {\n\t    return (\n\t      <div>\n\t        <button onClick={this.handleClick} />\n\t        <ListOfWords words={this.state.words} />\n\t      </div>\n\t    );\n\t  }\n\t}\n\n**在ListOfWords中，this.props.words是WordAdder中传入的其state的一个引用。虽然在WordAdder的handelClick方法中被改变了，但是对于ListOfWords来说，其引用是不变的，从而导致并没有被更新。**\n\n### 解决方法\n\n**在上面的问题中可以发现，当一个数据是不变数据时，可以使用一个引用。但是对于一个易变数据来说，不能使用引用的方式给到PureComponent。简单来说，就是我们在PureComponent外层来修改其使用的数据时，应该给其赋值一个新的对象或者引用，从而才能确保其能够进行重新渲染。例如上面例子中的handleClick可以通过以下几种来进行修改从而确认正确的渲染：**\n\n\thandleClick() {\n\t  this.setState(prevState => ({\n\t    words: prevState.words.concat(['marklar'])\n\t  }));\n\t}\n\t\n\t或者\n\t\n\thandleClick() {\n\t  this.setState(prevState => ({\n\t    words: [...prevState.words, 'marklar'],\n\t  }));\n\t};\n\t\n\t或者针对对象结构：\n\t\n\tfunction updateColorMap(oldObj) {\n\t  return Object.assign({}, oldObj, {key: new value});\n\t}\n\n#### immutable.js\n\n**是解决这个问题的另一种方法。它通过结构共享提供不可突变的，持久的集合：**\n\n详情参考[immutable.js](https://github.com/immutable-js/immutable-js)\n\n## 总结\n\n> **PureComponent 真正起作用的，只是在一些纯展示组件上，复杂组件使用的话shallowEqual 那一关基本就过不了。另外在使用的过程中为了确保能够正确的渲染，记得 props 和 state 不能使用同一个引用哦。**","slug":"PureComponent","published":1,"updated":"2019-04-03T02:05:07.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam6j000fn4wdmhok7la8","content":"<h2 id=\"React-Component-与-React-PureComponent（React之性能优化）\"><a href=\"#React-Component-与-React-PureComponent（React之性能优化）\" class=\"headerlink\" title=\"React.Component 与 React.PureComponent（React之性能优化）\"></a>React.Component 与 React.PureComponent（React之性能优化）</h2><p><strong>提起React.PureComponent，首先要从一个生命周期函数【shouldComponentUpdate】说起，都知道这个函数是用来控制组件是否应该被渲染</strong></p>\n<pre><code>shouldComponentUpdate\n</code></pre><p><strong>这个生命周期返回的是一个布尔值，如果返回为false的，其实就是不执行render函数，不执行就不会重新渲染，返回为true的时候，就会执行，如果不写这个生命周期，默认返回true</strong></p>\n<p><strong>写入shouldComponentUpdate，可以提高性能，你可以在该函数根据业务需求来判断是否重新渲染</strong></p>\n<pre><code>class CounterButton extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {count: 1};\n    }\n    shouldComponentUpdate(nextProps, nextState) {\n        if (this.props.color !== nextProps.color) {\n            return true;\n        }\n        if (this.state.count !== nextState.count) {\n            return true;\n        }\n        return false;\n    }\n    render() {\n        return (\n            &lt;button\n                color={this.props.color}\n                onClick={() =&gt; this.setState(state =&gt; ({count: state.count + 1}))}\n            &gt;\n                Count: {this.state.count}\n            &lt;/button&gt;\n        );\n    }\n}\n</code></pre><h2 id=\"React-Component-与-React-PureComponent\"><a href=\"#React-Component-与-React-PureComponent\" class=\"headerlink\" title=\"React.Component 与 React.PureComponent\"></a>React.Component 与 React.PureComponent</h2><p><strong>通常情况下，我们会使用ES6的class关键字来创建React组件：</strong></p>\n<pre><code>class MyComponent extends React.Component {\n    // some codes here ...\n}\n</code></pre><p><strong>但是，你也可以创建一个继承React.PureComponent的React组件，就像这样</strong></p>\n<pre><code>class MyComponent extends React.PureComponent {\n    // some codes here\n}\n</code></pre><h3 id=\"区别：\"><a href=\"#区别：\" class=\"headerlink\" title=\"区别：\"></a>区别：</h3><ul>\n<li>继承PureComponent时，不能再重写shouldComponentUpdate，否则会引发警告</li>\n</ul>\n<hr>\n<pre><code>Warning: ListOfWords has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.\n</code></pre><blockquote>\n<p>警告：ListOfWords有一个名为ShouldComponentUpdate（）的方法。扩展react.pureComponent时不应使用ShouldComponentUpdate。如果使用shouldComponentUpdate，请扩展react.component。</p>\n</blockquote>\n<ul>\n<li>继承PureComponent时，进行的是浅比较，也就是说，如果是引用类型的数据，只会比较是不是同一个地址，而不会比较具体这个地址存的数据是否完全一致</li>\n</ul>\n<h3 id=\"PureComponent\"><a href=\"#PureComponent\" class=\"headerlink\" title=\"PureComponent\"></a>PureComponent</h3><h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理:\"></a>原理:</h4><p><strong>当组件更新时，如果组件的 props 和 state 都没发生改变， render 方法就不会触发，省去 Virtual DOM 的生成和比对过程，达到提升性能的目的。具体就是 React 自动帮我们做了一层浅比较：</strong></p>\n<pre><code>if (this._compositeType === CompositeTypes.PureClass) {\n    shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);\n}\n</code></pre><p><strong>而 shallowEqual 又做了什么呢？会比较 Object.keys(state | props) 的长度是否一致，每一个 key 是否两者都有，并且是否是一个引用，也就是只比较了第一层的值，确实很浅，所以深层的嵌套数据是对比不出来的。</strong></p>\n<h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题:\"></a>问题:</h4><p><strong>大部分情况下，你可以使用React.PureComponent而不必写你自己的shouldComponentUpdate，它只做一个浅比较。但是由于浅比较会忽略属性或状态突变的情况，此时你不能使用它。</strong></p>\n<pre><code>class ListOfWords extends React.PureComponent {\n  render() {\n    return &lt;div&gt;{this.props.words.join(&#39;,&#39;)}&lt;/div&gt;;\n  }\n}\n\nclass WordAdder extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      words: [&#39;marklar&#39;]\n    };\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    // This section is bad style and causes a bug\n    const words = this.state.words;\n    words.push(&#39;marklar&#39;);\n    this.setState({words: words});\n  }\n\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;button onClick={this.handleClick} /&gt;\n        &lt;ListOfWords words={this.state.words} /&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n</code></pre><p><strong>在ListOfWords中，this.props.words是WordAdder中传入的其state的一个引用。虽然在WordAdder的handelClick方法中被改变了，但是对于ListOfWords来说，其引用是不变的，从而导致并没有被更新。</strong></p>\n<h3 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h3><p><strong>在上面的问题中可以发现，当一个数据是不变数据时，可以使用一个引用。但是对于一个易变数据来说，不能使用引用的方式给到PureComponent。简单来说，就是我们在PureComponent外层来修改其使用的数据时，应该给其赋值一个新的对象或者引用，从而才能确保其能够进行重新渲染。例如上面例子中的handleClick可以通过以下几种来进行修改从而确认正确的渲染：</strong></p>\n<pre><code>handleClick() {\n  this.setState(prevState =&gt; ({\n    words: prevState.words.concat([&#39;marklar&#39;])\n  }));\n}\n\n或者\n\nhandleClick() {\n  this.setState(prevState =&gt; ({\n    words: [...prevState.words, &#39;marklar&#39;],\n  }));\n};\n\n或者针对对象结构：\n\nfunction updateColorMap(oldObj) {\n  return Object.assign({}, oldObj, {key: new value});\n}\n</code></pre><h4 id=\"immutable-js\"><a href=\"#immutable-js\" class=\"headerlink\" title=\"immutable.js\"></a>immutable.js</h4><p><strong>是解决这个问题的另一种方法。它通过结构共享提供不可突变的，持久的集合：</strong></p>\n<p>详情参考<a href=\"https://github.com/immutable-js/immutable-js\" target=\"_blank\" rel=\"noopener\">immutable.js</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><blockquote>\n<p><strong>PureComponent 真正起作用的，只是在一些纯展示组件上，复杂组件使用的话shallowEqual 那一关基本就过不了。另外在使用的过程中为了确保能够正确的渲染，记得 props 和 state 不能使用同一个引用哦。</strong></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"React-Component-与-React-PureComponent（React之性能优化）\"><a href=\"#React-Component-与-React-PureComponent（React之性能优化）\" class=\"headerlink\" title=\"React.Component 与 React.PureComponent（React之性能优化）\"></a>React.Component 与 React.PureComponent（React之性能优化）</h2><p><strong>提起React.PureComponent，首先要从一个生命周期函数【shouldComponentUpdate】说起，都知道这个函数是用来控制组件是否应该被渲染</strong></p>\n<pre><code>shouldComponentUpdate\n</code></pre><p><strong>这个生命周期返回的是一个布尔值，如果返回为false的，其实就是不执行render函数，不执行就不会重新渲染，返回为true的时候，就会执行，如果不写这个生命周期，默认返回true</strong></p>\n<p><strong>写入shouldComponentUpdate，可以提高性能，你可以在该函数根据业务需求来判断是否重新渲染</strong></p>\n<pre><code>class CounterButton extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {count: 1};\n    }\n    shouldComponentUpdate(nextProps, nextState) {\n        if (this.props.color !== nextProps.color) {\n            return true;\n        }\n        if (this.state.count !== nextState.count) {\n            return true;\n        }\n        return false;\n    }\n    render() {\n        return (\n            &lt;button\n                color={this.props.color}\n                onClick={() =&gt; this.setState(state =&gt; ({count: state.count + 1}))}\n            &gt;\n                Count: {this.state.count}\n            &lt;/button&gt;\n        );\n    }\n}\n</code></pre><h2 id=\"React-Component-与-React-PureComponent\"><a href=\"#React-Component-与-React-PureComponent\" class=\"headerlink\" title=\"React.Component 与 React.PureComponent\"></a>React.Component 与 React.PureComponent</h2><p><strong>通常情况下，我们会使用ES6的class关键字来创建React组件：</strong></p>\n<pre><code>class MyComponent extends React.Component {\n    // some codes here ...\n}\n</code></pre><p><strong>但是，你也可以创建一个继承React.PureComponent的React组件，就像这样</strong></p>\n<pre><code>class MyComponent extends React.PureComponent {\n    // some codes here\n}\n</code></pre><h3 id=\"区别：\"><a href=\"#区别：\" class=\"headerlink\" title=\"区别：\"></a>区别：</h3><ul>\n<li>继承PureComponent时，不能再重写shouldComponentUpdate，否则会引发警告</li>\n</ul>\n<hr>\n<pre><code>Warning: ListOfWords has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.\n</code></pre><blockquote>\n<p>警告：ListOfWords有一个名为ShouldComponentUpdate（）的方法。扩展react.pureComponent时不应使用ShouldComponentUpdate。如果使用shouldComponentUpdate，请扩展react.component。</p>\n</blockquote>\n<ul>\n<li>继承PureComponent时，进行的是浅比较，也就是说，如果是引用类型的数据，只会比较是不是同一个地址，而不会比较具体这个地址存的数据是否完全一致</li>\n</ul>\n<h3 id=\"PureComponent\"><a href=\"#PureComponent\" class=\"headerlink\" title=\"PureComponent\"></a>PureComponent</h3><h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理:\"></a>原理:</h4><p><strong>当组件更新时，如果组件的 props 和 state 都没发生改变， render 方法就不会触发，省去 Virtual DOM 的生成和比对过程，达到提升性能的目的。具体就是 React 自动帮我们做了一层浅比较：</strong></p>\n<pre><code>if (this._compositeType === CompositeTypes.PureClass) {\n    shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);\n}\n</code></pre><p><strong>而 shallowEqual 又做了什么呢？会比较 Object.keys(state | props) 的长度是否一致，每一个 key 是否两者都有，并且是否是一个引用，也就是只比较了第一层的值，确实很浅，所以深层的嵌套数据是对比不出来的。</strong></p>\n<h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题:\"></a>问题:</h4><p><strong>大部分情况下，你可以使用React.PureComponent而不必写你自己的shouldComponentUpdate，它只做一个浅比较。但是由于浅比较会忽略属性或状态突变的情况，此时你不能使用它。</strong></p>\n<pre><code>class ListOfWords extends React.PureComponent {\n  render() {\n    return &lt;div&gt;{this.props.words.join(&#39;,&#39;)}&lt;/div&gt;;\n  }\n}\n\nclass WordAdder extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      words: [&#39;marklar&#39;]\n    };\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    // This section is bad style and causes a bug\n    const words = this.state.words;\n    words.push(&#39;marklar&#39;);\n    this.setState({words: words});\n  }\n\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;button onClick={this.handleClick} /&gt;\n        &lt;ListOfWords words={this.state.words} /&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n</code></pre><p><strong>在ListOfWords中，this.props.words是WordAdder中传入的其state的一个引用。虽然在WordAdder的handelClick方法中被改变了，但是对于ListOfWords来说，其引用是不变的，从而导致并没有被更新。</strong></p>\n<h3 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h3><p><strong>在上面的问题中可以发现，当一个数据是不变数据时，可以使用一个引用。但是对于一个易变数据来说，不能使用引用的方式给到PureComponent。简单来说，就是我们在PureComponent外层来修改其使用的数据时，应该给其赋值一个新的对象或者引用，从而才能确保其能够进行重新渲染。例如上面例子中的handleClick可以通过以下几种来进行修改从而确认正确的渲染：</strong></p>\n<pre><code>handleClick() {\n  this.setState(prevState =&gt; ({\n    words: prevState.words.concat([&#39;marklar&#39;])\n  }));\n}\n\n或者\n\nhandleClick() {\n  this.setState(prevState =&gt; ({\n    words: [...prevState.words, &#39;marklar&#39;],\n  }));\n};\n\n或者针对对象结构：\n\nfunction updateColorMap(oldObj) {\n  return Object.assign({}, oldObj, {key: new value});\n}\n</code></pre><h4 id=\"immutable-js\"><a href=\"#immutable-js\" class=\"headerlink\" title=\"immutable.js\"></a>immutable.js</h4><p><strong>是解决这个问题的另一种方法。它通过结构共享提供不可突变的，持久的集合：</strong></p>\n<p>详情参考<a href=\"https://github.com/immutable-js/immutable-js\" target=\"_blank\" rel=\"noopener\">immutable.js</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><blockquote>\n<p><strong>PureComponent 真正起作用的，只是在一些纯展示组件上，复杂组件使用的话shallowEqual 那一关基本就过不了。另外在使用的过程中为了确保能够正确的渲染，记得 props 和 state 不能使用同一个引用哦。</strong></p>\n</blockquote>\n"},{"title":"ajax","date":"2019-04-05T13:28:16.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"## ajax\n\n### 什么是ajax?\n\n**AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。Ajax 是一种用于创建快速动态网页的技术。Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。**\n\n### 原生js ajax请求有几个步骤？分别是什么\n\n\t//创建 XMLHttpRequest 对象\n\tvar ajax = new XMLHttpRequest();\n\t//规定请求的类型、URL 以及是否异步处理请求。\n\tajax.open('GET',url,true);\n\t//发送信息至服务器时内容编码类型\n\tajax.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"); \n\t//发送请求\n\tajax.send(null);  \n\t//接受服务器响应数据\n\tajax.onreadystatechange = function () {\n\t    if (ajax.readyState == 4 && (ajax.status == 200 || ajax.status == 304)) { \n\t    }\n\t};\n\n\n### ajax几种请求方式？他们的优缺点？\n\n**常用的post,get,delete。**\n\n\t // 代码上的区别\n\t 1: get通过url传递参数\n\t 2: post设置请求头  规定请求数据类型\n\n\t // 使用上的区别\n\t 1: post比get安全(因为post参数在请求体中。get参数在url上面)\n\t 2: get传输速度比post快 根据传参决定的。 (post通过请求体传参，后台通过数据流接收。速度稍微慢一些。而get通过url传参可以直接获取) \n\t 3: post传输文件大理论没有限制  get传输文件小大概7-8k ie4k左右\n\t 4: get获取数据\tpost上传数据(上传的数据比较多  而且上传数据都是重要数据。所以不论在安全性还是数据量级 post是最好的选择)\n\n### 优点：\n\n> 1.减轻服务器的负担,按需取数据,最大程度的减少冗余请求\n> \n> 2.局部刷新页面,减少用户心理和实际的等待时间,带来更好的用户体验\n> \n> 3.基于xml标准化,并被广泛支持,不需安装插件等,进一步促进页面和数据的分离\n\n### 缺点：\n\n> 1.AJAX大量的使用了javascript和ajax引擎,这些取决于浏览器的支持.在编写的时候考虑对浏览器的兼容性.\n> \n> 2.AJAX只是局部刷新,所以页面的后退按钮是没有用的.\n> \n> 3.对流媒体还有移动设备的支持不是太好等\n\n### 请求头：\n\n\theader('Access-Control-Allow-Origin:*');  //支持全域名访问，不安全，部署后需要固定限制为客户端网址\n\n\theader('Access-Control-Allow-Methods:POST,GET,OPTIONS,DELETE'); //支持的http 动作\n\t\n\theader('Access-Control-Allow-Headers:x-requested-with,content-type');  //响应头 请按照自己需求添加。","source":"_posts/ajax-task.md","raw":"---\ntitle: ajax\ndate: '4/5/2019 9:28:16 PM '\ntag: ['js', 'ajax']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n## ajax\n\n### 什么是ajax?\n\n**AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。Ajax 是一种用于创建快速动态网页的技术。Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。**\n\n### 原生js ajax请求有几个步骤？分别是什么\n\n\t//创建 XMLHttpRequest 对象\n\tvar ajax = new XMLHttpRequest();\n\t//规定请求的类型、URL 以及是否异步处理请求。\n\tajax.open('GET',url,true);\n\t//发送信息至服务器时内容编码类型\n\tajax.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"); \n\t//发送请求\n\tajax.send(null);  \n\t//接受服务器响应数据\n\tajax.onreadystatechange = function () {\n\t    if (ajax.readyState == 4 && (ajax.status == 200 || ajax.status == 304)) { \n\t    }\n\t};\n\n\n### ajax几种请求方式？他们的优缺点？\n\n**常用的post,get,delete。**\n\n\t // 代码上的区别\n\t 1: get通过url传递参数\n\t 2: post设置请求头  规定请求数据类型\n\n\t // 使用上的区别\n\t 1: post比get安全(因为post参数在请求体中。get参数在url上面)\n\t 2: get传输速度比post快 根据传参决定的。 (post通过请求体传参，后台通过数据流接收。速度稍微慢一些。而get通过url传参可以直接获取) \n\t 3: post传输文件大理论没有限制  get传输文件小大概7-8k ie4k左右\n\t 4: get获取数据\tpost上传数据(上传的数据比较多  而且上传数据都是重要数据。所以不论在安全性还是数据量级 post是最好的选择)\n\n### 优点：\n\n> 1.减轻服务器的负担,按需取数据,最大程度的减少冗余请求\n> \n> 2.局部刷新页面,减少用户心理和实际的等待时间,带来更好的用户体验\n> \n> 3.基于xml标准化,并被广泛支持,不需安装插件等,进一步促进页面和数据的分离\n\n### 缺点：\n\n> 1.AJAX大量的使用了javascript和ajax引擎,这些取决于浏览器的支持.在编写的时候考虑对浏览器的兼容性.\n> \n> 2.AJAX只是局部刷新,所以页面的后退按钮是没有用的.\n> \n> 3.对流媒体还有移动设备的支持不是太好等\n\n### 请求头：\n\n\theader('Access-Control-Allow-Origin:*');  //支持全域名访问，不安全，部署后需要固定限制为客户端网址\n\n\theader('Access-Control-Allow-Methods:POST,GET,OPTIONS,DELETE'); //支持的http 动作\n\t\n\theader('Access-Control-Allow-Headers:x-requested-with,content-type');  //响应头 请按照自己需求添加。","slug":"ajax-task","published":1,"updated":"2019-04-05T13:28:20.952Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam6l000hn4wdgsnfj805","content":"<h2 id=\"ajax\"><a href=\"#ajax\" class=\"headerlink\" title=\"ajax\"></a>ajax</h2><h3 id=\"什么是ajax\"><a href=\"#什么是ajax\" class=\"headerlink\" title=\"什么是ajax?\"></a>什么是ajax?</h3><p><strong>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。Ajax 是一种用于创建快速动态网页的技术。Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。</strong></p>\n<h3 id=\"原生js-ajax请求有几个步骤？分别是什么\"><a href=\"#原生js-ajax请求有几个步骤？分别是什么\" class=\"headerlink\" title=\"原生js ajax请求有几个步骤？分别是什么\"></a>原生js ajax请求有几个步骤？分别是什么</h3><pre><code>//创建 XMLHttpRequest 对象\nvar ajax = new XMLHttpRequest();\n//规定请求的类型、URL 以及是否异步处理请求。\najax.open(&#39;GET&#39;,url,true);\n//发送信息至服务器时内容编码类型\najax.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); \n//发送请求\najax.send(null);  \n//接受服务器响应数据\najax.onreadystatechange = function () {\n    if (ajax.readyState == 4 &amp;&amp; (ajax.status == 200 || ajax.status == 304)) { \n    }\n};\n</code></pre><h3 id=\"ajax几种请求方式？他们的优缺点？\"><a href=\"#ajax几种请求方式？他们的优缺点？\" class=\"headerlink\" title=\"ajax几种请求方式？他们的优缺点？\"></a>ajax几种请求方式？他们的优缺点？</h3><p><strong>常用的post,get,delete。</strong></p>\n<pre><code> // 代码上的区别\n 1: get通过url传递参数\n 2: post设置请求头  规定请求数据类型\n\n // 使用上的区别\n 1: post比get安全(因为post参数在请求体中。get参数在url上面)\n 2: get传输速度比post快 根据传参决定的。 (post通过请求体传参，后台通过数据流接收。速度稍微慢一些。而get通过url传参可以直接获取) \n 3: post传输文件大理论没有限制  get传输文件小大概7-8k ie4k左右\n 4: get获取数据    post上传数据(上传的数据比较多  而且上传数据都是重要数据。所以不论在安全性还是数据量级 post是最好的选择)\n</code></pre><h3 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><blockquote>\n<p>1.减轻服务器的负担,按需取数据,最大程度的减少冗余请求</p>\n<p>2.局部刷新页面,减少用户心理和实际的等待时间,带来更好的用户体验</p>\n<p>3.基于xml标准化,并被广泛支持,不需安装插件等,进一步促进页面和数据的分离</p>\n</blockquote>\n<h3 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h3><blockquote>\n<p>1.AJAX大量的使用了javascript和ajax引擎,这些取决于浏览器的支持.在编写的时候考虑对浏览器的兼容性.</p>\n<p>2.AJAX只是局部刷新,所以页面的后退按钮是没有用的.</p>\n<p>3.对流媒体还有移动设备的支持不是太好等</p>\n</blockquote>\n<h3 id=\"请求头：\"><a href=\"#请求头：\" class=\"headerlink\" title=\"请求头：\"></a>请求头：</h3><pre><code>header(&#39;Access-Control-Allow-Origin:*&#39;);  //支持全域名访问，不安全，部署后需要固定限制为客户端网址\n\nheader(&#39;Access-Control-Allow-Methods:POST,GET,OPTIONS,DELETE&#39;); //支持的http 动作\n\nheader(&#39;Access-Control-Allow-Headers:x-requested-with,content-type&#39;);  //响应头 请按照自己需求添加。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ajax\"><a href=\"#ajax\" class=\"headerlink\" title=\"ajax\"></a>ajax</h2><h3 id=\"什么是ajax\"><a href=\"#什么是ajax\" class=\"headerlink\" title=\"什么是ajax?\"></a>什么是ajax?</h3><p><strong>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。Ajax 是一种用于创建快速动态网页的技术。Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。</strong></p>\n<h3 id=\"原生js-ajax请求有几个步骤？分别是什么\"><a href=\"#原生js-ajax请求有几个步骤？分别是什么\" class=\"headerlink\" title=\"原生js ajax请求有几个步骤？分别是什么\"></a>原生js ajax请求有几个步骤？分别是什么</h3><pre><code>//创建 XMLHttpRequest 对象\nvar ajax = new XMLHttpRequest();\n//规定请求的类型、URL 以及是否异步处理请求。\najax.open(&#39;GET&#39;,url,true);\n//发送信息至服务器时内容编码类型\najax.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); \n//发送请求\najax.send(null);  \n//接受服务器响应数据\najax.onreadystatechange = function () {\n    if (ajax.readyState == 4 &amp;&amp; (ajax.status == 200 || ajax.status == 304)) { \n    }\n};\n</code></pre><h3 id=\"ajax几种请求方式？他们的优缺点？\"><a href=\"#ajax几种请求方式？他们的优缺点？\" class=\"headerlink\" title=\"ajax几种请求方式？他们的优缺点？\"></a>ajax几种请求方式？他们的优缺点？</h3><p><strong>常用的post,get,delete。</strong></p>\n<pre><code> // 代码上的区别\n 1: get通过url传递参数\n 2: post设置请求头  规定请求数据类型\n\n // 使用上的区别\n 1: post比get安全(因为post参数在请求体中。get参数在url上面)\n 2: get传输速度比post快 根据传参决定的。 (post通过请求体传参，后台通过数据流接收。速度稍微慢一些。而get通过url传参可以直接获取) \n 3: post传输文件大理论没有限制  get传输文件小大概7-8k ie4k左右\n 4: get获取数据    post上传数据(上传的数据比较多  而且上传数据都是重要数据。所以不论在安全性还是数据量级 post是最好的选择)\n</code></pre><h3 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><blockquote>\n<p>1.减轻服务器的负担,按需取数据,最大程度的减少冗余请求</p>\n<p>2.局部刷新页面,减少用户心理和实际的等待时间,带来更好的用户体验</p>\n<p>3.基于xml标准化,并被广泛支持,不需安装插件等,进一步促进页面和数据的分离</p>\n</blockquote>\n<h3 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h3><blockquote>\n<p>1.AJAX大量的使用了javascript和ajax引擎,这些取决于浏览器的支持.在编写的时候考虑对浏览器的兼容性.</p>\n<p>2.AJAX只是局部刷新,所以页面的后退按钮是没有用的.</p>\n<p>3.对流媒体还有移动设备的支持不是太好等</p>\n</blockquote>\n<h3 id=\"请求头：\"><a href=\"#请求头：\" class=\"headerlink\" title=\"请求头：\"></a>请求头：</h3><pre><code>header(&#39;Access-Control-Allow-Origin:*&#39;);  //支持全域名访问，不安全，部署后需要固定限制为客户端网址\n\nheader(&#39;Access-Control-Allow-Methods:POST,GET,OPTIONS,DELETE&#39;); //支持的http 动作\n\nheader(&#39;Access-Control-Allow-Headers:x-requested-with,content-type&#39;);  //响应头 请按照自己需求添加。\n</code></pre>"},{"title":"浅拷贝与深拷贝","date":"2019-03-29T09:00:10.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"# 浅拷贝与深拷贝\n\n----------\n\n\n## 数据类型\n\n###数据类型分为两种【基本数据类型，复杂数据类型】\n\n> - 基本数据类型：直接存储在栈(stack)中的数据\n> \t- String\n> \t- Number\n> \t- Boolean\n> \t- Null\n> \t- Undefined\n> \t- Symbol\n> \t\n\n----------\n\n> - 引用数据类型：存储的是该对象在栈中引用，真实的数据存放在堆内存里\n>  - 对象数据类型【object，function】\n\n## 浅拷贝与深拷贝\n\n### 深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。\n\n#### 浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。\n\n## 赋值和浅拷贝的区别\n\n> - **当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。**\n\n----------\n\n> - **浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。**\n\n## 浅拷贝的实现方式\n\n### Object.assign()\n\n> **Object.assign()进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。**\n> \n> **当object只有一层的时候，是深拷贝**\n\n### Array.prototype.concat()\n\n\tlet arr = [1, 3, \n\t  {\n\t    username: 'kobe',\n\t\t  childran: [\n\t        {\n\t          username: 'kobe',\n\t          childran: [\n\t              {\n\t                username: 'kobe',\n\t                  childran: [\n\t                      \n\t                  ]\n\t              }\n\t          ]\n\t        }\n\t    ]\n\t    }];\n\tlet arr2=arr.concat();    \n\tconsole.log(arr);\n\n> 修改新对象会改到原对象:\n\n### Array.prototype.slice()\n\n\tlet arr = [1, 3, {\n\t    username: ' kobe'\n\t    }];\n\tlet arr3 = arr.slice();\n\tarr3[2].username = 'wade'\n\tconsole.log(arr);\n\n> 同样修改新对象会改到原对象:\n\n### 关于Array的slice和concat方法的补充说明:\n\n**Array的slice和concat方法不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。**\n\n## 深拷贝的实现方式\n\n### JSON.parse(JSON.stringify())\n\n\tlet arr = [1, 3, {\n\t    username: ' kobe'\n\t}];\n\tlet arr4 = JSON.parse(JSON.stringify(arr));\n\tarr4[2].username = 'duncan'; \n\tconsole.log(arr, arr4)\n\n> 原理：\n\n**用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。**\n\n> 弊端：\n\n> **这种方法虽然可以实现数组或对象深拷贝,但不能处理函数**\n\n### 递归方法\n\n> 递归方法实现深度克隆原理:\n\n**遍历对象、数组直到里边都是基本数据类型，然后再去复制，就是深度拷贝**\n\n\t//定义检测数据类型的功能函数\n\tfunction checkedType(target) {\n\t  return Object.prototype.toString.call(target).slice(8, -1)\n\t}\n\t//实现深度克隆---对象/数组\n\tfunction clone(target) {\n\t  //判断拷贝的数据类型\n\t  //初始化变量result 成为最终克隆的数据\n\t  let result,\n\t    targetType = checkedType(target)\n\t  if (targetType === 'Object') {\n\t    result = {}\n\t  } else if (targetType === 'Array') {\n\t    result = []\n\t  } else {\n\t    return target\n\t  }\n\t  //遍历目标数据\n\t  for (let i in target) {\n\t    //获取遍历数据结构的每一项值。\n\t    let value = target[i]\n\t    //判断目标结构里的每一值是否存在对象/数组\n\t    if (checkedType(value) === 'Object' || checkedType(value) === 'Array') {\n\t      //对象/数组里嵌套了对象/数组\n\t      //继续遍历获取到value值\n\t      result[i] = clone(value)\n\t    } else {\n\t      //获取到value值是基本的数据类型或者是函数。\n\t      result[i] = value\n\t    }\n\t  }\n\t  return result\n\t}","source":"_posts/clone.md","raw":"---\ntitle: 浅拷贝与深拷贝\ndate: '3/29/2019 5:00:10 PM '\ntag: ['js', '拷贝']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n# 浅拷贝与深拷贝\n\n----------\n\n\n## 数据类型\n\n###数据类型分为两种【基本数据类型，复杂数据类型】\n\n> - 基本数据类型：直接存储在栈(stack)中的数据\n> \t- String\n> \t- Number\n> \t- Boolean\n> \t- Null\n> \t- Undefined\n> \t- Symbol\n> \t\n\n----------\n\n> - 引用数据类型：存储的是该对象在栈中引用，真实的数据存放在堆内存里\n>  - 对象数据类型【object，function】\n\n## 浅拷贝与深拷贝\n\n### 深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。\n\n#### 浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。\n\n## 赋值和浅拷贝的区别\n\n> - **当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。**\n\n----------\n\n> - **浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。**\n\n## 浅拷贝的实现方式\n\n### Object.assign()\n\n> **Object.assign()进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。**\n> \n> **当object只有一层的时候，是深拷贝**\n\n### Array.prototype.concat()\n\n\tlet arr = [1, 3, \n\t  {\n\t    username: 'kobe',\n\t\t  childran: [\n\t        {\n\t          username: 'kobe',\n\t          childran: [\n\t              {\n\t                username: 'kobe',\n\t                  childran: [\n\t                      \n\t                  ]\n\t              }\n\t          ]\n\t        }\n\t    ]\n\t    }];\n\tlet arr2=arr.concat();    \n\tconsole.log(arr);\n\n> 修改新对象会改到原对象:\n\n### Array.prototype.slice()\n\n\tlet arr = [1, 3, {\n\t    username: ' kobe'\n\t    }];\n\tlet arr3 = arr.slice();\n\tarr3[2].username = 'wade'\n\tconsole.log(arr);\n\n> 同样修改新对象会改到原对象:\n\n### 关于Array的slice和concat方法的补充说明:\n\n**Array的slice和concat方法不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。**\n\n## 深拷贝的实现方式\n\n### JSON.parse(JSON.stringify())\n\n\tlet arr = [1, 3, {\n\t    username: ' kobe'\n\t}];\n\tlet arr4 = JSON.parse(JSON.stringify(arr));\n\tarr4[2].username = 'duncan'; \n\tconsole.log(arr, arr4)\n\n> 原理：\n\n**用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。**\n\n> 弊端：\n\n> **这种方法虽然可以实现数组或对象深拷贝,但不能处理函数**\n\n### 递归方法\n\n> 递归方法实现深度克隆原理:\n\n**遍历对象、数组直到里边都是基本数据类型，然后再去复制，就是深度拷贝**\n\n\t//定义检测数据类型的功能函数\n\tfunction checkedType(target) {\n\t  return Object.prototype.toString.call(target).slice(8, -1)\n\t}\n\t//实现深度克隆---对象/数组\n\tfunction clone(target) {\n\t  //判断拷贝的数据类型\n\t  //初始化变量result 成为最终克隆的数据\n\t  let result,\n\t    targetType = checkedType(target)\n\t  if (targetType === 'Object') {\n\t    result = {}\n\t  } else if (targetType === 'Array') {\n\t    result = []\n\t  } else {\n\t    return target\n\t  }\n\t  //遍历目标数据\n\t  for (let i in target) {\n\t    //获取遍历数据结构的每一项值。\n\t    let value = target[i]\n\t    //判断目标结构里的每一值是否存在对象/数组\n\t    if (checkedType(value) === 'Object' || checkedType(value) === 'Array') {\n\t      //对象/数组里嵌套了对象/数组\n\t      //继续遍历获取到value值\n\t      result[i] = clone(value)\n\t    } else {\n\t      //获取到value值是基本的数据类型或者是函数。\n\t      result[i] = value\n\t    }\n\t  }\n\t  return result\n\t}","slug":"clone","published":1,"updated":"2019-03-29T09:00:26.640Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam6n000kn4wdm10vua2b","content":"<h1 id=\"浅拷贝与深拷贝\"><a href=\"#浅拷贝与深拷贝\" class=\"headerlink\" title=\"浅拷贝与深拷贝\"></a>浅拷贝与深拷贝</h1><hr>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>###数据类型分为两种【基本数据类型，复杂数据类型】</p>\n<blockquote>\n<ul>\n<li>基本数据类型：直接存储在栈(stack)中的数据<ul>\n<li>String</li>\n<li>Number</li>\n<li>Boolean</li>\n<li>Null</li>\n<li>Undefined</li>\n<li>Symbol</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<hr>\n<blockquote>\n<ul>\n<li>引用数据类型：存储的是该对象在栈中引用，真实的数据存放在堆内存里<ul>\n<li>对象数据类型【object，function】</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"浅拷贝与深拷贝-1\"><a href=\"#浅拷贝与深拷贝-1\" class=\"headerlink\" title=\"浅拷贝与深拷贝\"></a>浅拷贝与深拷贝</h2><h3 id=\"深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。\"><a href=\"#深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。\" class=\"headerlink\" title=\"深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。\"></a>深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。</h3><h4 id=\"浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。\"><a href=\"#浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。\" class=\"headerlink\" title=\"浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。\"></a>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</h4><h2 id=\"赋值和浅拷贝的区别\"><a href=\"#赋值和浅拷贝的区别\" class=\"headerlink\" title=\"赋值和浅拷贝的区别\"></a>赋值和浅拷贝的区别</h2><blockquote>\n<ul>\n<li><strong>当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。</strong></li>\n</ul>\n</blockquote>\n<hr>\n<blockquote>\n<ul>\n<li><strong>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。</strong></li>\n</ul>\n</blockquote>\n<h2 id=\"浅拷贝的实现方式\"><a href=\"#浅拷贝的实现方式\" class=\"headerlink\" title=\"浅拷贝的实现方式\"></a>浅拷贝的实现方式</h2><h3 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign()\"></a>Object.assign()</h3><blockquote>\n<p><strong>Object.assign()进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。</strong></p>\n<p><strong>当object只有一层的时候，是深拷贝</strong></p>\n</blockquote>\n<h3 id=\"Array-prototype-concat\"><a href=\"#Array-prototype-concat\" class=\"headerlink\" title=\"Array.prototype.concat()\"></a>Array.prototype.concat()</h3><pre><code>let arr = [1, 3, \n  {\n    username: &#39;kobe&#39;,\n      childran: [\n        {\n          username: &#39;kobe&#39;,\n          childran: [\n              {\n                username: &#39;kobe&#39;,\n                  childran: [\n\n                  ]\n              }\n          ]\n        }\n    ]\n    }];\nlet arr2=arr.concat();    \nconsole.log(arr);\n</code></pre><blockquote>\n<p>修改新对象会改到原对象:</p>\n</blockquote>\n<h3 id=\"Array-prototype-slice\"><a href=\"#Array-prototype-slice\" class=\"headerlink\" title=\"Array.prototype.slice()\"></a>Array.prototype.slice()</h3><pre><code>let arr = [1, 3, {\n    username: &#39; kobe&#39;\n    }];\nlet arr3 = arr.slice();\narr3[2].username = &#39;wade&#39;\nconsole.log(arr);\n</code></pre><blockquote>\n<p>同样修改新对象会改到原对象:</p>\n</blockquote>\n<h3 id=\"关于Array的slice和concat方法的补充说明\"><a href=\"#关于Array的slice和concat方法的补充说明\" class=\"headerlink\" title=\"关于Array的slice和concat方法的补充说明:\"></a>关于Array的slice和concat方法的补充说明:</h3><p><strong>Array的slice和concat方法不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。</strong></p>\n<h2 id=\"深拷贝的实现方式\"><a href=\"#深拷贝的实现方式\" class=\"headerlink\" title=\"深拷贝的实现方式\"></a>深拷贝的实现方式</h2><h3 id=\"JSON-parse-JSON-stringify\"><a href=\"#JSON-parse-JSON-stringify\" class=\"headerlink\" title=\"JSON.parse(JSON.stringify())\"></a>JSON.parse(JSON.stringify())</h3><pre><code>let arr = [1, 3, {\n    username: &#39; kobe&#39;\n}];\nlet arr4 = JSON.parse(JSON.stringify(arr));\narr4[2].username = &#39;duncan&#39;; \nconsole.log(arr, arr4)\n</code></pre><blockquote>\n<p>原理：</p>\n</blockquote>\n<p><strong>用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。</strong></p>\n<blockquote>\n<p>弊端：</p>\n</blockquote>\n<blockquote>\n<p><strong>这种方法虽然可以实现数组或对象深拷贝,但不能处理函数</strong></p>\n</blockquote>\n<h3 id=\"递归方法\"><a href=\"#递归方法\" class=\"headerlink\" title=\"递归方法\"></a>递归方法</h3><blockquote>\n<p>递归方法实现深度克隆原理:</p>\n</blockquote>\n<p><strong>遍历对象、数组直到里边都是基本数据类型，然后再去复制，就是深度拷贝</strong></p>\n<pre><code>//定义检测数据类型的功能函数\nfunction checkedType(target) {\n  return Object.prototype.toString.call(target).slice(8, -1)\n}\n//实现深度克隆---对象/数组\nfunction clone(target) {\n  //判断拷贝的数据类型\n  //初始化变量result 成为最终克隆的数据\n  let result,\n    targetType = checkedType(target)\n  if (targetType === &#39;Object&#39;) {\n    result = {}\n  } else if (targetType === &#39;Array&#39;) {\n    result = []\n  } else {\n    return target\n  }\n  //遍历目标数据\n  for (let i in target) {\n    //获取遍历数据结构的每一项值。\n    let value = target[i]\n    //判断目标结构里的每一值是否存在对象/数组\n    if (checkedType(value) === &#39;Object&#39; || checkedType(value) === &#39;Array&#39;) {\n      //对象/数组里嵌套了对象/数组\n      //继续遍历获取到value值\n      result[i] = clone(value)\n    } else {\n      //获取到value值是基本的数据类型或者是函数。\n      result[i] = value\n    }\n  }\n  return result\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"浅拷贝与深拷贝\"><a href=\"#浅拷贝与深拷贝\" class=\"headerlink\" title=\"浅拷贝与深拷贝\"></a>浅拷贝与深拷贝</h1><hr>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>###数据类型分为两种【基本数据类型，复杂数据类型】</p>\n<blockquote>\n<ul>\n<li>基本数据类型：直接存储在栈(stack)中的数据<ul>\n<li>String</li>\n<li>Number</li>\n<li>Boolean</li>\n<li>Null</li>\n<li>Undefined</li>\n<li>Symbol</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<hr>\n<blockquote>\n<ul>\n<li>引用数据类型：存储的是该对象在栈中引用，真实的数据存放在堆内存里<ul>\n<li>对象数据类型【object，function】</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"浅拷贝与深拷贝-1\"><a href=\"#浅拷贝与深拷贝-1\" class=\"headerlink\" title=\"浅拷贝与深拷贝\"></a>浅拷贝与深拷贝</h2><h3 id=\"深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。\"><a href=\"#深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。\" class=\"headerlink\" title=\"深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。\"></a>深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。</h3><h4 id=\"浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。\"><a href=\"#浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。\" class=\"headerlink\" title=\"浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。\"></a>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</h4><h2 id=\"赋值和浅拷贝的区别\"><a href=\"#赋值和浅拷贝的区别\" class=\"headerlink\" title=\"赋值和浅拷贝的区别\"></a>赋值和浅拷贝的区别</h2><blockquote>\n<ul>\n<li><strong>当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。</strong></li>\n</ul>\n</blockquote>\n<hr>\n<blockquote>\n<ul>\n<li><strong>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。</strong></li>\n</ul>\n</blockquote>\n<h2 id=\"浅拷贝的实现方式\"><a href=\"#浅拷贝的实现方式\" class=\"headerlink\" title=\"浅拷贝的实现方式\"></a>浅拷贝的实现方式</h2><h3 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign()\"></a>Object.assign()</h3><blockquote>\n<p><strong>Object.assign()进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。</strong></p>\n<p><strong>当object只有一层的时候，是深拷贝</strong></p>\n</blockquote>\n<h3 id=\"Array-prototype-concat\"><a href=\"#Array-prototype-concat\" class=\"headerlink\" title=\"Array.prototype.concat()\"></a>Array.prototype.concat()</h3><pre><code>let arr = [1, 3, \n  {\n    username: &#39;kobe&#39;,\n      childran: [\n        {\n          username: &#39;kobe&#39;,\n          childran: [\n              {\n                username: &#39;kobe&#39;,\n                  childran: [\n\n                  ]\n              }\n          ]\n        }\n    ]\n    }];\nlet arr2=arr.concat();    \nconsole.log(arr);\n</code></pre><blockquote>\n<p>修改新对象会改到原对象:</p>\n</blockquote>\n<h3 id=\"Array-prototype-slice\"><a href=\"#Array-prototype-slice\" class=\"headerlink\" title=\"Array.prototype.slice()\"></a>Array.prototype.slice()</h3><pre><code>let arr = [1, 3, {\n    username: &#39; kobe&#39;\n    }];\nlet arr3 = arr.slice();\narr3[2].username = &#39;wade&#39;\nconsole.log(arr);\n</code></pre><blockquote>\n<p>同样修改新对象会改到原对象:</p>\n</blockquote>\n<h3 id=\"关于Array的slice和concat方法的补充说明\"><a href=\"#关于Array的slice和concat方法的补充说明\" class=\"headerlink\" title=\"关于Array的slice和concat方法的补充说明:\"></a>关于Array的slice和concat方法的补充说明:</h3><p><strong>Array的slice和concat方法不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。</strong></p>\n<h2 id=\"深拷贝的实现方式\"><a href=\"#深拷贝的实现方式\" class=\"headerlink\" title=\"深拷贝的实现方式\"></a>深拷贝的实现方式</h2><h3 id=\"JSON-parse-JSON-stringify\"><a href=\"#JSON-parse-JSON-stringify\" class=\"headerlink\" title=\"JSON.parse(JSON.stringify())\"></a>JSON.parse(JSON.stringify())</h3><pre><code>let arr = [1, 3, {\n    username: &#39; kobe&#39;\n}];\nlet arr4 = JSON.parse(JSON.stringify(arr));\narr4[2].username = &#39;duncan&#39;; \nconsole.log(arr, arr4)\n</code></pre><blockquote>\n<p>原理：</p>\n</blockquote>\n<p><strong>用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。</strong></p>\n<blockquote>\n<p>弊端：</p>\n</blockquote>\n<blockquote>\n<p><strong>这种方法虽然可以实现数组或对象深拷贝,但不能处理函数</strong></p>\n</blockquote>\n<h3 id=\"递归方法\"><a href=\"#递归方法\" class=\"headerlink\" title=\"递归方法\"></a>递归方法</h3><blockquote>\n<p>递归方法实现深度克隆原理:</p>\n</blockquote>\n<p><strong>遍历对象、数组直到里边都是基本数据类型，然后再去复制，就是深度拷贝</strong></p>\n<pre><code>//定义检测数据类型的功能函数\nfunction checkedType(target) {\n  return Object.prototype.toString.call(target).slice(8, -1)\n}\n//实现深度克隆---对象/数组\nfunction clone(target) {\n  //判断拷贝的数据类型\n  //初始化变量result 成为最终克隆的数据\n  let result,\n    targetType = checkedType(target)\n  if (targetType === &#39;Object&#39;) {\n    result = {}\n  } else if (targetType === &#39;Array&#39;) {\n    result = []\n  } else {\n    return target\n  }\n  //遍历目标数据\n  for (let i in target) {\n    //获取遍历数据结构的每一项值。\n    let value = target[i]\n    //判断目标结构里的每一值是否存在对象/数组\n    if (checkedType(value) === &#39;Object&#39; || checkedType(value) === &#39;Array&#39;) {\n      //对象/数组里嵌套了对象/数组\n      //继续遍历获取到value值\n      result[i] = clone(value)\n    } else {\n      //获取到value值是基本的数据类型或者是函数。\n      result[i] = value\n    }\n  }\n  return result\n}\n</code></pre>"},{"title":"知识点总汇","date":"2019-01-25T08:36:42.000Z","top":10000,"meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"## react总汇图片查看\n\n### 下载下来进行查看 ****************\n\n> **[react知识点总汇图片查看](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/react.png)**\n\n## js基本知识总汇图片查看\n\n### 下载下来进行查看 ****************\n> \n> **[js基本知识总汇图片查看](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/js.png)**","source":"_posts/all.md","raw":"---\ntitle: 知识点总汇\ndate: ' 1/25/2019 4:36:42 PM '\ntag: []\ntop: 10000\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n## react总汇图片查看\n\n### 下载下来进行查看 ****************\n\n> **[react知识点总汇图片查看](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/react.png)**\n\n## js基本知识总汇图片查看\n\n### 下载下来进行查看 ****************\n> \n> **[js基本知识总汇图片查看](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/js.png)**","slug":"all","published":1,"updated":"2019-07-09T08:06:11.886Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam6o000ln4wdurmccwae","content":"<h2 id=\"react总汇图片查看\"><a href=\"#react总汇图片查看\" class=\"headerlink\" title=\"react总汇图片查看\"></a>react总汇图片查看</h2><h3 id=\"下载下来进行查看\"><a href=\"#下载下来进行查看\" class=\"headerlink\" title=\"下载下来进行查看 **\"></a>下载下来进行查看 <strong><strong><strong><em>**</em></strong></strong></strong></h3><blockquote>\n<p><strong><a href=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/react.png\" target=\"_blank\" rel=\"noopener\">react知识点总汇图片查看</a></strong></p>\n</blockquote>\n<h2 id=\"js基本知识总汇图片查看\"><a href=\"#js基本知识总汇图片查看\" class=\"headerlink\" title=\"js基本知识总汇图片查看\"></a>js基本知识总汇图片查看</h2><h3 id=\"下载下来进行查看-1\"><a href=\"#下载下来进行查看-1\" class=\"headerlink\" title=\"下载下来进行查看 **\"></a>下载下来进行查看 <strong><strong><strong><em>**</em></strong></strong></strong></h3><blockquote>\n<p><strong><a href=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/js.png\" target=\"_blank\" rel=\"noopener\">js基本知识总汇图片查看</a></strong></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"react总汇图片查看\"><a href=\"#react总汇图片查看\" class=\"headerlink\" title=\"react总汇图片查看\"></a>react总汇图片查看</h2><h3 id=\"下载下来进行查看\"><a href=\"#下载下来进行查看\" class=\"headerlink\" title=\"下载下来进行查看 **\"></a>下载下来进行查看 <strong><strong><strong><em>**</em></strong></strong></strong></h3><blockquote>\n<p><strong><a href=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/react.png\" target=\"_blank\" rel=\"noopener\">react知识点总汇图片查看</a></strong></p>\n</blockquote>\n<h2 id=\"js基本知识总汇图片查看\"><a href=\"#js基本知识总汇图片查看\" class=\"headerlink\" title=\"js基本知识总汇图片查看\"></a>js基本知识总汇图片查看</h2><h3 id=\"下载下来进行查看-1\"><a href=\"#下载下来进行查看-1\" class=\"headerlink\" title=\"下载下来进行查看 **\"></a>下载下来进行查看 <strong><strong><strong><em>**</em></strong></strong></strong></h3><blockquote>\n<p><strong><a href=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/js.png\" target=\"_blank\" rel=\"noopener\">js基本知识总汇图片查看</a></strong></p>\n</blockquote>\n"},{"title":"vue中封装axios方法","date":"2019-02-20T08:27:27.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"## vue中封装axios方法\n\n###  [axios基本配置](https://www.kancloud.cn/yunye/axios/234845)\n\n\n> **/src/util/axios.js**\n\n    import axios from 'axios' // 引入axios\n\timport vm from '@/main'\t// 引入vue实例化\n\t\n\t\n\t// 创建axios实例\n\tvar instance = axios.create({\n  \t// 设置默认请求头，使post请求发送的是formdata格式数据// axios的header默认的Content-Type好像是'application/json;charset=UTF-8'\n    \theaders: {  \n    \t  'Content-Type': 'application/x-www-form-urlencoded',\n\t      'token': 'asdasdasdasdasdasd' // 也可以自定义请求头\n        },\n\t\twithCredentials: true // 允许携带cookie\n\t})\n\n\t// 添加响应拦截器\n\tinstance.interceptors.response.use(function (response) {\n\t  // 对响应数据做点什么\n\t  return response.data\n\t}, function (error) {\n\t  // 统一的错误处理\n\t  console.log(error.response.status)\n\t  if (error.response.status !== 401) {\n\t    vm.$error(error.response.data.message)\n\t  }\n\t  // 对响应错误做点什么\n\t  return Promise.reject(error)\n\t})\n\n\texport const get = (url, data) => instance.get(url, {\n\t  params: data\n\t}) // get方式\n\t\n\texport const post = (url, data) => instance.post(url, data) //post方式\n\texport const put = (url, data) => instance.put(url, data) //put方式\n\n### **调用**\n\n\n> **api/index.js**\n\n    import {get, post} from '@/utils/axios'\n\n\tgetCityList: () => get('/api/cityList')\n","source":"_posts/axios.md","raw":"---\ntitle: vue中封装axios方法\ndate: '2/20/2019 4:27:27 PM  '\ntag: ['js', 'vue', 'axios']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n## vue中封装axios方法\n\n###  [axios基本配置](https://www.kancloud.cn/yunye/axios/234845)\n\n\n> **/src/util/axios.js**\n\n    import axios from 'axios' // 引入axios\n\timport vm from '@/main'\t// 引入vue实例化\n\t\n\t\n\t// 创建axios实例\n\tvar instance = axios.create({\n  \t// 设置默认请求头，使post请求发送的是formdata格式数据// axios的header默认的Content-Type好像是'application/json;charset=UTF-8'\n    \theaders: {  \n    \t  'Content-Type': 'application/x-www-form-urlencoded',\n\t      'token': 'asdasdasdasdasdasd' // 也可以自定义请求头\n        },\n\t\twithCredentials: true // 允许携带cookie\n\t})\n\n\t// 添加响应拦截器\n\tinstance.interceptors.response.use(function (response) {\n\t  // 对响应数据做点什么\n\t  return response.data\n\t}, function (error) {\n\t  // 统一的错误处理\n\t  console.log(error.response.status)\n\t  if (error.response.status !== 401) {\n\t    vm.$error(error.response.data.message)\n\t  }\n\t  // 对响应错误做点什么\n\t  return Promise.reject(error)\n\t})\n\n\texport const get = (url, data) => instance.get(url, {\n\t  params: data\n\t}) // get方式\n\t\n\texport const post = (url, data) => instance.post(url, data) //post方式\n\texport const put = (url, data) => instance.put(url, data) //put方式\n\n### **调用**\n\n\n> **api/index.js**\n\n    import {get, post} from '@/utils/axios'\n\n\tgetCityList: () => get('/api/cityList')\n","slug":"axios","published":1,"updated":"2019-02-20T06:27:58.338Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam6p000nn4wdu9ho4wfc","content":"<h2 id=\"vue中封装axios方法\"><a href=\"#vue中封装axios方法\" class=\"headerlink\" title=\"vue中封装axios方法\"></a>vue中封装axios方法</h2><h3 id=\"axios基本配置\"><a href=\"#axios基本配置\" class=\"headerlink\" title=\"axios基本配置\"></a><a href=\"https://www.kancloud.cn/yunye/axios/234845\" target=\"_blank\" rel=\"noopener\">axios基本配置</a></h3><blockquote>\n<p><strong>/src/util/axios.js</strong></p>\n</blockquote>\n<pre><code>import axios from &#39;axios&#39; // 引入axios\nimport vm from &#39;@/main&#39;    // 引入vue实例化\n\n\n// 创建axios实例\nvar instance = axios.create({\n  // 设置默认请求头，使post请求发送的是formdata格式数据// axios的header默认的Content-Type好像是&#39;application/json;charset=UTF-8&#39;\n    headers: {  \n      &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;,\n      &#39;token&#39;: &#39;asdasdasdasdasdasd&#39; // 也可以自定义请求头\n    },\n    withCredentials: true // 允许携带cookie\n})\n\n// 添加响应拦截器\ninstance.interceptors.response.use(function (response) {\n  // 对响应数据做点什么\n  return response.data\n}, function (error) {\n  // 统一的错误处理\n  console.log(error.response.status)\n  if (error.response.status !== 401) {\n    vm.$error(error.response.data.message)\n  }\n  // 对响应错误做点什么\n  return Promise.reject(error)\n})\n\nexport const get = (url, data) =&gt; instance.get(url, {\n  params: data\n}) // get方式\n\nexport const post = (url, data) =&gt; instance.post(url, data) //post方式\nexport const put = (url, data) =&gt; instance.put(url, data) //put方式\n</code></pre><h3 id=\"调用\"><a href=\"#调用\" class=\"headerlink\" title=\"调用\"></a><strong>调用</strong></h3><blockquote>\n<p><strong>api/index.js</strong></p>\n</blockquote>\n<pre><code>import {get, post} from &#39;@/utils/axios&#39;\n\ngetCityList: () =&gt; get(&#39;/api/cityList&#39;)\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"vue中封装axios方法\"><a href=\"#vue中封装axios方法\" class=\"headerlink\" title=\"vue中封装axios方法\"></a>vue中封装axios方法</h2><h3 id=\"axios基本配置\"><a href=\"#axios基本配置\" class=\"headerlink\" title=\"axios基本配置\"></a><a href=\"https://www.kancloud.cn/yunye/axios/234845\" target=\"_blank\" rel=\"noopener\">axios基本配置</a></h3><blockquote>\n<p><strong>/src/util/axios.js</strong></p>\n</blockquote>\n<pre><code>import axios from &#39;axios&#39; // 引入axios\nimport vm from &#39;@/main&#39;    // 引入vue实例化\n\n\n// 创建axios实例\nvar instance = axios.create({\n  // 设置默认请求头，使post请求发送的是formdata格式数据// axios的header默认的Content-Type好像是&#39;application/json;charset=UTF-8&#39;\n    headers: {  \n      &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;,\n      &#39;token&#39;: &#39;asdasdasdasdasdasd&#39; // 也可以自定义请求头\n    },\n    withCredentials: true // 允许携带cookie\n})\n\n// 添加响应拦截器\ninstance.interceptors.response.use(function (response) {\n  // 对响应数据做点什么\n  return response.data\n}, function (error) {\n  // 统一的错误处理\n  console.log(error.response.status)\n  if (error.response.status !== 401) {\n    vm.$error(error.response.data.message)\n  }\n  // 对响应错误做点什么\n  return Promise.reject(error)\n})\n\nexport const get = (url, data) =&gt; instance.get(url, {\n  params: data\n}) // get方式\n\nexport const post = (url, data) =&gt; instance.post(url, data) //post方式\nexport const put = (url, data) =&gt; instance.put(url, data) //put方式\n</code></pre><h3 id=\"调用\"><a href=\"#调用\" class=\"headerlink\" title=\"调用\"></a><strong>调用</strong></h3><blockquote>\n<p><strong>api/index.js</strong></p>\n</blockquote>\n<pre><code>import {get, post} from &#39;@/utils/axios&#39;\n\ngetCityList: () =&gt; get(&#39;/api/cityList&#39;)\n</code></pre>"},{"title":"JS 防抖（debouce）与节流（throttle）","date":"2019-02-21T08:46:31.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"## JS 防抖（debouce）与节流（throttle）\n\n\n###  防抖和节流是针对响应跟不上触发频率这类问题的两种解决方案。 在给DOM绑定事件时，有些事件我们是无法控制触发频率的。 如鼠标移动事件onmousemove, 滚动滚动条事件onscroll，窗口大小改变事件onresize，瞬间的操作都会导致这些事件会被高频触发。 如果事件的回调函数较为复杂，就会导致响应跟不上触发，出现页面卡顿，假死现象。 在实时检查输入时，如果我们绑定onkeyup事件发请求去服务端检查，用户输入过程中，事件的触发频率也会很高，会导致大量的请求发出，响应速度会大大跟不上触发。\n\n> #### 针对此类快速连续触发和不可控的高频触发问题，debounce 和 throttling 给出了两种解决策略；\n\n## 防抖(debouce)\n\n### 定义\n\t\n> 函数防抖的含义就是在一定时间段内只有一个同类的事件触发并执行；如果该时间段有同类的事件触发，则重新开始响应该事件\n\n\n----------\n\n\n> **实例**\n\n\t<!DOCTYPE html>\n\t<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title>Test</title>\n\t</head>\n\t<body>\n\t\t<input type=\"text\" name=\"input\" onkeyup=\"debouce(inputHandler);\">\n\t\t<script type=\"text/javascript\">\n\t\t\t let i = 0;\n\t    \tfunction inputHandler () {\n\t\t\t\tconsole.log(i++); \n\t\t\t}\n\t\t\tlet timer;\n\t\t\tfunction debouce (fn) {\n\t\t\t\tclearTimeout(timer); \n\t\t\t\ttimer = setTimeout(() => {\n\t\t\t\t\tfn();\n\t\t\t\t}, 500)\n\t\t\t}\n\t\t</script>\n\t</body>\n\t</html>\n\n## 节流（throttle）\n\n## 定义\n\n> **函数节流的含义就是在一定的时间段内相应的事件只能被触发一次；如果某段有已经有相应的事件在执行，则在该时间段内不再触发，直到本次事件执行结束；**\n\n\n----------\n> 实例\n\n\t<!DOCTYPE html>\n\t<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title>Test</title>\n\t</head>\n\t<body>\n\t\t<input type=\"text\" name=\"input\" onkeyup=\"debouce(inputHandler);\">\n\t\t<script type=\"text/javascript\">\n\t\t\t let i = 0;\n\t    \tfunction inputHandler () {\n\t\t\t\tconsole.log(i++); \n\t\t\t}\n\t\t\tlet timer;\n\t\t\tfunction throttle (fn) {\n\t\t\t    if (timer) {\n\t\t\t        return;\n\t\t\t    }\n\t\t\t    timer = setTimeout(() => {\n\t\t\t        fn();\n\t\t\t    }, 200);\n\t\t\t}\n\t\t</script>\n\t</body>\n\t</html>\n\n\n## 区别\n\n>    **——— 函数去抖和函数节流都是密集型操作中避免事件频繁出发造成性能损耗的解决方案；函数节流，顾名思义就是节约流量，所以每个时间段内只会执行一次，并在此时间段内屏蔽触发的同类事件；而函数去抖则是在用户连续操作中避免事件处理的处理效率不及时间触发速度，从而导致画面卡顿，操作不畅等不良用户体验，所以在很短的时间段内只响应最近触发的事件；**","source":"_posts/debouce.md","raw":"---\ntitle: JS 防抖（debouce）与节流（throttle）\ndate: '2019-02-21 16:46:31'\ntag: ['js', 'vue', 'debouce', 'throttle']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n## JS 防抖（debouce）与节流（throttle）\n\n\n###  防抖和节流是针对响应跟不上触发频率这类问题的两种解决方案。 在给DOM绑定事件时，有些事件我们是无法控制触发频率的。 如鼠标移动事件onmousemove, 滚动滚动条事件onscroll，窗口大小改变事件onresize，瞬间的操作都会导致这些事件会被高频触发。 如果事件的回调函数较为复杂，就会导致响应跟不上触发，出现页面卡顿，假死现象。 在实时检查输入时，如果我们绑定onkeyup事件发请求去服务端检查，用户输入过程中，事件的触发频率也会很高，会导致大量的请求发出，响应速度会大大跟不上触发。\n\n> #### 针对此类快速连续触发和不可控的高频触发问题，debounce 和 throttling 给出了两种解决策略；\n\n## 防抖(debouce)\n\n### 定义\n\t\n> 函数防抖的含义就是在一定时间段内只有一个同类的事件触发并执行；如果该时间段有同类的事件触发，则重新开始响应该事件\n\n\n----------\n\n\n> **实例**\n\n\t<!DOCTYPE html>\n\t<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title>Test</title>\n\t</head>\n\t<body>\n\t\t<input type=\"text\" name=\"input\" onkeyup=\"debouce(inputHandler);\">\n\t\t<script type=\"text/javascript\">\n\t\t\t let i = 0;\n\t    \tfunction inputHandler () {\n\t\t\t\tconsole.log(i++); \n\t\t\t}\n\t\t\tlet timer;\n\t\t\tfunction debouce (fn) {\n\t\t\t\tclearTimeout(timer); \n\t\t\t\ttimer = setTimeout(() => {\n\t\t\t\t\tfn();\n\t\t\t\t}, 500)\n\t\t\t}\n\t\t</script>\n\t</body>\n\t</html>\n\n## 节流（throttle）\n\n## 定义\n\n> **函数节流的含义就是在一定的时间段内相应的事件只能被触发一次；如果某段有已经有相应的事件在执行，则在该时间段内不再触发，直到本次事件执行结束；**\n\n\n----------\n> 实例\n\n\t<!DOCTYPE html>\n\t<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title>Test</title>\n\t</head>\n\t<body>\n\t\t<input type=\"text\" name=\"input\" onkeyup=\"debouce(inputHandler);\">\n\t\t<script type=\"text/javascript\">\n\t\t\t let i = 0;\n\t    \tfunction inputHandler () {\n\t\t\t\tconsole.log(i++); \n\t\t\t}\n\t\t\tlet timer;\n\t\t\tfunction throttle (fn) {\n\t\t\t    if (timer) {\n\t\t\t        return;\n\t\t\t    }\n\t\t\t    timer = setTimeout(() => {\n\t\t\t        fn();\n\t\t\t    }, 200);\n\t\t\t}\n\t\t</script>\n\t</body>\n\t</html>\n\n\n## 区别\n\n>    **——— 函数去抖和函数节流都是密集型操作中避免事件频繁出发造成性能损耗的解决方案；函数节流，顾名思义就是节约流量，所以每个时间段内只会执行一次，并在此时间段内屏蔽触发的同类事件；而函数去抖则是在用户连续操作中避免事件处理的处理效率不及时间触发速度，从而导致画面卡顿，操作不畅等不良用户体验，所以在很短的时间段内只响应最近触发的事件；**","slug":"debouce","published":1,"updated":"2019-02-21T08:19:34.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam6r000pn4wdsof7463u","content":"<h2 id=\"JS-防抖（debouce）与节流（throttle）\"><a href=\"#JS-防抖（debouce）与节流（throttle）\" class=\"headerlink\" title=\"JS 防抖（debouce）与节流（throttle）\"></a>JS 防抖（debouce）与节流（throttle）</h2><h3 id=\"防抖和节流是针对响应跟不上触发频率这类问题的两种解决方案。-在给DOM绑定事件时，有些事件我们是无法控制触发频率的。-如鼠标移动事件onmousemove-滚动滚动条事件onscroll，窗口大小改变事件onresize，瞬间的操作都会导致这些事件会被高频触发。-如果事件的回调函数较为复杂，就会导致响应跟不上触发，出现页面卡顿，假死现象。-在实时检查输入时，如果我们绑定onkeyup事件发请求去服务端检查，用户输入过程中，事件的触发频率也会很高，会导致大量的请求发出，响应速度会大大跟不上触发。\"><a href=\"#防抖和节流是针对响应跟不上触发频率这类问题的两种解决方案。-在给DOM绑定事件时，有些事件我们是无法控制触发频率的。-如鼠标移动事件onmousemove-滚动滚动条事件onscroll，窗口大小改变事件onresize，瞬间的操作都会导致这些事件会被高频触发。-如果事件的回调函数较为复杂，就会导致响应跟不上触发，出现页面卡顿，假死现象。-在实时检查输入时，如果我们绑定onkeyup事件发请求去服务端检查，用户输入过程中，事件的触发频率也会很高，会导致大量的请求发出，响应速度会大大跟不上触发。\" class=\"headerlink\" title=\"防抖和节流是针对响应跟不上触发频率这类问题的两种解决方案。 在给DOM绑定事件时，有些事件我们是无法控制触发频率的。 如鼠标移动事件onmousemove, 滚动滚动条事件onscroll，窗口大小改变事件onresize，瞬间的操作都会导致这些事件会被高频触发。 如果事件的回调函数较为复杂，就会导致响应跟不上触发，出现页面卡顿，假死现象。 在实时检查输入时，如果我们绑定onkeyup事件发请求去服务端检查，用户输入过程中，事件的触发频率也会很高，会导致大量的请求发出，响应速度会大大跟不上触发。\"></a>防抖和节流是针对响应跟不上触发频率这类问题的两种解决方案。 在给DOM绑定事件时，有些事件我们是无法控制触发频率的。 如鼠标移动事件onmousemove, 滚动滚动条事件onscroll，窗口大小改变事件onresize，瞬间的操作都会导致这些事件会被高频触发。 如果事件的回调函数较为复杂，就会导致响应跟不上触发，出现页面卡顿，假死现象。 在实时检查输入时，如果我们绑定onkeyup事件发请求去服务端检查，用户输入过程中，事件的触发频率也会很高，会导致大量的请求发出，响应速度会大大跟不上触发。</h3><blockquote>\n<h4 id=\"针对此类快速连续触发和不可控的高频触发问题，debounce-和-throttling-给出了两种解决策略；\"><a href=\"#针对此类快速连续触发和不可控的高频触发问题，debounce-和-throttling-给出了两种解决策略；\" class=\"headerlink\" title=\"针对此类快速连续触发和不可控的高频触发问题，debounce 和 throttling 给出了两种解决策略；\"></a>针对此类快速连续触发和不可控的高频触发问题，debounce 和 throttling 给出了两种解决策略；</h4></blockquote>\n<h2 id=\"防抖-debouce\"><a href=\"#防抖-debouce\" class=\"headerlink\" title=\"防抖(debouce)\"></a>防抖(debouce)</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><blockquote>\n<p>函数防抖的含义就是在一定时间段内只有一个同类的事件触发并执行；如果该时间段有同类的事件触发，则重新开始响应该事件</p>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>实例</strong></p>\n</blockquote>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Test&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;input type=&quot;text&quot; name=&quot;input&quot; onkeyup=&quot;debouce(inputHandler);&quot;&gt;\n    &lt;script type=&quot;text/javascript&quot;&gt;\n         let i = 0;\n        function inputHandler () {\n            console.log(i++); \n        }\n        let timer;\n        function debouce (fn) {\n            clearTimeout(timer); \n            timer = setTimeout(() =&gt; {\n                fn();\n            }, 500)\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><h2 id=\"节流（throttle）\"><a href=\"#节流（throttle）\" class=\"headerlink\" title=\"节流（throttle）\"></a>节流（throttle）</h2><h2 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h2><blockquote>\n<p><strong>函数节流的含义就是在一定的时间段内相应的事件只能被触发一次；如果某段有已经有相应的事件在执行，则在该时间段内不再触发，直到本次事件执行结束；</strong></p>\n</blockquote>\n<hr>\n<blockquote>\n<p>实例</p>\n</blockquote>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Test&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;input type=&quot;text&quot; name=&quot;input&quot; onkeyup=&quot;debouce(inputHandler);&quot;&gt;\n    &lt;script type=&quot;text/javascript&quot;&gt;\n         let i = 0;\n        function inputHandler () {\n            console.log(i++); \n        }\n        let timer;\n        function throttle (fn) {\n            if (timer) {\n                return;\n            }\n            timer = setTimeout(() =&gt; {\n                fn();\n            }, 200);\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><h2 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h2><blockquote>\n<p>   <strong>——— 函数去抖和函数节流都是密集型操作中避免事件频繁出发造成性能损耗的解决方案；函数节流，顾名思义就是节约流量，所以每个时间段内只会执行一次，并在此时间段内屏蔽触发的同类事件；而函数去抖则是在用户连续操作中避免事件处理的处理效率不及时间触发速度，从而导致画面卡顿，操作不畅等不良用户体验，所以在很短的时间段内只响应最近触发的事件；</strong></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"JS-防抖（debouce）与节流（throttle）\"><a href=\"#JS-防抖（debouce）与节流（throttle）\" class=\"headerlink\" title=\"JS 防抖（debouce）与节流（throttle）\"></a>JS 防抖（debouce）与节流（throttle）</h2><h3 id=\"防抖和节流是针对响应跟不上触发频率这类问题的两种解决方案。-在给DOM绑定事件时，有些事件我们是无法控制触发频率的。-如鼠标移动事件onmousemove-滚动滚动条事件onscroll，窗口大小改变事件onresize，瞬间的操作都会导致这些事件会被高频触发。-如果事件的回调函数较为复杂，就会导致响应跟不上触发，出现页面卡顿，假死现象。-在实时检查输入时，如果我们绑定onkeyup事件发请求去服务端检查，用户输入过程中，事件的触发频率也会很高，会导致大量的请求发出，响应速度会大大跟不上触发。\"><a href=\"#防抖和节流是针对响应跟不上触发频率这类问题的两种解决方案。-在给DOM绑定事件时，有些事件我们是无法控制触发频率的。-如鼠标移动事件onmousemove-滚动滚动条事件onscroll，窗口大小改变事件onresize，瞬间的操作都会导致这些事件会被高频触发。-如果事件的回调函数较为复杂，就会导致响应跟不上触发，出现页面卡顿，假死现象。-在实时检查输入时，如果我们绑定onkeyup事件发请求去服务端检查，用户输入过程中，事件的触发频率也会很高，会导致大量的请求发出，响应速度会大大跟不上触发。\" class=\"headerlink\" title=\"防抖和节流是针对响应跟不上触发频率这类问题的两种解决方案。 在给DOM绑定事件时，有些事件我们是无法控制触发频率的。 如鼠标移动事件onmousemove, 滚动滚动条事件onscroll，窗口大小改变事件onresize，瞬间的操作都会导致这些事件会被高频触发。 如果事件的回调函数较为复杂，就会导致响应跟不上触发，出现页面卡顿，假死现象。 在实时检查输入时，如果我们绑定onkeyup事件发请求去服务端检查，用户输入过程中，事件的触发频率也会很高，会导致大量的请求发出，响应速度会大大跟不上触发。\"></a>防抖和节流是针对响应跟不上触发频率这类问题的两种解决方案。 在给DOM绑定事件时，有些事件我们是无法控制触发频率的。 如鼠标移动事件onmousemove, 滚动滚动条事件onscroll，窗口大小改变事件onresize，瞬间的操作都会导致这些事件会被高频触发。 如果事件的回调函数较为复杂，就会导致响应跟不上触发，出现页面卡顿，假死现象。 在实时检查输入时，如果我们绑定onkeyup事件发请求去服务端检查，用户输入过程中，事件的触发频率也会很高，会导致大量的请求发出，响应速度会大大跟不上触发。</h3><blockquote>\n<h4 id=\"针对此类快速连续触发和不可控的高频触发问题，debounce-和-throttling-给出了两种解决策略；\"><a href=\"#针对此类快速连续触发和不可控的高频触发问题，debounce-和-throttling-给出了两种解决策略；\" class=\"headerlink\" title=\"针对此类快速连续触发和不可控的高频触发问题，debounce 和 throttling 给出了两种解决策略；\"></a>针对此类快速连续触发和不可控的高频触发问题，debounce 和 throttling 给出了两种解决策略；</h4></blockquote>\n<h2 id=\"防抖-debouce\"><a href=\"#防抖-debouce\" class=\"headerlink\" title=\"防抖(debouce)\"></a>防抖(debouce)</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><blockquote>\n<p>函数防抖的含义就是在一定时间段内只有一个同类的事件触发并执行；如果该时间段有同类的事件触发，则重新开始响应该事件</p>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>实例</strong></p>\n</blockquote>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Test&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;input type=&quot;text&quot; name=&quot;input&quot; onkeyup=&quot;debouce(inputHandler);&quot;&gt;\n    &lt;script type=&quot;text/javascript&quot;&gt;\n         let i = 0;\n        function inputHandler () {\n            console.log(i++); \n        }\n        let timer;\n        function debouce (fn) {\n            clearTimeout(timer); \n            timer = setTimeout(() =&gt; {\n                fn();\n            }, 500)\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><h2 id=\"节流（throttle）\"><a href=\"#节流（throttle）\" class=\"headerlink\" title=\"节流（throttle）\"></a>节流（throttle）</h2><h2 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h2><blockquote>\n<p><strong>函数节流的含义就是在一定的时间段内相应的事件只能被触发一次；如果某段有已经有相应的事件在执行，则在该时间段内不再触发，直到本次事件执行结束；</strong></p>\n</blockquote>\n<hr>\n<blockquote>\n<p>实例</p>\n</blockquote>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Test&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;input type=&quot;text&quot; name=&quot;input&quot; onkeyup=&quot;debouce(inputHandler);&quot;&gt;\n    &lt;script type=&quot;text/javascript&quot;&gt;\n         let i = 0;\n        function inputHandler () {\n            console.log(i++); \n        }\n        let timer;\n        function throttle (fn) {\n            if (timer) {\n                return;\n            }\n            timer = setTimeout(() =&gt; {\n                fn();\n            }, 200);\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><h2 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h2><blockquote>\n<p>   <strong>——— 函数去抖和函数节流都是密集型操作中避免事件频繁出发造成性能损耗的解决方案；函数节流，顾名思义就是节约流量，所以每个时间段内只会执行一次，并在此时间段内屏蔽触发的同类事件；而函数去抖则是在用户连续操作中避免事件处理的处理效率不及时间触发速度，从而导致画面卡顿，操作不畅等不良用户体验，所以在很短的时间段内只响应最近触发的事件；</strong></p>\n</blockquote>\n"},{"title":"跨域","date":"2019-02-13T10:39:12.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"## 跨域\n###[浏览器同源政策及其规避方法](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)\n### 跨域是由于浏览器的同源策略限制，而产生的一种安全模式。\n\n## 同源策略\n\n### 同源是指同协议，同域名，同端口，三者相同就是同源，如有一项不同就是跨域，而在浏览器中静态资源不受同源策略的影响（img,link，script,iframe）\n\n## 解决跨域\n\n### 利用同源策略的特点解决跨域问题\n\n## 方式一: jsonp请求\n\n### 利用静态资源不受跨域的限制解决跨域\n> ####封装jsonp\n\n\n\tconst getParams = (data) => { // 创建一个函数，接收一个参数\n\t  console.log(data, '444')\n\t  let params = ''\n\t  for (let key in data) {\n\t    console.log(key)\n\t    params += '&' + key + '=' + data[key]\n\t  }\n\t  return params\n\t}\n\tconst jsonp = (url, data) => { // 创建函数接收需要跨域请求的地址\n\t  return new Promise((resolve, reject) => {\n\t    const script = document.createElement('script') // 动态创建script标签\n\t    const callbackName = 'a' + (+new Date()) // 随机定义callback函数名\n\t    const params = getParams(data) // 拼接参数\n\t    script.src = url + '?callback=' + callbackName + '&' + params // 设置src属性为接口地址\n\t    console.log(script)\n\t    document.body.appendChild(script) // 动态插入到页面中\n\t    window[callbackName] = function (res) { // 动态设置callback函数到window上\n\t      resolve(res) // 成功后\n\t      document.body.removeChild(script) // 删除script标签\n\t      window[callbackName] = null // 清空window上的callback函数\n\t    }\n\t    console.log('aaa')\n\t  })\n\t}\n\texport default jsonp\n\n> ###后端【使用express来说】\n\n\trouter.get('/list', function(req,res){\n\t  console.log(req.query)\n\t  let {callback} = req.query\n\t  res.send(`${callback}('sssss')`)\n\t})\n\n\n#### 优点\n\n> 可以解决跨域，并且兼容所有浏览器\n\n#### 缺点\n\n> 只能get请求，不能post请求\n\n#### 特性\n\n> 利用了静态资源不受同源策略影响\n\n#### 原理\n\n> 动态生成script标签，并且设置src属性为接口地址，动态插入到页面中，发出请求，后端接到请求，需要获取callback的参数，而callback的参数\n> 动态生成script标签的时候，动态生成函数名称\n\n## 方式二：cors\n\ncors跨域资源共享，这是浏览器的新增特性，只需要操作服务即可，客户端不变，常用场景就是小程序\n\nCors是一个w3c标准，全称是“跨域资源共享”（Corss-origin rsource sharing）\n\n他允许浏览器向跨域服务器，发出XMLrequrest请求，从而克服了AJAX只能同源使用的限制\n\n前端不需要做任何修改，只需要服务端设置允许的header头即可\n\n\n\tapp.use((req, res, next) => {\n\t  res.header('Access-Control-Allow-Origin', '*'); // 允许所有跨域请求\n\t  res.header('Access-Control-Allow-Credentials', true) // 允许携带cookie\n\t  res.header('Access-Control-Allow-Headers', 'Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild'); //允许的header内容\n\t  res.header('Access-Control-Allow-Methods', 'PUT, POST, GET, DELETE, OPTIONS'); // 允许的请求方法\n\t\n\t  next()\n\t})\n\n### 优点 \n\n> #### 前端不需要做任何处理，支持get，post任何请求\n\n### 缺点\n\n> #### 浏览器兼容，不兼容IE10以下浏览器\n\n### 特性\n\n> #### 浏览器新特性\n\n## 方式三：代理\n一般情况下跨域产生的原因域名端口不一样，因为在开发环境中，前端启动的是自己的服务，后端启动也是自己的服务，而在后面上线了就不存在跨域了，这种情况下我们一般使用代理的形式（后端不需要做任何调整，只需要前端添加反向代理即可）\n\n\n客户端发出去请求 -- 本地服务器拦截 -- 发现是api开头 -- 本地服务发出请求请求(localhost:3000) -- 跨域服务器返回数据 -- 本地服务器接收数据 -- 将数据返回给客户端\n\n\n## 方式四：window.name+iframe\n\n### window.name通过在iframe（一般动态创建i）中加载跨域HTML文件来起作用。然后，HTML文件将传递给请求者的字符串内容赋值给window.name。然后，请求者可以检索window.name值作为响应。\n\n- iframe标签的跨域能力；\n- window.name属性值在文档刷新后依旧存在的能力（且最大允许2M左右）。\n\n> #### 每个iframe都有包裹它的window，而这个window是top window的子窗口。contentWindow属性返回iframe元素的Window对象。你可以使用这个Window对象来访问iframe的文档及其内部DOM。\n\n\t<!-- \n\t 下述用端口 \n\t 10000表示：domainA\n\t 10001表示：domainB\n\t-->\n\t\n\t<!-- localhost:10000 -->\n\t<script>\n\t  var iframe = document.createElement('iframe');\n\t  iframe.style.display = 'none'; // 隐藏\n\t\n\t  var state = 0; // 防止页面无限刷新\n\t  iframe.onload = function() {\n\t      if(state === 1) {\n\t          console.log(JSON.parse(iframe.contentWindow.name));\n\t          // 清除创建的iframe\n\t          iframe.contentWindow.document.write('');\n\t          iframe.contentWindow.close();\n\t          document.body.removeChild(iframe);\n\t      } else if(state === 0) {\n\t          state = 1;\n\t          // 加载完成，指向当前域，防止错误(proxy.html为空白页面)\n\t          // Blocked a frame with origin \"http://localhost:10000\" from accessing a cross-origin frame.\n\t          iframe.contentWindow.location = 'http://localhost:10000/proxy.html';\n\t      }\n\t  };\n\t\n\t  iframe.src = 'http://localhost:10001';\n\t  document.body.appendChild(iframe);\n\t</script>\n\t\n\t<!-- localhost:10001 -->\n\t<!DOCTYPE html>\n\t...\n\t<script>\n\t  window.name = JSON.stringify({a: 1, b: 2});\n\t</script>\n\t</html>\n\n### 注意：\n\n> 1. 直接嵌入其他域（localhots:10001）下的URL会报错，所以需要加载完成替换为当前域的URL(localhots:10000)，proxy.html为空白页面，只为解决该问题； \n> \n> 2. 重新设置src（http://localhost:10000/proxy.html）后导致页面不断刷新，所以通过state来控制；\n> \n> 3. 全部获取完结果后，清除该iframe。\n\n\n\n","source":"_posts/cors.md","raw":"---\ntitle: 跨域\ndate: '2/13/2019 6:39:12 PM'\n\ntag: ['js', 'cors', '跨域', 'jsonp']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n## 跨域\n###[浏览器同源政策及其规避方法](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)\n### 跨域是由于浏览器的同源策略限制，而产生的一种安全模式。\n\n## 同源策略\n\n### 同源是指同协议，同域名，同端口，三者相同就是同源，如有一项不同就是跨域，而在浏览器中静态资源不受同源策略的影响（img,link，script,iframe）\n\n## 解决跨域\n\n### 利用同源策略的特点解决跨域问题\n\n## 方式一: jsonp请求\n\n### 利用静态资源不受跨域的限制解决跨域\n> ####封装jsonp\n\n\n\tconst getParams = (data) => { // 创建一个函数，接收一个参数\n\t  console.log(data, '444')\n\t  let params = ''\n\t  for (let key in data) {\n\t    console.log(key)\n\t    params += '&' + key + '=' + data[key]\n\t  }\n\t  return params\n\t}\n\tconst jsonp = (url, data) => { // 创建函数接收需要跨域请求的地址\n\t  return new Promise((resolve, reject) => {\n\t    const script = document.createElement('script') // 动态创建script标签\n\t    const callbackName = 'a' + (+new Date()) // 随机定义callback函数名\n\t    const params = getParams(data) // 拼接参数\n\t    script.src = url + '?callback=' + callbackName + '&' + params // 设置src属性为接口地址\n\t    console.log(script)\n\t    document.body.appendChild(script) // 动态插入到页面中\n\t    window[callbackName] = function (res) { // 动态设置callback函数到window上\n\t      resolve(res) // 成功后\n\t      document.body.removeChild(script) // 删除script标签\n\t      window[callbackName] = null // 清空window上的callback函数\n\t    }\n\t    console.log('aaa')\n\t  })\n\t}\n\texport default jsonp\n\n> ###后端【使用express来说】\n\n\trouter.get('/list', function(req,res){\n\t  console.log(req.query)\n\t  let {callback} = req.query\n\t  res.send(`${callback}('sssss')`)\n\t})\n\n\n#### 优点\n\n> 可以解决跨域，并且兼容所有浏览器\n\n#### 缺点\n\n> 只能get请求，不能post请求\n\n#### 特性\n\n> 利用了静态资源不受同源策略影响\n\n#### 原理\n\n> 动态生成script标签，并且设置src属性为接口地址，动态插入到页面中，发出请求，后端接到请求，需要获取callback的参数，而callback的参数\n> 动态生成script标签的时候，动态生成函数名称\n\n## 方式二：cors\n\ncors跨域资源共享，这是浏览器的新增特性，只需要操作服务即可，客户端不变，常用场景就是小程序\n\nCors是一个w3c标准，全称是“跨域资源共享”（Corss-origin rsource sharing）\n\n他允许浏览器向跨域服务器，发出XMLrequrest请求，从而克服了AJAX只能同源使用的限制\n\n前端不需要做任何修改，只需要服务端设置允许的header头即可\n\n\n\tapp.use((req, res, next) => {\n\t  res.header('Access-Control-Allow-Origin', '*'); // 允许所有跨域请求\n\t  res.header('Access-Control-Allow-Credentials', true) // 允许携带cookie\n\t  res.header('Access-Control-Allow-Headers', 'Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild'); //允许的header内容\n\t  res.header('Access-Control-Allow-Methods', 'PUT, POST, GET, DELETE, OPTIONS'); // 允许的请求方法\n\t\n\t  next()\n\t})\n\n### 优点 \n\n> #### 前端不需要做任何处理，支持get，post任何请求\n\n### 缺点\n\n> #### 浏览器兼容，不兼容IE10以下浏览器\n\n### 特性\n\n> #### 浏览器新特性\n\n## 方式三：代理\n一般情况下跨域产生的原因域名端口不一样，因为在开发环境中，前端启动的是自己的服务，后端启动也是自己的服务，而在后面上线了就不存在跨域了，这种情况下我们一般使用代理的形式（后端不需要做任何调整，只需要前端添加反向代理即可）\n\n\n客户端发出去请求 -- 本地服务器拦截 -- 发现是api开头 -- 本地服务发出请求请求(localhost:3000) -- 跨域服务器返回数据 -- 本地服务器接收数据 -- 将数据返回给客户端\n\n\n## 方式四：window.name+iframe\n\n### window.name通过在iframe（一般动态创建i）中加载跨域HTML文件来起作用。然后，HTML文件将传递给请求者的字符串内容赋值给window.name。然后，请求者可以检索window.name值作为响应。\n\n- iframe标签的跨域能力；\n- window.name属性值在文档刷新后依旧存在的能力（且最大允许2M左右）。\n\n> #### 每个iframe都有包裹它的window，而这个window是top window的子窗口。contentWindow属性返回iframe元素的Window对象。你可以使用这个Window对象来访问iframe的文档及其内部DOM。\n\n\t<!-- \n\t 下述用端口 \n\t 10000表示：domainA\n\t 10001表示：domainB\n\t-->\n\t\n\t<!-- localhost:10000 -->\n\t<script>\n\t  var iframe = document.createElement('iframe');\n\t  iframe.style.display = 'none'; // 隐藏\n\t\n\t  var state = 0; // 防止页面无限刷新\n\t  iframe.onload = function() {\n\t      if(state === 1) {\n\t          console.log(JSON.parse(iframe.contentWindow.name));\n\t          // 清除创建的iframe\n\t          iframe.contentWindow.document.write('');\n\t          iframe.contentWindow.close();\n\t          document.body.removeChild(iframe);\n\t      } else if(state === 0) {\n\t          state = 1;\n\t          // 加载完成，指向当前域，防止错误(proxy.html为空白页面)\n\t          // Blocked a frame with origin \"http://localhost:10000\" from accessing a cross-origin frame.\n\t          iframe.contentWindow.location = 'http://localhost:10000/proxy.html';\n\t      }\n\t  };\n\t\n\t  iframe.src = 'http://localhost:10001';\n\t  document.body.appendChild(iframe);\n\t</script>\n\t\n\t<!-- localhost:10001 -->\n\t<!DOCTYPE html>\n\t...\n\t<script>\n\t  window.name = JSON.stringify({a: 1, b: 2});\n\t</script>\n\t</html>\n\n### 注意：\n\n> 1. 直接嵌入其他域（localhots:10001）下的URL会报错，所以需要加载完成替换为当前域的URL(localhots:10000)，proxy.html为空白页面，只为解决该问题； \n> \n> 2. 重新设置src（http://localhost:10000/proxy.html）后导致页面不断刷新，所以通过state来控制；\n> \n> 3. 全部获取完结果后，清除该iframe。\n\n\n\n","slug":"cors","published":1,"updated":"2019-02-18T05:43:50.669Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam6s000sn4wd2uk6t1vh","content":"<h2 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h2><p>###<a href=\"http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html\" target=\"_blank\" rel=\"noopener\">浏览器同源政策及其规避方法</a></p>\n<h3 id=\"跨域是由于浏览器的同源策略限制，而产生的一种安全模式。\"><a href=\"#跨域是由于浏览器的同源策略限制，而产生的一种安全模式。\" class=\"headerlink\" title=\"跨域是由于浏览器的同源策略限制，而产生的一种安全模式。\"></a>跨域是由于浏览器的同源策略限制，而产生的一种安全模式。</h3><h2 id=\"同源策略\"><a href=\"#同源策略\" class=\"headerlink\" title=\"同源策略\"></a>同源策略</h2><h3 id=\"同源是指同协议，同域名，同端口，三者相同就是同源，如有一项不同就是跨域，而在浏览器中静态资源不受同源策略的影响（img-link，script-iframe）\"><a href=\"#同源是指同协议，同域名，同端口，三者相同就是同源，如有一项不同就是跨域，而在浏览器中静态资源不受同源策略的影响（img-link，script-iframe）\" class=\"headerlink\" title=\"同源是指同协议，同域名，同端口，三者相同就是同源，如有一项不同就是跨域，而在浏览器中静态资源不受同源策略的影响（img,link，script,iframe）\"></a>同源是指同协议，同域名，同端口，三者相同就是同源，如有一项不同就是跨域，而在浏览器中静态资源不受同源策略的影响（img,link，script,iframe）</h3><h2 id=\"解决跨域\"><a href=\"#解决跨域\" class=\"headerlink\" title=\"解决跨域\"></a>解决跨域</h2><h3 id=\"利用同源策略的特点解决跨域问题\"><a href=\"#利用同源策略的特点解决跨域问题\" class=\"headerlink\" title=\"利用同源策略的特点解决跨域问题\"></a>利用同源策略的特点解决跨域问题</h3><h2 id=\"方式一-jsonp请求\"><a href=\"#方式一-jsonp请求\" class=\"headerlink\" title=\"方式一: jsonp请求\"></a>方式一: jsonp请求</h2><h3 id=\"利用静态资源不受跨域的限制解决跨域\"><a href=\"#利用静态资源不受跨域的限制解决跨域\" class=\"headerlink\" title=\"利用静态资源不受跨域的限制解决跨域\"></a>利用静态资源不受跨域的限制解决跨域</h3><blockquote>\n<p>####封装jsonp</p>\n</blockquote>\n<pre><code>const getParams = (data) =&gt; { // 创建一个函数，接收一个参数\n  console.log(data, &#39;444&#39;)\n  let params = &#39;&#39;\n  for (let key in data) {\n    console.log(key)\n    params += &#39;&amp;&#39; + key + &#39;=&#39; + data[key]\n  }\n  return params\n}\nconst jsonp = (url, data) =&gt; { // 创建函数接收需要跨域请求的地址\n  return new Promise((resolve, reject) =&gt; {\n    const script = document.createElement(&#39;script&#39;) // 动态创建script标签\n    const callbackName = &#39;a&#39; + (+new Date()) // 随机定义callback函数名\n    const params = getParams(data) // 拼接参数\n    script.src = url + &#39;?callback=&#39; + callbackName + &#39;&amp;&#39; + params // 设置src属性为接口地址\n    console.log(script)\n    document.body.appendChild(script) // 动态插入到页面中\n    window[callbackName] = function (res) { // 动态设置callback函数到window上\n      resolve(res) // 成功后\n      document.body.removeChild(script) // 删除script标签\n      window[callbackName] = null // 清空window上的callback函数\n    }\n    console.log(&#39;aaa&#39;)\n  })\n}\nexport default jsonp\n</code></pre><blockquote>\n<p>###后端【使用express来说】</p>\n</blockquote>\n<pre><code>router.get(&#39;/list&#39;, function(req,res){\n  console.log(req.query)\n  let {callback} = req.query\n  res.send(`${callback}(&#39;sssss&#39;)`)\n})\n</code></pre><h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><blockquote>\n<p>可以解决跨域，并且兼容所有浏览器</p>\n</blockquote>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><blockquote>\n<p>只能get请求，不能post请求</p>\n</blockquote>\n<h4 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h4><blockquote>\n<p>利用了静态资源不受同源策略影响</p>\n</blockquote>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><blockquote>\n<p>动态生成script标签，并且设置src属性为接口地址，动态插入到页面中，发出请求，后端接到请求，需要获取callback的参数，而callback的参数<br>动态生成script标签的时候，动态生成函数名称</p>\n</blockquote>\n<h2 id=\"方式二：cors\"><a href=\"#方式二：cors\" class=\"headerlink\" title=\"方式二：cors\"></a>方式二：cors</h2><p>cors跨域资源共享，这是浏览器的新增特性，只需要操作服务即可，客户端不变，常用场景就是小程序</p>\n<p>Cors是一个w3c标准，全称是“跨域资源共享”（Corss-origin rsource sharing）</p>\n<p>他允许浏览器向跨域服务器，发出XMLrequrest请求，从而克服了AJAX只能同源使用的限制</p>\n<p>前端不需要做任何修改，只需要服务端设置允许的header头即可</p>\n<pre><code>app.use((req, res, next) =&gt; {\n  res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;); // 允许所有跨域请求\n  res.header(&#39;Access-Control-Allow-Credentials&#39;, true) // 允许携带cookie\n  res.header(&#39;Access-Control-Allow-Headers&#39;, &#39;Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild&#39;); //允许的header内容\n  res.header(&#39;Access-Control-Allow-Methods&#39;, &#39;PUT, POST, GET, DELETE, OPTIONS&#39;); // 允许的请求方法\n\n  next()\n})\n</code></pre><h3 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h3><blockquote>\n<h4 id=\"前端不需要做任何处理，支持get，post任何请求\"><a href=\"#前端不需要做任何处理，支持get，post任何请求\" class=\"headerlink\" title=\"前端不需要做任何处理，支持get，post任何请求\"></a>前端不需要做任何处理，支持get，post任何请求</h4></blockquote>\n<h3 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><blockquote>\n<h4 id=\"浏览器兼容，不兼容IE10以下浏览器\"><a href=\"#浏览器兼容，不兼容IE10以下浏览器\" class=\"headerlink\" title=\"浏览器兼容，不兼容IE10以下浏览器\"></a>浏览器兼容，不兼容IE10以下浏览器</h4></blockquote>\n<h3 id=\"特性-1\"><a href=\"#特性-1\" class=\"headerlink\" title=\"特性\"></a>特性</h3><blockquote>\n<h4 id=\"浏览器新特性\"><a href=\"#浏览器新特性\" class=\"headerlink\" title=\"浏览器新特性\"></a>浏览器新特性</h4></blockquote>\n<h2 id=\"方式三：代理\"><a href=\"#方式三：代理\" class=\"headerlink\" title=\"方式三：代理\"></a>方式三：代理</h2><p>一般情况下跨域产生的原因域名端口不一样，因为在开发环境中，前端启动的是自己的服务，后端启动也是自己的服务，而在后面上线了就不存在跨域了，这种情况下我们一般使用代理的形式（后端不需要做任何调整，只需要前端添加反向代理即可）</p>\n<p>客户端发出去请求 – 本地服务器拦截 – 发现是api开头 – 本地服务发出请求请求(localhost:3000) – 跨域服务器返回数据 – 本地服务器接收数据 – 将数据返回给客户端</p>\n<h2 id=\"方式四：window-name-iframe\"><a href=\"#方式四：window-name-iframe\" class=\"headerlink\" title=\"方式四：window.name+iframe\"></a>方式四：window.name+iframe</h2><h3 id=\"window-name通过在iframe（一般动态创建i）中加载跨域HTML文件来起作用。然后，HTML文件将传递给请求者的字符串内容赋值给window-name。然后，请求者可以检索window-name值作为响应。\"><a href=\"#window-name通过在iframe（一般动态创建i）中加载跨域HTML文件来起作用。然后，HTML文件将传递给请求者的字符串内容赋值给window-name。然后，请求者可以检索window-name值作为响应。\" class=\"headerlink\" title=\"window.name通过在iframe（一般动态创建i）中加载跨域HTML文件来起作用。然后，HTML文件将传递给请求者的字符串内容赋值给window.name。然后，请求者可以检索window.name值作为响应。\"></a>window.name通过在iframe（一般动态创建i）中加载跨域HTML文件来起作用。然后，HTML文件将传递给请求者的字符串内容赋值给window.name。然后，请求者可以检索window.name值作为响应。</h3><ul>\n<li>iframe标签的跨域能力；</li>\n<li>window.name属性值在文档刷新后依旧存在的能力（且最大允许2M左右）。</li>\n</ul>\n<blockquote>\n<h4 id=\"每个iframe都有包裹它的window，而这个window是top-window的子窗口。contentWindow属性返回iframe元素的Window对象。你可以使用这个Window对象来访问iframe的文档及其内部DOM。\"><a href=\"#每个iframe都有包裹它的window，而这个window是top-window的子窗口。contentWindow属性返回iframe元素的Window对象。你可以使用这个Window对象来访问iframe的文档及其内部DOM。\" class=\"headerlink\" title=\"每个iframe都有包裹它的window，而这个window是top window的子窗口。contentWindow属性返回iframe元素的Window对象。你可以使用这个Window对象来访问iframe的文档及其内部DOM。\"></a>每个iframe都有包裹它的window，而这个window是top window的子窗口。contentWindow属性返回iframe元素的Window对象。你可以使用这个Window对象来访问iframe的文档及其内部DOM。</h4></blockquote>\n<pre><code>&lt;!-- \n 下述用端口 \n 10000表示：domainA\n 10001表示：domainB\n--&gt;\n\n&lt;!-- localhost:10000 --&gt;\n&lt;script&gt;\n  var iframe = document.createElement(&#39;iframe&#39;);\n  iframe.style.display = &#39;none&#39;; // 隐藏\n\n  var state = 0; // 防止页面无限刷新\n  iframe.onload = function() {\n      if(state === 1) {\n          console.log(JSON.parse(iframe.contentWindow.name));\n          // 清除创建的iframe\n          iframe.contentWindow.document.write(&#39;&#39;);\n          iframe.contentWindow.close();\n          document.body.removeChild(iframe);\n      } else if(state === 0) {\n          state = 1;\n          // 加载完成，指向当前域，防止错误(proxy.html为空白页面)\n          // Blocked a frame with origin &quot;http://localhost:10000&quot; from accessing a cross-origin frame.\n          iframe.contentWindow.location = &#39;http://localhost:10000/proxy.html&#39;;\n      }\n  };\n\n  iframe.src = &#39;http://localhost:10001&#39;;\n  document.body.appendChild(iframe);\n&lt;/script&gt;\n\n&lt;!-- localhost:10001 --&gt;\n&lt;!DOCTYPE html&gt;\n...\n&lt;script&gt;\n  window.name = JSON.stringify({a: 1, b: 2});\n&lt;/script&gt;\n&lt;/html&gt;\n</code></pre><h3 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h3><blockquote>\n<ol>\n<li><p>直接嵌入其他域（localhots:10001）下的URL会报错，所以需要加载完成替换为当前域的URL(localhots:10000)，proxy.html为空白页面，只为解决该问题； </p>\n</li>\n<li><p>重新设置src（<a href=\"http://localhost:10000/proxy.html）后导致页面不断刷新，所以通过state来控制；\" target=\"_blank\" rel=\"noopener\">http://localhost:10000/proxy.html）后导致页面不断刷新，所以通过state来控制；</a></p>\n</li>\n<li><p>全部获取完结果后，清除该iframe。</p>\n</li>\n</ol>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h2><p>###<a href=\"http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html\" target=\"_blank\" rel=\"noopener\">浏览器同源政策及其规避方法</a></p>\n<h3 id=\"跨域是由于浏览器的同源策略限制，而产生的一种安全模式。\"><a href=\"#跨域是由于浏览器的同源策略限制，而产生的一种安全模式。\" class=\"headerlink\" title=\"跨域是由于浏览器的同源策略限制，而产生的一种安全模式。\"></a>跨域是由于浏览器的同源策略限制，而产生的一种安全模式。</h3><h2 id=\"同源策略\"><a href=\"#同源策略\" class=\"headerlink\" title=\"同源策略\"></a>同源策略</h2><h3 id=\"同源是指同协议，同域名，同端口，三者相同就是同源，如有一项不同就是跨域，而在浏览器中静态资源不受同源策略的影响（img-link，script-iframe）\"><a href=\"#同源是指同协议，同域名，同端口，三者相同就是同源，如有一项不同就是跨域，而在浏览器中静态资源不受同源策略的影响（img-link，script-iframe）\" class=\"headerlink\" title=\"同源是指同协议，同域名，同端口，三者相同就是同源，如有一项不同就是跨域，而在浏览器中静态资源不受同源策略的影响（img,link，script,iframe）\"></a>同源是指同协议，同域名，同端口，三者相同就是同源，如有一项不同就是跨域，而在浏览器中静态资源不受同源策略的影响（img,link，script,iframe）</h3><h2 id=\"解决跨域\"><a href=\"#解决跨域\" class=\"headerlink\" title=\"解决跨域\"></a>解决跨域</h2><h3 id=\"利用同源策略的特点解决跨域问题\"><a href=\"#利用同源策略的特点解决跨域问题\" class=\"headerlink\" title=\"利用同源策略的特点解决跨域问题\"></a>利用同源策略的特点解决跨域问题</h3><h2 id=\"方式一-jsonp请求\"><a href=\"#方式一-jsonp请求\" class=\"headerlink\" title=\"方式一: jsonp请求\"></a>方式一: jsonp请求</h2><h3 id=\"利用静态资源不受跨域的限制解决跨域\"><a href=\"#利用静态资源不受跨域的限制解决跨域\" class=\"headerlink\" title=\"利用静态资源不受跨域的限制解决跨域\"></a>利用静态资源不受跨域的限制解决跨域</h3><blockquote>\n<p>####封装jsonp</p>\n</blockquote>\n<pre><code>const getParams = (data) =&gt; { // 创建一个函数，接收一个参数\n  console.log(data, &#39;444&#39;)\n  let params = &#39;&#39;\n  for (let key in data) {\n    console.log(key)\n    params += &#39;&amp;&#39; + key + &#39;=&#39; + data[key]\n  }\n  return params\n}\nconst jsonp = (url, data) =&gt; { // 创建函数接收需要跨域请求的地址\n  return new Promise((resolve, reject) =&gt; {\n    const script = document.createElement(&#39;script&#39;) // 动态创建script标签\n    const callbackName = &#39;a&#39; + (+new Date()) // 随机定义callback函数名\n    const params = getParams(data) // 拼接参数\n    script.src = url + &#39;?callback=&#39; + callbackName + &#39;&amp;&#39; + params // 设置src属性为接口地址\n    console.log(script)\n    document.body.appendChild(script) // 动态插入到页面中\n    window[callbackName] = function (res) { // 动态设置callback函数到window上\n      resolve(res) // 成功后\n      document.body.removeChild(script) // 删除script标签\n      window[callbackName] = null // 清空window上的callback函数\n    }\n    console.log(&#39;aaa&#39;)\n  })\n}\nexport default jsonp\n</code></pre><blockquote>\n<p>###后端【使用express来说】</p>\n</blockquote>\n<pre><code>router.get(&#39;/list&#39;, function(req,res){\n  console.log(req.query)\n  let {callback} = req.query\n  res.send(`${callback}(&#39;sssss&#39;)`)\n})\n</code></pre><h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><blockquote>\n<p>可以解决跨域，并且兼容所有浏览器</p>\n</blockquote>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><blockquote>\n<p>只能get请求，不能post请求</p>\n</blockquote>\n<h4 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h4><blockquote>\n<p>利用了静态资源不受同源策略影响</p>\n</blockquote>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><blockquote>\n<p>动态生成script标签，并且设置src属性为接口地址，动态插入到页面中，发出请求，后端接到请求，需要获取callback的参数，而callback的参数<br>动态生成script标签的时候，动态生成函数名称</p>\n</blockquote>\n<h2 id=\"方式二：cors\"><a href=\"#方式二：cors\" class=\"headerlink\" title=\"方式二：cors\"></a>方式二：cors</h2><p>cors跨域资源共享，这是浏览器的新增特性，只需要操作服务即可，客户端不变，常用场景就是小程序</p>\n<p>Cors是一个w3c标准，全称是“跨域资源共享”（Corss-origin rsource sharing）</p>\n<p>他允许浏览器向跨域服务器，发出XMLrequrest请求，从而克服了AJAX只能同源使用的限制</p>\n<p>前端不需要做任何修改，只需要服务端设置允许的header头即可</p>\n<pre><code>app.use((req, res, next) =&gt; {\n  res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;); // 允许所有跨域请求\n  res.header(&#39;Access-Control-Allow-Credentials&#39;, true) // 允许携带cookie\n  res.header(&#39;Access-Control-Allow-Headers&#39;, &#39;Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild&#39;); //允许的header内容\n  res.header(&#39;Access-Control-Allow-Methods&#39;, &#39;PUT, POST, GET, DELETE, OPTIONS&#39;); // 允许的请求方法\n\n  next()\n})\n</code></pre><h3 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h3><blockquote>\n<h4 id=\"前端不需要做任何处理，支持get，post任何请求\"><a href=\"#前端不需要做任何处理，支持get，post任何请求\" class=\"headerlink\" title=\"前端不需要做任何处理，支持get，post任何请求\"></a>前端不需要做任何处理，支持get，post任何请求</h4></blockquote>\n<h3 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><blockquote>\n<h4 id=\"浏览器兼容，不兼容IE10以下浏览器\"><a href=\"#浏览器兼容，不兼容IE10以下浏览器\" class=\"headerlink\" title=\"浏览器兼容，不兼容IE10以下浏览器\"></a>浏览器兼容，不兼容IE10以下浏览器</h4></blockquote>\n<h3 id=\"特性-1\"><a href=\"#特性-1\" class=\"headerlink\" title=\"特性\"></a>特性</h3><blockquote>\n<h4 id=\"浏览器新特性\"><a href=\"#浏览器新特性\" class=\"headerlink\" title=\"浏览器新特性\"></a>浏览器新特性</h4></blockquote>\n<h2 id=\"方式三：代理\"><a href=\"#方式三：代理\" class=\"headerlink\" title=\"方式三：代理\"></a>方式三：代理</h2><p>一般情况下跨域产生的原因域名端口不一样，因为在开发环境中，前端启动的是自己的服务，后端启动也是自己的服务，而在后面上线了就不存在跨域了，这种情况下我们一般使用代理的形式（后端不需要做任何调整，只需要前端添加反向代理即可）</p>\n<p>客户端发出去请求 – 本地服务器拦截 – 发现是api开头 – 本地服务发出请求请求(localhost:3000) – 跨域服务器返回数据 – 本地服务器接收数据 – 将数据返回给客户端</p>\n<h2 id=\"方式四：window-name-iframe\"><a href=\"#方式四：window-name-iframe\" class=\"headerlink\" title=\"方式四：window.name+iframe\"></a>方式四：window.name+iframe</h2><h3 id=\"window-name通过在iframe（一般动态创建i）中加载跨域HTML文件来起作用。然后，HTML文件将传递给请求者的字符串内容赋值给window-name。然后，请求者可以检索window-name值作为响应。\"><a href=\"#window-name通过在iframe（一般动态创建i）中加载跨域HTML文件来起作用。然后，HTML文件将传递给请求者的字符串内容赋值给window-name。然后，请求者可以检索window-name值作为响应。\" class=\"headerlink\" title=\"window.name通过在iframe（一般动态创建i）中加载跨域HTML文件来起作用。然后，HTML文件将传递给请求者的字符串内容赋值给window.name。然后，请求者可以检索window.name值作为响应。\"></a>window.name通过在iframe（一般动态创建i）中加载跨域HTML文件来起作用。然后，HTML文件将传递给请求者的字符串内容赋值给window.name。然后，请求者可以检索window.name值作为响应。</h3><ul>\n<li>iframe标签的跨域能力；</li>\n<li>window.name属性值在文档刷新后依旧存在的能力（且最大允许2M左右）。</li>\n</ul>\n<blockquote>\n<h4 id=\"每个iframe都有包裹它的window，而这个window是top-window的子窗口。contentWindow属性返回iframe元素的Window对象。你可以使用这个Window对象来访问iframe的文档及其内部DOM。\"><a href=\"#每个iframe都有包裹它的window，而这个window是top-window的子窗口。contentWindow属性返回iframe元素的Window对象。你可以使用这个Window对象来访问iframe的文档及其内部DOM。\" class=\"headerlink\" title=\"每个iframe都有包裹它的window，而这个window是top window的子窗口。contentWindow属性返回iframe元素的Window对象。你可以使用这个Window对象来访问iframe的文档及其内部DOM。\"></a>每个iframe都有包裹它的window，而这个window是top window的子窗口。contentWindow属性返回iframe元素的Window对象。你可以使用这个Window对象来访问iframe的文档及其内部DOM。</h4></blockquote>\n<pre><code>&lt;!-- \n 下述用端口 \n 10000表示：domainA\n 10001表示：domainB\n--&gt;\n\n&lt;!-- localhost:10000 --&gt;\n&lt;script&gt;\n  var iframe = document.createElement(&#39;iframe&#39;);\n  iframe.style.display = &#39;none&#39;; // 隐藏\n\n  var state = 0; // 防止页面无限刷新\n  iframe.onload = function() {\n      if(state === 1) {\n          console.log(JSON.parse(iframe.contentWindow.name));\n          // 清除创建的iframe\n          iframe.contentWindow.document.write(&#39;&#39;);\n          iframe.contentWindow.close();\n          document.body.removeChild(iframe);\n      } else if(state === 0) {\n          state = 1;\n          // 加载完成，指向当前域，防止错误(proxy.html为空白页面)\n          // Blocked a frame with origin &quot;http://localhost:10000&quot; from accessing a cross-origin frame.\n          iframe.contentWindow.location = &#39;http://localhost:10000/proxy.html&#39;;\n      }\n  };\n\n  iframe.src = &#39;http://localhost:10001&#39;;\n  document.body.appendChild(iframe);\n&lt;/script&gt;\n\n&lt;!-- localhost:10001 --&gt;\n&lt;!DOCTYPE html&gt;\n...\n&lt;script&gt;\n  window.name = JSON.stringify({a: 1, b: 2});\n&lt;/script&gt;\n&lt;/html&gt;\n</code></pre><h3 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h3><blockquote>\n<ol>\n<li><p>直接嵌入其他域（localhots:10001）下的URL会报错，所以需要加载完成替换为当前域的URL(localhots:10000)，proxy.html为空白页面，只为解决该问题； </p>\n</li>\n<li><p>重新设置src（<a href=\"http://localhost:10000/proxy.html）后导致页面不断刷新，所以通过state来控制；\" target=\"_blank\" rel=\"noopener\">http://localhost:10000/proxy.html）后导致页面不断刷新，所以通过state来控制；</a></p>\n</li>\n<li><p>全部获取完结果后，清除该iframe。</p>\n</li>\n</ol>\n</blockquote>\n"},{"title":"vue中使用高德地图定位","date":"2019-02-22T06:27:00.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"## 高德地图API\n\n### javascript API[高德地图官网链接](https://lbs.amap.com/api/javascript-api/guide/services/geolocation)\n\n#### 首先注册成为开发者\n\n> 为项目添加key\n\n### 在vue中使用高德地图定位\n\n> **/index.html**\n\n\t<script type=\"text/javascript\" src=\"https://webapi.amap.com/maps?v=1.4.12&key=添加你自己的key\"></script>\n\n> **/build/webpack.base.conf.js**\n\n\tmodule.exports = {\n\t\texternals: {\n\t\t    AMap: 'AMap'\n\t\t  },\n\t}\n\n\n### 以模块的形式引入\n\n> **/map.js**\n\n\timport AMap from 'AMap'\n\t/* eslint-disable */\n\tlet maps\n\tconst map = { // 定位\n\t  geolocation () {\n\t    return new Promise((resolve, reject) => {\n\t      AMap.plugin('AMap.Geolocation', () => {\n\t        var geolocation = new AMap.Geolocation({\n\t          // 是否使用高精度定位，默认：true\n\t          enableHighAccuracy: true,\n\t          // 设置定位超时时间，默认：无穷大\n\t          timeout: 10000\n\t        })\n\t        geolocation.getCurrentPosition() // 执行定位\n\t        AMap.event.addListener(geolocation, 'complete', (data) => {\n\t          resolve(data)\n\t        }) // 成功的回调\n\t        AMap.event.addListener(geolocation, 'error', (data) => {\n\t          reject(data)\n\t        }) // 失败的回调\n\t      })\n\t    })\n\t  },\n\t  citySearch () { // 当前所在城市信息\n\t    return new Promise((resolve, reject) => {\n\t      AMap.plugin('AMap.CitySearch', () => {\n\t        const citySearch = new AMap.CitySearch()\n\t        citySearch.getLocalCity(function (status, result) {\n\t          if (status === 'complete' && result.info === 'OK') {\n\t            // 查询成功，result即为当前所在城市信息\n\t            resolve(result)\n\t          }\n\t        })\n\t      })\n\t    })\n\t  },\n\t  search (key, city) { // 根据城市搜索附近地区\n\t    return new Promise((resolve, reject) => {\n\t      AMap.plugin(['AMap.PlaceSearch'], () => {\n\t        var placeSearch = new AMap.PlaceSearch({\n\t          city: city\n\t        })\n\t        placeSearch.search(key, (status, result) => {\n\t          if (result.poiList) {\n\t            resolve(result.poiList.pois)\n\t          }\n\t        })\n\t      })\n\t    })\n\t  },\n\t  renderMap (el) { // 渲染一张地图\n\t    console.log(el)\n\t    maps = new AMap.Map(el, {\n\t      resizeEnable: true, // 是否监控地图容器尺寸变化\n\t      zoom: 17,\n\t      center: [116.408075, 39.950187],\n\t      features: ['bg', 'road', 'building', 'point']\n\t    })\n\t    // AMap.plugin(['AMap.ToolBar', 'AMap.Scale'], function () {\n\t    //   maps.addControl(new AMap.ToolBar())\n\t    //   maps.addControl(new AMap.Scale())\n\t    // })\n\t  }\n\t}\n\t\n\texport default map\n\n\n> **使用的时候直接调用即可**\n\n\n\n\n","source":"_posts/gao de map.md","raw":"---\ntitle: vue中使用高德地图定位\ndate: '2/22/2019 2:27:00 PM '\ntag: ['js', 'vue', '定位']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n## 高德地图API\n\n### javascript API[高德地图官网链接](https://lbs.amap.com/api/javascript-api/guide/services/geolocation)\n\n#### 首先注册成为开发者\n\n> 为项目添加key\n\n### 在vue中使用高德地图定位\n\n> **/index.html**\n\n\t<script type=\"text/javascript\" src=\"https://webapi.amap.com/maps?v=1.4.12&key=添加你自己的key\"></script>\n\n> **/build/webpack.base.conf.js**\n\n\tmodule.exports = {\n\t\texternals: {\n\t\t    AMap: 'AMap'\n\t\t  },\n\t}\n\n\n### 以模块的形式引入\n\n> **/map.js**\n\n\timport AMap from 'AMap'\n\t/* eslint-disable */\n\tlet maps\n\tconst map = { // 定位\n\t  geolocation () {\n\t    return new Promise((resolve, reject) => {\n\t      AMap.plugin('AMap.Geolocation', () => {\n\t        var geolocation = new AMap.Geolocation({\n\t          // 是否使用高精度定位，默认：true\n\t          enableHighAccuracy: true,\n\t          // 设置定位超时时间，默认：无穷大\n\t          timeout: 10000\n\t        })\n\t        geolocation.getCurrentPosition() // 执行定位\n\t        AMap.event.addListener(geolocation, 'complete', (data) => {\n\t          resolve(data)\n\t        }) // 成功的回调\n\t        AMap.event.addListener(geolocation, 'error', (data) => {\n\t          reject(data)\n\t        }) // 失败的回调\n\t      })\n\t    })\n\t  },\n\t  citySearch () { // 当前所在城市信息\n\t    return new Promise((resolve, reject) => {\n\t      AMap.plugin('AMap.CitySearch', () => {\n\t        const citySearch = new AMap.CitySearch()\n\t        citySearch.getLocalCity(function (status, result) {\n\t          if (status === 'complete' && result.info === 'OK') {\n\t            // 查询成功，result即为当前所在城市信息\n\t            resolve(result)\n\t          }\n\t        })\n\t      })\n\t    })\n\t  },\n\t  search (key, city) { // 根据城市搜索附近地区\n\t    return new Promise((resolve, reject) => {\n\t      AMap.plugin(['AMap.PlaceSearch'], () => {\n\t        var placeSearch = new AMap.PlaceSearch({\n\t          city: city\n\t        })\n\t        placeSearch.search(key, (status, result) => {\n\t          if (result.poiList) {\n\t            resolve(result.poiList.pois)\n\t          }\n\t        })\n\t      })\n\t    })\n\t  },\n\t  renderMap (el) { // 渲染一张地图\n\t    console.log(el)\n\t    maps = new AMap.Map(el, {\n\t      resizeEnable: true, // 是否监控地图容器尺寸变化\n\t      zoom: 17,\n\t      center: [116.408075, 39.950187],\n\t      features: ['bg', 'road', 'building', 'point']\n\t    })\n\t    // AMap.plugin(['AMap.ToolBar', 'AMap.Scale'], function () {\n\t    //   maps.addControl(new AMap.ToolBar())\n\t    //   maps.addControl(new AMap.Scale())\n\t    // })\n\t  }\n\t}\n\t\n\texport default map\n\n\n> **使用的时候直接调用即可**\n\n\n\n\n","slug":"gao de map","published":1,"updated":"2019-02-24T13:00:05.924Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam6t000tn4wdqprras0v","content":"<h2 id=\"高德地图API\"><a href=\"#高德地图API\" class=\"headerlink\" title=\"高德地图API\"></a>高德地图API</h2><h3 id=\"javascript-API高德地图官网链接\"><a href=\"#javascript-API高德地图官网链接\" class=\"headerlink\" title=\"javascript API高德地图官网链接\"></a>javascript API<a href=\"https://lbs.amap.com/api/javascript-api/guide/services/geolocation\" target=\"_blank\" rel=\"noopener\">高德地图官网链接</a></h3><h4 id=\"首先注册成为开发者\"><a href=\"#首先注册成为开发者\" class=\"headerlink\" title=\"首先注册成为开发者\"></a>首先注册成为开发者</h4><blockquote>\n<p>为项目添加key</p>\n</blockquote>\n<h3 id=\"在vue中使用高德地图定位\"><a href=\"#在vue中使用高德地图定位\" class=\"headerlink\" title=\"在vue中使用高德地图定位\"></a>在vue中使用高德地图定位</h3><blockquote>\n<p><strong>/index.html</strong></p>\n</blockquote>\n<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;https://webapi.amap.com/maps?v=1.4.12&amp;key=添加你自己的key&quot;&gt;&lt;/script&gt;\n</code></pre><blockquote>\n<p><strong>/build/webpack.base.conf.js</strong></p>\n</blockquote>\n<pre><code>module.exports = {\n    externals: {\n        AMap: &#39;AMap&#39;\n      },\n}\n</code></pre><h3 id=\"以模块的形式引入\"><a href=\"#以模块的形式引入\" class=\"headerlink\" title=\"以模块的形式引入\"></a>以模块的形式引入</h3><blockquote>\n<p><strong>/map.js</strong></p>\n</blockquote>\n<pre><code>import AMap from &#39;AMap&#39;\n/* eslint-disable */\nlet maps\nconst map = { // 定位\n  geolocation () {\n    return new Promise((resolve, reject) =&gt; {\n      AMap.plugin(&#39;AMap.Geolocation&#39;, () =&gt; {\n        var geolocation = new AMap.Geolocation({\n          // 是否使用高精度定位，默认：true\n          enableHighAccuracy: true,\n          // 设置定位超时时间，默认：无穷大\n          timeout: 10000\n        })\n        geolocation.getCurrentPosition() // 执行定位\n        AMap.event.addListener(geolocation, &#39;complete&#39;, (data) =&gt; {\n          resolve(data)\n        }) // 成功的回调\n        AMap.event.addListener(geolocation, &#39;error&#39;, (data) =&gt; {\n          reject(data)\n        }) // 失败的回调\n      })\n    })\n  },\n  citySearch () { // 当前所在城市信息\n    return new Promise((resolve, reject) =&gt; {\n      AMap.plugin(&#39;AMap.CitySearch&#39;, () =&gt; {\n        const citySearch = new AMap.CitySearch()\n        citySearch.getLocalCity(function (status, result) {\n          if (status === &#39;complete&#39; &amp;&amp; result.info === &#39;OK&#39;) {\n            // 查询成功，result即为当前所在城市信息\n            resolve(result)\n          }\n        })\n      })\n    })\n  },\n  search (key, city) { // 根据城市搜索附近地区\n    return new Promise((resolve, reject) =&gt; {\n      AMap.plugin([&#39;AMap.PlaceSearch&#39;], () =&gt; {\n        var placeSearch = new AMap.PlaceSearch({\n          city: city\n        })\n        placeSearch.search(key, (status, result) =&gt; {\n          if (result.poiList) {\n            resolve(result.poiList.pois)\n          }\n        })\n      })\n    })\n  },\n  renderMap (el) { // 渲染一张地图\n    console.log(el)\n    maps = new AMap.Map(el, {\n      resizeEnable: true, // 是否监控地图容器尺寸变化\n      zoom: 17,\n      center: [116.408075, 39.950187],\n      features: [&#39;bg&#39;, &#39;road&#39;, &#39;building&#39;, &#39;point&#39;]\n    })\n    // AMap.plugin([&#39;AMap.ToolBar&#39;, &#39;AMap.Scale&#39;], function () {\n    //   maps.addControl(new AMap.ToolBar())\n    //   maps.addControl(new AMap.Scale())\n    // })\n  }\n}\n\nexport default map\n</code></pre><blockquote>\n<p><strong>使用的时候直接调用即可</strong></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"高德地图API\"><a href=\"#高德地图API\" class=\"headerlink\" title=\"高德地图API\"></a>高德地图API</h2><h3 id=\"javascript-API高德地图官网链接\"><a href=\"#javascript-API高德地图官网链接\" class=\"headerlink\" title=\"javascript API高德地图官网链接\"></a>javascript API<a href=\"https://lbs.amap.com/api/javascript-api/guide/services/geolocation\" target=\"_blank\" rel=\"noopener\">高德地图官网链接</a></h3><h4 id=\"首先注册成为开发者\"><a href=\"#首先注册成为开发者\" class=\"headerlink\" title=\"首先注册成为开发者\"></a>首先注册成为开发者</h4><blockquote>\n<p>为项目添加key</p>\n</blockquote>\n<h3 id=\"在vue中使用高德地图定位\"><a href=\"#在vue中使用高德地图定位\" class=\"headerlink\" title=\"在vue中使用高德地图定位\"></a>在vue中使用高德地图定位</h3><blockquote>\n<p><strong>/index.html</strong></p>\n</blockquote>\n<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;https://webapi.amap.com/maps?v=1.4.12&amp;key=添加你自己的key&quot;&gt;&lt;/script&gt;\n</code></pre><blockquote>\n<p><strong>/build/webpack.base.conf.js</strong></p>\n</blockquote>\n<pre><code>module.exports = {\n    externals: {\n        AMap: &#39;AMap&#39;\n      },\n}\n</code></pre><h3 id=\"以模块的形式引入\"><a href=\"#以模块的形式引入\" class=\"headerlink\" title=\"以模块的形式引入\"></a>以模块的形式引入</h3><blockquote>\n<p><strong>/map.js</strong></p>\n</blockquote>\n<pre><code>import AMap from &#39;AMap&#39;\n/* eslint-disable */\nlet maps\nconst map = { // 定位\n  geolocation () {\n    return new Promise((resolve, reject) =&gt; {\n      AMap.plugin(&#39;AMap.Geolocation&#39;, () =&gt; {\n        var geolocation = new AMap.Geolocation({\n          // 是否使用高精度定位，默认：true\n          enableHighAccuracy: true,\n          // 设置定位超时时间，默认：无穷大\n          timeout: 10000\n        })\n        geolocation.getCurrentPosition() // 执行定位\n        AMap.event.addListener(geolocation, &#39;complete&#39;, (data) =&gt; {\n          resolve(data)\n        }) // 成功的回调\n        AMap.event.addListener(geolocation, &#39;error&#39;, (data) =&gt; {\n          reject(data)\n        }) // 失败的回调\n      })\n    })\n  },\n  citySearch () { // 当前所在城市信息\n    return new Promise((resolve, reject) =&gt; {\n      AMap.plugin(&#39;AMap.CitySearch&#39;, () =&gt; {\n        const citySearch = new AMap.CitySearch()\n        citySearch.getLocalCity(function (status, result) {\n          if (status === &#39;complete&#39; &amp;&amp; result.info === &#39;OK&#39;) {\n            // 查询成功，result即为当前所在城市信息\n            resolve(result)\n          }\n        })\n      })\n    })\n  },\n  search (key, city) { // 根据城市搜索附近地区\n    return new Promise((resolve, reject) =&gt; {\n      AMap.plugin([&#39;AMap.PlaceSearch&#39;], () =&gt; {\n        var placeSearch = new AMap.PlaceSearch({\n          city: city\n        })\n        placeSearch.search(key, (status, result) =&gt; {\n          if (result.poiList) {\n            resolve(result.poiList.pois)\n          }\n        })\n      })\n    })\n  },\n  renderMap (el) { // 渲染一张地图\n    console.log(el)\n    maps = new AMap.Map(el, {\n      resizeEnable: true, // 是否监控地图容器尺寸变化\n      zoom: 17,\n      center: [116.408075, 39.950187],\n      features: [&#39;bg&#39;, &#39;road&#39;, &#39;building&#39;, &#39;point&#39;]\n    })\n    // AMap.plugin([&#39;AMap.ToolBar&#39;, &#39;AMap.Scale&#39;], function () {\n    //   maps.addControl(new AMap.ToolBar())\n    //   maps.addControl(new AMap.Scale())\n    // })\n  }\n}\n\nexport default map\n</code></pre><blockquote>\n<p><strong>使用的时候直接调用即可</strong></p>\n</blockquote>\n"},{"title":"fetch封装","date":"2019-03-14T01:29:29.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"# fetch\n\n## fetch封装\n\n----------\n\n\n> - 解决了fetch的get。post的传递参数不同\n> - 添加了fetch默认不携带cookie的配置\n> - 解决了fetch不能处理错误状态的问题\n> - 解决了fetch，response控制返回值json\n> - 添加公共参数token\n> - 统一错误出路\n> - 是否允许跨域\n> \n\n----------\n\n\tconst objParseQuery = (data) => {\n\t  let paramsArray = [];\n\t\tlet parameter = ''\n\t\t//拼接参数\n\t\tObject.keys(data).forEach(key => {\n\t\t\t\tif (data[key]) {\n\t\t\t\t\t\tparamsArray.push(key + '=' + data[key])\n\t\t\t\t}\n\t\t})\n\t\tif (parameter.search(/\\?/) === -1) {\n\t\t\t\tparameter += '?' + paramsArray.join('&')\n\t\t} else {\n\t\t\t\tparameter += '&' + paramsArray.join('&')\n\t  }\n\t  return parameter\n\t}\n\tlet fetchs = {\n\t  /**\n\t    * 基于 fetch 封装的 GET请求\n\t    * @param url\n\t    * @param params {}\n\t    * @param headers\n\t    * @returns {Promise}\n\t    */\n\t   get: (url, params) => {\n\t     \n\t     var fetchConfig = {\n\t         method: 'get',\n\t         headers: {\n\t           authorization: window.sessionStorage.getItem('token') ? window.sessionStorage.getItem('token') : null,\n\t           'Content-Type': 'application/json; charset=utf-8'\n\t         },\n\t         credentials: \"include\",\n\t         mode: 'cors',\n\t     }\n\t     if(params){\n\t      url += objParseQuery(params.data);\n\t     }\n\t     console.log(url)\n\t     return fetch(url, fetchConfig).then(response => {\n\t       return response.json().then((res) => {\n\t         console.log(res)\n\t         if (response.ok && res.code === 1) {\n\t           return Promise.resolve(res)\n\t         } else {\n\t           return Promise.reject(res)\n\t         }\n\t       })\n\t     })\n\t \t},\n\t\t post: (url, options) => {\n\t\t   return fetch(url, {\n\t\t     method: 'post',\n\t\t     headers: {\n\t\t       authorization: window.sessionStorage.getItem('token') ? window.sessionStorage.getItem('token') : null,\n\t\t       'Content-Type': 'application/json; charset=utf-8'\n\t\t     },\n\t\t     credentials: \"include\",\n\t\t     mode: 'cors',\n\t\t     body: JSON.stringify(options)\n\t\t   }).then(response => {\n\t\t     return response.json().then((res) => {\n\t\t       if (response.ok && res.code === 1) {\n\t\t         console.log(window.sessionStorage.getItem('token'))\n\t\t         return Promise.resolve(res)\n\t\t       } else {\n\t\t         return Promise.reject(res)\n\t\t       }\n\t\t     })\n\t\t   })\n\t\t },\n\t\t put: (url, options) => {\n\t\t  return fetch(url, {\n\t\t    method: 'post',\n\t\t    headers: {\n\t\t      authorization: window.sessionStorage.getItem('token') ? window.sessionStorage.getItem('token') : null,\n\t\t      'Content-Type': 'application/json; charset=utf-8'\n\t\t    },\n\t\t    credentials: \"include\",\n\t\t    mode: 'cors',\n\t\t    body: JSON.stringify(options)\n\t\t  }).then(response => {\n\t\t    return response.json().then((res) => {\n\t\t      if (response.ok && res.code === 1) {\n\t\t        console.log(window.sessionStorage.getItem('token'))\n\t\t        return Promise.resolve(res)\n\t\t      } else {\n\t\t        return Promise.reject(res)\n\t\t      }\n\t\t    })\n\t\t  })\n\t\t}\n\t}\n\t\n\texport default fetchs\n\t\n\t","source":"_posts/fetch.md","raw":"---\ntitle: fetch封装\ndate: '3/14/2019 9:29:29 AM '\ntag: ['js', 'fetch']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n# fetch\n\n## fetch封装\n\n----------\n\n\n> - 解决了fetch的get。post的传递参数不同\n> - 添加了fetch默认不携带cookie的配置\n> - 解决了fetch不能处理错误状态的问题\n> - 解决了fetch，response控制返回值json\n> - 添加公共参数token\n> - 统一错误出路\n> - 是否允许跨域\n> \n\n----------\n\n\tconst objParseQuery = (data) => {\n\t  let paramsArray = [];\n\t\tlet parameter = ''\n\t\t//拼接参数\n\t\tObject.keys(data).forEach(key => {\n\t\t\t\tif (data[key]) {\n\t\t\t\t\t\tparamsArray.push(key + '=' + data[key])\n\t\t\t\t}\n\t\t})\n\t\tif (parameter.search(/\\?/) === -1) {\n\t\t\t\tparameter += '?' + paramsArray.join('&')\n\t\t} else {\n\t\t\t\tparameter += '&' + paramsArray.join('&')\n\t  }\n\t  return parameter\n\t}\n\tlet fetchs = {\n\t  /**\n\t    * 基于 fetch 封装的 GET请求\n\t    * @param url\n\t    * @param params {}\n\t    * @param headers\n\t    * @returns {Promise}\n\t    */\n\t   get: (url, params) => {\n\t     \n\t     var fetchConfig = {\n\t         method: 'get',\n\t         headers: {\n\t           authorization: window.sessionStorage.getItem('token') ? window.sessionStorage.getItem('token') : null,\n\t           'Content-Type': 'application/json; charset=utf-8'\n\t         },\n\t         credentials: \"include\",\n\t         mode: 'cors',\n\t     }\n\t     if(params){\n\t      url += objParseQuery(params.data);\n\t     }\n\t     console.log(url)\n\t     return fetch(url, fetchConfig).then(response => {\n\t       return response.json().then((res) => {\n\t         console.log(res)\n\t         if (response.ok && res.code === 1) {\n\t           return Promise.resolve(res)\n\t         } else {\n\t           return Promise.reject(res)\n\t         }\n\t       })\n\t     })\n\t \t},\n\t\t post: (url, options) => {\n\t\t   return fetch(url, {\n\t\t     method: 'post',\n\t\t     headers: {\n\t\t       authorization: window.sessionStorage.getItem('token') ? window.sessionStorage.getItem('token') : null,\n\t\t       'Content-Type': 'application/json; charset=utf-8'\n\t\t     },\n\t\t     credentials: \"include\",\n\t\t     mode: 'cors',\n\t\t     body: JSON.stringify(options)\n\t\t   }).then(response => {\n\t\t     return response.json().then((res) => {\n\t\t       if (response.ok && res.code === 1) {\n\t\t         console.log(window.sessionStorage.getItem('token'))\n\t\t         return Promise.resolve(res)\n\t\t       } else {\n\t\t         return Promise.reject(res)\n\t\t       }\n\t\t     })\n\t\t   })\n\t\t },\n\t\t put: (url, options) => {\n\t\t  return fetch(url, {\n\t\t    method: 'post',\n\t\t    headers: {\n\t\t      authorization: window.sessionStorage.getItem('token') ? window.sessionStorage.getItem('token') : null,\n\t\t      'Content-Type': 'application/json; charset=utf-8'\n\t\t    },\n\t\t    credentials: \"include\",\n\t\t    mode: 'cors',\n\t\t    body: JSON.stringify(options)\n\t\t  }).then(response => {\n\t\t    return response.json().then((res) => {\n\t\t      if (response.ok && res.code === 1) {\n\t\t        console.log(window.sessionStorage.getItem('token'))\n\t\t        return Promise.resolve(res)\n\t\t      } else {\n\t\t        return Promise.reject(res)\n\t\t      }\n\t\t    })\n\t\t  })\n\t\t}\n\t}\n\t\n\texport default fetchs\n\t\n\t","slug":"fetch","published":1,"updated":"2019-03-21T03:11:06.945Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam6u000vn4wdwdqw1fq5","content":"<h1 id=\"fetch\"><a href=\"#fetch\" class=\"headerlink\" title=\"fetch\"></a>fetch</h1><h2 id=\"fetch封装\"><a href=\"#fetch封装\" class=\"headerlink\" title=\"fetch封装\"></a>fetch封装</h2><hr>\n<blockquote>\n<ul>\n<li>解决了fetch的get。post的传递参数不同</li>\n<li>添加了fetch默认不携带cookie的配置</li>\n<li>解决了fetch不能处理错误状态的问题</li>\n<li>解决了fetch，response控制返回值json</li>\n<li>添加公共参数token</li>\n<li>统一错误出路</li>\n<li>是否允许跨域</li>\n</ul>\n</blockquote>\n<hr>\n<pre><code>const objParseQuery = (data) =&gt; {\n  let paramsArray = [];\n    let parameter = &#39;&#39;\n    //拼接参数\n    Object.keys(data).forEach(key =&gt; {\n            if (data[key]) {\n                    paramsArray.push(key + &#39;=&#39; + data[key])\n            }\n    })\n    if (parameter.search(/\\?/) === -1) {\n            parameter += &#39;?&#39; + paramsArray.join(&#39;&amp;&#39;)\n    } else {\n            parameter += &#39;&amp;&#39; + paramsArray.join(&#39;&amp;&#39;)\n  }\n  return parameter\n}\nlet fetchs = {\n  /**\n    * 基于 fetch 封装的 GET请求\n    * @param url\n    * @param params {}\n    * @param headers\n    * @returns {Promise}\n    */\n   get: (url, params) =&gt; {\n\n     var fetchConfig = {\n         method: &#39;get&#39;,\n         headers: {\n           authorization: window.sessionStorage.getItem(&#39;token&#39;) ? window.sessionStorage.getItem(&#39;token&#39;) : null,\n           &#39;Content-Type&#39;: &#39;application/json; charset=utf-8&#39;\n         },\n         credentials: &quot;include&quot;,\n         mode: &#39;cors&#39;,\n     }\n     if(params){\n      url += objParseQuery(params.data);\n     }\n     console.log(url)\n     return fetch(url, fetchConfig).then(response =&gt; {\n       return response.json().then((res) =&gt; {\n         console.log(res)\n         if (response.ok &amp;&amp; res.code === 1) {\n           return Promise.resolve(res)\n         } else {\n           return Promise.reject(res)\n         }\n       })\n     })\n     },\n     post: (url, options) =&gt; {\n       return fetch(url, {\n         method: &#39;post&#39;,\n         headers: {\n           authorization: window.sessionStorage.getItem(&#39;token&#39;) ? window.sessionStorage.getItem(&#39;token&#39;) : null,\n           &#39;Content-Type&#39;: &#39;application/json; charset=utf-8&#39;\n         },\n         credentials: &quot;include&quot;,\n         mode: &#39;cors&#39;,\n         body: JSON.stringify(options)\n       }).then(response =&gt; {\n         return response.json().then((res) =&gt; {\n           if (response.ok &amp;&amp; res.code === 1) {\n             console.log(window.sessionStorage.getItem(&#39;token&#39;))\n             return Promise.resolve(res)\n           } else {\n             return Promise.reject(res)\n           }\n         })\n       })\n     },\n     put: (url, options) =&gt; {\n      return fetch(url, {\n        method: &#39;post&#39;,\n        headers: {\n          authorization: window.sessionStorage.getItem(&#39;token&#39;) ? window.sessionStorage.getItem(&#39;token&#39;) : null,\n          &#39;Content-Type&#39;: &#39;application/json; charset=utf-8&#39;\n        },\n        credentials: &quot;include&quot;,\n        mode: &#39;cors&#39;,\n        body: JSON.stringify(options)\n      }).then(response =&gt; {\n        return response.json().then((res) =&gt; {\n          if (response.ok &amp;&amp; res.code === 1) {\n            console.log(window.sessionStorage.getItem(&#39;token&#39;))\n            return Promise.resolve(res)\n          } else {\n            return Promise.reject(res)\n          }\n        })\n      })\n    }\n}\n\nexport default fetchs\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"fetch\"><a href=\"#fetch\" class=\"headerlink\" title=\"fetch\"></a>fetch</h1><h2 id=\"fetch封装\"><a href=\"#fetch封装\" class=\"headerlink\" title=\"fetch封装\"></a>fetch封装</h2><hr>\n<blockquote>\n<ul>\n<li>解决了fetch的get。post的传递参数不同</li>\n<li>添加了fetch默认不携带cookie的配置</li>\n<li>解决了fetch不能处理错误状态的问题</li>\n<li>解决了fetch，response控制返回值json</li>\n<li>添加公共参数token</li>\n<li>统一错误出路</li>\n<li>是否允许跨域</li>\n</ul>\n</blockquote>\n<hr>\n<pre><code>const objParseQuery = (data) =&gt; {\n  let paramsArray = [];\n    let parameter = &#39;&#39;\n    //拼接参数\n    Object.keys(data).forEach(key =&gt; {\n            if (data[key]) {\n                    paramsArray.push(key + &#39;=&#39; + data[key])\n            }\n    })\n    if (parameter.search(/\\?/) === -1) {\n            parameter += &#39;?&#39; + paramsArray.join(&#39;&amp;&#39;)\n    } else {\n            parameter += &#39;&amp;&#39; + paramsArray.join(&#39;&amp;&#39;)\n  }\n  return parameter\n}\nlet fetchs = {\n  /**\n    * 基于 fetch 封装的 GET请求\n    * @param url\n    * @param params {}\n    * @param headers\n    * @returns {Promise}\n    */\n   get: (url, params) =&gt; {\n\n     var fetchConfig = {\n         method: &#39;get&#39;,\n         headers: {\n           authorization: window.sessionStorage.getItem(&#39;token&#39;) ? window.sessionStorage.getItem(&#39;token&#39;) : null,\n           &#39;Content-Type&#39;: &#39;application/json; charset=utf-8&#39;\n         },\n         credentials: &quot;include&quot;,\n         mode: &#39;cors&#39;,\n     }\n     if(params){\n      url += objParseQuery(params.data);\n     }\n     console.log(url)\n     return fetch(url, fetchConfig).then(response =&gt; {\n       return response.json().then((res) =&gt; {\n         console.log(res)\n         if (response.ok &amp;&amp; res.code === 1) {\n           return Promise.resolve(res)\n         } else {\n           return Promise.reject(res)\n         }\n       })\n     })\n     },\n     post: (url, options) =&gt; {\n       return fetch(url, {\n         method: &#39;post&#39;,\n         headers: {\n           authorization: window.sessionStorage.getItem(&#39;token&#39;) ? window.sessionStorage.getItem(&#39;token&#39;) : null,\n           &#39;Content-Type&#39;: &#39;application/json; charset=utf-8&#39;\n         },\n         credentials: &quot;include&quot;,\n         mode: &#39;cors&#39;,\n         body: JSON.stringify(options)\n       }).then(response =&gt; {\n         return response.json().then((res) =&gt; {\n           if (response.ok &amp;&amp; res.code === 1) {\n             console.log(window.sessionStorage.getItem(&#39;token&#39;))\n             return Promise.resolve(res)\n           } else {\n             return Promise.reject(res)\n           }\n         })\n       })\n     },\n     put: (url, options) =&gt; {\n      return fetch(url, {\n        method: &#39;post&#39;,\n        headers: {\n          authorization: window.sessionStorage.getItem(&#39;token&#39;) ? window.sessionStorage.getItem(&#39;token&#39;) : null,\n          &#39;Content-Type&#39;: &#39;application/json; charset=utf-8&#39;\n        },\n        credentials: &quot;include&quot;,\n        mode: &#39;cors&#39;,\n        body: JSON.stringify(options)\n      }).then(response =&gt; {\n        return response.json().then((res) =&gt; {\n          if (response.ok &amp;&amp; res.code === 1) {\n            console.log(window.sessionStorage.getItem(&#39;token&#39;))\n            return Promise.resolve(res)\n          } else {\n            return Promise.reject(res)\n          }\n        })\n      })\n    }\n}\n\nexport default fetchs\n</code></pre>"},{"title":"代码整洁之道：程序员的职业素养","date":"2019-01-25T08:36:42.000Z","top":100000,"meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"----------\n# 代码整洁之道：程序员的职业素养\n\n--------\n\n> 我们并非是因为喜欢和其他人在一起工作才选择做程序员的。我们都认为人际关系难以应付而且毫无规律。编程用的机器则整洁，行为也可预见。如果可以一个人待在房间里数个小时沉浸在一些真正有趣的问题上，那将会是最开心的时光。\n\n--------\n\n> **以下全部内容均为本人2019年读书过程中所喜欢或者有感触的片段的摘录，来自于不同的书目，每本书标注了书名，书籍排序仅仅是阅读顺序（倒时间顺序），版权归原作者所有，这里仅作摘录整理。**\n\n# 阿加莎·克里斯蒂的真实人生\n\n--------\n\n> 你无法创作命运，命运会不请自来，就是这么回事。\n  人人都做梦，但他们的梦不一样。\n  那些夜里在脏兮兮的脑袋瓜里做梦的人，\n  白天一觉醒来发现不过是虚幻一场；\n  要小心那些在白天做梦的人，\n  因为他们会睁大眼睛做梦，\n  用行动让梦想变成现实。\n  天真是一种罪过，冷漠是一种爱。律师以为自己操纵着游戏，但不过是他想加害的人手中的玩偶。\n\n--------\n\n# 牧羊少年奇幻之旅\n\n--------\n\n> 不管是牧羊人、海员，还是推销员，总会有一个地方令他们魂牵梦萦，那里会有一个人让他们忘记自由自在周游世界的快乐。\n  当总是面对同样的面孔，像在神学院里那样，就会渐渐让那些人成为生活的一部分。而由于他们是你生活的一部分，当然就想改变你的生活。如果你不像他们所期望的那样，他们就会不高兴。因为，对于该怎样生活，所有人都有固定的观念。但是他们对于自己该怎样生活却一头雾水，就像那个给人解梦、却不会把梦变成现实的老妇人。\n  男孩心想，人总会说一些刁钻古怪的事情。有的时候，最好与羊群为伴，羊群不声不响，只顾吃草和水晶。与书为伴也行，书总是在人们最想听故事的时候，告诉你一些意想不到的事情。但是，当人与人交谈的时候，有些人说的话会让我们无所适从，不知该怎样把谈话继续下去。\n「天命就是你一直期望去做的事情。人一旦步入青年时期，就知道什么是自己的天命了。在人生的这个阶段，一切都那么明朗，没有做不到的事情。人们敢于梦想，期待完成他们一生中喜欢做的一切事情。但是，随着时光的流逝，一股神秘的力量开始企图证明，根本不可能实现天命。」\n实际上，每天都一成不变，是因为人们已经失去了对美好事物的敏锐感觉。\n我和别人没什么两样：总是以理想的眼光看待世界，以为事情会按理想的方式发展，而不会用现实的眼光看待世界，看不到事情真相。\n「因为麦加是支撑我活下去的希望，使我能够忍受平庸的岁月，忍受橱柜里那些不会说话的水晶，忍受那间糟糕透顶的餐厅里的午饭和晚饭。我害怕实现我的梦想，实现之后，我就没有活下去的动力了。」\n「你的梦想是羊群和金字塔。你与我不同，因为你希望实现你的梦想，而我只是想保有去麦加的梦想。我曾无数次地想象过，如何穿过沙漠，到达安放着圣石的广场，在触摸圣石之前，围着它绕行七圈。我曾想象过有些人站在我身旁，有些人站在我前面，还有我们的谈话和共同的祈祷。可是，我担心会大失所望，所以我宁愿只保留一个梦想。」\n「你一度成为我的福音。而今天我明白了一个道理，任何不被接纳的福音，都会变成诅咒。我对生活没有更多的要求。而你正迫使我盯着从未见过的财富和前景。现在，我知道了这些财富和前景，也知道了我完全有可能拥有它们。可是我的感觉却比以前糟糕了。因为我知道我自己可以拥有这一切，却不愿拥有它们。」\n别的事情不好说，但在这件事上，男孩坚信不疑，尽管他的父母以及先辈都说过，必须在恋爱、订婚、相互了解和有了钱之后才可以结婚。说这话的人大概从来不了解宇宙的语言，因为如果掌握了这种语言，很容易就能理解，世上总有人在等待着另外一个人，无论是在大沙漠还是在大城市。当这两个人最终相遇，四目相对的时候，过去的一切和将来的一切全都变得无足轻重了，只有眼前的这一刻最重要。\n因为生活永远是，也仅仅是我们现在经历的这一刻。\n这正是需要爱发挥力量的地方，因为当我们有爱的时候，总是希望自己变得更好。\n\n--------\n\n# 且听风吟\n\n--------\n\n> 说到底，写文章并非自我诊治的手段，充其量不过是自我疗养的一种小小的尝试。\n问题是，直言不讳是件极为困难的事。甚至越是想直言不讳，直率的言语越是遁入黑暗的深处。\n死去的祖母常说「心情抑郁的人只能做抑郁的梦，要是更加抑郁的，连梦都不做的。」\n如果你志在追求艺术追求文学，那么去读一读希腊人写的东西好了。因为要诞生真正的艺术，奴隶制度是必不可少的。而古希腊人便是这样：奴隶们耕种、烧饭、划船，而市民们则在地中海的阳光下陶醉于吟诗作赋，埋头于数学解析。所谓艺术便是这么一种玩意儿。\n至于半夜三点半在悄无声息的厨房寻找电冰箱里的食品的人，只能写出这等模样的文章。\n而那就是我。\n「我时常想：假如活着不给任何人添麻烦该有多好！你说能做到吗？」\n「怎么说呢，大概因为厌烦了吧。可我也在尽我的努力——就连自己都难以置信。我也在考虑别人，像考虑自己的事一样，也因此挨过警察的揍。但到时候人们终究要各归其位，唯独我无处可归，就像玩『抢椅子』游戏没了椅子。」\n「不过你认真想想看：条件大伙都一样，就像同坐一架出了故障的飞机。诚然，有的运气好些，有的运气差些，有的坚强些有的懦弱些，有的有钱有的没钱。但没有一个家伙怀有超乎常人的自信，大家一个样，拥有什么的家伙生怕一旦失去，一无所有的家伙担心永远一无所有，大家一个样。所以，早些察觉到这一点的人 应该力争使自己多少怀有自信，哪怕装模做样也好，对吧？什么自信之人，那样的人根本没有，有的不过是能够装出自信的人。」\n「把谁都知道的事写成小说，那究竟有何意味可言？」\n我有时说谎。\n最后一次说谎是在去年。\n说谎是非常令人讨厌的勾当。不妨说，说谎与沉默是现代人类中流行的两大罪过。我们实际上经常说谎，也往往沉默不语。\n然而，倘若我们一年四季都喋喋不休，而且喋喋不休的无不真实，那么真实的价值必然荡然无存。\n\n--------\n\n# 超能力侦探事务所\n\n--------\n\n> 和事件无关的人，只要时间够久，或有新的事件发生，就会很快忘记过往的事。\n世界上永远没有「感同身受」这件事，因为没有亲身经历，无法体会到当事人的痛苦。\n\n--------","source":"_posts/index.md","raw":"---\ntitle: 代码整洁之道：程序员的职业素养\ndate: ' 1/25/2019 4:36:42 PM '\ntag: []\ntop: 100000\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n----------\n# 代码整洁之道：程序员的职业素养\n\n--------\n\n> 我们并非是因为喜欢和其他人在一起工作才选择做程序员的。我们都认为人际关系难以应付而且毫无规律。编程用的机器则整洁，行为也可预见。如果可以一个人待在房间里数个小时沉浸在一些真正有趣的问题上，那将会是最开心的时光。\n\n--------\n\n> **以下全部内容均为本人2019年读书过程中所喜欢或者有感触的片段的摘录，来自于不同的书目，每本书标注了书名，书籍排序仅仅是阅读顺序（倒时间顺序），版权归原作者所有，这里仅作摘录整理。**\n\n# 阿加莎·克里斯蒂的真实人生\n\n--------\n\n> 你无法创作命运，命运会不请自来，就是这么回事。\n  人人都做梦，但他们的梦不一样。\n  那些夜里在脏兮兮的脑袋瓜里做梦的人，\n  白天一觉醒来发现不过是虚幻一场；\n  要小心那些在白天做梦的人，\n  因为他们会睁大眼睛做梦，\n  用行动让梦想变成现实。\n  天真是一种罪过，冷漠是一种爱。律师以为自己操纵着游戏，但不过是他想加害的人手中的玩偶。\n\n--------\n\n# 牧羊少年奇幻之旅\n\n--------\n\n> 不管是牧羊人、海员，还是推销员，总会有一个地方令他们魂牵梦萦，那里会有一个人让他们忘记自由自在周游世界的快乐。\n  当总是面对同样的面孔，像在神学院里那样，就会渐渐让那些人成为生活的一部分。而由于他们是你生活的一部分，当然就想改变你的生活。如果你不像他们所期望的那样，他们就会不高兴。因为，对于该怎样生活，所有人都有固定的观念。但是他们对于自己该怎样生活却一头雾水，就像那个给人解梦、却不会把梦变成现实的老妇人。\n  男孩心想，人总会说一些刁钻古怪的事情。有的时候，最好与羊群为伴，羊群不声不响，只顾吃草和水晶。与书为伴也行，书总是在人们最想听故事的时候，告诉你一些意想不到的事情。但是，当人与人交谈的时候，有些人说的话会让我们无所适从，不知该怎样把谈话继续下去。\n「天命就是你一直期望去做的事情。人一旦步入青年时期，就知道什么是自己的天命了。在人生的这个阶段，一切都那么明朗，没有做不到的事情。人们敢于梦想，期待完成他们一生中喜欢做的一切事情。但是，随着时光的流逝，一股神秘的力量开始企图证明，根本不可能实现天命。」\n实际上，每天都一成不变，是因为人们已经失去了对美好事物的敏锐感觉。\n我和别人没什么两样：总是以理想的眼光看待世界，以为事情会按理想的方式发展，而不会用现实的眼光看待世界，看不到事情真相。\n「因为麦加是支撑我活下去的希望，使我能够忍受平庸的岁月，忍受橱柜里那些不会说话的水晶，忍受那间糟糕透顶的餐厅里的午饭和晚饭。我害怕实现我的梦想，实现之后，我就没有活下去的动力了。」\n「你的梦想是羊群和金字塔。你与我不同，因为你希望实现你的梦想，而我只是想保有去麦加的梦想。我曾无数次地想象过，如何穿过沙漠，到达安放着圣石的广场，在触摸圣石之前，围着它绕行七圈。我曾想象过有些人站在我身旁，有些人站在我前面，还有我们的谈话和共同的祈祷。可是，我担心会大失所望，所以我宁愿只保留一个梦想。」\n「你一度成为我的福音。而今天我明白了一个道理，任何不被接纳的福音，都会变成诅咒。我对生活没有更多的要求。而你正迫使我盯着从未见过的财富和前景。现在，我知道了这些财富和前景，也知道了我完全有可能拥有它们。可是我的感觉却比以前糟糕了。因为我知道我自己可以拥有这一切，却不愿拥有它们。」\n别的事情不好说，但在这件事上，男孩坚信不疑，尽管他的父母以及先辈都说过，必须在恋爱、订婚、相互了解和有了钱之后才可以结婚。说这话的人大概从来不了解宇宙的语言，因为如果掌握了这种语言，很容易就能理解，世上总有人在等待着另外一个人，无论是在大沙漠还是在大城市。当这两个人最终相遇，四目相对的时候，过去的一切和将来的一切全都变得无足轻重了，只有眼前的这一刻最重要。\n因为生活永远是，也仅仅是我们现在经历的这一刻。\n这正是需要爱发挥力量的地方，因为当我们有爱的时候，总是希望自己变得更好。\n\n--------\n\n# 且听风吟\n\n--------\n\n> 说到底，写文章并非自我诊治的手段，充其量不过是自我疗养的一种小小的尝试。\n问题是，直言不讳是件极为困难的事。甚至越是想直言不讳，直率的言语越是遁入黑暗的深处。\n死去的祖母常说「心情抑郁的人只能做抑郁的梦，要是更加抑郁的，连梦都不做的。」\n如果你志在追求艺术追求文学，那么去读一读希腊人写的东西好了。因为要诞生真正的艺术，奴隶制度是必不可少的。而古希腊人便是这样：奴隶们耕种、烧饭、划船，而市民们则在地中海的阳光下陶醉于吟诗作赋，埋头于数学解析。所谓艺术便是这么一种玩意儿。\n至于半夜三点半在悄无声息的厨房寻找电冰箱里的食品的人，只能写出这等模样的文章。\n而那就是我。\n「我时常想：假如活着不给任何人添麻烦该有多好！你说能做到吗？」\n「怎么说呢，大概因为厌烦了吧。可我也在尽我的努力——就连自己都难以置信。我也在考虑别人，像考虑自己的事一样，也因此挨过警察的揍。但到时候人们终究要各归其位，唯独我无处可归，就像玩『抢椅子』游戏没了椅子。」\n「不过你认真想想看：条件大伙都一样，就像同坐一架出了故障的飞机。诚然，有的运气好些，有的运气差些，有的坚强些有的懦弱些，有的有钱有的没钱。但没有一个家伙怀有超乎常人的自信，大家一个样，拥有什么的家伙生怕一旦失去，一无所有的家伙担心永远一无所有，大家一个样。所以，早些察觉到这一点的人 应该力争使自己多少怀有自信，哪怕装模做样也好，对吧？什么自信之人，那样的人根本没有，有的不过是能够装出自信的人。」\n「把谁都知道的事写成小说，那究竟有何意味可言？」\n我有时说谎。\n最后一次说谎是在去年。\n说谎是非常令人讨厌的勾当。不妨说，说谎与沉默是现代人类中流行的两大罪过。我们实际上经常说谎，也往往沉默不语。\n然而，倘若我们一年四季都喋喋不休，而且喋喋不休的无不真实，那么真实的价值必然荡然无存。\n\n--------\n\n# 超能力侦探事务所\n\n--------\n\n> 和事件无关的人，只要时间够久，或有新的事件发生，就会很快忘记过往的事。\n世界上永远没有「感同身受」这件事，因为没有亲身经历，无法体会到当事人的痛苦。\n\n--------","slug":"index","published":1,"updated":"2019-01-27T11:30:17.005Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam6v000xn4wdyfgmd8bd","content":"<hr>\n<h1 id=\"代码整洁之道：程序员的职业素养\"><a href=\"#代码整洁之道：程序员的职业素养\" class=\"headerlink\" title=\"代码整洁之道：程序员的职业素养\"></a>代码整洁之道：程序员的职业素养</h1><hr>\n<blockquote>\n<p>我们并非是因为喜欢和其他人在一起工作才选择做程序员的。我们都认为人际关系难以应付而且毫无规律。编程用的机器则整洁，行为也可预见。如果可以一个人待在房间里数个小时沉浸在一些真正有趣的问题上，那将会是最开心的时光。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>以下全部内容均为本人2019年读书过程中所喜欢或者有感触的片段的摘录，来自于不同的书目，每本书标注了书名，书籍排序仅仅是阅读顺序（倒时间顺序），版权归原作者所有，这里仅作摘录整理。</strong></p>\n</blockquote>\n<h1 id=\"阿加莎·克里斯蒂的真实人生\"><a href=\"#阿加莎·克里斯蒂的真实人生\" class=\"headerlink\" title=\"阿加莎·克里斯蒂的真实人生\"></a>阿加莎·克里斯蒂的真实人生</h1><hr>\n<blockquote>\n<p>你无法创作命运，命运会不请自来，就是这么回事。<br>  人人都做梦，但他们的梦不一样。<br>  那些夜里在脏兮兮的脑袋瓜里做梦的人，<br>  白天一觉醒来发现不过是虚幻一场；<br>  要小心那些在白天做梦的人，<br>  因为他们会睁大眼睛做梦，<br>  用行动让梦想变成现实。<br>  天真是一种罪过，冷漠是一种爱。律师以为自己操纵着游戏，但不过是他想加害的人手中的玩偶。</p>\n</blockquote>\n<hr>\n<h1 id=\"牧羊少年奇幻之旅\"><a href=\"#牧羊少年奇幻之旅\" class=\"headerlink\" title=\"牧羊少年奇幻之旅\"></a>牧羊少年奇幻之旅</h1><hr>\n<blockquote>\n<p>不管是牧羊人、海员，还是推销员，总会有一个地方令他们魂牵梦萦，那里会有一个人让他们忘记自由自在周游世界的快乐。<br>  当总是面对同样的面孔，像在神学院里那样，就会渐渐让那些人成为生活的一部分。而由于他们是你生活的一部分，当然就想改变你的生活。如果你不像他们所期望的那样，他们就会不高兴。因为，对于该怎样生活，所有人都有固定的观念。但是他们对于自己该怎样生活却一头雾水，就像那个给人解梦、却不会把梦变成现实的老妇人。<br>  男孩心想，人总会说一些刁钻古怪的事情。有的时候，最好与羊群为伴，羊群不声不响，只顾吃草和水晶。与书为伴也行，书总是在人们最想听故事的时候，告诉你一些意想不到的事情。但是，当人与人交谈的时候，有些人说的话会让我们无所适从，不知该怎样把谈话继续下去。<br>「天命就是你一直期望去做的事情。人一旦步入青年时期，就知道什么是自己的天命了。在人生的这个阶段，一切都那么明朗，没有做不到的事情。人们敢于梦想，期待完成他们一生中喜欢做的一切事情。但是，随着时光的流逝，一股神秘的力量开始企图证明，根本不可能实现天命。」<br>实际上，每天都一成不变，是因为人们已经失去了对美好事物的敏锐感觉。<br>我和别人没什么两样：总是以理想的眼光看待世界，以为事情会按理想的方式发展，而不会用现实的眼光看待世界，看不到事情真相。<br>「因为麦加是支撑我活下去的希望，使我能够忍受平庸的岁月，忍受橱柜里那些不会说话的水晶，忍受那间糟糕透顶的餐厅里的午饭和晚饭。我害怕实现我的梦想，实现之后，我就没有活下去的动力了。」<br>「你的梦想是羊群和金字塔。你与我不同，因为你希望实现你的梦想，而我只是想保有去麦加的梦想。我曾无数次地想象过，如何穿过沙漠，到达安放着圣石的广场，在触摸圣石之前，围着它绕行七圈。我曾想象过有些人站在我身旁，有些人站在我前面，还有我们的谈话和共同的祈祷。可是，我担心会大失所望，所以我宁愿只保留一个梦想。」<br>「你一度成为我的福音。而今天我明白了一个道理，任何不被接纳的福音，都会变成诅咒。我对生活没有更多的要求。而你正迫使我盯着从未见过的财富和前景。现在，我知道了这些财富和前景，也知道了我完全有可能拥有它们。可是我的感觉却比以前糟糕了。因为我知道我自己可以拥有这一切，却不愿拥有它们。」<br>别的事情不好说，但在这件事上，男孩坚信不疑，尽管他的父母以及先辈都说过，必须在恋爱、订婚、相互了解和有了钱之后才可以结婚。说这话的人大概从来不了解宇宙的语言，因为如果掌握了这种语言，很容易就能理解，世上总有人在等待着另外一个人，无论是在大沙漠还是在大城市。当这两个人最终相遇，四目相对的时候，过去的一切和将来的一切全都变得无足轻重了，只有眼前的这一刻最重要。<br>因为生活永远是，也仅仅是我们现在经历的这一刻。<br>这正是需要爱发挥力量的地方，因为当我们有爱的时候，总是希望自己变得更好。</p>\n</blockquote>\n<hr>\n<h1 id=\"且听风吟\"><a href=\"#且听风吟\" class=\"headerlink\" title=\"且听风吟\"></a>且听风吟</h1><hr>\n<blockquote>\n<p>说到底，写文章并非自我诊治的手段，充其量不过是自我疗养的一种小小的尝试。<br>问题是，直言不讳是件极为困难的事。甚至越是想直言不讳，直率的言语越是遁入黑暗的深处。<br>死去的祖母常说「心情抑郁的人只能做抑郁的梦，要是更加抑郁的，连梦都不做的。」<br>如果你志在追求艺术追求文学，那么去读一读希腊人写的东西好了。因为要诞生真正的艺术，奴隶制度是必不可少的。而古希腊人便是这样：奴隶们耕种、烧饭、划船，而市民们则在地中海的阳光下陶醉于吟诗作赋，埋头于数学解析。所谓艺术便是这么一种玩意儿。<br>至于半夜三点半在悄无声息的厨房寻找电冰箱里的食品的人，只能写出这等模样的文章。<br>而那就是我。<br>「我时常想：假如活着不给任何人添麻烦该有多好！你说能做到吗？」<br>「怎么说呢，大概因为厌烦了吧。可我也在尽我的努力——就连自己都难以置信。我也在考虑别人，像考虑自己的事一样，也因此挨过警察的揍。但到时候人们终究要各归其位，唯独我无处可归，就像玩『抢椅子』游戏没了椅子。」<br>「不过你认真想想看：条件大伙都一样，就像同坐一架出了故障的飞机。诚然，有的运气好些，有的运气差些，有的坚强些有的懦弱些，有的有钱有的没钱。但没有一个家伙怀有超乎常人的自信，大家一个样，拥有什么的家伙生怕一旦失去，一无所有的家伙担心永远一无所有，大家一个样。所以，早些察觉到这一点的人 应该力争使自己多少怀有自信，哪怕装模做样也好，对吧？什么自信之人，那样的人根本没有，有的不过是能够装出自信的人。」<br>「把谁都知道的事写成小说，那究竟有何意味可言？」<br>我有时说谎。<br>最后一次说谎是在去年。<br>说谎是非常令人讨厌的勾当。不妨说，说谎与沉默是现代人类中流行的两大罪过。我们实际上经常说谎，也往往沉默不语。<br>然而，倘若我们一年四季都喋喋不休，而且喋喋不休的无不真实，那么真实的价值必然荡然无存。</p>\n</blockquote>\n<hr>\n<h1 id=\"超能力侦探事务所\"><a href=\"#超能力侦探事务所\" class=\"headerlink\" title=\"超能力侦探事务所\"></a>超能力侦探事务所</h1><hr>\n<blockquote>\n<p>和事件无关的人，只要时间够久，或有新的事件发生，就会很快忘记过往的事。<br>世界上永远没有「感同身受」这件事，因为没有亲身经历，无法体会到当事人的痛苦。</p>\n</blockquote>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<h1 id=\"代码整洁之道：程序员的职业素养\"><a href=\"#代码整洁之道：程序员的职业素养\" class=\"headerlink\" title=\"代码整洁之道：程序员的职业素养\"></a>代码整洁之道：程序员的职业素养</h1><hr>\n<blockquote>\n<p>我们并非是因为喜欢和其他人在一起工作才选择做程序员的。我们都认为人际关系难以应付而且毫无规律。编程用的机器则整洁，行为也可预见。如果可以一个人待在房间里数个小时沉浸在一些真正有趣的问题上，那将会是最开心的时光。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>以下全部内容均为本人2019年读书过程中所喜欢或者有感触的片段的摘录，来自于不同的书目，每本书标注了书名，书籍排序仅仅是阅读顺序（倒时间顺序），版权归原作者所有，这里仅作摘录整理。</strong></p>\n</blockquote>\n<h1 id=\"阿加莎·克里斯蒂的真实人生\"><a href=\"#阿加莎·克里斯蒂的真实人生\" class=\"headerlink\" title=\"阿加莎·克里斯蒂的真实人生\"></a>阿加莎·克里斯蒂的真实人生</h1><hr>\n<blockquote>\n<p>你无法创作命运，命运会不请自来，就是这么回事。<br>  人人都做梦，但他们的梦不一样。<br>  那些夜里在脏兮兮的脑袋瓜里做梦的人，<br>  白天一觉醒来发现不过是虚幻一场；<br>  要小心那些在白天做梦的人，<br>  因为他们会睁大眼睛做梦，<br>  用行动让梦想变成现实。<br>  天真是一种罪过，冷漠是一种爱。律师以为自己操纵着游戏，但不过是他想加害的人手中的玩偶。</p>\n</blockquote>\n<hr>\n<h1 id=\"牧羊少年奇幻之旅\"><a href=\"#牧羊少年奇幻之旅\" class=\"headerlink\" title=\"牧羊少年奇幻之旅\"></a>牧羊少年奇幻之旅</h1><hr>\n<blockquote>\n<p>不管是牧羊人、海员，还是推销员，总会有一个地方令他们魂牵梦萦，那里会有一个人让他们忘记自由自在周游世界的快乐。<br>  当总是面对同样的面孔，像在神学院里那样，就会渐渐让那些人成为生活的一部分。而由于他们是你生活的一部分，当然就想改变你的生活。如果你不像他们所期望的那样，他们就会不高兴。因为，对于该怎样生活，所有人都有固定的观念。但是他们对于自己该怎样生活却一头雾水，就像那个给人解梦、却不会把梦变成现实的老妇人。<br>  男孩心想，人总会说一些刁钻古怪的事情。有的时候，最好与羊群为伴，羊群不声不响，只顾吃草和水晶。与书为伴也行，书总是在人们最想听故事的时候，告诉你一些意想不到的事情。但是，当人与人交谈的时候，有些人说的话会让我们无所适从，不知该怎样把谈话继续下去。<br>「天命就是你一直期望去做的事情。人一旦步入青年时期，就知道什么是自己的天命了。在人生的这个阶段，一切都那么明朗，没有做不到的事情。人们敢于梦想，期待完成他们一生中喜欢做的一切事情。但是，随着时光的流逝，一股神秘的力量开始企图证明，根本不可能实现天命。」<br>实际上，每天都一成不变，是因为人们已经失去了对美好事物的敏锐感觉。<br>我和别人没什么两样：总是以理想的眼光看待世界，以为事情会按理想的方式发展，而不会用现实的眼光看待世界，看不到事情真相。<br>「因为麦加是支撑我活下去的希望，使我能够忍受平庸的岁月，忍受橱柜里那些不会说话的水晶，忍受那间糟糕透顶的餐厅里的午饭和晚饭。我害怕实现我的梦想，实现之后，我就没有活下去的动力了。」<br>「你的梦想是羊群和金字塔。你与我不同，因为你希望实现你的梦想，而我只是想保有去麦加的梦想。我曾无数次地想象过，如何穿过沙漠，到达安放着圣石的广场，在触摸圣石之前，围着它绕行七圈。我曾想象过有些人站在我身旁，有些人站在我前面，还有我们的谈话和共同的祈祷。可是，我担心会大失所望，所以我宁愿只保留一个梦想。」<br>「你一度成为我的福音。而今天我明白了一个道理，任何不被接纳的福音，都会变成诅咒。我对生活没有更多的要求。而你正迫使我盯着从未见过的财富和前景。现在，我知道了这些财富和前景，也知道了我完全有可能拥有它们。可是我的感觉却比以前糟糕了。因为我知道我自己可以拥有这一切，却不愿拥有它们。」<br>别的事情不好说，但在这件事上，男孩坚信不疑，尽管他的父母以及先辈都说过，必须在恋爱、订婚、相互了解和有了钱之后才可以结婚。说这话的人大概从来不了解宇宙的语言，因为如果掌握了这种语言，很容易就能理解，世上总有人在等待着另外一个人，无论是在大沙漠还是在大城市。当这两个人最终相遇，四目相对的时候，过去的一切和将来的一切全都变得无足轻重了，只有眼前的这一刻最重要。<br>因为生活永远是，也仅仅是我们现在经历的这一刻。<br>这正是需要爱发挥力量的地方，因为当我们有爱的时候，总是希望自己变得更好。</p>\n</blockquote>\n<hr>\n<h1 id=\"且听风吟\"><a href=\"#且听风吟\" class=\"headerlink\" title=\"且听风吟\"></a>且听风吟</h1><hr>\n<blockquote>\n<p>说到底，写文章并非自我诊治的手段，充其量不过是自我疗养的一种小小的尝试。<br>问题是，直言不讳是件极为困难的事。甚至越是想直言不讳，直率的言语越是遁入黑暗的深处。<br>死去的祖母常说「心情抑郁的人只能做抑郁的梦，要是更加抑郁的，连梦都不做的。」<br>如果你志在追求艺术追求文学，那么去读一读希腊人写的东西好了。因为要诞生真正的艺术，奴隶制度是必不可少的。而古希腊人便是这样：奴隶们耕种、烧饭、划船，而市民们则在地中海的阳光下陶醉于吟诗作赋，埋头于数学解析。所谓艺术便是这么一种玩意儿。<br>至于半夜三点半在悄无声息的厨房寻找电冰箱里的食品的人，只能写出这等模样的文章。<br>而那就是我。<br>「我时常想：假如活着不给任何人添麻烦该有多好！你说能做到吗？」<br>「怎么说呢，大概因为厌烦了吧。可我也在尽我的努力——就连自己都难以置信。我也在考虑别人，像考虑自己的事一样，也因此挨过警察的揍。但到时候人们终究要各归其位，唯独我无处可归，就像玩『抢椅子』游戏没了椅子。」<br>「不过你认真想想看：条件大伙都一样，就像同坐一架出了故障的飞机。诚然，有的运气好些，有的运气差些，有的坚强些有的懦弱些，有的有钱有的没钱。但没有一个家伙怀有超乎常人的自信，大家一个样，拥有什么的家伙生怕一旦失去，一无所有的家伙担心永远一无所有，大家一个样。所以，早些察觉到这一点的人 应该力争使自己多少怀有自信，哪怕装模做样也好，对吧？什么自信之人，那样的人根本没有，有的不过是能够装出自信的人。」<br>「把谁都知道的事写成小说，那究竟有何意味可言？」<br>我有时说谎。<br>最后一次说谎是在去年。<br>说谎是非常令人讨厌的勾当。不妨说，说谎与沉默是现代人类中流行的两大罪过。我们实际上经常说谎，也往往沉默不语。<br>然而，倘若我们一年四季都喋喋不休，而且喋喋不休的无不真实，那么真实的价值必然荡然无存。</p>\n</blockquote>\n<hr>\n<h1 id=\"超能力侦探事务所\"><a href=\"#超能力侦探事务所\" class=\"headerlink\" title=\"超能力侦探事务所\"></a>超能力侦探事务所</h1><hr>\n<blockquote>\n<p>和事件无关的人，只要时间够久，或有新的事件发生，就会很快忘记过往的事。<br>世界上永远没有「感同身受」这件事，因为没有亲身经历，无法体会到当事人的痛苦。</p>\n</blockquote>\n<hr>\n"},{"title":"js继承的几种方式","date":"2019-03-29T11:56:04.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"## js继承的几种方式\n\n### 构造函数继承\n\n> 在构造函数内部调用被继承对象的构造函数，，使用call将this传入\n\n\tfunction Parent() {\n\t  this.name = 'parent';\n\t}\n\tfunction Child() {\n\t  Parent.call(this);\n\t  this.type = 'child';\n\t}\n\n**缺点：**\n\n> 只能实现部分继承。不能继承构造函数原型上的属性和方法，应为本身的原型对象没有被修改\n\n### 原型链继承\n\n> 把原型修改为继承对象的实例化对象\n\n\tfunction Parent() {\n\t  this.name = 'parent';\n\t}\n\tfunction Child() {\n\t  this.type = 'child';\n\t}\n\tChild.prototype = new Parent();\n\n**缺点：**\n\n> 不能继承构造函数内部的属性和方法\n> \n> 不能像构造函数内部参数进行初始化\n\n### 原型链+构造函数继承\n\n\tfunction Parent() {\n\t  this.name = 'parent5';\n\t  this.play = [1, 2, 3];\n\t}\n\t\n\tfunction Child() {\n\t  Parent.call(this);\n\t  this.type = 'child5';\n\t}\n\t// 产生一个中间对象隔离`Child`的`prototype`属性和`Parent`的`prototype`属性引用的同一个原型。\n\tChild.prototype = Object.create(Parent.prototype); \n\t// 给Child的原型对象重新写一个自己的constructor。\n\tChild.prototype.constructor = Child;\n","source":"_posts/extend.md","raw":"---\ntitle: js继承的几种方式\ndate: '3/29/2019 7:56:04 PM '\ntag: ['js', 'extend']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n## js继承的几种方式\n\n### 构造函数继承\n\n> 在构造函数内部调用被继承对象的构造函数，，使用call将this传入\n\n\tfunction Parent() {\n\t  this.name = 'parent';\n\t}\n\tfunction Child() {\n\t  Parent.call(this);\n\t  this.type = 'child';\n\t}\n\n**缺点：**\n\n> 只能实现部分继承。不能继承构造函数原型上的属性和方法，应为本身的原型对象没有被修改\n\n### 原型链继承\n\n> 把原型修改为继承对象的实例化对象\n\n\tfunction Parent() {\n\t  this.name = 'parent';\n\t}\n\tfunction Child() {\n\t  this.type = 'child';\n\t}\n\tChild.prototype = new Parent();\n\n**缺点：**\n\n> 不能继承构造函数内部的属性和方法\n> \n> 不能像构造函数内部参数进行初始化\n\n### 原型链+构造函数继承\n\n\tfunction Parent() {\n\t  this.name = 'parent5';\n\t  this.play = [1, 2, 3];\n\t}\n\t\n\tfunction Child() {\n\t  Parent.call(this);\n\t  this.type = 'child5';\n\t}\n\t// 产生一个中间对象隔离`Child`的`prototype`属性和`Parent`的`prototype`属性引用的同一个原型。\n\tChild.prototype = Object.create(Parent.prototype); \n\t// 给Child的原型对象重新写一个自己的constructor。\n\tChild.prototype.constructor = Child;\n","slug":"extend","published":1,"updated":"2019-03-29T12:30:05.956Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam6w000zn4wdpo5tgn8c","content":"<h2 id=\"js继承的几种方式\"><a href=\"#js继承的几种方式\" class=\"headerlink\" title=\"js继承的几种方式\"></a>js继承的几种方式</h2><h3 id=\"构造函数继承\"><a href=\"#构造函数继承\" class=\"headerlink\" title=\"构造函数继承\"></a>构造函数继承</h3><blockquote>\n<p>在构造函数内部调用被继承对象的构造函数，，使用call将this传入</p>\n</blockquote>\n<pre><code>function Parent() {\n  this.name = &#39;parent&#39;;\n}\nfunction Child() {\n  Parent.call(this);\n  this.type = &#39;child&#39;;\n}\n</code></pre><p><strong>缺点：</strong></p>\n<blockquote>\n<p>只能实现部分继承。不能继承构造函数原型上的属性和方法，应为本身的原型对象没有被修改</p>\n</blockquote>\n<h3 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h3><blockquote>\n<p>把原型修改为继承对象的实例化对象</p>\n</blockquote>\n<pre><code>function Parent() {\n  this.name = &#39;parent&#39;;\n}\nfunction Child() {\n  this.type = &#39;child&#39;;\n}\nChild.prototype = new Parent();\n</code></pre><p><strong>缺点：</strong></p>\n<blockquote>\n<p>不能继承构造函数内部的属性和方法</p>\n<p>不能像构造函数内部参数进行初始化</p>\n</blockquote>\n<h3 id=\"原型链-构造函数继承\"><a href=\"#原型链-构造函数继承\" class=\"headerlink\" title=\"原型链+构造函数继承\"></a>原型链+构造函数继承</h3><pre><code>function Parent() {\n  this.name = &#39;parent5&#39;;\n  this.play = [1, 2, 3];\n}\n\nfunction Child() {\n  Parent.call(this);\n  this.type = &#39;child5&#39;;\n}\n// 产生一个中间对象隔离`Child`的`prototype`属性和`Parent`的`prototype`属性引用的同一个原型。\nChild.prototype = Object.create(Parent.prototype); \n// 给Child的原型对象重新写一个自己的constructor。\nChild.prototype.constructor = Child;\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"js继承的几种方式\"><a href=\"#js继承的几种方式\" class=\"headerlink\" title=\"js继承的几种方式\"></a>js继承的几种方式</h2><h3 id=\"构造函数继承\"><a href=\"#构造函数继承\" class=\"headerlink\" title=\"构造函数继承\"></a>构造函数继承</h3><blockquote>\n<p>在构造函数内部调用被继承对象的构造函数，，使用call将this传入</p>\n</blockquote>\n<pre><code>function Parent() {\n  this.name = &#39;parent&#39;;\n}\nfunction Child() {\n  Parent.call(this);\n  this.type = &#39;child&#39;;\n}\n</code></pre><p><strong>缺点：</strong></p>\n<blockquote>\n<p>只能实现部分继承。不能继承构造函数原型上的属性和方法，应为本身的原型对象没有被修改</p>\n</blockquote>\n<h3 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h3><blockquote>\n<p>把原型修改为继承对象的实例化对象</p>\n</blockquote>\n<pre><code>function Parent() {\n  this.name = &#39;parent&#39;;\n}\nfunction Child() {\n  this.type = &#39;child&#39;;\n}\nChild.prototype = new Parent();\n</code></pre><p><strong>缺点：</strong></p>\n<blockquote>\n<p>不能继承构造函数内部的属性和方法</p>\n<p>不能像构造函数内部参数进行初始化</p>\n</blockquote>\n<h3 id=\"原型链-构造函数继承\"><a href=\"#原型链-构造函数继承\" class=\"headerlink\" title=\"原型链+构造函数继承\"></a>原型链+构造函数继承</h3><pre><code>function Parent() {\n  this.name = &#39;parent5&#39;;\n  this.play = [1, 2, 3];\n}\n\nfunction Child() {\n  Parent.call(this);\n  this.type = &#39;child5&#39;;\n}\n// 产生一个中间对象隔离`Child`的`prototype`属性和`Parent`的`prototype`属性引用的同一个原型。\nChild.prototype = Object.create(Parent.prototype); \n// 给Child的原型对象重新写一个自己的constructor。\nChild.prototype.constructor = Child;\n</code></pre>"},{"title":"开启nginx服务器压缩Gzip","date":"2019-03-28T03:03:27.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"# 开启nginx服务器压缩\n\n> nginx.conf(加入以下配置即可)\n\n\tserver{\n\t  listen       80;\n\t  server_name  my.ignorantscholar.cn;\n\t  \n\t  gzip on;\n\t  gzip_min_length 1k;\n\t  gzip_buffers 4 16k;\n\t  #gzip_http_version 1.0;\n\t  gzip_comp_level 8;\n\t  gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;\n\t  gzip_vary off;\n\t  gzip_disable \"MSIE [1-6]\\.\";\n\t\n\t  location / {\n\t       proxy_pass http://127.0.0.1:3001;\n\t  }\n\t}\n\n> 在浏览器端查看是否开启可压缩\n\n#### Network 查看请求的Headers头，\n\n\tAccept-Encoding: gzip\n\n#### 即开启了压缩","source":"_posts/gzipmd.md","raw":"---\ntitle: 开启nginx服务器压缩Gzip\ndate: '3/28/2019 11:03:27 AM '\ntag: ['nginx', 'gzip']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n# 开启nginx服务器压缩\n\n> nginx.conf(加入以下配置即可)\n\n\tserver{\n\t  listen       80;\n\t  server_name  my.ignorantscholar.cn;\n\t  \n\t  gzip on;\n\t  gzip_min_length 1k;\n\t  gzip_buffers 4 16k;\n\t  #gzip_http_version 1.0;\n\t  gzip_comp_level 8;\n\t  gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;\n\t  gzip_vary off;\n\t  gzip_disable \"MSIE [1-6]\\.\";\n\t\n\t  location / {\n\t       proxy_pass http://127.0.0.1:3001;\n\t  }\n\t}\n\n> 在浏览器端查看是否开启可压缩\n\n#### Network 查看请求的Headers头，\n\n\tAccept-Encoding: gzip\n\n#### 即开启了压缩","slug":"gzipmd","published":1,"updated":"2019-03-28T03:03:50.036Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam6x0012n4wdbpd48shf","content":"<h1 id=\"开启nginx服务器压缩\"><a href=\"#开启nginx服务器压缩\" class=\"headerlink\" title=\"开启nginx服务器压缩\"></a>开启nginx服务器压缩</h1><blockquote>\n<p>nginx.conf(加入以下配置即可)</p>\n</blockquote>\n<pre><code>server{\n  listen       80;\n  server_name  my.ignorantscholar.cn;\n\n  gzip on;\n  gzip_min_length 1k;\n  gzip_buffers 4 16k;\n  #gzip_http_version 1.0;\n  gzip_comp_level 8;\n  gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;\n  gzip_vary off;\n  gzip_disable &quot;MSIE [1-6]\\.&quot;;\n\n  location / {\n       proxy_pass http://127.0.0.1:3001;\n  }\n}\n</code></pre><blockquote>\n<p>在浏览器端查看是否开启可压缩</p>\n</blockquote>\n<h4 id=\"Network-查看请求的Headers头，\"><a href=\"#Network-查看请求的Headers头，\" class=\"headerlink\" title=\"Network 查看请求的Headers头，\"></a>Network 查看请求的Headers头，</h4><pre><code>Accept-Encoding: gzip\n</code></pre><h4 id=\"即开启了压缩\"><a href=\"#即开启了压缩\" class=\"headerlink\" title=\"即开启了压缩\"></a>即开启了压缩</h4>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"开启nginx服务器压缩\"><a href=\"#开启nginx服务器压缩\" class=\"headerlink\" title=\"开启nginx服务器压缩\"></a>开启nginx服务器压缩</h1><blockquote>\n<p>nginx.conf(加入以下配置即可)</p>\n</blockquote>\n<pre><code>server{\n  listen       80;\n  server_name  my.ignorantscholar.cn;\n\n  gzip on;\n  gzip_min_length 1k;\n  gzip_buffers 4 16k;\n  #gzip_http_version 1.0;\n  gzip_comp_level 8;\n  gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;\n  gzip_vary off;\n  gzip_disable &quot;MSIE [1-6]\\.&quot;;\n\n  location / {\n       proxy_pass http://127.0.0.1:3001;\n  }\n}\n</code></pre><blockquote>\n<p>在浏览器端查看是否开启可压缩</p>\n</blockquote>\n<h4 id=\"Network-查看请求的Headers头，\"><a href=\"#Network-查看请求的Headers头，\" class=\"headerlink\" title=\"Network 查看请求的Headers头，\"></a>Network 查看请求的Headers头，</h4><pre><code>Accept-Encoding: gzip\n</code></pre><h4 id=\"即开启了压缩\"><a href=\"#即开启了压缩\" class=\"headerlink\" title=\"即开启了压缩\"></a>即开启了压缩</h4>"},{"title":"node + koa2基础","date":"2019-09-26T02:41:49.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"# node + koa2基础\n\n> **使用koa2，必须保持你的node版本在7.6以上，最好实在10以上，如低于7.6版本请更新您的node版本**\n\n## 搭建http服务+\n\n> 使用koa2搭建服务，只需要三步\n\n    /index.js\n\n    const Koa = require('koa')\n    const app = new Koa()\n\n    app.listen(3000)\n\n**使用node命令运行即可**\n\n    node index.js\n\n> 打开浏览器输入http://loaclhost:3000访问，页面中会显示Not Found，这是因为我们没有去指定koa该返回什么内容，这一点与express不同，koa内部会自动判断，是否有返回内容\n\n## Context对象\n\n**koa内部提供了一个Context对象，表示一次对话的上下文【包括http的请求对象和响应对象】，通过操控这个对象我们可以控制返回给用户的内容**\n\n    /index.js\n\n    const Koa = require('koa')\n    const app = new Koa()\n\n    app.use(async (ctx, next) => {  \n        ctx.response.body = 'hello'\n        await next()\n    })\n    app.listen(3000)\n\n\n## 路由【koa-router】的使用\n\n    const router = require('koa-router')()\n    const Koa = require('koa')\n    const app = new Koa()\n\n    router.get('/list', ctx => {\n        ctx.response.body = 'hellow, list'\n    })\n\n    router.get('/home', ctx => {\n        ctx.response.body = 'hellow, home'\n    })\n\n    app.use(router.routes()).use(router.allowedMethods()) // 启动路由\n\n## 中间件\n\n### 应用级别中间件\n\n> 任何路由都会经过应用级别中间件,当执行玩成后next()去匹配相应的路由\n\n    app.use(async (ctx, next) => {\n        await next()\n    })\n\n### 错误处理中间件\n\n    app.use(async (ctx, next) => {\n        await next()\n        if (ctx.status == 404) {\n            ctx.body = '404'\n        }\n    })\n\n### 路由中间件\n\n> 在匹配路由的过程中匹配到的路由会依次执行中间件,知道最后一个没有next参数\n\n    router.get('/', async (ctx, next) => {\n        ctx.response.body = 'hellow'\n        ctx.response.status = 200\n        await next()\n    })\n\n    router.get('/home', ctx => {\n        ctx.body = 'hellow, world'\n    })\n\n\n## 中间件的合成\n\n> koa-compose 模块可以将多个中间件合成为一个\n\n    const Koa = require('koa')\n    const app = new Koa()\n    const compose = require('koa-compose')\n\n    const logger = (ctx,next) => {\n        console.log(new Date())\n        next()\n    }\n\n    const main = (ctx,next) => {\n        ctx.response.body =  'hello world'\n    }\n\n    const middleWares = compose([logger,main])\n    app.use(middleWares)\n    app.listen(3000)\n\n## xtemplate模板渲染【koa-xtpl】\n\n    app.use(xtpl({\n        root: path.join(__dirname, 'template'), // 获取到模板所在的文件夹\n        extname: 'xtpl', // 模板后缀\n        commands: {}\n    }))\n\n> 新建template/login/index.xtpl（模板必须以xtpl后缀结尾）\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>后台管理系统</title>\n    </head>\n    <body>\n        <div class=\"container-fluid\">\n            hellow, world\n        </div>\n    </body>\n    </html>\n\n> 打开index.js\n\n    router.get('/', async (ctx, next) => {\n        await ctx.render('login/index', { title: new Date() })\n        await next()\n    })\n\n**运行就可以看到页面中出现  hellow, world**\n\n## 静态资源\n\n> 如果网站提供了静态资源（图片，字体，样式，脚本），为他们一个个写路由就很麻烦，也没必要  koa-static 模块封装了这部分的请求\n\n    const Koa = require('koa')\n    const app = new Koa()\n    const serve = require('koa-static')\n    const path = require('path')\n\n    const main = serve(path.join(__dirname))\n\n    app.use(main)\n\n\n    app.listen(3000)\n\n**设置之后可以直接在URL地址中输入静态资源文件名进行访问**\n","source":"_posts/koa.md","raw":"---\ntitle: node + koa2基础\ndate: '9/26/2019 10:41:49'\ntag: ['node', 'koa']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n# node + koa2基础\n\n> **使用koa2，必须保持你的node版本在7.6以上，最好实在10以上，如低于7.6版本请更新您的node版本**\n\n## 搭建http服务+\n\n> 使用koa2搭建服务，只需要三步\n\n    /index.js\n\n    const Koa = require('koa')\n    const app = new Koa()\n\n    app.listen(3000)\n\n**使用node命令运行即可**\n\n    node index.js\n\n> 打开浏览器输入http://loaclhost:3000访问，页面中会显示Not Found，这是因为我们没有去指定koa该返回什么内容，这一点与express不同，koa内部会自动判断，是否有返回内容\n\n## Context对象\n\n**koa内部提供了一个Context对象，表示一次对话的上下文【包括http的请求对象和响应对象】，通过操控这个对象我们可以控制返回给用户的内容**\n\n    /index.js\n\n    const Koa = require('koa')\n    const app = new Koa()\n\n    app.use(async (ctx, next) => {  \n        ctx.response.body = 'hello'\n        await next()\n    })\n    app.listen(3000)\n\n\n## 路由【koa-router】的使用\n\n    const router = require('koa-router')()\n    const Koa = require('koa')\n    const app = new Koa()\n\n    router.get('/list', ctx => {\n        ctx.response.body = 'hellow, list'\n    })\n\n    router.get('/home', ctx => {\n        ctx.response.body = 'hellow, home'\n    })\n\n    app.use(router.routes()).use(router.allowedMethods()) // 启动路由\n\n## 中间件\n\n### 应用级别中间件\n\n> 任何路由都会经过应用级别中间件,当执行玩成后next()去匹配相应的路由\n\n    app.use(async (ctx, next) => {\n        await next()\n    })\n\n### 错误处理中间件\n\n    app.use(async (ctx, next) => {\n        await next()\n        if (ctx.status == 404) {\n            ctx.body = '404'\n        }\n    })\n\n### 路由中间件\n\n> 在匹配路由的过程中匹配到的路由会依次执行中间件,知道最后一个没有next参数\n\n    router.get('/', async (ctx, next) => {\n        ctx.response.body = 'hellow'\n        ctx.response.status = 200\n        await next()\n    })\n\n    router.get('/home', ctx => {\n        ctx.body = 'hellow, world'\n    })\n\n\n## 中间件的合成\n\n> koa-compose 模块可以将多个中间件合成为一个\n\n    const Koa = require('koa')\n    const app = new Koa()\n    const compose = require('koa-compose')\n\n    const logger = (ctx,next) => {\n        console.log(new Date())\n        next()\n    }\n\n    const main = (ctx,next) => {\n        ctx.response.body =  'hello world'\n    }\n\n    const middleWares = compose([logger,main])\n    app.use(middleWares)\n    app.listen(3000)\n\n## xtemplate模板渲染【koa-xtpl】\n\n    app.use(xtpl({\n        root: path.join(__dirname, 'template'), // 获取到模板所在的文件夹\n        extname: 'xtpl', // 模板后缀\n        commands: {}\n    }))\n\n> 新建template/login/index.xtpl（模板必须以xtpl后缀结尾）\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>后台管理系统</title>\n    </head>\n    <body>\n        <div class=\"container-fluid\">\n            hellow, world\n        </div>\n    </body>\n    </html>\n\n> 打开index.js\n\n    router.get('/', async (ctx, next) => {\n        await ctx.render('login/index', { title: new Date() })\n        await next()\n    })\n\n**运行就可以看到页面中出现  hellow, world**\n\n## 静态资源\n\n> 如果网站提供了静态资源（图片，字体，样式，脚本），为他们一个个写路由就很麻烦，也没必要  koa-static 模块封装了这部分的请求\n\n    const Koa = require('koa')\n    const app = new Koa()\n    const serve = require('koa-static')\n    const path = require('path')\n\n    const main = serve(path.join(__dirname))\n\n    app.use(main)\n\n\n    app.listen(3000)\n\n**设置之后可以直接在URL地址中输入静态资源文件名进行访问**\n","slug":"koa","published":1,"updated":"2019-09-27T01:35:47.259Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam6z0014n4wd3r9q8cwo","content":"<h1 id=\"node-koa2基础\"><a href=\"#node-koa2基础\" class=\"headerlink\" title=\"node + koa2基础\"></a>node + koa2基础</h1><blockquote>\n<p><strong>使用koa2，必须保持你的node版本在7.6以上，最好实在10以上，如低于7.6版本请更新您的node版本</strong></p>\n</blockquote>\n<h2 id=\"搭建http服务\"><a href=\"#搭建http服务\" class=\"headerlink\" title=\"搭建http服务+\"></a>搭建http服务+</h2><blockquote>\n<p>使用koa2搭建服务，只需要三步</p>\n</blockquote>\n<pre><code>/index.js\n\nconst Koa = require(&#39;koa&#39;)\nconst app = new Koa()\n\napp.listen(3000)\n</code></pre><p><strong>使用node命令运行即可</strong></p>\n<pre><code>node index.js\n</code></pre><blockquote>\n<p>打开浏览器输入<a href=\"http://loaclhost:3000访问，页面中会显示Not\" target=\"_blank\" rel=\"noopener\">http://loaclhost:3000访问，页面中会显示Not</a> Found，这是因为我们没有去指定koa该返回什么内容，这一点与express不同，koa内部会自动判断，是否有返回内容</p>\n</blockquote>\n<h2 id=\"Context对象\"><a href=\"#Context对象\" class=\"headerlink\" title=\"Context对象\"></a>Context对象</h2><p><strong>koa内部提供了一个Context对象，表示一次对话的上下文【包括http的请求对象和响应对象】，通过操控这个对象我们可以控制返回给用户的内容</strong></p>\n<pre><code>/index.js\n\nconst Koa = require(&#39;koa&#39;)\nconst app = new Koa()\n\napp.use(async (ctx, next) =&gt; {  \n    ctx.response.body = &#39;hello&#39;\n    await next()\n})\napp.listen(3000)\n</code></pre><h2 id=\"路由【koa-router】的使用\"><a href=\"#路由【koa-router】的使用\" class=\"headerlink\" title=\"路由【koa-router】的使用\"></a>路由【koa-router】的使用</h2><pre><code>const router = require(&#39;koa-router&#39;)()\nconst Koa = require(&#39;koa&#39;)\nconst app = new Koa()\n\nrouter.get(&#39;/list&#39;, ctx =&gt; {\n    ctx.response.body = &#39;hellow, list&#39;\n})\n\nrouter.get(&#39;/home&#39;, ctx =&gt; {\n    ctx.response.body = &#39;hellow, home&#39;\n})\n\napp.use(router.routes()).use(router.allowedMethods()) // 启动路由\n</code></pre><h2 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h2><h3 id=\"应用级别中间件\"><a href=\"#应用级别中间件\" class=\"headerlink\" title=\"应用级别中间件\"></a>应用级别中间件</h3><blockquote>\n<p>任何路由都会经过应用级别中间件,当执行玩成后next()去匹配相应的路由</p>\n</blockquote>\n<pre><code>app.use(async (ctx, next) =&gt; {\n    await next()\n})\n</code></pre><h3 id=\"错误处理中间件\"><a href=\"#错误处理中间件\" class=\"headerlink\" title=\"错误处理中间件\"></a>错误处理中间件</h3><pre><code>app.use(async (ctx, next) =&gt; {\n    await next()\n    if (ctx.status == 404) {\n        ctx.body = &#39;404&#39;\n    }\n})\n</code></pre><h3 id=\"路由中间件\"><a href=\"#路由中间件\" class=\"headerlink\" title=\"路由中间件\"></a>路由中间件</h3><blockquote>\n<p>在匹配路由的过程中匹配到的路由会依次执行中间件,知道最后一个没有next参数</p>\n</blockquote>\n<pre><code>router.get(&#39;/&#39;, async (ctx, next) =&gt; {\n    ctx.response.body = &#39;hellow&#39;\n    ctx.response.status = 200\n    await next()\n})\n\nrouter.get(&#39;/home&#39;, ctx =&gt; {\n    ctx.body = &#39;hellow, world&#39;\n})\n</code></pre><h2 id=\"中间件的合成\"><a href=\"#中间件的合成\" class=\"headerlink\" title=\"中间件的合成\"></a>中间件的合成</h2><blockquote>\n<p>koa-compose 模块可以将多个中间件合成为一个</p>\n</blockquote>\n<pre><code>const Koa = require(&#39;koa&#39;)\nconst app = new Koa()\nconst compose = require(&#39;koa-compose&#39;)\n\nconst logger = (ctx,next) =&gt; {\n    console.log(new Date())\n    next()\n}\n\nconst main = (ctx,next) =&gt; {\n    ctx.response.body =  &#39;hello world&#39;\n}\n\nconst middleWares = compose([logger,main])\napp.use(middleWares)\napp.listen(3000)\n</code></pre><h2 id=\"xtemplate模板渲染【koa-xtpl】\"><a href=\"#xtemplate模板渲染【koa-xtpl】\" class=\"headerlink\" title=\"xtemplate模板渲染【koa-xtpl】\"></a>xtemplate模板渲染【koa-xtpl】</h2><pre><code>app.use(xtpl({\n    root: path.join(__dirname, &#39;template&#39;), // 获取到模板所在的文件夹\n    extname: &#39;xtpl&#39;, // 模板后缀\n    commands: {}\n}))\n</code></pre><blockquote>\n<p>新建template/login/index.xtpl（模板必须以xtpl后缀结尾）</p>\n</blockquote>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;后台管理系统&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=&quot;container-fluid&quot;&gt;\n        hellow, world\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><blockquote>\n<p>打开index.js</p>\n</blockquote>\n<pre><code>router.get(&#39;/&#39;, async (ctx, next) =&gt; {\n    await ctx.render(&#39;login/index&#39;, { title: new Date() })\n    await next()\n})\n</code></pre><p><strong>运行就可以看到页面中出现  hellow, world</strong></p>\n<h2 id=\"静态资源\"><a href=\"#静态资源\" class=\"headerlink\" title=\"静态资源\"></a>静态资源</h2><blockquote>\n<p>如果网站提供了静态资源（图片，字体，样式，脚本），为他们一个个写路由就很麻烦，也没必要  koa-static 模块封装了这部分的请求</p>\n</blockquote>\n<pre><code>const Koa = require(&#39;koa&#39;)\nconst app = new Koa()\nconst serve = require(&#39;koa-static&#39;)\nconst path = require(&#39;path&#39;)\n\nconst main = serve(path.join(__dirname))\n\napp.use(main)\n\n\napp.listen(3000)\n</code></pre><p><strong>设置之后可以直接在URL地址中输入静态资源文件名进行访问</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"node-koa2基础\"><a href=\"#node-koa2基础\" class=\"headerlink\" title=\"node + koa2基础\"></a>node + koa2基础</h1><blockquote>\n<p><strong>使用koa2，必须保持你的node版本在7.6以上，最好实在10以上，如低于7.6版本请更新您的node版本</strong></p>\n</blockquote>\n<h2 id=\"搭建http服务\"><a href=\"#搭建http服务\" class=\"headerlink\" title=\"搭建http服务+\"></a>搭建http服务+</h2><blockquote>\n<p>使用koa2搭建服务，只需要三步</p>\n</blockquote>\n<pre><code>/index.js\n\nconst Koa = require(&#39;koa&#39;)\nconst app = new Koa()\n\napp.listen(3000)\n</code></pre><p><strong>使用node命令运行即可</strong></p>\n<pre><code>node index.js\n</code></pre><blockquote>\n<p>打开浏览器输入<a href=\"http://loaclhost:3000访问，页面中会显示Not\" target=\"_blank\" rel=\"noopener\">http://loaclhost:3000访问，页面中会显示Not</a> Found，这是因为我们没有去指定koa该返回什么内容，这一点与express不同，koa内部会自动判断，是否有返回内容</p>\n</blockquote>\n<h2 id=\"Context对象\"><a href=\"#Context对象\" class=\"headerlink\" title=\"Context对象\"></a>Context对象</h2><p><strong>koa内部提供了一个Context对象，表示一次对话的上下文【包括http的请求对象和响应对象】，通过操控这个对象我们可以控制返回给用户的内容</strong></p>\n<pre><code>/index.js\n\nconst Koa = require(&#39;koa&#39;)\nconst app = new Koa()\n\napp.use(async (ctx, next) =&gt; {  \n    ctx.response.body = &#39;hello&#39;\n    await next()\n})\napp.listen(3000)\n</code></pre><h2 id=\"路由【koa-router】的使用\"><a href=\"#路由【koa-router】的使用\" class=\"headerlink\" title=\"路由【koa-router】的使用\"></a>路由【koa-router】的使用</h2><pre><code>const router = require(&#39;koa-router&#39;)()\nconst Koa = require(&#39;koa&#39;)\nconst app = new Koa()\n\nrouter.get(&#39;/list&#39;, ctx =&gt; {\n    ctx.response.body = &#39;hellow, list&#39;\n})\n\nrouter.get(&#39;/home&#39;, ctx =&gt; {\n    ctx.response.body = &#39;hellow, home&#39;\n})\n\napp.use(router.routes()).use(router.allowedMethods()) // 启动路由\n</code></pre><h2 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h2><h3 id=\"应用级别中间件\"><a href=\"#应用级别中间件\" class=\"headerlink\" title=\"应用级别中间件\"></a>应用级别中间件</h3><blockquote>\n<p>任何路由都会经过应用级别中间件,当执行玩成后next()去匹配相应的路由</p>\n</blockquote>\n<pre><code>app.use(async (ctx, next) =&gt; {\n    await next()\n})\n</code></pre><h3 id=\"错误处理中间件\"><a href=\"#错误处理中间件\" class=\"headerlink\" title=\"错误处理中间件\"></a>错误处理中间件</h3><pre><code>app.use(async (ctx, next) =&gt; {\n    await next()\n    if (ctx.status == 404) {\n        ctx.body = &#39;404&#39;\n    }\n})\n</code></pre><h3 id=\"路由中间件\"><a href=\"#路由中间件\" class=\"headerlink\" title=\"路由中间件\"></a>路由中间件</h3><blockquote>\n<p>在匹配路由的过程中匹配到的路由会依次执行中间件,知道最后一个没有next参数</p>\n</blockquote>\n<pre><code>router.get(&#39;/&#39;, async (ctx, next) =&gt; {\n    ctx.response.body = &#39;hellow&#39;\n    ctx.response.status = 200\n    await next()\n})\n\nrouter.get(&#39;/home&#39;, ctx =&gt; {\n    ctx.body = &#39;hellow, world&#39;\n})\n</code></pre><h2 id=\"中间件的合成\"><a href=\"#中间件的合成\" class=\"headerlink\" title=\"中间件的合成\"></a>中间件的合成</h2><blockquote>\n<p>koa-compose 模块可以将多个中间件合成为一个</p>\n</blockquote>\n<pre><code>const Koa = require(&#39;koa&#39;)\nconst app = new Koa()\nconst compose = require(&#39;koa-compose&#39;)\n\nconst logger = (ctx,next) =&gt; {\n    console.log(new Date())\n    next()\n}\n\nconst main = (ctx,next) =&gt; {\n    ctx.response.body =  &#39;hello world&#39;\n}\n\nconst middleWares = compose([logger,main])\napp.use(middleWares)\napp.listen(3000)\n</code></pre><h2 id=\"xtemplate模板渲染【koa-xtpl】\"><a href=\"#xtemplate模板渲染【koa-xtpl】\" class=\"headerlink\" title=\"xtemplate模板渲染【koa-xtpl】\"></a>xtemplate模板渲染【koa-xtpl】</h2><pre><code>app.use(xtpl({\n    root: path.join(__dirname, &#39;template&#39;), // 获取到模板所在的文件夹\n    extname: &#39;xtpl&#39;, // 模板后缀\n    commands: {}\n}))\n</code></pre><blockquote>\n<p>新建template/login/index.xtpl（模板必须以xtpl后缀结尾）</p>\n</blockquote>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;后台管理系统&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=&quot;container-fluid&quot;&gt;\n        hellow, world\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><blockquote>\n<p>打开index.js</p>\n</blockquote>\n<pre><code>router.get(&#39;/&#39;, async (ctx, next) =&gt; {\n    await ctx.render(&#39;login/index&#39;, { title: new Date() })\n    await next()\n})\n</code></pre><p><strong>运行就可以看到页面中出现  hellow, world</strong></p>\n<h2 id=\"静态资源\"><a href=\"#静态资源\" class=\"headerlink\" title=\"静态资源\"></a>静态资源</h2><blockquote>\n<p>如果网站提供了静态资源（图片，字体，样式，脚本），为他们一个个写路由就很麻烦，也没必要  koa-static 模块封装了这部分的请求</p>\n</blockquote>\n<pre><code>const Koa = require(&#39;koa&#39;)\nconst app = new Koa()\nconst serve = require(&#39;koa-static&#39;)\nconst path = require(&#39;path&#39;)\n\nconst main = serve(path.join(__dirname))\n\napp.use(main)\n\n\napp.listen(3000)\n</code></pre><p><strong>设置之后可以直接在URL地址中输入静态资源文件名进行访问</strong></p>\n"},{"title":"json web token【跨域认证的解决方案】","date":"2019-02-25T03:49:43.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"\n## json web token【跨域认证的解决方案】\n\n#### 一般互联网认证用户流程\n\n> 1.**用户向服务器发送用户名和密码。**\n\n> 2、**服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。**\n> \n> 3、**服务器向用户返回一个 session_id，写入用户的 Cookie。**\n> \n> 4、**用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。**\n> \n> 5、**服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。**\n\n\n#### 缺点\n\n> 扩展性不够好单机当然没有问题，如果是服务器集群，就要求 session 数据共享，每台服务器都能够读取 session。\n\n## JWT以及具体实现\n\t\n### JWT鉴权的简单流程\n\n###  JWT分为三部分\n> \n> Header（包含加密方式等）\n\n\t{\n\t  \"alg\": \"HS256\",// 默认签名算法\n\t  \"typ\": \"JWT\" // 类型\n\t}\n\n> Payload（包含用户必要信息，以及过期时间等）\n\n\tiss (issuer)：签发人\n\texp (expiration time)：过期时间\n\tsub (subject)：主题\n\taud (audience)：受众\n\tnbf (Not Before)：生效时间\n\tiat (Issued At)：签发时间\n\tjti (JWT ID)：编号\n\n\t用来存放需要传递的实际数据\n\n> Signature（针对前两部分生成，防止数据篡改）。\n\n### 流程\n\n\t用户登录成功后，后台根据用户信息加上一个用户唯一的密钥值，生成一串字符串，即Token串，将其设置\n    在Cookie中；\n    用户下次带Token访问，系统会先根据前两部分以及密钥值，对Token进行有效性以及正确性的验证，如果       \n    验证通过的话，再执行下一步操作...\n\n#### 如果要写入私密数据时需要加密\n\n\tconst token = jwt.sign({...getu},\"usermessag\",{\n    \texpiresIn: 60*60*1  // 1小时过期\n  \t})\n\n#### 解密\n\n\tjwt.verify(token,'usermessag',(err, decode) => {\n\t\tconsole.log(decode) // n拿到解密的值\n\t}","source":"_posts/json web token.md","raw":"---\ntitle: json web token【跨域认证的解决方案】\ndate: '2/25/2019 11:49:43 AM '\ntag: ['js', 'vue', 'json web token']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n\n## json web token【跨域认证的解决方案】\n\n#### 一般互联网认证用户流程\n\n> 1.**用户向服务器发送用户名和密码。**\n\n> 2、**服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。**\n> \n> 3、**服务器向用户返回一个 session_id，写入用户的 Cookie。**\n> \n> 4、**用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。**\n> \n> 5、**服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。**\n\n\n#### 缺点\n\n> 扩展性不够好单机当然没有问题，如果是服务器集群，就要求 session 数据共享，每台服务器都能够读取 session。\n\n## JWT以及具体实现\n\t\n### JWT鉴权的简单流程\n\n###  JWT分为三部分\n> \n> Header（包含加密方式等）\n\n\t{\n\t  \"alg\": \"HS256\",// 默认签名算法\n\t  \"typ\": \"JWT\" // 类型\n\t}\n\n> Payload（包含用户必要信息，以及过期时间等）\n\n\tiss (issuer)：签发人\n\texp (expiration time)：过期时间\n\tsub (subject)：主题\n\taud (audience)：受众\n\tnbf (Not Before)：生效时间\n\tiat (Issued At)：签发时间\n\tjti (JWT ID)：编号\n\n\t用来存放需要传递的实际数据\n\n> Signature（针对前两部分生成，防止数据篡改）。\n\n### 流程\n\n\t用户登录成功后，后台根据用户信息加上一个用户唯一的密钥值，生成一串字符串，即Token串，将其设置\n    在Cookie中；\n    用户下次带Token访问，系统会先根据前两部分以及密钥值，对Token进行有效性以及正确性的验证，如果       \n    验证通过的话，再执行下一步操作...\n\n#### 如果要写入私密数据时需要加密\n\n\tconst token = jwt.sign({...getu},\"usermessag\",{\n    \texpiresIn: 60*60*1  // 1小时过期\n  \t})\n\n#### 解密\n\n\tjwt.verify(token,'usermessag',(err, decode) => {\n\t\tconsole.log(decode) // n拿到解密的值\n\t}","slug":"json web token","published":1,"updated":"2019-02-25T03:49:44.591Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam710016n4wdqxj7739a","content":"<h2 id=\"json-web-token【跨域认证的解决方案】\"><a href=\"#json-web-token【跨域认证的解决方案】\" class=\"headerlink\" title=\"json web token【跨域认证的解决方案】\"></a>json web token【跨域认证的解决方案】</h2><h4 id=\"一般互联网认证用户流程\"><a href=\"#一般互联网认证用户流程\" class=\"headerlink\" title=\"一般互联网认证用户流程\"></a>一般互联网认证用户流程</h4><blockquote>\n<p>1.<strong>用户向服务器发送用户名和密码。</strong></p>\n</blockquote>\n<blockquote>\n<p>2、<strong>服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</strong></p>\n<p>3、<strong>服务器向用户返回一个 session_id，写入用户的 Cookie。</strong></p>\n<p>4、<strong>用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</strong></p>\n<p>5、<strong>服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</strong></p>\n</blockquote>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><blockquote>\n<p>扩展性不够好单机当然没有问题，如果是服务器集群，就要求 session 数据共享，每台服务器都能够读取 session。</p>\n</blockquote>\n<h2 id=\"JWT以及具体实现\"><a href=\"#JWT以及具体实现\" class=\"headerlink\" title=\"JWT以及具体实现\"></a>JWT以及具体实现</h2><h3 id=\"JWT鉴权的简单流程\"><a href=\"#JWT鉴权的简单流程\" class=\"headerlink\" title=\"JWT鉴权的简单流程\"></a>JWT鉴权的简单流程</h3><h3 id=\"JWT分为三部分\"><a href=\"#JWT分为三部分\" class=\"headerlink\" title=\"JWT分为三部分\"></a>JWT分为三部分</h3><blockquote>\n<p>Header（包含加密方式等）</p>\n</blockquote>\n<pre><code>{\n  &quot;alg&quot;: &quot;HS256&quot;,// 默认签名算法\n  &quot;typ&quot;: &quot;JWT&quot; // 类型\n}\n</code></pre><blockquote>\n<p>Payload（包含用户必要信息，以及过期时间等）</p>\n</blockquote>\n<pre><code>iss (issuer)：签发人\nexp (expiration time)：过期时间\nsub (subject)：主题\naud (audience)：受众\nnbf (Not Before)：生效时间\niat (Issued At)：签发时间\njti (JWT ID)：编号\n\n用来存放需要传递的实际数据\n</code></pre><blockquote>\n<p>Signature（针对前两部分生成，防止数据篡改）。</p>\n</blockquote>\n<h3 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h3><pre><code>用户登录成功后，后台根据用户信息加上一个用户唯一的密钥值，生成一串字符串，即Token串，将其设置\n在Cookie中；\n用户下次带Token访问，系统会先根据前两部分以及密钥值，对Token进行有效性以及正确性的验证，如果       \n验证通过的话，再执行下一步操作...\n</code></pre><h4 id=\"如果要写入私密数据时需要加密\"><a href=\"#如果要写入私密数据时需要加密\" class=\"headerlink\" title=\"如果要写入私密数据时需要加密\"></a>如果要写入私密数据时需要加密</h4><pre><code>const token = jwt.sign({...getu},&quot;usermessag&quot;,{\n    expiresIn: 60*60*1  // 1小时过期\n  })\n</code></pre><h4 id=\"解密\"><a href=\"#解密\" class=\"headerlink\" title=\"解密\"></a>解密</h4><pre><code>jwt.verify(token,&#39;usermessag&#39;,(err, decode) =&gt; {\n    console.log(decode) // n拿到解密的值\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"json-web-token【跨域认证的解决方案】\"><a href=\"#json-web-token【跨域认证的解决方案】\" class=\"headerlink\" title=\"json web token【跨域认证的解决方案】\"></a>json web token【跨域认证的解决方案】</h2><h4 id=\"一般互联网认证用户流程\"><a href=\"#一般互联网认证用户流程\" class=\"headerlink\" title=\"一般互联网认证用户流程\"></a>一般互联网认证用户流程</h4><blockquote>\n<p>1.<strong>用户向服务器发送用户名和密码。</strong></p>\n</blockquote>\n<blockquote>\n<p>2、<strong>服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</strong></p>\n<p>3、<strong>服务器向用户返回一个 session_id，写入用户的 Cookie。</strong></p>\n<p>4、<strong>用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</strong></p>\n<p>5、<strong>服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</strong></p>\n</blockquote>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><blockquote>\n<p>扩展性不够好单机当然没有问题，如果是服务器集群，就要求 session 数据共享，每台服务器都能够读取 session。</p>\n</blockquote>\n<h2 id=\"JWT以及具体实现\"><a href=\"#JWT以及具体实现\" class=\"headerlink\" title=\"JWT以及具体实现\"></a>JWT以及具体实现</h2><h3 id=\"JWT鉴权的简单流程\"><a href=\"#JWT鉴权的简单流程\" class=\"headerlink\" title=\"JWT鉴权的简单流程\"></a>JWT鉴权的简单流程</h3><h3 id=\"JWT分为三部分\"><a href=\"#JWT分为三部分\" class=\"headerlink\" title=\"JWT分为三部分\"></a>JWT分为三部分</h3><blockquote>\n<p>Header（包含加密方式等）</p>\n</blockquote>\n<pre><code>{\n  &quot;alg&quot;: &quot;HS256&quot;,// 默认签名算法\n  &quot;typ&quot;: &quot;JWT&quot; // 类型\n}\n</code></pre><blockquote>\n<p>Payload（包含用户必要信息，以及过期时间等）</p>\n</blockquote>\n<pre><code>iss (issuer)：签发人\nexp (expiration time)：过期时间\nsub (subject)：主题\naud (audience)：受众\nnbf (Not Before)：生效时间\niat (Issued At)：签发时间\njti (JWT ID)：编号\n\n用来存放需要传递的实际数据\n</code></pre><blockquote>\n<p>Signature（针对前两部分生成，防止数据篡改）。</p>\n</blockquote>\n<h3 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h3><pre><code>用户登录成功后，后台根据用户信息加上一个用户唯一的密钥值，生成一串字符串，即Token串，将其设置\n在Cookie中；\n用户下次带Token访问，系统会先根据前两部分以及密钥值，对Token进行有效性以及正确性的验证，如果       \n验证通过的话，再执行下一步操作...\n</code></pre><h4 id=\"如果要写入私密数据时需要加密\"><a href=\"#如果要写入私密数据时需要加密\" class=\"headerlink\" title=\"如果要写入私密数据时需要加密\"></a>如果要写入私密数据时需要加密</h4><pre><code>const token = jwt.sign({...getu},&quot;usermessag&quot;,{\n    expiresIn: 60*60*1  // 1小时过期\n  })\n</code></pre><h4 id=\"解密\"><a href=\"#解密\" class=\"headerlink\" title=\"解密\"></a>解密</h4><pre><code>jwt.verify(token,&#39;usermessag&#39;,(err, decode) =&gt; {\n    console.log(decode) // n拿到解密的值\n}\n</code></pre>"},{"title":"centos7中安装mysql的步骤","date":"2019-03-28T01:22:06.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"# centos7中安装mysql的步骤\n\n\n## 一、   安装：\n\n> 1.   下载源码包，一般将源码包放在/usr/local/中；\n\n    cd /usr/local/\n    \n    mkdir -p tools\n    \n    cd tools\n    \n    wget http://repo.mysql.com/mysql57-community-release-el7-8.noarch.rpm\n\n**(这里的版本可以随时去mysql官网进行选择)**\n\n> 2.   查看系统中是否已安装 MySQL 服务\n\n    rpm -qa | grep mysql\n    或\n    yum list installed | grep mysql\n\n> 3.   如果已安装则删除 MySQL 及其依赖的包：\n\n    yum -y remove mysql-libs.x86_64\n\n> 4.   安装 mysql57-community-release-el7-8.noarch.rpm：\n\n    rpm -ivh mysql57-community-release-el7-8.noarch.rpm\n\n> 安装完后，得到如下两个包：（在/etc/yum.repos.d/文件下）\n\n    mysql-community.repo\n    mysql-community-source.repo\n\n> 5.   安装mysql\n\n    $ yum install mysql-server\n\n**根据步骤安装就可以了，不过安装完成后，没有密码，需要重置密码。**\n> \n> 6.重置密码：\n\n    mysql -u root；\n\n> 报错：ERROR 2002 (HY000): Can‘t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock‘ (2)，原因是/var/lib/mysql的访问权限问题。下面的命令把/var/lib/mysql的拥有者改为当前用户：\n\n    sudo chown -R openscanner:openscanner /var/lib/mysql\n\n> 重启服务：\n\n     service mysqld restart\n\n> 再次登录:\n\n    mysql -u root\n\n> 报错：\n\n> error 1045 (28000):Access denied for user ‘root’ @ ‘localhost’ (using password: NO）\n\n**此种情况是因为存在了默认密码问题，解决：（最保险的是重置root密码）**\n\n> 1、修改 /etc/my.cnf，在 [mysqld] 小节下添加一行：skip-grant-tables=1\n> \n> 这一行配置让 mysqld 启动时不对密码进行验证\n> \n> 2、重启 mysqld 服务：systemctl restart mysqld\n> \n> 3、使用 root 用户登录到 mysql：mysql -u root \n> \n> 4、切换到mysql数据库，更新 user 表：\n\n    update user set authentication_string = password('root'),host='%',password_expired = 'N', password_last_changed = now() where user = 'root';\n\n> 在之前的版本中，密码字段的字段名是 password，5.7版本改为了 authentication_string\n\n> 5、退出 mysql，编辑 /etc/my.cnf 文件，删除 skip-grant-tables=1 的内容\n> \n> 6、重启 mysqld 服务，再用新密码登录即可\n\n \n\n> 7.   开放防火墙：\n\n    vim /etc/sysconfig/iptables\n\n> 添加以下内容：\n\n    -A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT\n\n> 保存后重启防火墙：\n\n    $ sudo service iptables restart\n\n> 这样从其它客户机也可以连接上mysql服务了。\n> \n\n----------\n\n\n> 8.   阿里云安全组设置：\n\n**如果此时在其他客户机上还是链接不上mysql，登录阿里云，查看实例的安全组有没有为3306端口开启规则；**","source":"_posts/mysql.md","raw":"---\ntitle: centos7中安装mysql的步骤\ndate: '3/28/2019 9:22:06 AM '\ntag: ['mysql', 'linux服务器配置']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n# centos7中安装mysql的步骤\n\n\n## 一、   安装：\n\n> 1.   下载源码包，一般将源码包放在/usr/local/中；\n\n    cd /usr/local/\n    \n    mkdir -p tools\n    \n    cd tools\n    \n    wget http://repo.mysql.com/mysql57-community-release-el7-8.noarch.rpm\n\n**(这里的版本可以随时去mysql官网进行选择)**\n\n> 2.   查看系统中是否已安装 MySQL 服务\n\n    rpm -qa | grep mysql\n    或\n    yum list installed | grep mysql\n\n> 3.   如果已安装则删除 MySQL 及其依赖的包：\n\n    yum -y remove mysql-libs.x86_64\n\n> 4.   安装 mysql57-community-release-el7-8.noarch.rpm：\n\n    rpm -ivh mysql57-community-release-el7-8.noarch.rpm\n\n> 安装完后，得到如下两个包：（在/etc/yum.repos.d/文件下）\n\n    mysql-community.repo\n    mysql-community-source.repo\n\n> 5.   安装mysql\n\n    $ yum install mysql-server\n\n**根据步骤安装就可以了，不过安装完成后，没有密码，需要重置密码。**\n> \n> 6.重置密码：\n\n    mysql -u root；\n\n> 报错：ERROR 2002 (HY000): Can‘t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock‘ (2)，原因是/var/lib/mysql的访问权限问题。下面的命令把/var/lib/mysql的拥有者改为当前用户：\n\n    sudo chown -R openscanner:openscanner /var/lib/mysql\n\n> 重启服务：\n\n     service mysqld restart\n\n> 再次登录:\n\n    mysql -u root\n\n> 报错：\n\n> error 1045 (28000):Access denied for user ‘root’ @ ‘localhost’ (using password: NO）\n\n**此种情况是因为存在了默认密码问题，解决：（最保险的是重置root密码）**\n\n> 1、修改 /etc/my.cnf，在 [mysqld] 小节下添加一行：skip-grant-tables=1\n> \n> 这一行配置让 mysqld 启动时不对密码进行验证\n> \n> 2、重启 mysqld 服务：systemctl restart mysqld\n> \n> 3、使用 root 用户登录到 mysql：mysql -u root \n> \n> 4、切换到mysql数据库，更新 user 表：\n\n    update user set authentication_string = password('root'),host='%',password_expired = 'N', password_last_changed = now() where user = 'root';\n\n> 在之前的版本中，密码字段的字段名是 password，5.7版本改为了 authentication_string\n\n> 5、退出 mysql，编辑 /etc/my.cnf 文件，删除 skip-grant-tables=1 的内容\n> \n> 6、重启 mysqld 服务，再用新密码登录即可\n\n \n\n> 7.   开放防火墙：\n\n    vim /etc/sysconfig/iptables\n\n> 添加以下内容：\n\n    -A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT\n\n> 保存后重启防火墙：\n\n    $ sudo service iptables restart\n\n> 这样从其它客户机也可以连接上mysql服务了。\n> \n\n----------\n\n\n> 8.   阿里云安全组设置：\n\n**如果此时在其他客户机上还是链接不上mysql，登录阿里云，查看实例的安全组有没有为3306端口开启规则；**","slug":"mysql","published":1,"updated":"2019-03-28T01:23:10.405Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam730018n4wdz7yu9pw4","content":"<h1 id=\"centos7中安装mysql的步骤\"><a href=\"#centos7中安装mysql的步骤\" class=\"headerlink\" title=\"centos7中安装mysql的步骤\"></a>centos7中安装mysql的步骤</h1><h2 id=\"一、-安装：\"><a href=\"#一、-安装：\" class=\"headerlink\" title=\"一、   安装：\"></a>一、   安装：</h2><blockquote>\n<ol>\n<li>下载源码包，一般将源码包放在/usr/local/中；</li>\n</ol>\n</blockquote>\n<pre><code>cd /usr/local/\n\nmkdir -p tools\n\ncd tools\n\nwget http://repo.mysql.com/mysql57-community-release-el7-8.noarch.rpm\n</code></pre><p><strong>(这里的版本可以随时去mysql官网进行选择)</strong></p>\n<blockquote>\n<ol start=\"2\">\n<li>查看系统中是否已安装 MySQL 服务</li>\n</ol>\n</blockquote>\n<pre><code>rpm -qa | grep mysql\n或\nyum list installed | grep mysql\n</code></pre><blockquote>\n<ol start=\"3\">\n<li>如果已安装则删除 MySQL 及其依赖的包：</li>\n</ol>\n</blockquote>\n<pre><code>yum -y remove mysql-libs.x86_64\n</code></pre><blockquote>\n<ol start=\"4\">\n<li>安装 mysql57-community-release-el7-8.noarch.rpm：</li>\n</ol>\n</blockquote>\n<pre><code>rpm -ivh mysql57-community-release-el7-8.noarch.rpm\n</code></pre><blockquote>\n<p>安装完后，得到如下两个包：（在/etc/yum.repos.d/文件下）</p>\n</blockquote>\n<pre><code>mysql-community.repo\nmysql-community-source.repo\n</code></pre><blockquote>\n<ol start=\"5\">\n<li>安装mysql</li>\n</ol>\n</blockquote>\n<pre><code>$ yum install mysql-server\n</code></pre><p><strong>根据步骤安装就可以了，不过安装完成后，没有密码，需要重置密码。</strong></p>\n<blockquote>\n<p>6.重置密码：</p>\n</blockquote>\n<pre><code>mysql -u root；\n</code></pre><blockquote>\n<p>报错：ERROR 2002 (HY000): Can‘t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock‘ (2)，原因是/var/lib/mysql的访问权限问题。下面的命令把/var/lib/mysql的拥有者改为当前用户：</p>\n</blockquote>\n<pre><code>sudo chown -R openscanner:openscanner /var/lib/mysql\n</code></pre><blockquote>\n<p>重启服务：</p>\n</blockquote>\n<pre><code> service mysqld restart\n</code></pre><blockquote>\n<p>再次登录:</p>\n</blockquote>\n<pre><code>mysql -u root\n</code></pre><blockquote>\n<p>报错：</p>\n</blockquote>\n<blockquote>\n<p>error 1045 (28000):Access denied for user ‘root’ @ ‘localhost’ (using password: NO）</p>\n</blockquote>\n<p><strong>此种情况是因为存在了默认密码问题，解决：（最保险的是重置root密码）</strong></p>\n<blockquote>\n<p>1、修改 /etc/my.cnf，在 [mysqld] 小节下添加一行：skip-grant-tables=1</p>\n<p>这一行配置让 mysqld 启动时不对密码进行验证</p>\n<p>2、重启 mysqld 服务：systemctl restart mysqld</p>\n<p>3、使用 root 用户登录到 mysql：mysql -u root </p>\n<p>4、切换到mysql数据库，更新 user 表：</p>\n</blockquote>\n<pre><code>update user set authentication_string = password(&#39;root&#39;),host=&#39;%&#39;,password_expired = &#39;N&#39;, password_last_changed = now() where user = &#39;root&#39;;\n</code></pre><blockquote>\n<p>在之前的版本中，密码字段的字段名是 password，5.7版本改为了 authentication_string</p>\n</blockquote>\n<blockquote>\n<p>5、退出 mysql，编辑 /etc/my.cnf 文件，删除 skip-grant-tables=1 的内容</p>\n<p>6、重启 mysqld 服务，再用新密码登录即可</p>\n</blockquote>\n<blockquote>\n<ol start=\"7\">\n<li>开放防火墙：</li>\n</ol>\n</blockquote>\n<pre><code>vim /etc/sysconfig/iptables\n</code></pre><blockquote>\n<p>添加以下内容：</p>\n</blockquote>\n<pre><code>-A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT\n</code></pre><blockquote>\n<p>保存后重启防火墙：</p>\n</blockquote>\n<pre><code>$ sudo service iptables restart\n</code></pre><blockquote>\n<p>这样从其它客户机也可以连接上mysql服务了。</p>\n</blockquote>\n<hr>\n<blockquote>\n<ol start=\"8\">\n<li>阿里云安全组设置：</li>\n</ol>\n</blockquote>\n<p><strong>如果此时在其他客户机上还是链接不上mysql，登录阿里云，查看实例的安全组有没有为3306端口开启规则；</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"centos7中安装mysql的步骤\"><a href=\"#centos7中安装mysql的步骤\" class=\"headerlink\" title=\"centos7中安装mysql的步骤\"></a>centos7中安装mysql的步骤</h1><h2 id=\"一、-安装：\"><a href=\"#一、-安装：\" class=\"headerlink\" title=\"一、   安装：\"></a>一、   安装：</h2><blockquote>\n<ol>\n<li>下载源码包，一般将源码包放在/usr/local/中；</li>\n</ol>\n</blockquote>\n<pre><code>cd /usr/local/\n\nmkdir -p tools\n\ncd tools\n\nwget http://repo.mysql.com/mysql57-community-release-el7-8.noarch.rpm\n</code></pre><p><strong>(这里的版本可以随时去mysql官网进行选择)</strong></p>\n<blockquote>\n<ol start=\"2\">\n<li>查看系统中是否已安装 MySQL 服务</li>\n</ol>\n</blockquote>\n<pre><code>rpm -qa | grep mysql\n或\nyum list installed | grep mysql\n</code></pre><blockquote>\n<ol start=\"3\">\n<li>如果已安装则删除 MySQL 及其依赖的包：</li>\n</ol>\n</blockquote>\n<pre><code>yum -y remove mysql-libs.x86_64\n</code></pre><blockquote>\n<ol start=\"4\">\n<li>安装 mysql57-community-release-el7-8.noarch.rpm：</li>\n</ol>\n</blockquote>\n<pre><code>rpm -ivh mysql57-community-release-el7-8.noarch.rpm\n</code></pre><blockquote>\n<p>安装完后，得到如下两个包：（在/etc/yum.repos.d/文件下）</p>\n</blockquote>\n<pre><code>mysql-community.repo\nmysql-community-source.repo\n</code></pre><blockquote>\n<ol start=\"5\">\n<li>安装mysql</li>\n</ol>\n</blockquote>\n<pre><code>$ yum install mysql-server\n</code></pre><p><strong>根据步骤安装就可以了，不过安装完成后，没有密码，需要重置密码。</strong></p>\n<blockquote>\n<p>6.重置密码：</p>\n</blockquote>\n<pre><code>mysql -u root；\n</code></pre><blockquote>\n<p>报错：ERROR 2002 (HY000): Can‘t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock‘ (2)，原因是/var/lib/mysql的访问权限问题。下面的命令把/var/lib/mysql的拥有者改为当前用户：</p>\n</blockquote>\n<pre><code>sudo chown -R openscanner:openscanner /var/lib/mysql\n</code></pre><blockquote>\n<p>重启服务：</p>\n</blockquote>\n<pre><code> service mysqld restart\n</code></pre><blockquote>\n<p>再次登录:</p>\n</blockquote>\n<pre><code>mysql -u root\n</code></pre><blockquote>\n<p>报错：</p>\n</blockquote>\n<blockquote>\n<p>error 1045 (28000):Access denied for user ‘root’ @ ‘localhost’ (using password: NO）</p>\n</blockquote>\n<p><strong>此种情况是因为存在了默认密码问题，解决：（最保险的是重置root密码）</strong></p>\n<blockquote>\n<p>1、修改 /etc/my.cnf，在 [mysqld] 小节下添加一行：skip-grant-tables=1</p>\n<p>这一行配置让 mysqld 启动时不对密码进行验证</p>\n<p>2、重启 mysqld 服务：systemctl restart mysqld</p>\n<p>3、使用 root 用户登录到 mysql：mysql -u root </p>\n<p>4、切换到mysql数据库，更新 user 表：</p>\n</blockquote>\n<pre><code>update user set authentication_string = password(&#39;root&#39;),host=&#39;%&#39;,password_expired = &#39;N&#39;, password_last_changed = now() where user = &#39;root&#39;;\n</code></pre><blockquote>\n<p>在之前的版本中，密码字段的字段名是 password，5.7版本改为了 authentication_string</p>\n</blockquote>\n<blockquote>\n<p>5、退出 mysql，编辑 /etc/my.cnf 文件，删除 skip-grant-tables=1 的内容</p>\n<p>6、重启 mysqld 服务，再用新密码登录即可</p>\n</blockquote>\n<blockquote>\n<ol start=\"7\">\n<li>开放防火墙：</li>\n</ol>\n</blockquote>\n<pre><code>vim /etc/sysconfig/iptables\n</code></pre><blockquote>\n<p>添加以下内容：</p>\n</blockquote>\n<pre><code>-A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT\n</code></pre><blockquote>\n<p>保存后重启防火墙：</p>\n</blockquote>\n<pre><code>$ sudo service iptables restart\n</code></pre><blockquote>\n<p>这样从其它客户机也可以连接上mysql服务了。</p>\n</blockquote>\n<hr>\n<blockquote>\n<ol start=\"8\">\n<li>阿里云安全组设置：</li>\n</ol>\n</blockquote>\n<p><strong>如果此时在其他客户机上还是链接不上mysql，登录阿里云，查看实例的安全组有没有为3306端口开启规则；</strong></p>\n"},{"title":"centos7中搭建nginx服务器","date":"2019-03-28T01:22:52.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"# centos7中搭建nginx服务器\n\n\n> **nginx可以使用各平台的默认包来安装，本文是介绍使用源码编译安装，包括具体的编译参数信息。\n正式开始前，编译环境gcc g++ 开发库之类的需要提前装好，这里默认你已经装好。**\n\n### centos平台编译环境使用如下指令\n\n> 安装make：\n\n \n\n\tyum -y install gcc automake autoconf libtool make\n\n \n\n> 安装g++:\n\n \n\n\tyum install gcc gcc-c++\n\n \n\n## 下面正式开始：\n\n### 一般我们都需要先装pcre, zlib，前者为了重写rewrite，后者为了gzip压缩。\n\n**注：下面所使用的所有版本均为截止2017年8月14号，最新版本**\n\n> 1.选定源码目录\n> 可以是任何目录，本文选定的是/usr/local/src\n\n\tcd /usr/local/src\n\n \n\n> 2.安装PCRE库\n> ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/ 下载最新的 PCRE 源码包，使用下面命令下载编译和安装 PCRE 包：\n\n \n\n\tcd /usr/local/src\n\n\twget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.41.tar.gz\n\n\ttar -zxvf pcre-8.41.tar.gz\n\n\tcd pcre-8.41\n\n\t./configure\n\n\tmake\n\n\tmake install\n\n \n\n \n> \n> 3.安装zlib库\n> http://zlib.net/zlib-1.2.11.tar.gz 下载最新的 zlib 源码包，使用下面命令下载编译和安装 zlib包：\n\n \n\n\n\tcd /usr/local/src\n\n\twget   http://zlib.net/zlib-1.2.11.tar.gz\n\n\ttar -zxvf zlib-1.2.11.tar.gz\n\n\tcd zlib-1.2.11\n\n\t./configure\n\n\tmake\n\n\tmake install\n\n \n\n> 4.安装ssl（某些vps默认没装ssl)\n\n \n\n\tcd /usr/local/src\n\n\twget https://www.openssl.org/source/openssl-1.0.2l.tar.gz\n\n\ttar -zxvf openssl-1.0.2l.tar.gz\n\n \n\n> 5.安装nginx\n\n**Nginx 一般有两个版本，分别是稳定版和开发版，您可以根据您的目的来选择这两个版本的其中一个，下面是把 Nginx 安装到 /usr/local/nginx 目录下的详细步骤：**\n\n \n\n\tcd /usr/local/src\n\n\twget http://nginx.org/download/nginx-1.13.4.tar.gz\n\t\n\ttar -zxvf nginx-1.13.4.tar.gz\n\n\tcd nginx-1.13.4\n\n \n\n\t./configure --sbin-path=/usr/local/nginx/nginx\n\n\t--conf-path=/usr/local/nginx/nginx.conf\n\n\t--pid-path=/usr/local/nginx/nginx.pid\n\n\t--with-http_ssl_module\n\n\t--with-pcre=/usr/local/src/pcre-8.41\n\n\t--with-zlib=/usr/local/src/zlib-1.2.11\n\n\t--with-openssl=/usr/local/src/openssl-1.0.2l\n\n \n\n\tmake\n\n\tmake install\n\n \n\n>  --with-pcre=/usr/local/src/pcre-8.41 指的是pcre-8.41 的源码路径。\n> --with-zlib=/usr/local/src/zlib-1.2.11 指的是zlib-1.2.11 的源码路径。\n\n \n\n> 安装成功：\n\n**安装成功后 /usr/local/nginx 会有此目录**\n\n \n\n \n\n> 6.启动\n\n**确保系统的 80 端口没被其他程序占用，运行/usr/local/nginx/nginx 命令来启动 Nginx，**\n\n \n\n> 打开浏览器访问此机器的 IP，如果浏览器出现 Welcome to nginx! 则表示 Nginx 已经安装并运行成功。\n> \n> \n> 到这里nginx就安装完成了，如果只是处理静态html就不用继续安装了\n> \n> 如果你需要处理php脚本的话，还需要安装php-fpm。\n\n \n\n \n\n## 常见错误：\n\n附：可能遇到的错误和一些帮助信息\n\n1.1编译pcre错误\n\n \n\t\n\tmake[1]: Leaving directory `/usr/local/src/pcre-8.34'\n\t\n\tmake: *** [all] Error 2\n\n \n\n> 解决办法：安装g++,别忘了重新configure\n\n \n\n\tapt-get install g++\n\t\n\tapt-get install build-essential\n\t\n\tmake clean\n\t\n\t./configure\n\t\n\tmake\n\n \n\n \n\n> 1.2 make出错\n\n \n\n\tmake: *** No targets specified and no makefile found.  Stop.\n\n \n\n**按照下面安装方法**\n\n\n    yum -y install openssl openssl-devel\n\n\n> 2.nginx编译选项（下面代码必须在一行）\n\n \n\n    ./configure --sbin-path=/usr/local/nginx/nginx\n    \n    --conf-path=/usr/local/nginx/nginx.conf\n    \n    --pid-path=/usr/local/nginx/nginx.pid\n    \n    --with-http_ssl_module\n    \n    --with-pcre=/usr/local/src/pcre-8.41\n    \n    --with-zlib=/usr/local/src/zlib-1.2.11\n    \n    --with-openssl=/usr/local/src/openssl-1.0.2l\n    \n","source":"_posts/ngsinx.md","raw":"---\ntitle: centos7中搭建nginx服务器\ndate: '3/28/2019 9:22:52 AM '\ntag: ['nginx', 'linux服务器配置']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n# centos7中搭建nginx服务器\n\n\n> **nginx可以使用各平台的默认包来安装，本文是介绍使用源码编译安装，包括具体的编译参数信息。\n正式开始前，编译环境gcc g++ 开发库之类的需要提前装好，这里默认你已经装好。**\n\n### centos平台编译环境使用如下指令\n\n> 安装make：\n\n \n\n\tyum -y install gcc automake autoconf libtool make\n\n \n\n> 安装g++:\n\n \n\n\tyum install gcc gcc-c++\n\n \n\n## 下面正式开始：\n\n### 一般我们都需要先装pcre, zlib，前者为了重写rewrite，后者为了gzip压缩。\n\n**注：下面所使用的所有版本均为截止2017年8月14号，最新版本**\n\n> 1.选定源码目录\n> 可以是任何目录，本文选定的是/usr/local/src\n\n\tcd /usr/local/src\n\n \n\n> 2.安装PCRE库\n> ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/ 下载最新的 PCRE 源码包，使用下面命令下载编译和安装 PCRE 包：\n\n \n\n\tcd /usr/local/src\n\n\twget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.41.tar.gz\n\n\ttar -zxvf pcre-8.41.tar.gz\n\n\tcd pcre-8.41\n\n\t./configure\n\n\tmake\n\n\tmake install\n\n \n\n \n> \n> 3.安装zlib库\n> http://zlib.net/zlib-1.2.11.tar.gz 下载最新的 zlib 源码包，使用下面命令下载编译和安装 zlib包：\n\n \n\n\n\tcd /usr/local/src\n\n\twget   http://zlib.net/zlib-1.2.11.tar.gz\n\n\ttar -zxvf zlib-1.2.11.tar.gz\n\n\tcd zlib-1.2.11\n\n\t./configure\n\n\tmake\n\n\tmake install\n\n \n\n> 4.安装ssl（某些vps默认没装ssl)\n\n \n\n\tcd /usr/local/src\n\n\twget https://www.openssl.org/source/openssl-1.0.2l.tar.gz\n\n\ttar -zxvf openssl-1.0.2l.tar.gz\n\n \n\n> 5.安装nginx\n\n**Nginx 一般有两个版本，分别是稳定版和开发版，您可以根据您的目的来选择这两个版本的其中一个，下面是把 Nginx 安装到 /usr/local/nginx 目录下的详细步骤：**\n\n \n\n\tcd /usr/local/src\n\n\twget http://nginx.org/download/nginx-1.13.4.tar.gz\n\t\n\ttar -zxvf nginx-1.13.4.tar.gz\n\n\tcd nginx-1.13.4\n\n \n\n\t./configure --sbin-path=/usr/local/nginx/nginx\n\n\t--conf-path=/usr/local/nginx/nginx.conf\n\n\t--pid-path=/usr/local/nginx/nginx.pid\n\n\t--with-http_ssl_module\n\n\t--with-pcre=/usr/local/src/pcre-8.41\n\n\t--with-zlib=/usr/local/src/zlib-1.2.11\n\n\t--with-openssl=/usr/local/src/openssl-1.0.2l\n\n \n\n\tmake\n\n\tmake install\n\n \n\n>  --with-pcre=/usr/local/src/pcre-8.41 指的是pcre-8.41 的源码路径。\n> --with-zlib=/usr/local/src/zlib-1.2.11 指的是zlib-1.2.11 的源码路径。\n\n \n\n> 安装成功：\n\n**安装成功后 /usr/local/nginx 会有此目录**\n\n \n\n \n\n> 6.启动\n\n**确保系统的 80 端口没被其他程序占用，运行/usr/local/nginx/nginx 命令来启动 Nginx，**\n\n \n\n> 打开浏览器访问此机器的 IP，如果浏览器出现 Welcome to nginx! 则表示 Nginx 已经安装并运行成功。\n> \n> \n> 到这里nginx就安装完成了，如果只是处理静态html就不用继续安装了\n> \n> 如果你需要处理php脚本的话，还需要安装php-fpm。\n\n \n\n \n\n## 常见错误：\n\n附：可能遇到的错误和一些帮助信息\n\n1.1编译pcre错误\n\n \n\t\n\tmake[1]: Leaving directory `/usr/local/src/pcre-8.34'\n\t\n\tmake: *** [all] Error 2\n\n \n\n> 解决办法：安装g++,别忘了重新configure\n\n \n\n\tapt-get install g++\n\t\n\tapt-get install build-essential\n\t\n\tmake clean\n\t\n\t./configure\n\t\n\tmake\n\n \n\n \n\n> 1.2 make出错\n\n \n\n\tmake: *** No targets specified and no makefile found.  Stop.\n\n \n\n**按照下面安装方法**\n\n\n    yum -y install openssl openssl-devel\n\n\n> 2.nginx编译选项（下面代码必须在一行）\n\n \n\n    ./configure --sbin-path=/usr/local/nginx/nginx\n    \n    --conf-path=/usr/local/nginx/nginx.conf\n    \n    --pid-path=/usr/local/nginx/nginx.pid\n    \n    --with-http_ssl_module\n    \n    --with-pcre=/usr/local/src/pcre-8.41\n    \n    --with-zlib=/usr/local/src/zlib-1.2.11\n    \n    --with-openssl=/usr/local/src/openssl-1.0.2l\n    \n","slug":"ngsinx","published":1,"updated":"2019-03-28T01:22:54.976Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam75001bn4wdcy6678s5","content":"<h1 id=\"centos7中搭建nginx服务器\"><a href=\"#centos7中搭建nginx服务器\" class=\"headerlink\" title=\"centos7中搭建nginx服务器\"></a>centos7中搭建nginx服务器</h1><blockquote>\n<p><strong>nginx可以使用各平台的默认包来安装，本文是介绍使用源码编译安装，包括具体的编译参数信息。<br>正式开始前，编译环境gcc g++ 开发库之类的需要提前装好，这里默认你已经装好。</strong></p>\n</blockquote>\n<h3 id=\"centos平台编译环境使用如下指令\"><a href=\"#centos平台编译环境使用如下指令\" class=\"headerlink\" title=\"centos平台编译环境使用如下指令\"></a>centos平台编译环境使用如下指令</h3><blockquote>\n<p>安装make：</p>\n</blockquote>\n<pre><code>yum -y install gcc automake autoconf libtool make\n</code></pre><blockquote>\n<p>安装g++:</p>\n</blockquote>\n<pre><code>yum install gcc gcc-c++\n</code></pre><h2 id=\"下面正式开始：\"><a href=\"#下面正式开始：\" class=\"headerlink\" title=\"下面正式开始：\"></a>下面正式开始：</h2><h3 id=\"一般我们都需要先装pcre-zlib，前者为了重写rewrite，后者为了gzip压缩。\"><a href=\"#一般我们都需要先装pcre-zlib，前者为了重写rewrite，后者为了gzip压缩。\" class=\"headerlink\" title=\"一般我们都需要先装pcre, zlib，前者为了重写rewrite，后者为了gzip压缩。\"></a>一般我们都需要先装pcre, zlib，前者为了重写rewrite，后者为了gzip压缩。</h3><p><strong>注：下面所使用的所有版本均为截止2017年8月14号，最新版本</strong></p>\n<blockquote>\n<p>1.选定源码目录<br>可以是任何目录，本文选定的是/usr/local/src</p>\n</blockquote>\n<pre><code>cd /usr/local/src\n</code></pre><blockquote>\n<p>2.安装PCRE库<br><a href=\"ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/\" target=\"_blank\" rel=\"noopener\">ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/</a> 下载最新的 PCRE 源码包，使用下面命令下载编译和安装 PCRE 包：</p>\n</blockquote>\n<pre><code>cd /usr/local/src\n\nwget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.41.tar.gz\n\ntar -zxvf pcre-8.41.tar.gz\n\ncd pcre-8.41\n\n./configure\n\nmake\n\nmake install\n</code></pre><blockquote>\n<p>3.安装zlib库<br><a href=\"http://zlib.net/zlib-1.2.11.tar.gz\" target=\"_blank\" rel=\"noopener\">http://zlib.net/zlib-1.2.11.tar.gz</a> 下载最新的 zlib 源码包，使用下面命令下载编译和安装 zlib包：</p>\n</blockquote>\n<pre><code>cd /usr/local/src\n\nwget   http://zlib.net/zlib-1.2.11.tar.gz\n\ntar -zxvf zlib-1.2.11.tar.gz\n\ncd zlib-1.2.11\n\n./configure\n\nmake\n\nmake install\n</code></pre><blockquote>\n<p>4.安装ssl（某些vps默认没装ssl)</p>\n</blockquote>\n<pre><code>cd /usr/local/src\n\nwget https://www.openssl.org/source/openssl-1.0.2l.tar.gz\n\ntar -zxvf openssl-1.0.2l.tar.gz\n</code></pre><blockquote>\n<p>5.安装nginx</p>\n</blockquote>\n<p><strong>Nginx 一般有两个版本，分别是稳定版和开发版，您可以根据您的目的来选择这两个版本的其中一个，下面是把 Nginx 安装到 /usr/local/nginx 目录下的详细步骤：</strong></p>\n<pre><code>cd /usr/local/src\n\nwget http://nginx.org/download/nginx-1.13.4.tar.gz\n\ntar -zxvf nginx-1.13.4.tar.gz\n\ncd nginx-1.13.4\n\n\n\n./configure --sbin-path=/usr/local/nginx/nginx\n\n--conf-path=/usr/local/nginx/nginx.conf\n\n--pid-path=/usr/local/nginx/nginx.pid\n\n--with-http_ssl_module\n\n--with-pcre=/usr/local/src/pcre-8.41\n\n--with-zlib=/usr/local/src/zlib-1.2.11\n\n--with-openssl=/usr/local/src/openssl-1.0.2l\n\n\n\nmake\n\nmake install\n</code></pre><blockquote>\n<p> –with-pcre=/usr/local/src/pcre-8.41 指的是pcre-8.41 的源码路径。<br>–with-zlib=/usr/local/src/zlib-1.2.11 指的是zlib-1.2.11 的源码路径。</p>\n</blockquote>\n<blockquote>\n<p>安装成功：</p>\n</blockquote>\n<p><strong>安装成功后 /usr/local/nginx 会有此目录</strong></p>\n<blockquote>\n<p>6.启动</p>\n</blockquote>\n<p><strong>确保系统的 80 端口没被其他程序占用，运行/usr/local/nginx/nginx 命令来启动 Nginx，</strong></p>\n<blockquote>\n<p>打开浏览器访问此机器的 IP，如果浏览器出现 Welcome to nginx! 则表示 Nginx 已经安装并运行成功。</p>\n<p>到这里nginx就安装完成了，如果只是处理静态html就不用继续安装了</p>\n<p>如果你需要处理php脚本的话，还需要安装php-fpm。</p>\n</blockquote>\n<h2 id=\"常见错误：\"><a href=\"#常见错误：\" class=\"headerlink\" title=\"常见错误：\"></a>常见错误：</h2><p>附：可能遇到的错误和一些帮助信息</p>\n<p>1.1编译pcre错误</p>\n<pre><code>make[1]: Leaving directory `/usr/local/src/pcre-8.34&#39;\n\nmake: *** [all] Error 2\n</code></pre><blockquote>\n<p>解决办法：安装g++,别忘了重新configure</p>\n</blockquote>\n<pre><code>apt-get install g++\n\napt-get install build-essential\n\nmake clean\n\n./configure\n\nmake\n</code></pre><blockquote>\n<p>1.2 make出错</p>\n</blockquote>\n<pre><code>make: *** No targets specified and no makefile found.  Stop.\n</code></pre><p><strong>按照下面安装方法</strong></p>\n<pre><code>yum -y install openssl openssl-devel\n</code></pre><blockquote>\n<p>2.nginx编译选项（下面代码必须在一行）</p>\n</blockquote>\n<pre><code>./configure --sbin-path=/usr/local/nginx/nginx\n\n--conf-path=/usr/local/nginx/nginx.conf\n\n--pid-path=/usr/local/nginx/nginx.pid\n\n--with-http_ssl_module\n\n--with-pcre=/usr/local/src/pcre-8.41\n\n--with-zlib=/usr/local/src/zlib-1.2.11\n\n--with-openssl=/usr/local/src/openssl-1.0.2l\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"centos7中搭建nginx服务器\"><a href=\"#centos7中搭建nginx服务器\" class=\"headerlink\" title=\"centos7中搭建nginx服务器\"></a>centos7中搭建nginx服务器</h1><blockquote>\n<p><strong>nginx可以使用各平台的默认包来安装，本文是介绍使用源码编译安装，包括具体的编译参数信息。<br>正式开始前，编译环境gcc g++ 开发库之类的需要提前装好，这里默认你已经装好。</strong></p>\n</blockquote>\n<h3 id=\"centos平台编译环境使用如下指令\"><a href=\"#centos平台编译环境使用如下指令\" class=\"headerlink\" title=\"centos平台编译环境使用如下指令\"></a>centos平台编译环境使用如下指令</h3><blockquote>\n<p>安装make：</p>\n</blockquote>\n<pre><code>yum -y install gcc automake autoconf libtool make\n</code></pre><blockquote>\n<p>安装g++:</p>\n</blockquote>\n<pre><code>yum install gcc gcc-c++\n</code></pre><h2 id=\"下面正式开始：\"><a href=\"#下面正式开始：\" class=\"headerlink\" title=\"下面正式开始：\"></a>下面正式开始：</h2><h3 id=\"一般我们都需要先装pcre-zlib，前者为了重写rewrite，后者为了gzip压缩。\"><a href=\"#一般我们都需要先装pcre-zlib，前者为了重写rewrite，后者为了gzip压缩。\" class=\"headerlink\" title=\"一般我们都需要先装pcre, zlib，前者为了重写rewrite，后者为了gzip压缩。\"></a>一般我们都需要先装pcre, zlib，前者为了重写rewrite，后者为了gzip压缩。</h3><p><strong>注：下面所使用的所有版本均为截止2017年8月14号，最新版本</strong></p>\n<blockquote>\n<p>1.选定源码目录<br>可以是任何目录，本文选定的是/usr/local/src</p>\n</blockquote>\n<pre><code>cd /usr/local/src\n</code></pre><blockquote>\n<p>2.安装PCRE库<br><a href=\"ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/\" target=\"_blank\" rel=\"noopener\">ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/</a> 下载最新的 PCRE 源码包，使用下面命令下载编译和安装 PCRE 包：</p>\n</blockquote>\n<pre><code>cd /usr/local/src\n\nwget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.41.tar.gz\n\ntar -zxvf pcre-8.41.tar.gz\n\ncd pcre-8.41\n\n./configure\n\nmake\n\nmake install\n</code></pre><blockquote>\n<p>3.安装zlib库<br><a href=\"http://zlib.net/zlib-1.2.11.tar.gz\" target=\"_blank\" rel=\"noopener\">http://zlib.net/zlib-1.2.11.tar.gz</a> 下载最新的 zlib 源码包，使用下面命令下载编译和安装 zlib包：</p>\n</blockquote>\n<pre><code>cd /usr/local/src\n\nwget   http://zlib.net/zlib-1.2.11.tar.gz\n\ntar -zxvf zlib-1.2.11.tar.gz\n\ncd zlib-1.2.11\n\n./configure\n\nmake\n\nmake install\n</code></pre><blockquote>\n<p>4.安装ssl（某些vps默认没装ssl)</p>\n</blockquote>\n<pre><code>cd /usr/local/src\n\nwget https://www.openssl.org/source/openssl-1.0.2l.tar.gz\n\ntar -zxvf openssl-1.0.2l.tar.gz\n</code></pre><blockquote>\n<p>5.安装nginx</p>\n</blockquote>\n<p><strong>Nginx 一般有两个版本，分别是稳定版和开发版，您可以根据您的目的来选择这两个版本的其中一个，下面是把 Nginx 安装到 /usr/local/nginx 目录下的详细步骤：</strong></p>\n<pre><code>cd /usr/local/src\n\nwget http://nginx.org/download/nginx-1.13.4.tar.gz\n\ntar -zxvf nginx-1.13.4.tar.gz\n\ncd nginx-1.13.4\n\n\n\n./configure --sbin-path=/usr/local/nginx/nginx\n\n--conf-path=/usr/local/nginx/nginx.conf\n\n--pid-path=/usr/local/nginx/nginx.pid\n\n--with-http_ssl_module\n\n--with-pcre=/usr/local/src/pcre-8.41\n\n--with-zlib=/usr/local/src/zlib-1.2.11\n\n--with-openssl=/usr/local/src/openssl-1.0.2l\n\n\n\nmake\n\nmake install\n</code></pre><blockquote>\n<p> –with-pcre=/usr/local/src/pcre-8.41 指的是pcre-8.41 的源码路径。<br>–with-zlib=/usr/local/src/zlib-1.2.11 指的是zlib-1.2.11 的源码路径。</p>\n</blockquote>\n<blockquote>\n<p>安装成功：</p>\n</blockquote>\n<p><strong>安装成功后 /usr/local/nginx 会有此目录</strong></p>\n<blockquote>\n<p>6.启动</p>\n</blockquote>\n<p><strong>确保系统的 80 端口没被其他程序占用，运行/usr/local/nginx/nginx 命令来启动 Nginx，</strong></p>\n<blockquote>\n<p>打开浏览器访问此机器的 IP，如果浏览器出现 Welcome to nginx! 则表示 Nginx 已经安装并运行成功。</p>\n<p>到这里nginx就安装完成了，如果只是处理静态html就不用继续安装了</p>\n<p>如果你需要处理php脚本的话，还需要安装php-fpm。</p>\n</blockquote>\n<h2 id=\"常见错误：\"><a href=\"#常见错误：\" class=\"headerlink\" title=\"常见错误：\"></a>常见错误：</h2><p>附：可能遇到的错误和一些帮助信息</p>\n<p>1.1编译pcre错误</p>\n<pre><code>make[1]: Leaving directory `/usr/local/src/pcre-8.34&#39;\n\nmake: *** [all] Error 2\n</code></pre><blockquote>\n<p>解决办法：安装g++,别忘了重新configure</p>\n</blockquote>\n<pre><code>apt-get install g++\n\napt-get install build-essential\n\nmake clean\n\n./configure\n\nmake\n</code></pre><blockquote>\n<p>1.2 make出错</p>\n</blockquote>\n<pre><code>make: *** No targets specified and no makefile found.  Stop.\n</code></pre><p><strong>按照下面安装方法</strong></p>\n<pre><code>yum -y install openssl openssl-devel\n</code></pre><blockquote>\n<p>2.nginx编译选项（下面代码必须在一行）</p>\n</blockquote>\n<pre><code>./configure --sbin-path=/usr/local/nginx/nginx\n\n--conf-path=/usr/local/nginx/nginx.conf\n\n--pid-path=/usr/local/nginx/nginx.pid\n\n--with-http_ssl_module\n\n--with-pcre=/usr/local/src/pcre-8.41\n\n--with-zlib=/usr/local/src/zlib-1.2.11\n\n--with-openssl=/usr/local/src/openssl-1.0.2l\n</code></pre>"},{"title":"vue混入【mixins】","date":"2019-04-02T03:42:35.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"## vue混入【mixins】\n\n**混入 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。**\n\n\t// 定义一个混入对象\n\tvar myMixin = {\n\t  created: function () {\n\t    this.hello()\n\t  },\n\t  methods: {\n\t    hello: function () {\n\t      console.log('hello from mixin!')\n\t    }\n\t  }\n\t}\n\t\n\t// 定义一个使用混入对象的组件\n\tvar Component = Vue.extend({\n\t  mixins: [myMixin]\n\t})\n\t\n\tvar component = new Component() // => \"hello from mixin!\"\n\n## 选项合并\n\n**当组件和混入对象含有同名选项时，这些选项将以恰当的方式混合。**\n\n**比如，数据对象在内部会进行递归合并，在和组件的数据发生冲突时以组件数据优先。**\n\n\tvar mixin = {\n\t  data: function () {\n\t    return {\n\t      message: 'hello',\n\t      foo: 'abc'\n\t    }\n\t  }\n\t}\n\t\n\tnew Vue({\n\t  mixins: [mixin],\n\t  data: function () {\n\t    return {\n\t      message: 'goodbye',\n\t      bar: 'def'\n\t    }\n\t  },\n\t  created: function () {\n\t    console.log(this.$data)\n\t    // => { message: \"goodbye\", foo: \"abc\", bar: \"def\" }\n\t  }\n\t})\n\n**同名钩子函数将混合为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。**\n\n\tvar mixin = {\n\t  created: function () {\n\t    console.log('混入对象的钩子被调用')\n\t  }\n\t}\n\t\n\tnew Vue({\n\t  mixins: [mixin],\n\t  created: function () {\n\t    console.log('组件钩子被调用')\n\t  }\n\t})\n\t\n\t// => \"混入对象的钩子被调用\"\n\t// => \"组件钩子被调用\"\n\n**值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。**\n\n\tvar mixin = {\n\t  methods: {\n\t    foo: function () {\n\t      console.log('foo')\n\t    },\n\t    conflicting: function () {\n\t      console.log('from mixin')\n\t    }\n\t  }\n\t}\n\t\n\tvar vm = new Vue({\n\t  mixins: [mixin],\n\t  methods: {\n\t    bar: function () {\n\t      console.log('bar')\n\t    },\n\t    conflicting: function () {\n\t      console.log('from self')\n\t    }\n\t  }\n\t})\n\t\n\tvm.foo() // => \"foo\"\n\tvm.bar() // => \"bar\"\n\tvm.conflicting() // => \"from self\"\n\n**注意：Vue.extend() 也使用同样的策略进行合并。**\n\n## 全局混入\n\n**也可以全局注册混入对象。注意使用！ 一旦使用全局混入对象，将会影响到 所有 之后创建的 Vue 实例。使用恰当时，可以为自定义对象注入处理逻辑。**\n\n\t// 为自定义的选项 'myOption' 注入一个处理器。\n\tVue.mixin({\n\t  created: function () {\n\t    var myOption = this.$options.myOption\n\t    if (myOption) {\n\t      console.log(myOption)\n\t    }\n\t  }\n\t})\n\t\n\tnew Vue({\n\t  myOption: 'hello!'\n\t})\n\t// => \"hello!\"\n\n> **谨慎使用全局混入对象，因为会影响到每个单独创建的 Vue 实例 (包括第三方模板)。大多数情况下，只应当应用于自定义选项，就像上面示例一样。也可以将其用作 Plugins 以避免产生重复应用**\n> ","source":"_posts/minxins.md","raw":"---\ntitle: vue混入【mixins】\ndate: '4/2/2019 11:42:35 AM '\ntag: ['js', 'vue']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n## vue混入【mixins】\n\n**混入 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。**\n\n\t// 定义一个混入对象\n\tvar myMixin = {\n\t  created: function () {\n\t    this.hello()\n\t  },\n\t  methods: {\n\t    hello: function () {\n\t      console.log('hello from mixin!')\n\t    }\n\t  }\n\t}\n\t\n\t// 定义一个使用混入对象的组件\n\tvar Component = Vue.extend({\n\t  mixins: [myMixin]\n\t})\n\t\n\tvar component = new Component() // => \"hello from mixin!\"\n\n## 选项合并\n\n**当组件和混入对象含有同名选项时，这些选项将以恰当的方式混合。**\n\n**比如，数据对象在内部会进行递归合并，在和组件的数据发生冲突时以组件数据优先。**\n\n\tvar mixin = {\n\t  data: function () {\n\t    return {\n\t      message: 'hello',\n\t      foo: 'abc'\n\t    }\n\t  }\n\t}\n\t\n\tnew Vue({\n\t  mixins: [mixin],\n\t  data: function () {\n\t    return {\n\t      message: 'goodbye',\n\t      bar: 'def'\n\t    }\n\t  },\n\t  created: function () {\n\t    console.log(this.$data)\n\t    // => { message: \"goodbye\", foo: \"abc\", bar: \"def\" }\n\t  }\n\t})\n\n**同名钩子函数将混合为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。**\n\n\tvar mixin = {\n\t  created: function () {\n\t    console.log('混入对象的钩子被调用')\n\t  }\n\t}\n\t\n\tnew Vue({\n\t  mixins: [mixin],\n\t  created: function () {\n\t    console.log('组件钩子被调用')\n\t  }\n\t})\n\t\n\t// => \"混入对象的钩子被调用\"\n\t// => \"组件钩子被调用\"\n\n**值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。**\n\n\tvar mixin = {\n\t  methods: {\n\t    foo: function () {\n\t      console.log('foo')\n\t    },\n\t    conflicting: function () {\n\t      console.log('from mixin')\n\t    }\n\t  }\n\t}\n\t\n\tvar vm = new Vue({\n\t  mixins: [mixin],\n\t  methods: {\n\t    bar: function () {\n\t      console.log('bar')\n\t    },\n\t    conflicting: function () {\n\t      console.log('from self')\n\t    }\n\t  }\n\t})\n\t\n\tvm.foo() // => \"foo\"\n\tvm.bar() // => \"bar\"\n\tvm.conflicting() // => \"from self\"\n\n**注意：Vue.extend() 也使用同样的策略进行合并。**\n\n## 全局混入\n\n**也可以全局注册混入对象。注意使用！ 一旦使用全局混入对象，将会影响到 所有 之后创建的 Vue 实例。使用恰当时，可以为自定义对象注入处理逻辑。**\n\n\t// 为自定义的选项 'myOption' 注入一个处理器。\n\tVue.mixin({\n\t  created: function () {\n\t    var myOption = this.$options.myOption\n\t    if (myOption) {\n\t      console.log(myOption)\n\t    }\n\t  }\n\t})\n\t\n\tnew Vue({\n\t  myOption: 'hello!'\n\t})\n\t// => \"hello!\"\n\n> **谨慎使用全局混入对象，因为会影响到每个单独创建的 Vue 实例 (包括第三方模板)。大多数情况下，只应当应用于自定义选项，就像上面示例一样。也可以将其用作 Plugins 以避免产生重复应用**\n> ","slug":"minxins","published":1,"updated":"2019-04-02T02:43:05.716Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam76001cn4wdc3mhf1z7","content":"<h2 id=\"vue混入【mixins】\"><a href=\"#vue混入【mixins】\" class=\"headerlink\" title=\"vue混入【mixins】\"></a>vue混入【mixins】</h2><p><strong>混入 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。</strong></p>\n<pre><code>// 定义一个混入对象\nvar myMixin = {\n  created: function () {\n    this.hello()\n  },\n  methods: {\n    hello: function () {\n      console.log(&#39;hello from mixin!&#39;)\n    }\n  }\n}\n\n// 定义一个使用混入对象的组件\nvar Component = Vue.extend({\n  mixins: [myMixin]\n})\n\nvar component = new Component() // =&gt; &quot;hello from mixin!&quot;\n</code></pre><h2 id=\"选项合并\"><a href=\"#选项合并\" class=\"headerlink\" title=\"选项合并\"></a>选项合并</h2><p><strong>当组件和混入对象含有同名选项时，这些选项将以恰当的方式混合。</strong></p>\n<p><strong>比如，数据对象在内部会进行递归合并，在和组件的数据发生冲突时以组件数据优先。</strong></p>\n<pre><code>var mixin = {\n  data: function () {\n    return {\n      message: &#39;hello&#39;,\n      foo: &#39;abc&#39;\n    }\n  }\n}\n\nnew Vue({\n  mixins: [mixin],\n  data: function () {\n    return {\n      message: &#39;goodbye&#39;,\n      bar: &#39;def&#39;\n    }\n  },\n  created: function () {\n    console.log(this.$data)\n    // =&gt; { message: &quot;goodbye&quot;, foo: &quot;abc&quot;, bar: &quot;def&quot; }\n  }\n})\n</code></pre><p><strong>同名钩子函数将混合为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。</strong></p>\n<pre><code>var mixin = {\n  created: function () {\n    console.log(&#39;混入对象的钩子被调用&#39;)\n  }\n}\n\nnew Vue({\n  mixins: [mixin],\n  created: function () {\n    console.log(&#39;组件钩子被调用&#39;)\n  }\n})\n\n// =&gt; &quot;混入对象的钩子被调用&quot;\n// =&gt; &quot;组件钩子被调用&quot;\n</code></pre><p><strong>值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。</strong></p>\n<pre><code>var mixin = {\n  methods: {\n    foo: function () {\n      console.log(&#39;foo&#39;)\n    },\n    conflicting: function () {\n      console.log(&#39;from mixin&#39;)\n    }\n  }\n}\n\nvar vm = new Vue({\n  mixins: [mixin],\n  methods: {\n    bar: function () {\n      console.log(&#39;bar&#39;)\n    },\n    conflicting: function () {\n      console.log(&#39;from self&#39;)\n    }\n  }\n})\n\nvm.foo() // =&gt; &quot;foo&quot;\nvm.bar() // =&gt; &quot;bar&quot;\nvm.conflicting() // =&gt; &quot;from self&quot;\n</code></pre><p><strong>注意：Vue.extend() 也使用同样的策略进行合并。</strong></p>\n<h2 id=\"全局混入\"><a href=\"#全局混入\" class=\"headerlink\" title=\"全局混入\"></a>全局混入</h2><p><strong>也可以全局注册混入对象。注意使用！ 一旦使用全局混入对象，将会影响到 所有 之后创建的 Vue 实例。使用恰当时，可以为自定义对象注入处理逻辑。</strong></p>\n<pre><code>// 为自定义的选项 &#39;myOption&#39; 注入一个处理器。\nVue.mixin({\n  created: function () {\n    var myOption = this.$options.myOption\n    if (myOption) {\n      console.log(myOption)\n    }\n  }\n})\n\nnew Vue({\n  myOption: &#39;hello!&#39;\n})\n// =&gt; &quot;hello!&quot;\n</code></pre><blockquote>\n<p><strong>谨慎使用全局混入对象，因为会影响到每个单独创建的 Vue 实例 (包括第三方模板)。大多数情况下，只应当应用于自定义选项，就像上面示例一样。也可以将其用作 Plugins 以避免产生重复应用</strong></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"vue混入【mixins】\"><a href=\"#vue混入【mixins】\" class=\"headerlink\" title=\"vue混入【mixins】\"></a>vue混入【mixins】</h2><p><strong>混入 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。</strong></p>\n<pre><code>// 定义一个混入对象\nvar myMixin = {\n  created: function () {\n    this.hello()\n  },\n  methods: {\n    hello: function () {\n      console.log(&#39;hello from mixin!&#39;)\n    }\n  }\n}\n\n// 定义一个使用混入对象的组件\nvar Component = Vue.extend({\n  mixins: [myMixin]\n})\n\nvar component = new Component() // =&gt; &quot;hello from mixin!&quot;\n</code></pre><h2 id=\"选项合并\"><a href=\"#选项合并\" class=\"headerlink\" title=\"选项合并\"></a>选项合并</h2><p><strong>当组件和混入对象含有同名选项时，这些选项将以恰当的方式混合。</strong></p>\n<p><strong>比如，数据对象在内部会进行递归合并，在和组件的数据发生冲突时以组件数据优先。</strong></p>\n<pre><code>var mixin = {\n  data: function () {\n    return {\n      message: &#39;hello&#39;,\n      foo: &#39;abc&#39;\n    }\n  }\n}\n\nnew Vue({\n  mixins: [mixin],\n  data: function () {\n    return {\n      message: &#39;goodbye&#39;,\n      bar: &#39;def&#39;\n    }\n  },\n  created: function () {\n    console.log(this.$data)\n    // =&gt; { message: &quot;goodbye&quot;, foo: &quot;abc&quot;, bar: &quot;def&quot; }\n  }\n})\n</code></pre><p><strong>同名钩子函数将混合为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。</strong></p>\n<pre><code>var mixin = {\n  created: function () {\n    console.log(&#39;混入对象的钩子被调用&#39;)\n  }\n}\n\nnew Vue({\n  mixins: [mixin],\n  created: function () {\n    console.log(&#39;组件钩子被调用&#39;)\n  }\n})\n\n// =&gt; &quot;混入对象的钩子被调用&quot;\n// =&gt; &quot;组件钩子被调用&quot;\n</code></pre><p><strong>值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。</strong></p>\n<pre><code>var mixin = {\n  methods: {\n    foo: function () {\n      console.log(&#39;foo&#39;)\n    },\n    conflicting: function () {\n      console.log(&#39;from mixin&#39;)\n    }\n  }\n}\n\nvar vm = new Vue({\n  mixins: [mixin],\n  methods: {\n    bar: function () {\n      console.log(&#39;bar&#39;)\n    },\n    conflicting: function () {\n      console.log(&#39;from self&#39;)\n    }\n  }\n})\n\nvm.foo() // =&gt; &quot;foo&quot;\nvm.bar() // =&gt; &quot;bar&quot;\nvm.conflicting() // =&gt; &quot;from self&quot;\n</code></pre><p><strong>注意：Vue.extend() 也使用同样的策略进行合并。</strong></p>\n<h2 id=\"全局混入\"><a href=\"#全局混入\" class=\"headerlink\" title=\"全局混入\"></a>全局混入</h2><p><strong>也可以全局注册混入对象。注意使用！ 一旦使用全局混入对象，将会影响到 所有 之后创建的 Vue 实例。使用恰当时，可以为自定义对象注入处理逻辑。</strong></p>\n<pre><code>// 为自定义的选项 &#39;myOption&#39; 注入一个处理器。\nVue.mixin({\n  created: function () {\n    var myOption = this.$options.myOption\n    if (myOption) {\n      console.log(myOption)\n    }\n  }\n})\n\nnew Vue({\n  myOption: &#39;hello!&#39;\n})\n// =&gt; &quot;hello!&quot;\n</code></pre><blockquote>\n<p><strong>谨慎使用全局混入对象，因为会影响到每个单独创建的 Vue 实例 (包括第三方模板)。大多数情况下，只应当应用于自定义选项，就像上面示例一样。也可以将其用作 Plugins 以避免产生重复应用</strong></p>\n</blockquote>\n"},{"title":"node简单的压缩/解压缩","date":"2019-08-10T02:41:49.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"# node简单的压缩/解压缩\n\n> 为了减少网络传输数据量，http传输过程中会采用通用的压缩算法来压缩数据，gzip属于最常用的压缩算法。\n\n## 压缩文件\n\n    //压缩文件\n\n    let zlib=require(\"zlib\")\n    let fs=require(\"fs\")\n\n    var gzip=zlib.createGzip()\n    let rs=fs.createReadStream('./copy.js')\n    let ws=fs.createWriteStream('./copy.js.gz')\n\n    re.pipe(gzip).pipe.(ws)\n\n## 解压文件\n\n    //解压文件\n    let zlib=require(\"zlib\")\n    let fs=require(\"fs\")\n\n    var gzip=zlib.createGzip()\n    let rs=fs.createReadStream('./copy.js.gz')\n    let ws=fs.createWriteStream('./copy.js')\n\n    re.pipe(gzip).pipe.(ws)\n\n## 服务端的gzip压缩\n\n    //服务端的gzip压缩\n\n    //先起一个服务，判断req.headers['accept-encoding']是否包含gzip\n\n    let server=http.createServer(function(req,res){\n        console.log(req)\n        var zp=req.headers[['accept-encoding']]\n        console.log(zp)\n        if(zp.indexOf('gzip')!=-1){//判断是否需要gzip压缩\n        \n            var gzip = zlib.createGzip();\n            res.writeHead(200, {//记得响应 Content-Encoding，告诉浏览器：文件被 gzip 压缩过\n                'Content-Encoding': 'gzip'\n            });\n            let ws=fs.createWriteStream(\"./cop.js.gz\")\n            fs.createReadStream(\"./cop.js\").pipe(gzip).pipe(ws);\n        }else{\n            \n            fs.createReadStream(\"./cop.js\").pipe(res);\n        }\n        res.end()\n        \n    }).listen(3000)\n","source":"_posts/node_zip.md","raw":"---\ntitle: node简单的压缩/解压缩\ndate: '8/10/2019 10:41:49'\ntag: ['js', 'node']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n# node简单的压缩/解压缩\n\n> 为了减少网络传输数据量，http传输过程中会采用通用的压缩算法来压缩数据，gzip属于最常用的压缩算法。\n\n## 压缩文件\n\n    //压缩文件\n\n    let zlib=require(\"zlib\")\n    let fs=require(\"fs\")\n\n    var gzip=zlib.createGzip()\n    let rs=fs.createReadStream('./copy.js')\n    let ws=fs.createWriteStream('./copy.js.gz')\n\n    re.pipe(gzip).pipe.(ws)\n\n## 解压文件\n\n    //解压文件\n    let zlib=require(\"zlib\")\n    let fs=require(\"fs\")\n\n    var gzip=zlib.createGzip()\n    let rs=fs.createReadStream('./copy.js.gz')\n    let ws=fs.createWriteStream('./copy.js')\n\n    re.pipe(gzip).pipe.(ws)\n\n## 服务端的gzip压缩\n\n    //服务端的gzip压缩\n\n    //先起一个服务，判断req.headers['accept-encoding']是否包含gzip\n\n    let server=http.createServer(function(req,res){\n        console.log(req)\n        var zp=req.headers[['accept-encoding']]\n        console.log(zp)\n        if(zp.indexOf('gzip')!=-1){//判断是否需要gzip压缩\n        \n            var gzip = zlib.createGzip();\n            res.writeHead(200, {//记得响应 Content-Encoding，告诉浏览器：文件被 gzip 压缩过\n                'Content-Encoding': 'gzip'\n            });\n            let ws=fs.createWriteStream(\"./cop.js.gz\")\n            fs.createReadStream(\"./cop.js\").pipe(gzip).pipe(ws);\n        }else{\n            \n            fs.createReadStream(\"./cop.js\").pipe(res);\n        }\n        res.end()\n        \n    }).listen(3000)\n","slug":"node_zip","published":1,"updated":"2019-09-27T01:35:25.554Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam77001en4wdvdk3fjfo","content":"<h1 id=\"node简单的压缩-解压缩\"><a href=\"#node简单的压缩-解压缩\" class=\"headerlink\" title=\"node简单的压缩/解压缩\"></a>node简单的压缩/解压缩</h1><blockquote>\n<p>为了减少网络传输数据量，http传输过程中会采用通用的压缩算法来压缩数据，gzip属于最常用的压缩算法。</p>\n</blockquote>\n<h2 id=\"压缩文件\"><a href=\"#压缩文件\" class=\"headerlink\" title=\"压缩文件\"></a>压缩文件</h2><pre><code>//压缩文件\n\nlet zlib=require(&quot;zlib&quot;)\nlet fs=require(&quot;fs&quot;)\n\nvar gzip=zlib.createGzip()\nlet rs=fs.createReadStream(&#39;./copy.js&#39;)\nlet ws=fs.createWriteStream(&#39;./copy.js.gz&#39;)\n\nre.pipe(gzip).pipe.(ws)\n</code></pre><h2 id=\"解压文件\"><a href=\"#解压文件\" class=\"headerlink\" title=\"解压文件\"></a>解压文件</h2><pre><code>//解压文件\nlet zlib=require(&quot;zlib&quot;)\nlet fs=require(&quot;fs&quot;)\n\nvar gzip=zlib.createGzip()\nlet rs=fs.createReadStream(&#39;./copy.js.gz&#39;)\nlet ws=fs.createWriteStream(&#39;./copy.js&#39;)\n\nre.pipe(gzip).pipe.(ws)\n</code></pre><h2 id=\"服务端的gzip压缩\"><a href=\"#服务端的gzip压缩\" class=\"headerlink\" title=\"服务端的gzip压缩\"></a>服务端的gzip压缩</h2><pre><code>//服务端的gzip压缩\n\n//先起一个服务，判断req.headers[&#39;accept-encoding&#39;]是否包含gzip\n\nlet server=http.createServer(function(req,res){\n    console.log(req)\n    var zp=req.headers[[&#39;accept-encoding&#39;]]\n    console.log(zp)\n    if(zp.indexOf(&#39;gzip&#39;)!=-1){//判断是否需要gzip压缩\n\n        var gzip = zlib.createGzip();\n        res.writeHead(200, {//记得响应 Content-Encoding，告诉浏览器：文件被 gzip 压缩过\n            &#39;Content-Encoding&#39;: &#39;gzip&#39;\n        });\n        let ws=fs.createWriteStream(&quot;./cop.js.gz&quot;)\n        fs.createReadStream(&quot;./cop.js&quot;).pipe(gzip).pipe(ws);\n    }else{\n\n        fs.createReadStream(&quot;./cop.js&quot;).pipe(res);\n    }\n    res.end()\n\n}).listen(3000)\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"node简单的压缩-解压缩\"><a href=\"#node简单的压缩-解压缩\" class=\"headerlink\" title=\"node简单的压缩/解压缩\"></a>node简单的压缩/解压缩</h1><blockquote>\n<p>为了减少网络传输数据量，http传输过程中会采用通用的压缩算法来压缩数据，gzip属于最常用的压缩算法。</p>\n</blockquote>\n<h2 id=\"压缩文件\"><a href=\"#压缩文件\" class=\"headerlink\" title=\"压缩文件\"></a>压缩文件</h2><pre><code>//压缩文件\n\nlet zlib=require(&quot;zlib&quot;)\nlet fs=require(&quot;fs&quot;)\n\nvar gzip=zlib.createGzip()\nlet rs=fs.createReadStream(&#39;./copy.js&#39;)\nlet ws=fs.createWriteStream(&#39;./copy.js.gz&#39;)\n\nre.pipe(gzip).pipe.(ws)\n</code></pre><h2 id=\"解压文件\"><a href=\"#解压文件\" class=\"headerlink\" title=\"解压文件\"></a>解压文件</h2><pre><code>//解压文件\nlet zlib=require(&quot;zlib&quot;)\nlet fs=require(&quot;fs&quot;)\n\nvar gzip=zlib.createGzip()\nlet rs=fs.createReadStream(&#39;./copy.js.gz&#39;)\nlet ws=fs.createWriteStream(&#39;./copy.js&#39;)\n\nre.pipe(gzip).pipe.(ws)\n</code></pre><h2 id=\"服务端的gzip压缩\"><a href=\"#服务端的gzip压缩\" class=\"headerlink\" title=\"服务端的gzip压缩\"></a>服务端的gzip压缩</h2><pre><code>//服务端的gzip压缩\n\n//先起一个服务，判断req.headers[&#39;accept-encoding&#39;]是否包含gzip\n\nlet server=http.createServer(function(req,res){\n    console.log(req)\n    var zp=req.headers[[&#39;accept-encoding&#39;]]\n    console.log(zp)\n    if(zp.indexOf(&#39;gzip&#39;)!=-1){//判断是否需要gzip压缩\n\n        var gzip = zlib.createGzip();\n        res.writeHead(200, {//记得响应 Content-Encoding，告诉浏览器：文件被 gzip 压缩过\n            &#39;Content-Encoding&#39;: &#39;gzip&#39;\n        });\n        let ws=fs.createWriteStream(&quot;./cop.js.gz&quot;)\n        fs.createReadStream(&quot;./cop.js&quot;).pipe(gzip).pipe(ws);\n    }else{\n\n        fs.createReadStream(&quot;./cop.js&quot;).pipe(res);\n    }\n    res.end()\n\n}).listen(3000)\n</code></pre>"},{"title":"node配置","date":"2019-03-28T01:21:19.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"# node配置\n\n## 一、安装node： ##\n\n> 1.下载并安装NVM脚本\n\n    curl https://raw.githubusercontent.com/creationix/nvm/v0.13.1/install.sh | bash\n    source ~/.bash_profile\n\n\n> 2.列出所需要的版本\n\n    nvm list-remote\n\n> 3.安装相应的版本\n\n    nvm install v8.3.0\n\n> 4.查看已安装的版本\n\n    nvm list\n\n> 5.切换版本\n\n\n    nvm use v8.3.0\n\n> 6.设置默认版本\n\n\n    nvm alias default v8.3.0","source":"_posts/nodemd.md","raw":"---\ntitle: node配置\ndate: '3/28/2019 9:21:19 AM '\ntag: ['node', 'linux服务器配置']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n# node配置\n\n## 一、安装node： ##\n\n> 1.下载并安装NVM脚本\n\n    curl https://raw.githubusercontent.com/creationix/nvm/v0.13.1/install.sh | bash\n    source ~/.bash_profile\n\n\n> 2.列出所需要的版本\n\n    nvm list-remote\n\n> 3.安装相应的版本\n\n    nvm install v8.3.0\n\n> 4.查看已安装的版本\n\n    nvm list\n\n> 5.切换版本\n\n\n    nvm use v8.3.0\n\n> 6.设置默认版本\n\n\n    nvm alias default v8.3.0","slug":"nodemd","published":1,"updated":"2019-03-28T01:22:36.586Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam78001gn4wdxb4knzga","content":"<h1 id=\"node配置\"><a href=\"#node配置\" class=\"headerlink\" title=\"node配置\"></a>node配置</h1><h2 id=\"一、安装node：\"><a href=\"#一、安装node：\" class=\"headerlink\" title=\"一、安装node：\"></a>一、安装node：</h2><blockquote>\n<p>1.下载并安装NVM脚本</p>\n</blockquote>\n<pre><code>curl https://raw.githubusercontent.com/creationix/nvm/v0.13.1/install.sh | bash\nsource ~/.bash_profile\n</code></pre><blockquote>\n<p>2.列出所需要的版本</p>\n</blockquote>\n<pre><code>nvm list-remote\n</code></pre><blockquote>\n<p>3.安装相应的版本</p>\n</blockquote>\n<pre><code>nvm install v8.3.0\n</code></pre><blockquote>\n<p>4.查看已安装的版本</p>\n</blockquote>\n<pre><code>nvm list\n</code></pre><blockquote>\n<p>5.切换版本</p>\n</blockquote>\n<pre><code>nvm use v8.3.0\n</code></pre><blockquote>\n<p>6.设置默认版本</p>\n</blockquote>\n<pre><code>nvm alias default v8.3.0\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"node配置\"><a href=\"#node配置\" class=\"headerlink\" title=\"node配置\"></a>node配置</h1><h2 id=\"一、安装node：\"><a href=\"#一、安装node：\" class=\"headerlink\" title=\"一、安装node：\"></a>一、安装node：</h2><blockquote>\n<p>1.下载并安装NVM脚本</p>\n</blockquote>\n<pre><code>curl https://raw.githubusercontent.com/creationix/nvm/v0.13.1/install.sh | bash\nsource ~/.bash_profile\n</code></pre><blockquote>\n<p>2.列出所需要的版本</p>\n</blockquote>\n<pre><code>nvm list-remote\n</code></pre><blockquote>\n<p>3.安装相应的版本</p>\n</blockquote>\n<pre><code>nvm install v8.3.0\n</code></pre><blockquote>\n<p>4.查看已安装的版本</p>\n</blockquote>\n<pre><code>nvm list\n</code></pre><blockquote>\n<p>5.切换版本</p>\n</blockquote>\n<pre><code>nvm use v8.3.0\n</code></pre><blockquote>\n<p>6.设置默认版本</p>\n</blockquote>\n<pre><code>nvm alias default v8.3.0\n</code></pre>"},{"title":"浅谈Mvc.","date":"2019-02-17T03:59:07.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"## 浅谈mvc\n\n### 定义：\n\t\n\n> MVC即Model、View、Controller即模型、视图、控制器。我在和同行讨论技术，阅读别人的代码时发现，很多程序员倾向于将软件的业务逻辑放在Controller里，将数据库访问操作的代码放在Model里。\n> \n> ####最终网站的代码结构是，View层是界面，Controller层是业务逻辑，Model层是数据库访问。 \t\n\n###MVC要实现的目标是将软件用户界面和业务逻辑分离以使代码可扩展性、可复用性、可维护性、灵活性加强。\n\n\n> View层是界面，Model层是业务逻辑，Controller层用来调度View层和Model层，将用户界面和业务逻辑合理的组织在一起，起粘合剂的效果。所以Controller中的内容能少则少，这样才能提供最大的灵活性。\n\n\n----------\n> #### 比方说，有一个View会提交数据给Model进行处理以实现具体的行为，View通常不会直接提交数据给Model，它会先把数据提交给Controller，然后Controller再将数据转发给Model。假如此时程序业务逻辑的处理方式有变化，那么只需要在Controller中将原来的Model换成新实现的Model就可以了，控制器的作用就是这么简单， 用来将不同的View和不同的Model组织在一起，顺便替双方传递消息，仅此而已。 \n> \n\n----------\n\n\n> 各Model之间是可以相互调用的， Controller也可以无障碍的调用Model，因此将业务逻辑放在Model中可以灵活的使用组合的方式复用代码。\n\n## MVC的优缺点\n\n### 优点：\n\n- 耦合性低（ MVC设计模式可以说实现了分层开发。各个层都有各个层的作用。 ）\n- 重用性高\n- 部署快，生命周期成本低\n- 可维护性高（修改模型不会影响到视图，反过来，修改视图，也不会影响到模型。 ）\n\n### 缺点：\n- 完全理解MVC比较复杂。\n\n- 调试困难。\n\n- 不适合小型，中等规模的应用程序（对于简单页面，严格遵循mvc，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。 ）\n- 增加系统结构和实现的复杂性\n\n## 总结一下，关于MVC各层之间关系所对应的设计模式\n\n- View层，单独实现了组合模式\n- Model层和View层，实现了观察者模式\n- View层和Controller层，实现了策咯模式","source":"_posts/mvc.md","raw":"---\ntitle: 浅谈Mvc.\ndate: '2/17/2019 11:59:07 AM '\ntag: ['js', 'mvc']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n## 浅谈mvc\n\n### 定义：\n\t\n\n> MVC即Model、View、Controller即模型、视图、控制器。我在和同行讨论技术，阅读别人的代码时发现，很多程序员倾向于将软件的业务逻辑放在Controller里，将数据库访问操作的代码放在Model里。\n> \n> ####最终网站的代码结构是，View层是界面，Controller层是业务逻辑，Model层是数据库访问。 \t\n\n###MVC要实现的目标是将软件用户界面和业务逻辑分离以使代码可扩展性、可复用性、可维护性、灵活性加强。\n\n\n> View层是界面，Model层是业务逻辑，Controller层用来调度View层和Model层，将用户界面和业务逻辑合理的组织在一起，起粘合剂的效果。所以Controller中的内容能少则少，这样才能提供最大的灵活性。\n\n\n----------\n> #### 比方说，有一个View会提交数据给Model进行处理以实现具体的行为，View通常不会直接提交数据给Model，它会先把数据提交给Controller，然后Controller再将数据转发给Model。假如此时程序业务逻辑的处理方式有变化，那么只需要在Controller中将原来的Model换成新实现的Model就可以了，控制器的作用就是这么简单， 用来将不同的View和不同的Model组织在一起，顺便替双方传递消息，仅此而已。 \n> \n\n----------\n\n\n> 各Model之间是可以相互调用的， Controller也可以无障碍的调用Model，因此将业务逻辑放在Model中可以灵活的使用组合的方式复用代码。\n\n## MVC的优缺点\n\n### 优点：\n\n- 耦合性低（ MVC设计模式可以说实现了分层开发。各个层都有各个层的作用。 ）\n- 重用性高\n- 部署快，生命周期成本低\n- 可维护性高（修改模型不会影响到视图，反过来，修改视图，也不会影响到模型。 ）\n\n### 缺点：\n- 完全理解MVC比较复杂。\n\n- 调试困难。\n\n- 不适合小型，中等规模的应用程序（对于简单页面，严格遵循mvc，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。 ）\n- 增加系统结构和实现的复杂性\n\n## 总结一下，关于MVC各层之间关系所对应的设计模式\n\n- View层，单独实现了组合模式\n- Model层和View层，实现了观察者模式\n- View层和Controller层，实现了策咯模式","slug":"mvc","published":1,"updated":"2019-02-18T05:43:17.468Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam79001in4wda7frtoql","content":"<h2 id=\"浅谈mvc\"><a href=\"#浅谈mvc\" class=\"headerlink\" title=\"浅谈mvc\"></a>浅谈mvc</h2><h3 id=\"定义：\"><a href=\"#定义：\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><blockquote>\n<p>MVC即Model、View、Controller即模型、视图、控制器。我在和同行讨论技术，阅读别人的代码时发现，很多程序员倾向于将软件的业务逻辑放在Controller里，将数据库访问操作的代码放在Model里。</p>\n<p>####最终网站的代码结构是，View层是界面，Controller层是业务逻辑，Model层是数据库访问。     </p>\n</blockquote>\n<p>###MVC要实现的目标是将软件用户界面和业务逻辑分离以使代码可扩展性、可复用性、可维护性、灵活性加强。</p>\n<blockquote>\n<p>View层是界面，Model层是业务逻辑，Controller层用来调度View层和Model层，将用户界面和业务逻辑合理的组织在一起，起粘合剂的效果。所以Controller中的内容能少则少，这样才能提供最大的灵活性。</p>\n</blockquote>\n<hr>\n<blockquote>\n<h4 id=\"比方说，有一个View会提交数据给Model进行处理以实现具体的行为，View通常不会直接提交数据给Model，它会先把数据提交给Controller，然后Controller再将数据转发给Model。假如此时程序业务逻辑的处理方式有变化，那么只需要在Controller中将原来的Model换成新实现的Model就可以了，控制器的作用就是这么简单，-用来将不同的View和不同的Model组织在一起，顺便替双方传递消息，仅此而已。\"><a href=\"#比方说，有一个View会提交数据给Model进行处理以实现具体的行为，View通常不会直接提交数据给Model，它会先把数据提交给Controller，然后Controller再将数据转发给Model。假如此时程序业务逻辑的处理方式有变化，那么只需要在Controller中将原来的Model换成新实现的Model就可以了，控制器的作用就是这么简单，-用来将不同的View和不同的Model组织在一起，顺便替双方传递消息，仅此而已。\" class=\"headerlink\" title=\"比方说，有一个View会提交数据给Model进行处理以实现具体的行为，View通常不会直接提交数据给Model，它会先把数据提交给Controller，然后Controller再将数据转发给Model。假如此时程序业务逻辑的处理方式有变化，那么只需要在Controller中将原来的Model换成新实现的Model就可以了，控制器的作用就是这么简单， 用来将不同的View和不同的Model组织在一起，顺便替双方传递消息，仅此而已。\"></a>比方说，有一个View会提交数据给Model进行处理以实现具体的行为，View通常不会直接提交数据给Model，它会先把数据提交给Controller，然后Controller再将数据转发给Model。假如此时程序业务逻辑的处理方式有变化，那么只需要在Controller中将原来的Model换成新实现的Model就可以了，控制器的作用就是这么简单， 用来将不同的View和不同的Model组织在一起，顺便替双方传递消息，仅此而已。</h4></blockquote>\n<hr>\n<blockquote>\n<p>各Model之间是可以相互调用的， Controller也可以无障碍的调用Model，因此将业务逻辑放在Model中可以灵活的使用组合的方式复用代码。</p>\n</blockquote>\n<h2 id=\"MVC的优缺点\"><a href=\"#MVC的优缺点\" class=\"headerlink\" title=\"MVC的优缺点\"></a>MVC的优缺点</h2><h3 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ul>\n<li>耦合性低（ MVC设计模式可以说实现了分层开发。各个层都有各个层的作用。 ）</li>\n<li>重用性高</li>\n<li>部署快，生命周期成本低</li>\n<li>可维护性高（修改模型不会影响到视图，反过来，修改视图，也不会影响到模型。 ）</li>\n</ul>\n<h3 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h3><ul>\n<li><p>完全理解MVC比较复杂。</p>\n</li>\n<li><p>调试困难。</p>\n</li>\n<li><p>不适合小型，中等规模的应用程序（对于简单页面，严格遵循mvc，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。 ）</p>\n</li>\n<li>增加系统结构和实现的复杂性</li>\n</ul>\n<h2 id=\"总结一下，关于MVC各层之间关系所对应的设计模式\"><a href=\"#总结一下，关于MVC各层之间关系所对应的设计模式\" class=\"headerlink\" title=\"总结一下，关于MVC各层之间关系所对应的设计模式\"></a>总结一下，关于MVC各层之间关系所对应的设计模式</h2><ul>\n<li>View层，单独实现了组合模式</li>\n<li>Model层和View层，实现了观察者模式</li>\n<li>View层和Controller层，实现了策咯模式</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"浅谈mvc\"><a href=\"#浅谈mvc\" class=\"headerlink\" title=\"浅谈mvc\"></a>浅谈mvc</h2><h3 id=\"定义：\"><a href=\"#定义：\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><blockquote>\n<p>MVC即Model、View、Controller即模型、视图、控制器。我在和同行讨论技术，阅读别人的代码时发现，很多程序员倾向于将软件的业务逻辑放在Controller里，将数据库访问操作的代码放在Model里。</p>\n<p>####最终网站的代码结构是，View层是界面，Controller层是业务逻辑，Model层是数据库访问。     </p>\n</blockquote>\n<p>###MVC要实现的目标是将软件用户界面和业务逻辑分离以使代码可扩展性、可复用性、可维护性、灵活性加强。</p>\n<blockquote>\n<p>View层是界面，Model层是业务逻辑，Controller层用来调度View层和Model层，将用户界面和业务逻辑合理的组织在一起，起粘合剂的效果。所以Controller中的内容能少则少，这样才能提供最大的灵活性。</p>\n</blockquote>\n<hr>\n<blockquote>\n<h4 id=\"比方说，有一个View会提交数据给Model进行处理以实现具体的行为，View通常不会直接提交数据给Model，它会先把数据提交给Controller，然后Controller再将数据转发给Model。假如此时程序业务逻辑的处理方式有变化，那么只需要在Controller中将原来的Model换成新实现的Model就可以了，控制器的作用就是这么简单，-用来将不同的View和不同的Model组织在一起，顺便替双方传递消息，仅此而已。\"><a href=\"#比方说，有一个View会提交数据给Model进行处理以实现具体的行为，View通常不会直接提交数据给Model，它会先把数据提交给Controller，然后Controller再将数据转发给Model。假如此时程序业务逻辑的处理方式有变化，那么只需要在Controller中将原来的Model换成新实现的Model就可以了，控制器的作用就是这么简单，-用来将不同的View和不同的Model组织在一起，顺便替双方传递消息，仅此而已。\" class=\"headerlink\" title=\"比方说，有一个View会提交数据给Model进行处理以实现具体的行为，View通常不会直接提交数据给Model，它会先把数据提交给Controller，然后Controller再将数据转发给Model。假如此时程序业务逻辑的处理方式有变化，那么只需要在Controller中将原来的Model换成新实现的Model就可以了，控制器的作用就是这么简单， 用来将不同的View和不同的Model组织在一起，顺便替双方传递消息，仅此而已。\"></a>比方说，有一个View会提交数据给Model进行处理以实现具体的行为，View通常不会直接提交数据给Model，它会先把数据提交给Controller，然后Controller再将数据转发给Model。假如此时程序业务逻辑的处理方式有变化，那么只需要在Controller中将原来的Model换成新实现的Model就可以了，控制器的作用就是这么简单， 用来将不同的View和不同的Model组织在一起，顺便替双方传递消息，仅此而已。</h4></blockquote>\n<hr>\n<blockquote>\n<p>各Model之间是可以相互调用的， Controller也可以无障碍的调用Model，因此将业务逻辑放在Model中可以灵活的使用组合的方式复用代码。</p>\n</blockquote>\n<h2 id=\"MVC的优缺点\"><a href=\"#MVC的优缺点\" class=\"headerlink\" title=\"MVC的优缺点\"></a>MVC的优缺点</h2><h3 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ul>\n<li>耦合性低（ MVC设计模式可以说实现了分层开发。各个层都有各个层的作用。 ）</li>\n<li>重用性高</li>\n<li>部署快，生命周期成本低</li>\n<li>可维护性高（修改模型不会影响到视图，反过来，修改视图，也不会影响到模型。 ）</li>\n</ul>\n<h3 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h3><ul>\n<li><p>完全理解MVC比较复杂。</p>\n</li>\n<li><p>调试困难。</p>\n</li>\n<li><p>不适合小型，中等规模的应用程序（对于简单页面，严格遵循mvc，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。 ）</p>\n</li>\n<li>增加系统结构和实现的复杂性</li>\n</ul>\n<h2 id=\"总结一下，关于MVC各层之间关系所对应的设计模式\"><a href=\"#总结一下，关于MVC各层之间关系所对应的设计模式\" class=\"headerlink\" title=\"总结一下，关于MVC各层之间关系所对应的设计模式\"></a>总结一下，关于MVC各层之间关系所对应的设计模式</h2><ul>\n<li>View层，单独实现了组合模式</li>\n<li>Model层和View层，实现了观察者模式</li>\n<li>View层和Controller层，实现了策咯模式</li>\n</ul>\n"},{"title":"页面重构如何操作？","date":"2019-03-29T13:27:10.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"## 页面重构如何操作？\n\n### 网站重构：\n\n> 在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。 \n> \n> 也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。 \n\n### 对于传统的网站来说重构通常是： \n\n> 表格(table)布局改为DIV+CSS \n> \n> 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) \n> \n> 对于移动平台的优化 \n> \n> 针对于SEO进行优化 \n> \n> 深层次的网站重构应该考虑的方面 \n> \n> 减少代码间的耦合\n>                \n> 让代码保持弹性 \n> \n> 严格按规范编写代码 \n> \n> 设计可扩展的API \n> \n> 代替旧有的框架、语言(如VB) \n> \n> 增强用户体验 \n> \n> 通常来说对于速度的优化也包含在重构中 \n> \n> 压缩JS、CSS、image等前端资源(通常是由服务器来解决) \n> \n> 程序的性能优化(如数据读写) \n> \n> 采用CDN来加速资源加载 \n> \n> 对于JS DOM的优化 \n> \n> HTTP服务器的文件缓存 \n> \n","source":"_posts/optimization.md","raw":"---\ntitle: 页面重构如何操作？\ndate: '3/29/2019 9:27:10 PM '\ntag: ['js', '兼容与优化']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n## 页面重构如何操作？\n\n### 网站重构：\n\n> 在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。 \n> \n> 也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。 \n\n### 对于传统的网站来说重构通常是： \n\n> 表格(table)布局改为DIV+CSS \n> \n> 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) \n> \n> 对于移动平台的优化 \n> \n> 针对于SEO进行优化 \n> \n> 深层次的网站重构应该考虑的方面 \n> \n> 减少代码间的耦合\n>                \n> 让代码保持弹性 \n> \n> 严格按规范编写代码 \n> \n> 设计可扩展的API \n> \n> 代替旧有的框架、语言(如VB) \n> \n> 增强用户体验 \n> \n> 通常来说对于速度的优化也包含在重构中 \n> \n> 压缩JS、CSS、image等前端资源(通常是由服务器来解决) \n> \n> 程序的性能优化(如数据读写) \n> \n> 采用CDN来加速资源加载 \n> \n> 对于JS DOM的优化 \n> \n> HTTP服务器的文件缓存 \n> \n","slug":"optimization","published":1,"updated":"2019-03-29T12:30:03.144Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam7a001ln4wdhemv9ooh","content":"<h2 id=\"页面重构如何操作？\"><a href=\"#页面重构如何操作？\" class=\"headerlink\" title=\"页面重构如何操作？\"></a>页面重构如何操作？</h2><h3 id=\"网站重构：\"><a href=\"#网站重构：\" class=\"headerlink\" title=\"网站重构：\"></a>网站重构：</h3><blockquote>\n<p>在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。 </p>\n<p>也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。 </p>\n</blockquote>\n<h3 id=\"对于传统的网站来说重构通常是：\"><a href=\"#对于传统的网站来说重构通常是：\" class=\"headerlink\" title=\"对于传统的网站来说重构通常是：\"></a>对于传统的网站来说重构通常是：</h3><blockquote>\n<p>表格(table)布局改为DIV+CSS </p>\n<p>使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) </p>\n<p>对于移动平台的优化 </p>\n<p>针对于SEO进行优化 </p>\n<p>深层次的网站重构应该考虑的方面 </p>\n<p>减少代码间的耦合</p>\n<p>让代码保持弹性 </p>\n<p>严格按规范编写代码 </p>\n<p>设计可扩展的API </p>\n<p>代替旧有的框架、语言(如VB) </p>\n<p>增强用户体验 </p>\n<p>通常来说对于速度的优化也包含在重构中 </p>\n<p>压缩JS、CSS、image等前端资源(通常是由服务器来解决) </p>\n<p>程序的性能优化(如数据读写) </p>\n<p>采用CDN来加速资源加载 </p>\n<p>对于JS DOM的优化 </p>\n<p>HTTP服务器的文件缓存 </p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"页面重构如何操作？\"><a href=\"#页面重构如何操作？\" class=\"headerlink\" title=\"页面重构如何操作？\"></a>页面重构如何操作？</h2><h3 id=\"网站重构：\"><a href=\"#网站重构：\" class=\"headerlink\" title=\"网站重构：\"></a>网站重构：</h3><blockquote>\n<p>在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。 </p>\n<p>也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。 </p>\n</blockquote>\n<h3 id=\"对于传统的网站来说重构通常是：\"><a href=\"#对于传统的网站来说重构通常是：\" class=\"headerlink\" title=\"对于传统的网站来说重构通常是：\"></a>对于传统的网站来说重构通常是：</h3><blockquote>\n<p>表格(table)布局改为DIV+CSS </p>\n<p>使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) </p>\n<p>对于移动平台的优化 </p>\n<p>针对于SEO进行优化 </p>\n<p>深层次的网站重构应该考虑的方面 </p>\n<p>减少代码间的耦合</p>\n<p>让代码保持弹性 </p>\n<p>严格按规范编写代码 </p>\n<p>设计可扩展的API </p>\n<p>代替旧有的框架、语言(如VB) </p>\n<p>增强用户体验 </p>\n<p>通常来说对于速度的优化也包含在重构中 </p>\n<p>压缩JS、CSS、image等前端资源(通常是由服务器来解决) </p>\n<p>程序的性能优化(如数据读写) </p>\n<p>采用CDN来加速资源加载 </p>\n<p>对于JS DOM的优化 </p>\n<p>HTTP服务器的文件缓存 </p>\n</blockquote>\n"},{"title":"px2rem 移动端自适应方案","date":"2019-01-25T08:36:42.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"----------\n\n1/25/2019 4:36:42 PM\n\n----------\n\n# px2rem\n\n## vue-cli中如何使用px2rem\n\n### 实际开发中，我们通过设计稿得到的值单位是 px，所以要将 px 转换成 rem 再写进样式中。将 px 转换成 rem 我们将使用 px2rem 这个工具，它有 webpack 的 loader：px2rem-loader\n\n## 安装 px2rem-loader\n\n### 在命令行中运行如下安装：\n\n\tnpm i px2rem-loader --save-dev\n\n## 配置 px2rem-loader\n\n1/25/2019 4:36:17 PM \n### 在 vue-cli 生成的 webpack 配置中，vue-loader 的 options 和其他样式文件 loader 最终是都是由 build/utils.js 里的一个方法生成的。\n\n### 我们只需在 cssLoader 后再加上一个 px2remLoader 即可，px2rem-loader 的 remUnit 选项意思是 1rem=多少像素，结合 lib-flexible 的方案，我们将 px2remLoader 的 options.remUnit 设置成设计稿宽度的 1/10，这里我们假设设计稿宽为 750px。\n\n\t// utils.js\n\tvar cssLoader = {\n\tloader: 'css-loader',\n\t    options: {\n\t    sourceMap: options.sourceMap\n\t  }\n\t}\n\tvar px2remLoader = {\n\tloader: 'px2rem-loader',\n\t    options: {\n\t    remUnit: 75\n\t  }\n\t}\n\n## 并放进 loaders 数组中\n\n\t// utils.js\n\tfunction generateLoaders(loader, loaderOptions) {\n\t    var loaders = [cssLoader, px2remLoader]\n\t}\n\n## 也可以动态的根据可视窗口的大小来设置[在这里写一个计算]\n\n\tconst size = 200\n\tconst screen = 375\n\tconst flexFn = () => {\n\t    const windowWidth = window.outerWidth\n\t    const ratio = windowWidth / screen\n\t    const newSize = ratio * (size / 2)\n\t\n\t    document.querySelector('html').style.fontSize = newSize + \"px\"\n\t}\n\t\n\tflexFn()\n\t\n\twindow.addEventListener(\"resize\", () => {\n\t    flexFn()\n\t},false)\n\n直接将该js引入到main.js中即可\n\n\n## 修改配置后需要重启，然后我们在组件中写单位直接写 px，设计稿量多少就可以写多少了，舒服多了。","source":"_posts/px2rem.md","raw":"---\ntitle: px2rem 移动端自适应方案\ndate: ' 1/25/2019 4:36:42 PM '\ntag: ['js', 'vue' , 'vue-cli' , 'px2rem']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n----------\n\n1/25/2019 4:36:42 PM\n\n----------\n\n# px2rem\n\n## vue-cli中如何使用px2rem\n\n### 实际开发中，我们通过设计稿得到的值单位是 px，所以要将 px 转换成 rem 再写进样式中。将 px 转换成 rem 我们将使用 px2rem 这个工具，它有 webpack 的 loader：px2rem-loader\n\n## 安装 px2rem-loader\n\n### 在命令行中运行如下安装：\n\n\tnpm i px2rem-loader --save-dev\n\n## 配置 px2rem-loader\n\n1/25/2019 4:36:17 PM \n### 在 vue-cli 生成的 webpack 配置中，vue-loader 的 options 和其他样式文件 loader 最终是都是由 build/utils.js 里的一个方法生成的。\n\n### 我们只需在 cssLoader 后再加上一个 px2remLoader 即可，px2rem-loader 的 remUnit 选项意思是 1rem=多少像素，结合 lib-flexible 的方案，我们将 px2remLoader 的 options.remUnit 设置成设计稿宽度的 1/10，这里我们假设设计稿宽为 750px。\n\n\t// utils.js\n\tvar cssLoader = {\n\tloader: 'css-loader',\n\t    options: {\n\t    sourceMap: options.sourceMap\n\t  }\n\t}\n\tvar px2remLoader = {\n\tloader: 'px2rem-loader',\n\t    options: {\n\t    remUnit: 75\n\t  }\n\t}\n\n## 并放进 loaders 数组中\n\n\t// utils.js\n\tfunction generateLoaders(loader, loaderOptions) {\n\t    var loaders = [cssLoader, px2remLoader]\n\t}\n\n## 也可以动态的根据可视窗口的大小来设置[在这里写一个计算]\n\n\tconst size = 200\n\tconst screen = 375\n\tconst flexFn = () => {\n\t    const windowWidth = window.outerWidth\n\t    const ratio = windowWidth / screen\n\t    const newSize = ratio * (size / 2)\n\t\n\t    document.querySelector('html').style.fontSize = newSize + \"px\"\n\t}\n\t\n\tflexFn()\n\t\n\twindow.addEventListener(\"resize\", () => {\n\t    flexFn()\n\t},false)\n\n直接将该js引入到main.js中即可\n\n\n## 修改配置后需要重启，然后我们在组件中写单位直接写 px，设计稿量多少就可以写多少了，舒服多了。","slug":"px2rem","published":1,"updated":"2019-01-26T10:52:24.692Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam7b001nn4wddcal5dyi","content":"<hr>\n<p>1/25/2019 4:36:42 PM</p>\n<hr>\n<h1 id=\"px2rem\"><a href=\"#px2rem\" class=\"headerlink\" title=\"px2rem\"></a>px2rem</h1><h2 id=\"vue-cli中如何使用px2rem\"><a href=\"#vue-cli中如何使用px2rem\" class=\"headerlink\" title=\"vue-cli中如何使用px2rem\"></a>vue-cli中如何使用px2rem</h2><h3 id=\"实际开发中，我们通过设计稿得到的值单位是-px，所以要将-px-转换成-rem-再写进样式中。将-px-转换成-rem-我们将使用-px2rem-这个工具，它有-webpack-的-loader：px2rem-loader\"><a href=\"#实际开发中，我们通过设计稿得到的值单位是-px，所以要将-px-转换成-rem-再写进样式中。将-px-转换成-rem-我们将使用-px2rem-这个工具，它有-webpack-的-loader：px2rem-loader\" class=\"headerlink\" title=\"实际开发中，我们通过设计稿得到的值单位是 px，所以要将 px 转换成 rem 再写进样式中。将 px 转换成 rem 我们将使用 px2rem 这个工具，它有 webpack 的 loader：px2rem-loader\"></a>实际开发中，我们通过设计稿得到的值单位是 px，所以要将 px 转换成 rem 再写进样式中。将 px 转换成 rem 我们将使用 px2rem 这个工具，它有 webpack 的 loader：px2rem-loader</h3><h2 id=\"安装-px2rem-loader\"><a href=\"#安装-px2rem-loader\" class=\"headerlink\" title=\"安装 px2rem-loader\"></a>安装 px2rem-loader</h2><h3 id=\"在命令行中运行如下安装：\"><a href=\"#在命令行中运行如下安装：\" class=\"headerlink\" title=\"在命令行中运行如下安装：\"></a>在命令行中运行如下安装：</h3><pre><code>npm i px2rem-loader --save-dev\n</code></pre><h2 id=\"配置-px2rem-loader\"><a href=\"#配置-px2rem-loader\" class=\"headerlink\" title=\"配置 px2rem-loader\"></a>配置 px2rem-loader</h2><p>1/25/2019 4:36:17 PM </p>\n<h3 id=\"在-vue-cli-生成的-webpack-配置中，vue-loader-的-options-和其他样式文件-loader-最终是都是由-build-utils-js-里的一个方法生成的。\"><a href=\"#在-vue-cli-生成的-webpack-配置中，vue-loader-的-options-和其他样式文件-loader-最终是都是由-build-utils-js-里的一个方法生成的。\" class=\"headerlink\" title=\"在 vue-cli 生成的 webpack 配置中，vue-loader 的 options 和其他样式文件 loader 最终是都是由 build/utils.js 里的一个方法生成的。\"></a>在 vue-cli 生成的 webpack 配置中，vue-loader 的 options 和其他样式文件 loader 最终是都是由 build/utils.js 里的一个方法生成的。</h3><h3 id=\"我们只需在-cssLoader-后再加上一个-px2remLoader-即可，px2rem-loader-的-remUnit-选项意思是-1rem-多少像素，结合-lib-flexible-的方案，我们将-px2remLoader-的-options-remUnit-设置成设计稿宽度的-1-10，这里我们假设设计稿宽为-750px。\"><a href=\"#我们只需在-cssLoader-后再加上一个-px2remLoader-即可，px2rem-loader-的-remUnit-选项意思是-1rem-多少像素，结合-lib-flexible-的方案，我们将-px2remLoader-的-options-remUnit-设置成设计稿宽度的-1-10，这里我们假设设计稿宽为-750px。\" class=\"headerlink\" title=\"我们只需在 cssLoader 后再加上一个 px2remLoader 即可，px2rem-loader 的 remUnit 选项意思是 1rem=多少像素，结合 lib-flexible 的方案，我们将 px2remLoader 的 options.remUnit 设置成设计稿宽度的 1/10，这里我们假设设计稿宽为 750px。\"></a>我们只需在 cssLoader 后再加上一个 px2remLoader 即可，px2rem-loader 的 remUnit 选项意思是 1rem=多少像素，结合 lib-flexible 的方案，我们将 px2remLoader 的 options.remUnit 设置成设计稿宽度的 1/10，这里我们假设设计稿宽为 750px。</h3><pre><code>// utils.js\nvar cssLoader = {\nloader: &#39;css-loader&#39;,\n    options: {\n    sourceMap: options.sourceMap\n  }\n}\nvar px2remLoader = {\nloader: &#39;px2rem-loader&#39;,\n    options: {\n    remUnit: 75\n  }\n}\n</code></pre><h2 id=\"并放进-loaders-数组中\"><a href=\"#并放进-loaders-数组中\" class=\"headerlink\" title=\"并放进 loaders 数组中\"></a>并放进 loaders 数组中</h2><pre><code>// utils.js\nfunction generateLoaders(loader, loaderOptions) {\n    var loaders = [cssLoader, px2remLoader]\n}\n</code></pre><h2 id=\"也可以动态的根据可视窗口的大小来设置-在这里写一个计算\"><a href=\"#也可以动态的根据可视窗口的大小来设置-在这里写一个计算\" class=\"headerlink\" title=\"也可以动态的根据可视窗口的大小来设置[在这里写一个计算]\"></a>也可以动态的根据可视窗口的大小来设置[在这里写一个计算]</h2><pre><code>const size = 200\nconst screen = 375\nconst flexFn = () =&gt; {\n    const windowWidth = window.outerWidth\n    const ratio = windowWidth / screen\n    const newSize = ratio * (size / 2)\n\n    document.querySelector(&#39;html&#39;).style.fontSize = newSize + &quot;px&quot;\n}\n\nflexFn()\n\nwindow.addEventListener(&quot;resize&quot;, () =&gt; {\n    flexFn()\n},false)\n</code></pre><p>直接将该js引入到main.js中即可</p>\n<h2 id=\"修改配置后需要重启，然后我们在组件中写单位直接写-px，设计稿量多少就可以写多少了，舒服多了。\"><a href=\"#修改配置后需要重启，然后我们在组件中写单位直接写-px，设计稿量多少就可以写多少了，舒服多了。\" class=\"headerlink\" title=\"修改配置后需要重启，然后我们在组件中写单位直接写 px，设计稿量多少就可以写多少了，舒服多了。\"></a>修改配置后需要重启，然后我们在组件中写单位直接写 px，设计稿量多少就可以写多少了，舒服多了。</h2>","site":{"data":{}},"excerpt":"","more":"<hr>\n<p>1/25/2019 4:36:42 PM</p>\n<hr>\n<h1 id=\"px2rem\"><a href=\"#px2rem\" class=\"headerlink\" title=\"px2rem\"></a>px2rem</h1><h2 id=\"vue-cli中如何使用px2rem\"><a href=\"#vue-cli中如何使用px2rem\" class=\"headerlink\" title=\"vue-cli中如何使用px2rem\"></a>vue-cli中如何使用px2rem</h2><h3 id=\"实际开发中，我们通过设计稿得到的值单位是-px，所以要将-px-转换成-rem-再写进样式中。将-px-转换成-rem-我们将使用-px2rem-这个工具，它有-webpack-的-loader：px2rem-loader\"><a href=\"#实际开发中，我们通过设计稿得到的值单位是-px，所以要将-px-转换成-rem-再写进样式中。将-px-转换成-rem-我们将使用-px2rem-这个工具，它有-webpack-的-loader：px2rem-loader\" class=\"headerlink\" title=\"实际开发中，我们通过设计稿得到的值单位是 px，所以要将 px 转换成 rem 再写进样式中。将 px 转换成 rem 我们将使用 px2rem 这个工具，它有 webpack 的 loader：px2rem-loader\"></a>实际开发中，我们通过设计稿得到的值单位是 px，所以要将 px 转换成 rem 再写进样式中。将 px 转换成 rem 我们将使用 px2rem 这个工具，它有 webpack 的 loader：px2rem-loader</h3><h2 id=\"安装-px2rem-loader\"><a href=\"#安装-px2rem-loader\" class=\"headerlink\" title=\"安装 px2rem-loader\"></a>安装 px2rem-loader</h2><h3 id=\"在命令行中运行如下安装：\"><a href=\"#在命令行中运行如下安装：\" class=\"headerlink\" title=\"在命令行中运行如下安装：\"></a>在命令行中运行如下安装：</h3><pre><code>npm i px2rem-loader --save-dev\n</code></pre><h2 id=\"配置-px2rem-loader\"><a href=\"#配置-px2rem-loader\" class=\"headerlink\" title=\"配置 px2rem-loader\"></a>配置 px2rem-loader</h2><p>1/25/2019 4:36:17 PM </p>\n<h3 id=\"在-vue-cli-生成的-webpack-配置中，vue-loader-的-options-和其他样式文件-loader-最终是都是由-build-utils-js-里的一个方法生成的。\"><a href=\"#在-vue-cli-生成的-webpack-配置中，vue-loader-的-options-和其他样式文件-loader-最终是都是由-build-utils-js-里的一个方法生成的。\" class=\"headerlink\" title=\"在 vue-cli 生成的 webpack 配置中，vue-loader 的 options 和其他样式文件 loader 最终是都是由 build/utils.js 里的一个方法生成的。\"></a>在 vue-cli 生成的 webpack 配置中，vue-loader 的 options 和其他样式文件 loader 最终是都是由 build/utils.js 里的一个方法生成的。</h3><h3 id=\"我们只需在-cssLoader-后再加上一个-px2remLoader-即可，px2rem-loader-的-remUnit-选项意思是-1rem-多少像素，结合-lib-flexible-的方案，我们将-px2remLoader-的-options-remUnit-设置成设计稿宽度的-1-10，这里我们假设设计稿宽为-750px。\"><a href=\"#我们只需在-cssLoader-后再加上一个-px2remLoader-即可，px2rem-loader-的-remUnit-选项意思是-1rem-多少像素，结合-lib-flexible-的方案，我们将-px2remLoader-的-options-remUnit-设置成设计稿宽度的-1-10，这里我们假设设计稿宽为-750px。\" class=\"headerlink\" title=\"我们只需在 cssLoader 后再加上一个 px2remLoader 即可，px2rem-loader 的 remUnit 选项意思是 1rem=多少像素，结合 lib-flexible 的方案，我们将 px2remLoader 的 options.remUnit 设置成设计稿宽度的 1/10，这里我们假设设计稿宽为 750px。\"></a>我们只需在 cssLoader 后再加上一个 px2remLoader 即可，px2rem-loader 的 remUnit 选项意思是 1rem=多少像素，结合 lib-flexible 的方案，我们将 px2remLoader 的 options.remUnit 设置成设计稿宽度的 1/10，这里我们假设设计稿宽为 750px。</h3><pre><code>// utils.js\nvar cssLoader = {\nloader: &#39;css-loader&#39;,\n    options: {\n    sourceMap: options.sourceMap\n  }\n}\nvar px2remLoader = {\nloader: &#39;px2rem-loader&#39;,\n    options: {\n    remUnit: 75\n  }\n}\n</code></pre><h2 id=\"并放进-loaders-数组中\"><a href=\"#并放进-loaders-数组中\" class=\"headerlink\" title=\"并放进 loaders 数组中\"></a>并放进 loaders 数组中</h2><pre><code>// utils.js\nfunction generateLoaders(loader, loaderOptions) {\n    var loaders = [cssLoader, px2remLoader]\n}\n</code></pre><h2 id=\"也可以动态的根据可视窗口的大小来设置-在这里写一个计算\"><a href=\"#也可以动态的根据可视窗口的大小来设置-在这里写一个计算\" class=\"headerlink\" title=\"也可以动态的根据可视窗口的大小来设置[在这里写一个计算]\"></a>也可以动态的根据可视窗口的大小来设置[在这里写一个计算]</h2><pre><code>const size = 200\nconst screen = 375\nconst flexFn = () =&gt; {\n    const windowWidth = window.outerWidth\n    const ratio = windowWidth / screen\n    const newSize = ratio * (size / 2)\n\n    document.querySelector(&#39;html&#39;).style.fontSize = newSize + &quot;px&quot;\n}\n\nflexFn()\n\nwindow.addEventListener(&quot;resize&quot;, () =&gt; {\n    flexFn()\n},false)\n</code></pre><p>直接将该js引入到main.js中即可</p>\n<h2 id=\"修改配置后需要重启，然后我们在组件中写单位直接写-px，设计稿量多少就可以写多少了，舒服多了。\"><a href=\"#修改配置后需要重启，然后我们在组件中写单位直接写-px，设计稿量多少就可以写多少了，舒服多了。\" class=\"headerlink\" title=\"修改配置后需要重启，然后我们在组件中写单位直接写 px，设计稿量多少就可以写多少了，舒服多了。\"></a>修改配置后需要重启，然后我们在组件中写单位直接写 px，设计稿量多少就可以写多少了，舒服多了。</h2>"},{"title":"React-Native填坑之删除第三方开源组件的依赖包","date":"2019-05-24T10:06:52.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"## React-Native填坑之删除第三方开源组件的依赖包\n\n**今天遇到了一个问题：下载了react-native-webview的开源组件，可是在Android中遇到了问题，编译不通过，我想删除这个组件，然后写其他的功能，以后再添加这个地图功能，可是发现无法删除干净，android和ios原生都编译失败。就这个问题研究了下，现将方法卸载下面：**\n\n\tnpm uninstall -s -D -O react-native-webview\n\n----------\n> 进入Android目录，找到setting.gradle文件\n\n\t删除所有有关该包的依赖\n\n----------\n> 然后进入android/app目录下，打开build.gradle\n\n\t删除所有有关该包的依赖\n\n----------\n\n> 打开android/app/src/main/java/com/包名/MainApplication.java,\n\n\t删除所有有关该包的依赖\n\n----------\n> 然后终端运行\n\n\tnpm install\n\treact-native run-android\n\n----------\n> 成功！！！","source":"_posts/react-native unlink.md","raw":"---\ntitle: React-Native填坑之删除第三方开源组件的依赖包\ndate: '5/24/2019 6:06:52 PM '\ntag: ['react-native']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n## React-Native填坑之删除第三方开源组件的依赖包\n\n**今天遇到了一个问题：下载了react-native-webview的开源组件，可是在Android中遇到了问题，编译不通过，我想删除这个组件，然后写其他的功能，以后再添加这个地图功能，可是发现无法删除干净，android和ios原生都编译失败。就这个问题研究了下，现将方法卸载下面：**\n\n\tnpm uninstall -s -D -O react-native-webview\n\n----------\n> 进入Android目录，找到setting.gradle文件\n\n\t删除所有有关该包的依赖\n\n----------\n> 然后进入android/app目录下，打开build.gradle\n\n\t删除所有有关该包的依赖\n\n----------\n\n> 打开android/app/src/main/java/com/包名/MainApplication.java,\n\n\t删除所有有关该包的依赖\n\n----------\n> 然后终端运行\n\n\tnpm install\n\treact-native run-android\n\n----------\n> 成功！！！","slug":"react-native unlink","published":1,"updated":"2019-05-24T10:07:16.623Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam7c001qn4wd803ilnbi","content":"<h2 id=\"React-Native填坑之删除第三方开源组件的依赖包\"><a href=\"#React-Native填坑之删除第三方开源组件的依赖包\" class=\"headerlink\" title=\"React-Native填坑之删除第三方开源组件的依赖包\"></a>React-Native填坑之删除第三方开源组件的依赖包</h2><p><strong>今天遇到了一个问题：下载了react-native-webview的开源组件，可是在Android中遇到了问题，编译不通过，我想删除这个组件，然后写其他的功能，以后再添加这个地图功能，可是发现无法删除干净，android和ios原生都编译失败。就这个问题研究了下，现将方法卸载下面：</strong></p>\n<pre><code>npm uninstall -s -D -O react-native-webview\n</code></pre><hr>\n<blockquote>\n<p>进入Android目录，找到setting.gradle文件</p>\n</blockquote>\n<pre><code>删除所有有关该包的依赖\n</code></pre><hr>\n<blockquote>\n<p>然后进入android/app目录下，打开build.gradle</p>\n</blockquote>\n<pre><code>删除所有有关该包的依赖\n</code></pre><hr>\n<blockquote>\n<p>打开android/app/src/main/java/com/包名/MainApplication.java,</p>\n</blockquote>\n<pre><code>删除所有有关该包的依赖\n</code></pre><hr>\n<blockquote>\n<p>然后终端运行</p>\n</blockquote>\n<pre><code>npm install\nreact-native run-android\n</code></pre><hr>\n<blockquote>\n<p>成功！！！</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"React-Native填坑之删除第三方开源组件的依赖包\"><a href=\"#React-Native填坑之删除第三方开源组件的依赖包\" class=\"headerlink\" title=\"React-Native填坑之删除第三方开源组件的依赖包\"></a>React-Native填坑之删除第三方开源组件的依赖包</h2><p><strong>今天遇到了一个问题：下载了react-native-webview的开源组件，可是在Android中遇到了问题，编译不通过，我想删除这个组件，然后写其他的功能，以后再添加这个地图功能，可是发现无法删除干净，android和ios原生都编译失败。就这个问题研究了下，现将方法卸载下面：</strong></p>\n<pre><code>npm uninstall -s -D -O react-native-webview\n</code></pre><hr>\n<blockquote>\n<p>进入Android目录，找到setting.gradle文件</p>\n</blockquote>\n<pre><code>删除所有有关该包的依赖\n</code></pre><hr>\n<blockquote>\n<p>然后进入android/app目录下，打开build.gradle</p>\n</blockquote>\n<pre><code>删除所有有关该包的依赖\n</code></pre><hr>\n<blockquote>\n<p>打开android/app/src/main/java/com/包名/MainApplication.java,</p>\n</blockquote>\n<pre><code>删除所有有关该包的依赖\n</code></pre><hr>\n<blockquote>\n<p>然后终端运行</p>\n</blockquote>\n<pre><code>npm install\nreact-native run-android\n</code></pre><hr>\n<blockquote>\n<p>成功！！！</p>\n</blockquote>\n"},{"title":"react组件优化及组件通讯","date":"2019-04-03T08:46:51.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"## react组件优化\n\n### key值\n\n**在使用v-for的情况下，给每个变量的元素都加上key值，加key值得好处已经在上一文中提到过，主要为了提高渲染效率**\n\n### shouldComponentUpdate\n\n**该生命周期可以决定数据改变的时候是否进行render，返回值为boolean，返回true即为渲染，返回false及不渲染，默认不写为true**\n\n### 纯函数组件\n\n**将单独的项封装成一个组件，已达到服用效果**\n\n## 组件通讯\n\n### 父传子\n\n> 使用props传值\n\n**父组件**\n\n\timport React,{ Component } from \"react\";\n\timport Sub from \"./SubComponent.js\";\n\timport \"./App.css\";\n\t\n\texport default class App extends Component{\n\t\n\t    render(){\n\t        return(\n\t            <div>\n\t                <Sub title = \"今年过节不收礼\" />\n\t            </div>\n\t        )\n\t    }\n\t}\n\n**子组件**\n\n\timport React from \"react\";\n\n\tconst Sub = (props) => {\n\t    return(\n\t        <h1>\n\t            { props.title }\n\t        </h1>\n\t    )\n\t}\n\t\n\texport default Sub;\n\n### 子传父\n\n**父组件**\n\n\timport React,{ Component } from \"react\";\n\timport Sub from \"./SubComponent.js\";\n\timport \"./App.css\";\n\t\n\texport default class App extends Component{\n\t    callback(msg){\n\t        console.log(msg);\n\t    }\n\t    render(){\n\t        return(\n\t            <div>\n\t                <Sub callback = { this.callback.bind(this) } />\n\t            </div>\n\t        )\n\t    }\n\t}\n\n**子组件**\n\n\timport React from \"react\";\n\n\tconst Sub = (props) => {\n\t    const cb = (msg) => {\n\t        return () => {\n\t            props.callback(msg)\n\t        }\n\t    }\n\t    return(\n\t        <div>\n\t            <button onClick = { cb(\"我们通信把\") }>点击我</button>\n\t        </div>\n\t    )\n\t}\n\t\n\texport default Sub;\n\n### 跨组件传值\n\n> 16.3版本提供了新的context api,并且用了生产者消费者模式，\n\t\n\tconst {Provider, Consumer} = React.createContext({\n\t    color: 'white'\n\t});\n\t \n\t \n\tclass Item extends Component {\n\t    static contextTypes = {\n\t        color: React.PropTypes.string,\n\t    };\n\t \n\t    render() {\n\t        const {value} = this.props;\n\t        return (\n\t            <Consumer>\n\t                {context => (\n\t                    <li style={{background: context.color}}>\n\t                        <span>{value}</span>\n\t                    </li>\n\t                )}\n\t            </Consumer>\n\t        );\n\t    }\n\t}\n\t \n\t \n\tclass List extends Component {\n\t \n\t    render() {\n\t        const {list} = [{id: '1', text: 1}, {id: '1', text: 2}, {id: '1', text: 3}]\n\t        return (\n\t            <Provider value={{color: 'green'}}>\n\t                <div>\n\t                    <ul>\n\t                        {list.map((entry, index) => (\n\t                            <Item key={entry.id} value={entry.text}/>\n\t                        ))}\n\t                    </ul>\n\t                </div>\n\t            </Provider>\n\t        );\n\t    }\n\t}\n\n**上面的代码通过React.createContext创建出一个上下文：Context对象，然后这个Context对象又包含两个属性，一个叫Provider，另一个叫Consumer，这两个属性都是纯种的React组件。**\n\n**在父组件中运用Provider，在子组件中运用Consumer即可，Provider中通过value属性可以向Consumer传递参数，而Consumer的子组件则是一个函数，在这个子组件中定义一个函数，Consumer会向它传递一个context，这个context来自于Provider，达到通信的目的**\n\n### 非嵌套组件间通信\n\n**这里我们采用自定义事件的方式来实现非嵌套组件间的通信。**\n\n\tnpm install events --save\n\n> 新建一个 ev.js，引入 events 包，并向外提供一个事件对象，供通信时使用：\n\n\timport { EventEmitter } from \"events\";\n\texport default new EventEmitter();\n\n> App.js：\n\n\timport React, { Component } from 'react';\n\n\timport Foo from \"./Foo\";\n\timport Boo from \"./Boo\";\n\t\n\timport \"./App.css\";\n\t\n\texport default class App extends Component{\n\t    render(){\n\t        return(\n\t            <div>\n\t                <Foo />\n\t                <Boo />\n\t            </div>\n\t        );\n\t    }\n\t}\n\n> Foo.js：\n\n\timport React,{ Component } from \"react\";\n\timport emitter from \"./ev\"\n\t\n\texport default class Foo extends Component{\n\t    constructor(props) {\n\t        super(props);\n\t        this.state = {\n\t            msg:null,\n\t        };\n\t    }\n\t    componentDidMount(){\n\t        // 声明一个自定义事件\n\t        // 在组件装载完成以后\n\t        this.eventEmitter = emitter.addListener(\"callMe\",(msg)=>{\n\t            this.setState({\n\t                msg\n\t            })\n\t        });\n\t    }\n\t    // 组件销毁前移除事件监听\n\t    componentWillUnmount(){\n\t        emitter.removeListener(this.eventEmitter);\n\t    }\n\t    render(){\n\t        return(\n\t            <div>\n\t                { this.state.msg }\n\t                我是非嵌套 1 号\n\t            </div>\n\t        );\n\t    }\n\t}\n\n> Boo.js：\n\n\timport React,{ Component } from \"react\";\n\timport emitter from \"./ev\"\n\t\n\texport default class Boo extends Component{\n\t    render(){\n\t        const cb = (msg) => {\n\t            return () => {\n\t                // 触发自定义事件\n\t                emitter.emit(\"callMe\",\"Hello\")\n\t            }\n\t        }\n\t        return(\n\t            <div>\n\t                我是非嵌套 2 号\n\t                <button onClick = { cb(\"blue\") }>点击我</button>\n\t            </div>\n\t        );\n\t    }\n\t}\n\n**自定义事件是典型的发布/订阅模式，通过向事件对象上添加监听器和触发事件来实现组件间通信。**\n\n## 总结：\n\n- 父传子：通过props\n- 子传父：通过回调\n- 跨组件传值： 引入react.createContext()中的{provider, consumer}，使用生产者和消费者模式，在父组件中使用provider 传入值，子组件通consumer 接收一个对象的函数回调[<consumer>{context => (<\\li>{context}<\\/li>)}]\n- 同级组件通讯：使用events插件，通过发布订阅者模式执行\n\n\n\n\n\n","source":"_posts/react-optimization.md","raw":"---\ntitle: react组件优化及组件通讯\ndate: '4/3/2019 4:46:51 PM '\ntag: ['js', 'react']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n## react组件优化\n\n### key值\n\n**在使用v-for的情况下，给每个变量的元素都加上key值，加key值得好处已经在上一文中提到过，主要为了提高渲染效率**\n\n### shouldComponentUpdate\n\n**该生命周期可以决定数据改变的时候是否进行render，返回值为boolean，返回true即为渲染，返回false及不渲染，默认不写为true**\n\n### 纯函数组件\n\n**将单独的项封装成一个组件，已达到服用效果**\n\n## 组件通讯\n\n### 父传子\n\n> 使用props传值\n\n**父组件**\n\n\timport React,{ Component } from \"react\";\n\timport Sub from \"./SubComponent.js\";\n\timport \"./App.css\";\n\t\n\texport default class App extends Component{\n\t\n\t    render(){\n\t        return(\n\t            <div>\n\t                <Sub title = \"今年过节不收礼\" />\n\t            </div>\n\t        )\n\t    }\n\t}\n\n**子组件**\n\n\timport React from \"react\";\n\n\tconst Sub = (props) => {\n\t    return(\n\t        <h1>\n\t            { props.title }\n\t        </h1>\n\t    )\n\t}\n\t\n\texport default Sub;\n\n### 子传父\n\n**父组件**\n\n\timport React,{ Component } from \"react\";\n\timport Sub from \"./SubComponent.js\";\n\timport \"./App.css\";\n\t\n\texport default class App extends Component{\n\t    callback(msg){\n\t        console.log(msg);\n\t    }\n\t    render(){\n\t        return(\n\t            <div>\n\t                <Sub callback = { this.callback.bind(this) } />\n\t            </div>\n\t        )\n\t    }\n\t}\n\n**子组件**\n\n\timport React from \"react\";\n\n\tconst Sub = (props) => {\n\t    const cb = (msg) => {\n\t        return () => {\n\t            props.callback(msg)\n\t        }\n\t    }\n\t    return(\n\t        <div>\n\t            <button onClick = { cb(\"我们通信把\") }>点击我</button>\n\t        </div>\n\t    )\n\t}\n\t\n\texport default Sub;\n\n### 跨组件传值\n\n> 16.3版本提供了新的context api,并且用了生产者消费者模式，\n\t\n\tconst {Provider, Consumer} = React.createContext({\n\t    color: 'white'\n\t});\n\t \n\t \n\tclass Item extends Component {\n\t    static contextTypes = {\n\t        color: React.PropTypes.string,\n\t    };\n\t \n\t    render() {\n\t        const {value} = this.props;\n\t        return (\n\t            <Consumer>\n\t                {context => (\n\t                    <li style={{background: context.color}}>\n\t                        <span>{value}</span>\n\t                    </li>\n\t                )}\n\t            </Consumer>\n\t        );\n\t    }\n\t}\n\t \n\t \n\tclass List extends Component {\n\t \n\t    render() {\n\t        const {list} = [{id: '1', text: 1}, {id: '1', text: 2}, {id: '1', text: 3}]\n\t        return (\n\t            <Provider value={{color: 'green'}}>\n\t                <div>\n\t                    <ul>\n\t                        {list.map((entry, index) => (\n\t                            <Item key={entry.id} value={entry.text}/>\n\t                        ))}\n\t                    </ul>\n\t                </div>\n\t            </Provider>\n\t        );\n\t    }\n\t}\n\n**上面的代码通过React.createContext创建出一个上下文：Context对象，然后这个Context对象又包含两个属性，一个叫Provider，另一个叫Consumer，这两个属性都是纯种的React组件。**\n\n**在父组件中运用Provider，在子组件中运用Consumer即可，Provider中通过value属性可以向Consumer传递参数，而Consumer的子组件则是一个函数，在这个子组件中定义一个函数，Consumer会向它传递一个context，这个context来自于Provider，达到通信的目的**\n\n### 非嵌套组件间通信\n\n**这里我们采用自定义事件的方式来实现非嵌套组件间的通信。**\n\n\tnpm install events --save\n\n> 新建一个 ev.js，引入 events 包，并向外提供一个事件对象，供通信时使用：\n\n\timport { EventEmitter } from \"events\";\n\texport default new EventEmitter();\n\n> App.js：\n\n\timport React, { Component } from 'react';\n\n\timport Foo from \"./Foo\";\n\timport Boo from \"./Boo\";\n\t\n\timport \"./App.css\";\n\t\n\texport default class App extends Component{\n\t    render(){\n\t        return(\n\t            <div>\n\t                <Foo />\n\t                <Boo />\n\t            </div>\n\t        );\n\t    }\n\t}\n\n> Foo.js：\n\n\timport React,{ Component } from \"react\";\n\timport emitter from \"./ev\"\n\t\n\texport default class Foo extends Component{\n\t    constructor(props) {\n\t        super(props);\n\t        this.state = {\n\t            msg:null,\n\t        };\n\t    }\n\t    componentDidMount(){\n\t        // 声明一个自定义事件\n\t        // 在组件装载完成以后\n\t        this.eventEmitter = emitter.addListener(\"callMe\",(msg)=>{\n\t            this.setState({\n\t                msg\n\t            })\n\t        });\n\t    }\n\t    // 组件销毁前移除事件监听\n\t    componentWillUnmount(){\n\t        emitter.removeListener(this.eventEmitter);\n\t    }\n\t    render(){\n\t        return(\n\t            <div>\n\t                { this.state.msg }\n\t                我是非嵌套 1 号\n\t            </div>\n\t        );\n\t    }\n\t}\n\n> Boo.js：\n\n\timport React,{ Component } from \"react\";\n\timport emitter from \"./ev\"\n\t\n\texport default class Boo extends Component{\n\t    render(){\n\t        const cb = (msg) => {\n\t            return () => {\n\t                // 触发自定义事件\n\t                emitter.emit(\"callMe\",\"Hello\")\n\t            }\n\t        }\n\t        return(\n\t            <div>\n\t                我是非嵌套 2 号\n\t                <button onClick = { cb(\"blue\") }>点击我</button>\n\t            </div>\n\t        );\n\t    }\n\t}\n\n**自定义事件是典型的发布/订阅模式，通过向事件对象上添加监听器和触发事件来实现组件间通信。**\n\n## 总结：\n\n- 父传子：通过props\n- 子传父：通过回调\n- 跨组件传值： 引入react.createContext()中的{provider, consumer}，使用生产者和消费者模式，在父组件中使用provider 传入值，子组件通consumer 接收一个对象的函数回调[<consumer>{context => (<\\li>{context}<\\/li>)}]\n- 同级组件通讯：使用events插件，通过发布订阅者模式执行\n\n\n\n\n\n","slug":"react-optimization","published":1,"updated":"2019-04-03T08:46:59.491Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam7d001sn4wdib69s8bp","content":"<h2 id=\"react组件优化\"><a href=\"#react组件优化\" class=\"headerlink\" title=\"react组件优化\"></a>react组件优化</h2><h3 id=\"key值\"><a href=\"#key值\" class=\"headerlink\" title=\"key值\"></a>key值</h3><p><strong>在使用v-for的情况下，给每个变量的元素都加上key值，加key值得好处已经在上一文中提到过，主要为了提高渲染效率</strong></p>\n<h3 id=\"shouldComponentUpdate\"><a href=\"#shouldComponentUpdate\" class=\"headerlink\" title=\"shouldComponentUpdate\"></a>shouldComponentUpdate</h3><p><strong>该生命周期可以决定数据改变的时候是否进行render，返回值为boolean，返回true即为渲染，返回false及不渲染，默认不写为true</strong></p>\n<h3 id=\"纯函数组件\"><a href=\"#纯函数组件\" class=\"headerlink\" title=\"纯函数组件\"></a>纯函数组件</h3><p><strong>将单独的项封装成一个组件，已达到服用效果</strong></p>\n<h2 id=\"组件通讯\"><a href=\"#组件通讯\" class=\"headerlink\" title=\"组件通讯\"></a>组件通讯</h2><h3 id=\"父传子\"><a href=\"#父传子\" class=\"headerlink\" title=\"父传子\"></a>父传子</h3><blockquote>\n<p>使用props传值</p>\n</blockquote>\n<p><strong>父组件</strong></p>\n<pre><code>import React,{ Component } from &quot;react&quot;;\nimport Sub from &quot;./SubComponent.js&quot;;\nimport &quot;./App.css&quot;;\n\nexport default class App extends Component{\n\n    render(){\n        return(\n            &lt;div&gt;\n                &lt;Sub title = &quot;今年过节不收礼&quot; /&gt;\n            &lt;/div&gt;\n        )\n    }\n}\n</code></pre><p><strong>子组件</strong></p>\n<pre><code>import React from &quot;react&quot;;\n\nconst Sub = (props) =&gt; {\n    return(\n        &lt;h1&gt;\n            { props.title }\n        &lt;/h1&gt;\n    )\n}\n\nexport default Sub;\n</code></pre><h3 id=\"子传父\"><a href=\"#子传父\" class=\"headerlink\" title=\"子传父\"></a>子传父</h3><p><strong>父组件</strong></p>\n<pre><code>import React,{ Component } from &quot;react&quot;;\nimport Sub from &quot;./SubComponent.js&quot;;\nimport &quot;./App.css&quot;;\n\nexport default class App extends Component{\n    callback(msg){\n        console.log(msg);\n    }\n    render(){\n        return(\n            &lt;div&gt;\n                &lt;Sub callback = { this.callback.bind(this) } /&gt;\n            &lt;/div&gt;\n        )\n    }\n}\n</code></pre><p><strong>子组件</strong></p>\n<pre><code>import React from &quot;react&quot;;\n\nconst Sub = (props) =&gt; {\n    const cb = (msg) =&gt; {\n        return () =&gt; {\n            props.callback(msg)\n        }\n    }\n    return(\n        &lt;div&gt;\n            &lt;button onClick = { cb(&quot;我们通信把&quot;) }&gt;点击我&lt;/button&gt;\n        &lt;/div&gt;\n    )\n}\n\nexport default Sub;\n</code></pre><h3 id=\"跨组件传值\"><a href=\"#跨组件传值\" class=\"headerlink\" title=\"跨组件传值\"></a>跨组件传值</h3><blockquote>\n<p>16.3版本提供了新的context api,并且用了生产者消费者模式，</p>\n</blockquote>\n<pre><code>const {Provider, Consumer} = React.createContext({\n    color: &#39;white&#39;\n});\n\n\nclass Item extends Component {\n    static contextTypes = {\n        color: React.PropTypes.string,\n    };\n\n    render() {\n        const {value} = this.props;\n        return (\n            &lt;Consumer&gt;\n                {context =&gt; (\n                    &lt;li style={{background: context.color}}&gt;\n                        &lt;span&gt;{value}&lt;/span&gt;\n                    &lt;/li&gt;\n                )}\n            &lt;/Consumer&gt;\n        );\n    }\n}\n\n\nclass List extends Component {\n\n    render() {\n        const {list} = [{id: &#39;1&#39;, text: 1}, {id: &#39;1&#39;, text: 2}, {id: &#39;1&#39;, text: 3}]\n        return (\n            &lt;Provider value={{color: 'green'}}&gt;\n                &lt;div&gt;\n                    &lt;ul&gt;\n                        {list.map((entry, index) =&gt; (\n                            &lt;Item key={entry.id} value={entry.text}/&gt;\n                        ))}\n                    &lt;/ul&gt;\n                &lt;/div&gt;\n            &lt;/Provider&gt;\n        );\n    }\n}\n</code></pre><p><strong>上面的代码通过React.createContext创建出一个上下文：Context对象，然后这个Context对象又包含两个属性，一个叫Provider，另一个叫Consumer，这两个属性都是纯种的React组件。</strong></p>\n<p><strong>在父组件中运用Provider，在子组件中运用Consumer即可，Provider中通过value属性可以向Consumer传递参数，而Consumer的子组件则是一个函数，在这个子组件中定义一个函数，Consumer会向它传递一个context，这个context来自于Provider，达到通信的目的</strong></p>\n<h3 id=\"非嵌套组件间通信\"><a href=\"#非嵌套组件间通信\" class=\"headerlink\" title=\"非嵌套组件间通信\"></a>非嵌套组件间通信</h3><p><strong>这里我们采用自定义事件的方式来实现非嵌套组件间的通信。</strong></p>\n<pre><code>npm install events --save\n</code></pre><blockquote>\n<p>新建一个 ev.js，引入 events 包，并向外提供一个事件对象，供通信时使用：</p>\n</blockquote>\n<pre><code>import { EventEmitter } from &quot;events&quot;;\nexport default new EventEmitter();\n</code></pre><blockquote>\n<p>App.js：</p>\n</blockquote>\n<pre><code>import React, { Component } from &#39;react&#39;;\n\nimport Foo from &quot;./Foo&quot;;\nimport Boo from &quot;./Boo&quot;;\n\nimport &quot;./App.css&quot;;\n\nexport default class App extends Component{\n    render(){\n        return(\n            &lt;div&gt;\n                &lt;Foo /&gt;\n                &lt;Boo /&gt;\n            &lt;/div&gt;\n        );\n    }\n}\n</code></pre><blockquote>\n<p>Foo.js：</p>\n</blockquote>\n<pre><code>import React,{ Component } from &quot;react&quot;;\nimport emitter from &quot;./ev&quot;\n\nexport default class Foo extends Component{\n    constructor(props) {\n        super(props);\n        this.state = {\n            msg:null,\n        };\n    }\n    componentDidMount(){\n        // 声明一个自定义事件\n        // 在组件装载完成以后\n        this.eventEmitter = emitter.addListener(&quot;callMe&quot;,(msg)=&gt;{\n            this.setState({\n                msg\n            })\n        });\n    }\n    // 组件销毁前移除事件监听\n    componentWillUnmount(){\n        emitter.removeListener(this.eventEmitter);\n    }\n    render(){\n        return(\n            &lt;div&gt;\n                { this.state.msg }\n                我是非嵌套 1 号\n            &lt;/div&gt;\n        );\n    }\n}\n</code></pre><blockquote>\n<p>Boo.js：</p>\n</blockquote>\n<pre><code>import React,{ Component } from &quot;react&quot;;\nimport emitter from &quot;./ev&quot;\n\nexport default class Boo extends Component{\n    render(){\n        const cb = (msg) =&gt; {\n            return () =&gt; {\n                // 触发自定义事件\n                emitter.emit(&quot;callMe&quot;,&quot;Hello&quot;)\n            }\n        }\n        return(\n            &lt;div&gt;\n                我是非嵌套 2 号\n                &lt;button onClick = { cb(&quot;blue&quot;) }&gt;点击我&lt;/button&gt;\n            &lt;/div&gt;\n        );\n    }\n}\n</code></pre><p><strong>自定义事件是典型的发布/订阅模式，通过向事件对象上添加监听器和触发事件来实现组件间通信。</strong></p>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><ul>\n<li>父传子：通过props</li>\n<li>子传父：通过回调</li>\n<li>跨组件传值： 引入react.createContext()中的{provider, consumer}，使用生产者和消费者模式，在父组件中使用provider 传入值，子组件通consumer 接收一个对象的函数回调[<consumer>{context =&gt; (&lt;\\li&gt;{context}&lt;\\/li&gt;)}]</consumer></li>\n<li>同级组件通讯：使用events插件，通过发布订阅者模式执行</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"react组件优化\"><a href=\"#react组件优化\" class=\"headerlink\" title=\"react组件优化\"></a>react组件优化</h2><h3 id=\"key值\"><a href=\"#key值\" class=\"headerlink\" title=\"key值\"></a>key值</h3><p><strong>在使用v-for的情况下，给每个变量的元素都加上key值，加key值得好处已经在上一文中提到过，主要为了提高渲染效率</strong></p>\n<h3 id=\"shouldComponentUpdate\"><a href=\"#shouldComponentUpdate\" class=\"headerlink\" title=\"shouldComponentUpdate\"></a>shouldComponentUpdate</h3><p><strong>该生命周期可以决定数据改变的时候是否进行render，返回值为boolean，返回true即为渲染，返回false及不渲染，默认不写为true</strong></p>\n<h3 id=\"纯函数组件\"><a href=\"#纯函数组件\" class=\"headerlink\" title=\"纯函数组件\"></a>纯函数组件</h3><p><strong>将单独的项封装成一个组件，已达到服用效果</strong></p>\n<h2 id=\"组件通讯\"><a href=\"#组件通讯\" class=\"headerlink\" title=\"组件通讯\"></a>组件通讯</h2><h3 id=\"父传子\"><a href=\"#父传子\" class=\"headerlink\" title=\"父传子\"></a>父传子</h3><blockquote>\n<p>使用props传值</p>\n</blockquote>\n<p><strong>父组件</strong></p>\n<pre><code>import React,{ Component } from &quot;react&quot;;\nimport Sub from &quot;./SubComponent.js&quot;;\nimport &quot;./App.css&quot;;\n\nexport default class App extends Component{\n\n    render(){\n        return(\n            &lt;div&gt;\n                &lt;Sub title = &quot;今年过节不收礼&quot; /&gt;\n            &lt;/div&gt;\n        )\n    }\n}\n</code></pre><p><strong>子组件</strong></p>\n<pre><code>import React from &quot;react&quot;;\n\nconst Sub = (props) =&gt; {\n    return(\n        &lt;h1&gt;\n            { props.title }\n        &lt;/h1&gt;\n    )\n}\n\nexport default Sub;\n</code></pre><h3 id=\"子传父\"><a href=\"#子传父\" class=\"headerlink\" title=\"子传父\"></a>子传父</h3><p><strong>父组件</strong></p>\n<pre><code>import React,{ Component } from &quot;react&quot;;\nimport Sub from &quot;./SubComponent.js&quot;;\nimport &quot;./App.css&quot;;\n\nexport default class App extends Component{\n    callback(msg){\n        console.log(msg);\n    }\n    render(){\n        return(\n            &lt;div&gt;\n                &lt;Sub callback = { this.callback.bind(this) } /&gt;\n            &lt;/div&gt;\n        )\n    }\n}\n</code></pre><p><strong>子组件</strong></p>\n<pre><code>import React from &quot;react&quot;;\n\nconst Sub = (props) =&gt; {\n    const cb = (msg) =&gt; {\n        return () =&gt; {\n            props.callback(msg)\n        }\n    }\n    return(\n        &lt;div&gt;\n            &lt;button onClick = { cb(&quot;我们通信把&quot;) }&gt;点击我&lt;/button&gt;\n        &lt;/div&gt;\n    )\n}\n\nexport default Sub;\n</code></pre><h3 id=\"跨组件传值\"><a href=\"#跨组件传值\" class=\"headerlink\" title=\"跨组件传值\"></a>跨组件传值</h3><blockquote>\n<p>16.3版本提供了新的context api,并且用了生产者消费者模式，</p>\n</blockquote>\n<pre><code>const {Provider, Consumer} = React.createContext({\n    color: &#39;white&#39;\n});\n\n\nclass Item extends Component {\n    static contextTypes = {\n        color: React.PropTypes.string,\n    };\n\n    render() {\n        const {value} = this.props;\n        return (\n            &lt;Consumer&gt;\n                {context =&gt; (\n                    &lt;li style={{background: context.color}}&gt;\n                        &lt;span&gt;{value}&lt;/span&gt;\n                    &lt;/li&gt;\n                )}\n            &lt;/Consumer&gt;\n        );\n    }\n}\n\n\nclass List extends Component {\n\n    render() {\n        const {list} = [{id: &#39;1&#39;, text: 1}, {id: &#39;1&#39;, text: 2}, {id: &#39;1&#39;, text: 3}]\n        return (\n            &lt;Provider value={{color: 'green'}}&gt;\n                &lt;div&gt;\n                    &lt;ul&gt;\n                        {list.map((entry, index) =&gt; (\n                            &lt;Item key={entry.id} value={entry.text}/&gt;\n                        ))}\n                    &lt;/ul&gt;\n                &lt;/div&gt;\n            &lt;/Provider&gt;\n        );\n    }\n}\n</code></pre><p><strong>上面的代码通过React.createContext创建出一个上下文：Context对象，然后这个Context对象又包含两个属性，一个叫Provider，另一个叫Consumer，这两个属性都是纯种的React组件。</strong></p>\n<p><strong>在父组件中运用Provider，在子组件中运用Consumer即可，Provider中通过value属性可以向Consumer传递参数，而Consumer的子组件则是一个函数，在这个子组件中定义一个函数，Consumer会向它传递一个context，这个context来自于Provider，达到通信的目的</strong></p>\n<h3 id=\"非嵌套组件间通信\"><a href=\"#非嵌套组件间通信\" class=\"headerlink\" title=\"非嵌套组件间通信\"></a>非嵌套组件间通信</h3><p><strong>这里我们采用自定义事件的方式来实现非嵌套组件间的通信。</strong></p>\n<pre><code>npm install events --save\n</code></pre><blockquote>\n<p>新建一个 ev.js，引入 events 包，并向外提供一个事件对象，供通信时使用：</p>\n</blockquote>\n<pre><code>import { EventEmitter } from &quot;events&quot;;\nexport default new EventEmitter();\n</code></pre><blockquote>\n<p>App.js：</p>\n</blockquote>\n<pre><code>import React, { Component } from &#39;react&#39;;\n\nimport Foo from &quot;./Foo&quot;;\nimport Boo from &quot;./Boo&quot;;\n\nimport &quot;./App.css&quot;;\n\nexport default class App extends Component{\n    render(){\n        return(\n            &lt;div&gt;\n                &lt;Foo /&gt;\n                &lt;Boo /&gt;\n            &lt;/div&gt;\n        );\n    }\n}\n</code></pre><blockquote>\n<p>Foo.js：</p>\n</blockquote>\n<pre><code>import React,{ Component } from &quot;react&quot;;\nimport emitter from &quot;./ev&quot;\n\nexport default class Foo extends Component{\n    constructor(props) {\n        super(props);\n        this.state = {\n            msg:null,\n        };\n    }\n    componentDidMount(){\n        // 声明一个自定义事件\n        // 在组件装载完成以后\n        this.eventEmitter = emitter.addListener(&quot;callMe&quot;,(msg)=&gt;{\n            this.setState({\n                msg\n            })\n        });\n    }\n    // 组件销毁前移除事件监听\n    componentWillUnmount(){\n        emitter.removeListener(this.eventEmitter);\n    }\n    render(){\n        return(\n            &lt;div&gt;\n                { this.state.msg }\n                我是非嵌套 1 号\n            &lt;/div&gt;\n        );\n    }\n}\n</code></pre><blockquote>\n<p>Boo.js：</p>\n</blockquote>\n<pre><code>import React,{ Component } from &quot;react&quot;;\nimport emitter from &quot;./ev&quot;\n\nexport default class Boo extends Component{\n    render(){\n        const cb = (msg) =&gt; {\n            return () =&gt; {\n                // 触发自定义事件\n                emitter.emit(&quot;callMe&quot;,&quot;Hello&quot;)\n            }\n        }\n        return(\n            &lt;div&gt;\n                我是非嵌套 2 号\n                &lt;button onClick = { cb(&quot;blue&quot;) }&gt;点击我&lt;/button&gt;\n            &lt;/div&gt;\n        );\n    }\n}\n</code></pre><p><strong>自定义事件是典型的发布/订阅模式，通过向事件对象上添加监听器和触发事件来实现组件间通信。</strong></p>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><ul>\n<li>父传子：通过props</li>\n<li>子传父：通过回调</li>\n<li>跨组件传值： 引入react.createContext()中的{provider, consumer}，使用生产者和消费者模式，在父组件中使用provider 传入值，子组件通consumer 接收一个对象的函数回调[<consumer>{context =&gt; (&lt;\\li&gt;{context}&lt;\\/li&gt;)}]</consumer></li>\n<li>同级组件通讯：使用events插件，通过发布订阅者模式执行</li>\n</ul>\n"},{"title":"React组件销毁中清理异步操作和取消请求","date":"2019-04-03T06:12:32.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"## React组件销毁中清理异步操作和取消请求\n\n### 问题描述\n\n**当我们在平时切换组件的时候，会遇到这种情况，如果组件中有异步请求任务，【当接口已经发出请求，但是组件已经销毁，那么接口返回数据后。。。】**\n\n**会有这么一个警告**\n\n> Warning: Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.\n\n----------\n> 翻译： 警告：无法对未安装的组件执行响应状态更新。这是一个禁止操作，但它表示应用程序内存泄漏。要修复，请取消componentwillunmount方法中的所有订阅和异步任务。\n\n### 解决方法\n\n> 情况一: 阻止异步操作\n\n\tcomponentWillUnmount() {\n\t  this.setState = (state, callback) => {\n\t    return\n\t  }\n\t}\n\n> 情况二: 清除定时\n\n\tvar timer;\n\t...\n\tcomponentDidMount = () => {\n\t     timer = setTimeout(() => {\n\t        this.setState({a:123})\n\t    },1000)\n\t}\n\tcomponentWillUnMount = () => {\n\t    clearTimeout(timer)\n\t}\n","source":"_posts/react-question.md","raw":"---\ntitle: React组件销毁中清理异步操作和取消请求\ndate: '4/3/2019 2:12:32 PM '\ntag: ['js', 'react']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n## React组件销毁中清理异步操作和取消请求\n\n### 问题描述\n\n**当我们在平时切换组件的时候，会遇到这种情况，如果组件中有异步请求任务，【当接口已经发出请求，但是组件已经销毁，那么接口返回数据后。。。】**\n\n**会有这么一个警告**\n\n> Warning: Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.\n\n----------\n> 翻译： 警告：无法对未安装的组件执行响应状态更新。这是一个禁止操作，但它表示应用程序内存泄漏。要修复，请取消componentwillunmount方法中的所有订阅和异步任务。\n\n### 解决方法\n\n> 情况一: 阻止异步操作\n\n\tcomponentWillUnmount() {\n\t  this.setState = (state, callback) => {\n\t    return\n\t  }\n\t}\n\n> 情况二: 清除定时\n\n\tvar timer;\n\t...\n\tcomponentDidMount = () => {\n\t     timer = setTimeout(() => {\n\t        this.setState({a:123})\n\t    },1000)\n\t}\n\tcomponentWillUnMount = () => {\n\t    clearTimeout(timer)\n\t}\n","slug":"react-question","published":1,"updated":"2019-04-03T06:12:36.154Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam7f001vn4wdobvpgkgy","content":"<h2 id=\"React组件销毁中清理异步操作和取消请求\"><a href=\"#React组件销毁中清理异步操作和取消请求\" class=\"headerlink\" title=\"React组件销毁中清理异步操作和取消请求\"></a>React组件销毁中清理异步操作和取消请求</h2><h3 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h3><p><strong>当我们在平时切换组件的时候，会遇到这种情况，如果组件中有异步请求任务，【当接口已经发出请求，但是组件已经销毁，那么接口返回数据后。。。】</strong></p>\n<p><strong>会有这么一个警告</strong></p>\n<blockquote>\n<p>Warning: Can’t perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>翻译： 警告：无法对未安装的组件执行响应状态更新。这是一个禁止操作，但它表示应用程序内存泄漏。要修复，请取消componentwillunmount方法中的所有订阅和异步任务。</p>\n</blockquote>\n<h3 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h3><blockquote>\n<p>情况一: 阻止异步操作</p>\n</blockquote>\n<pre><code>componentWillUnmount() {\n  this.setState = (state, callback) =&gt; {\n    return\n  }\n}\n</code></pre><blockquote>\n<p>情况二: 清除定时</p>\n</blockquote>\n<pre><code>var timer;\n...\ncomponentDidMount = () =&gt; {\n     timer = setTimeout(() =&gt; {\n        this.setState({a:123})\n    },1000)\n}\ncomponentWillUnMount = () =&gt; {\n    clearTimeout(timer)\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"React组件销毁中清理异步操作和取消请求\"><a href=\"#React组件销毁中清理异步操作和取消请求\" class=\"headerlink\" title=\"React组件销毁中清理异步操作和取消请求\"></a>React组件销毁中清理异步操作和取消请求</h2><h3 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h3><p><strong>当我们在平时切换组件的时候，会遇到这种情况，如果组件中有异步请求任务，【当接口已经发出请求，但是组件已经销毁，那么接口返回数据后。。。】</strong></p>\n<p><strong>会有这么一个警告</strong></p>\n<blockquote>\n<p>Warning: Can’t perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>翻译： 警告：无法对未安装的组件执行响应状态更新。这是一个禁止操作，但它表示应用程序内存泄漏。要修复，请取消componentwillunmount方法中的所有订阅和异步任务。</p>\n</blockquote>\n<h3 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h3><blockquote>\n<p>情况一: 阻止异步操作</p>\n</blockquote>\n<pre><code>componentWillUnmount() {\n  this.setState = (state, callback) =&gt; {\n    return\n  }\n}\n</code></pre><blockquote>\n<p>情况二: 清除定时</p>\n</blockquote>\n<pre><code>var timer;\n...\ncomponentDidMount = () =&gt; {\n     timer = setTimeout(() =&gt; {\n        this.setState({a:123})\n    },1000)\n}\ncomponentWillUnMount = () =&gt; {\n    clearTimeout(timer)\n}\n</code></pre>"},{"title":"使用react-native基础环境搭建","date":"2019-05-22T10:06:58.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"## 使用react-native基础环境搭建\n\n## Android Studio开发window环境搭建 \n\n### Android 开发环境搭建 \n\n**下载jdk**\n> 在这里你可以点击[链接](https://www.oracle.com/technetwork/java/javase/downloads/index.html)去下载\n\n\n**操作步骤按照下图进行操作**\n\n\n>  点进去以后是这么个页面\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.0.png)\n\n----------\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.1.png)\n\n----------\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.2.png)\n\n----------\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.3.png)\n\n----------\n\n**傻瓜式操作**\n\n### 接下来是配置环境变量\n> 小娜搜索\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.4.png)\n\n----------\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.5.png)\n\n----------\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.6.png)\n\n----------\n\n变量名：JAVA_HOME\n变量值：当然是你安装的jdk目录了\n\n> 编辑Path变量值\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.7.png)\n\n在Path值的前头加上 %JAVA_HOME%\\bin;\n\n> CLASSPATH变量\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.8.png)\n\n----------\n看一下如果你的系统变量中没有CLASSPATH变量，就新建一个输入变量值 \n\t\n\t.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;\n\n> 测试\n\n好了，现在我们来测试一下我们的环境变量是否配置成功 “开始”--“cmd”打开我们的dos命了窗口输入 \n\n\tjavac\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.9.png)\n\n----------\n\n### 安装Android Studio\n\n**地址： [http://www.android-studio.org/](http://www.android-studio.org/ \"http://www.android-studio.org/\")**\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.10.png)\n\n----------\n> 现在的安装包一般没有sdk安装，直接下一步，不要慌\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.11.png)\n\n----------\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.12.png)\n\n----------\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.13.png)\n\n----------\n**成功安装后，**\n\n### Android Studio配置\n\n加载本地配置信息提示\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.14.png)\n\n**刚开始打开的时候会问我们是否加载本地的配置信息，其实就是android studio的配置环境信息等，如果你以前没有用过，忽略掉就好了。直接按默认的点ok启动android studio**\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.15.png)\n\n----------\n\n**接下来如果还有，直接Cancel**\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.16.png)\n\n----------\n**这时候我们需要sdk**\n\n附上链接[https://www.androiddevtools.cn/](https://www.androiddevtools.cn/ \"https://www.androiddevtools.cn/\")\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.17.png)\n\n----------\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.18.png)\n\n----------\n> 安装完以后是这个样子\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.19.png)\n\n----------\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.20.png)\n\n----------\n\n### 设置sdk的环境变量\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.21.png)\n\n----------\n\n**设置adb环境变量【用来链接手机，这里不过多阐述】**\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.22.png)\n\n----------\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.23.png)\n\n----------\n\n**验证**\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.24.png)\n\n----------\n\n**基础环境以搭建完成**\n\n> **这里需要着重强调必须node版本为10以上**\n\n\n> 如何安装node就不都在过多阐述\n\n\n*** 安装 react-native-cli ***\n\n\tnpm install -g react-native-cli\n\n**安装完成后，通过 react-native-cli -v 查看版本，确定是否安装成功**\n\n### 初始化项目\n\n**到指定目录下，通过命令行初始化一个项目：**\n\n\treact-native init NewProject\n\n随后开始初始化项目，下载资源：\n\n运行项目\n\n来到项目根目录下，通过输入如下命令来运行项目：\n\n\treact-native run-android\n\n**输入命令后，项目开始初始化运行，运行过程中会打开一个 node 服务窗口，如下所示：**\n\n- ![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.25.png)\n\n----------\n**然后重新输入命令 react-native run-android 来初始化运行项目，程序首先会解压 gradle 压缩文件，第一次初始化可能需要一点时间：**\n\n**初始化完成后，项目运行成功，可以在手机上看到如下界面：**\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.26.png)\n\n----------\n> 到现在为止，一个环境就搭建完成了，中还有少许挫折，但是还是成功了。。。。。。。。。","source":"_posts/react-native-windows.md","raw":"---\ntitle: 使用react-native基础环境搭建\ndate: '5/22/2019 6:06:58 PM '\ntag: ['react-native']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n## 使用react-native基础环境搭建\n\n## Android Studio开发window环境搭建 \n\n### Android 开发环境搭建 \n\n**下载jdk**\n> 在这里你可以点击[链接](https://www.oracle.com/technetwork/java/javase/downloads/index.html)去下载\n\n\n**操作步骤按照下图进行操作**\n\n\n>  点进去以后是这么个页面\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.0.png)\n\n----------\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.1.png)\n\n----------\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.2.png)\n\n----------\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.3.png)\n\n----------\n\n**傻瓜式操作**\n\n### 接下来是配置环境变量\n> 小娜搜索\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.4.png)\n\n----------\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.5.png)\n\n----------\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.6.png)\n\n----------\n\n变量名：JAVA_HOME\n变量值：当然是你安装的jdk目录了\n\n> 编辑Path变量值\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.7.png)\n\n在Path值的前头加上 %JAVA_HOME%\\bin;\n\n> CLASSPATH变量\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.8.png)\n\n----------\n看一下如果你的系统变量中没有CLASSPATH变量，就新建一个输入变量值 \n\t\n\t.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;\n\n> 测试\n\n好了，现在我们来测试一下我们的环境变量是否配置成功 “开始”--“cmd”打开我们的dos命了窗口输入 \n\n\tjavac\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.9.png)\n\n----------\n\n### 安装Android Studio\n\n**地址： [http://www.android-studio.org/](http://www.android-studio.org/ \"http://www.android-studio.org/\")**\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.10.png)\n\n----------\n> 现在的安装包一般没有sdk安装，直接下一步，不要慌\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.11.png)\n\n----------\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.12.png)\n\n----------\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.13.png)\n\n----------\n**成功安装后，**\n\n### Android Studio配置\n\n加载本地配置信息提示\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.14.png)\n\n**刚开始打开的时候会问我们是否加载本地的配置信息，其实就是android studio的配置环境信息等，如果你以前没有用过，忽略掉就好了。直接按默认的点ok启动android studio**\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.15.png)\n\n----------\n\n**接下来如果还有，直接Cancel**\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.16.png)\n\n----------\n**这时候我们需要sdk**\n\n附上链接[https://www.androiddevtools.cn/](https://www.androiddevtools.cn/ \"https://www.androiddevtools.cn/\")\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.17.png)\n\n----------\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.18.png)\n\n----------\n> 安装完以后是这个样子\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.19.png)\n\n----------\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.20.png)\n\n----------\n\n### 设置sdk的环境变量\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.21.png)\n\n----------\n\n**设置adb环境变量【用来链接手机，这里不过多阐述】**\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.22.png)\n\n----------\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.23.png)\n\n----------\n\n**验证**\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.24.png)\n\n----------\n\n**基础环境以搭建完成**\n\n> **这里需要着重强调必须node版本为10以上**\n\n\n> 如何安装node就不都在过多阐述\n\n\n*** 安装 react-native-cli ***\n\n\tnpm install -g react-native-cli\n\n**安装完成后，通过 react-native-cli -v 查看版本，确定是否安装成功**\n\n### 初始化项目\n\n**到指定目录下，通过命令行初始化一个项目：**\n\n\treact-native init NewProject\n\n随后开始初始化项目，下载资源：\n\n运行项目\n\n来到项目根目录下，通过输入如下命令来运行项目：\n\n\treact-native run-android\n\n**输入命令后，项目开始初始化运行，运行过程中会打开一个 node 服务窗口，如下所示：**\n\n- ![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.25.png)\n\n----------\n**然后重新输入命令 react-native run-android 来初始化运行项目，程序首先会解压 gradle 压缩文件，第一次初始化可能需要一点时间：**\n\n**初始化完成后，项目运行成功，可以在手机上看到如下界面：**\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.26.png)\n\n----------\n> 到现在为止，一个环境就搭建完成了，中还有少许挫折，但是还是成功了。。。。。。。。。","slug":"react-native-windows","published":1,"updated":"2019-07-09T08:39:49.153Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam7g001xn4wdd2kfapp5","content":"<h2 id=\"使用react-native基础环境搭建\"><a href=\"#使用react-native基础环境搭建\" class=\"headerlink\" title=\"使用react-native基础环境搭建\"></a>使用react-native基础环境搭建</h2><h2 id=\"Android-Studio开发window环境搭建\"><a href=\"#Android-Studio开发window环境搭建\" class=\"headerlink\" title=\"Android Studio开发window环境搭建\"></a>Android Studio开发window环境搭建</h2><h3 id=\"Android-开发环境搭建\"><a href=\"#Android-开发环境搭建\" class=\"headerlink\" title=\"Android 开发环境搭建\"></a>Android 开发环境搭建</h3><p><strong>下载jdk</strong></p>\n<blockquote>\n<p>在这里你可以点击<a href=\"https://www.oracle.com/technetwork/java/javase/downloads/index.html\" target=\"_blank\" rel=\"noopener\">链接</a>去下载</p>\n</blockquote>\n<p><strong>操作步骤按照下图进行操作</strong></p>\n<blockquote>\n<p> 点进去以后是这么个页面</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.0.png\" alt=\"\"></p>\n<hr>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.1.png\" alt=\"\"></p>\n<hr>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.2.png\" alt=\"\"></p>\n<hr>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.3.png\" alt=\"\"></p>\n<hr>\n<p><strong>傻瓜式操作</strong></p>\n<h3 id=\"接下来是配置环境变量\"><a href=\"#接下来是配置环境变量\" class=\"headerlink\" title=\"接下来是配置环境变量\"></a>接下来是配置环境变量</h3><blockquote>\n<p>小娜搜索</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.4.png\" alt=\"\"></p>\n<hr>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.5.png\" alt=\"\"></p>\n<hr>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.6.png\" alt=\"\"></p>\n<hr>\n<p>变量名：JAVA_HOME<br>变量值：当然是你安装的jdk目录了</p>\n<blockquote>\n<p>编辑Path变量值</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.7.png\" alt=\"\"></p>\n<p>在Path值的前头加上 %JAVA_HOME%\\bin;</p>\n<blockquote>\n<p>CLASSPATH变量</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.8.png\" alt=\"\"></p>\n<hr>\n<p>看一下如果你的系统变量中没有CLASSPATH变量，就新建一个输入变量值 </p>\n<pre><code>.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;\n</code></pre><blockquote>\n<p>测试</p>\n</blockquote>\n<p>好了，现在我们来测试一下我们的环境变量是否配置成功 “开始”–“cmd”打开我们的dos命了窗口输入 </p>\n<pre><code>javac\n</code></pre><p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.9.png\" alt=\"\"></p>\n<hr>\n<h3 id=\"安装Android-Studio\"><a href=\"#安装Android-Studio\" class=\"headerlink\" title=\"安装Android Studio\"></a>安装Android Studio</h3><p><strong>地址： <a href=\"http://www.android-studio.org/\" title=\"http://www.android-studio.org/\" target=\"_blank\" rel=\"noopener\">http://www.android-studio.org/</a></strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.10.png\" alt=\"\"></p>\n<hr>\n<blockquote>\n<p>现在的安装包一般没有sdk安装，直接下一步，不要慌<br><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.11.png\" alt=\"\"></p>\n</blockquote>\n<hr>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.12.png\" alt=\"\"></p>\n<hr>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.13.png\" alt=\"\"></p>\n<hr>\n<p><strong>成功安装后，</strong></p>\n<h3 id=\"Android-Studio配置\"><a href=\"#Android-Studio配置\" class=\"headerlink\" title=\"Android Studio配置\"></a>Android Studio配置</h3><p>加载本地配置信息提示</p>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.14.png\" alt=\"\"></p>\n<p><strong>刚开始打开的时候会问我们是否加载本地的配置信息，其实就是android studio的配置环境信息等，如果你以前没有用过，忽略掉就好了。直接按默认的点ok启动android studio</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.15.png\" alt=\"\"></p>\n<hr>\n<p><strong>接下来如果还有，直接Cancel</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.16.png\" alt=\"\"></p>\n<hr>\n<p><strong>这时候我们需要sdk</strong></p>\n<p>附上链接<a href=\"https://www.androiddevtools.cn/\" title=\"https://www.androiddevtools.cn/\" target=\"_blank\" rel=\"noopener\">https://www.androiddevtools.cn/</a></p>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.17.png\" alt=\"\"></p>\n<hr>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.18.png\" alt=\"\"></p>\n<hr>\n<blockquote>\n<p>安装完以后是这个样子</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.19.png\" alt=\"\"></p>\n<hr>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.20.png\" alt=\"\"></p>\n<hr>\n<h3 id=\"设置sdk的环境变量\"><a href=\"#设置sdk的环境变量\" class=\"headerlink\" title=\"设置sdk的环境变量\"></a>设置sdk的环境变量</h3><p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.21.png\" alt=\"\"></p>\n<hr>\n<p><strong>设置adb环境变量【用来链接手机，这里不过多阐述】</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.22.png\" alt=\"\"></p>\n<hr>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.23.png\" alt=\"\"></p>\n<hr>\n<p><strong>验证</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.24.png\" alt=\"\"></p>\n<hr>\n<p><strong>基础环境以搭建完成</strong></p>\n<blockquote>\n<p><strong>这里需要着重强调必须node版本为10以上</strong></p>\n</blockquote>\n<blockquote>\n<p>如何安装node就不都在过多阐述</p>\n</blockquote>\n<p><strong><em> 安装 react-native-cli </em></strong></p>\n<pre><code>npm install -g react-native-cli\n</code></pre><p><strong>安装完成后，通过 react-native-cli -v 查看版本，确定是否安装成功</strong></p>\n<h3 id=\"初始化项目\"><a href=\"#初始化项目\" class=\"headerlink\" title=\"初始化项目\"></a>初始化项目</h3><p><strong>到指定目录下，通过命令行初始化一个项目：</strong></p>\n<pre><code>react-native init NewProject\n</code></pre><p>随后开始初始化项目，下载资源：</p>\n<p>运行项目</p>\n<p>来到项目根目录下，通过输入如下命令来运行项目：</p>\n<pre><code>react-native run-android\n</code></pre><p><strong>输入命令后，项目开始初始化运行，运行过程中会打开一个 node 服务窗口，如下所示：</strong></p>\n<ul>\n<li><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.25.png\" alt=\"\"></li>\n</ul>\n<hr>\n<p><strong>然后重新输入命令 react-native run-android 来初始化运行项目，程序首先会解压 gradle 压缩文件，第一次初始化可能需要一点时间：</strong></p>\n<p><strong>初始化完成后，项目运行成功，可以在手机上看到如下界面：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.26.png\" alt=\"\"></p>\n<hr>\n<blockquote>\n<p>到现在为止，一个环境就搭建完成了，中还有少许挫折，但是还是成功了。。。。。。。。。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"使用react-native基础环境搭建\"><a href=\"#使用react-native基础环境搭建\" class=\"headerlink\" title=\"使用react-native基础环境搭建\"></a>使用react-native基础环境搭建</h2><h2 id=\"Android-Studio开发window环境搭建\"><a href=\"#Android-Studio开发window环境搭建\" class=\"headerlink\" title=\"Android Studio开发window环境搭建\"></a>Android Studio开发window环境搭建</h2><h3 id=\"Android-开发环境搭建\"><a href=\"#Android-开发环境搭建\" class=\"headerlink\" title=\"Android 开发环境搭建\"></a>Android 开发环境搭建</h3><p><strong>下载jdk</strong></p>\n<blockquote>\n<p>在这里你可以点击<a href=\"https://www.oracle.com/technetwork/java/javase/downloads/index.html\" target=\"_blank\" rel=\"noopener\">链接</a>去下载</p>\n</blockquote>\n<p><strong>操作步骤按照下图进行操作</strong></p>\n<blockquote>\n<p> 点进去以后是这么个页面</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.0.png\" alt=\"\"></p>\n<hr>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.1.png\" alt=\"\"></p>\n<hr>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.2.png\" alt=\"\"></p>\n<hr>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.3.png\" alt=\"\"></p>\n<hr>\n<p><strong>傻瓜式操作</strong></p>\n<h3 id=\"接下来是配置环境变量\"><a href=\"#接下来是配置环境变量\" class=\"headerlink\" title=\"接下来是配置环境变量\"></a>接下来是配置环境变量</h3><blockquote>\n<p>小娜搜索</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.4.png\" alt=\"\"></p>\n<hr>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.5.png\" alt=\"\"></p>\n<hr>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.6.png\" alt=\"\"></p>\n<hr>\n<p>变量名：JAVA_HOME<br>变量值：当然是你安装的jdk目录了</p>\n<blockquote>\n<p>编辑Path变量值</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.7.png\" alt=\"\"></p>\n<p>在Path值的前头加上 %JAVA_HOME%\\bin;</p>\n<blockquote>\n<p>CLASSPATH变量</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.8.png\" alt=\"\"></p>\n<hr>\n<p>看一下如果你的系统变量中没有CLASSPATH变量，就新建一个输入变量值 </p>\n<pre><code>.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;\n</code></pre><blockquote>\n<p>测试</p>\n</blockquote>\n<p>好了，现在我们来测试一下我们的环境变量是否配置成功 “开始”–“cmd”打开我们的dos命了窗口输入 </p>\n<pre><code>javac\n</code></pre><p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.9.png\" alt=\"\"></p>\n<hr>\n<h3 id=\"安装Android-Studio\"><a href=\"#安装Android-Studio\" class=\"headerlink\" title=\"安装Android Studio\"></a>安装Android Studio</h3><p><strong>地址： <a href=\"http://www.android-studio.org/\" title=\"http://www.android-studio.org/\" target=\"_blank\" rel=\"noopener\">http://www.android-studio.org/</a></strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.10.png\" alt=\"\"></p>\n<hr>\n<blockquote>\n<p>现在的安装包一般没有sdk安装，直接下一步，不要慌<br><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.11.png\" alt=\"\"></p>\n</blockquote>\n<hr>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.12.png\" alt=\"\"></p>\n<hr>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.13.png\" alt=\"\"></p>\n<hr>\n<p><strong>成功安装后，</strong></p>\n<h3 id=\"Android-Studio配置\"><a href=\"#Android-Studio配置\" class=\"headerlink\" title=\"Android Studio配置\"></a>Android Studio配置</h3><p>加载本地配置信息提示</p>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.14.png\" alt=\"\"></p>\n<p><strong>刚开始打开的时候会问我们是否加载本地的配置信息，其实就是android studio的配置环境信息等，如果你以前没有用过，忽略掉就好了。直接按默认的点ok启动android studio</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.15.png\" alt=\"\"></p>\n<hr>\n<p><strong>接下来如果还有，直接Cancel</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.16.png\" alt=\"\"></p>\n<hr>\n<p><strong>这时候我们需要sdk</strong></p>\n<p>附上链接<a href=\"https://www.androiddevtools.cn/\" title=\"https://www.androiddevtools.cn/\" target=\"_blank\" rel=\"noopener\">https://www.androiddevtools.cn/</a></p>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.17.png\" alt=\"\"></p>\n<hr>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.18.png\" alt=\"\"></p>\n<hr>\n<blockquote>\n<p>安装完以后是这个样子</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.19.png\" alt=\"\"></p>\n<hr>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.20.png\" alt=\"\"></p>\n<hr>\n<h3 id=\"设置sdk的环境变量\"><a href=\"#设置sdk的环境变量\" class=\"headerlink\" title=\"设置sdk的环境变量\"></a>设置sdk的环境变量</h3><p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.21.png\" alt=\"\"></p>\n<hr>\n<p><strong>设置adb环境变量【用来链接手机，这里不过多阐述】</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.22.png\" alt=\"\"></p>\n<hr>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.23.png\" alt=\"\"></p>\n<hr>\n<p><strong>验证</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.24.png\" alt=\"\"></p>\n<hr>\n<p><strong>基础环境以搭建完成</strong></p>\n<blockquote>\n<p><strong>这里需要着重强调必须node版本为10以上</strong></p>\n</blockquote>\n<blockquote>\n<p>如何安装node就不都在过多阐述</p>\n</blockquote>\n<p><strong><em> 安装 react-native-cli </em></strong></p>\n<pre><code>npm install -g react-native-cli\n</code></pre><p><strong>安装完成后，通过 react-native-cli -v 查看版本，确定是否安装成功</strong></p>\n<h3 id=\"初始化项目\"><a href=\"#初始化项目\" class=\"headerlink\" title=\"初始化项目\"></a>初始化项目</h3><p><strong>到指定目录下，通过命令行初始化一个项目：</strong></p>\n<pre><code>react-native init NewProject\n</code></pre><p>随后开始初始化项目，下载资源：</p>\n<p>运行项目</p>\n<p>来到项目根目录下，通过输入如下命令来运行项目：</p>\n<pre><code>react-native run-android\n</code></pre><p><strong>输入命令后，项目开始初始化运行，运行过程中会打开一个 node 服务窗口，如下所示：</strong></p>\n<ul>\n<li><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.25.png\" alt=\"\"></li>\n</ul>\n<hr>\n<p><strong>然后重新输入命令 react-native run-android 来初始化运行项目，程序首先会解压 gradle 压缩文件，第一次初始化可能需要一点时间：</strong></p>\n<p><strong>初始化完成后，项目运行成功，可以在手机上看到如下界面：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.26.png\" alt=\"\"></p>\n<hr>\n<blockquote>\n<p>到现在为止，一个环境就搭建完成了，中还有少许挫折，但是还是成功了。。。。。。。。。</p>\n</blockquote>\n"},{"title":"session和cookie","date":"2019-02-18T03:59:36.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"\n\n## 无状态的http\n\t\n### http的请求和响应都是对应的，客户端向服务器发送请求数据，服务器端不会记录状态,因此服务器端想知道是哪个客户端提交的请求，通常使用cookie和session来完成\n\n## Cookie【req.cookies】\n\n### cookie是从服务端发送的，服务端给不同的客户端发送不同的标识，这个标识标识该用户的身份，服务器通过这个标识来识别用户的身份，从而将数据发送到该客户端【express使用cookie-parser 】，但是客户端的cookie具有局限性\n\n## 局限性：\n\n### cookie的数量长度限制，每个cookie长度不能超过4kb，最多只能有20条\n\n## Session\n\n### express-session是express的一个中间件来创建session，服务端生成了一个session id，客户端使用cookie保存了session id这个请求的信息，而将用户的请求信息保存到客户端，session记录的客户端与服务端之间的会话状态，该状态是用来确定客户端的身份【req.session】\n\t\n## cookie和session的区别\n\n#### 1、最大的区别应该在于存储的地方不一样，cookie存储在客户端，session存储在服务器；\n\n#### 2、从安全性方面来说，cookie存储在客户端，很容易被窃取，暴露用户信息，而session存储在服务器，被窃取的机会小很多，故session的安全性比cookie高；\n#### 3、从性能方面来说，cookie存储在浏览器端消耗的是用户的资源，相对比较分散，而session消耗的服务器的内存，会造成服务器端的压力；\n#### 4、cookie可以长期的存储在客户端，但是数量和大小都是有限制的；session存在服务器的时间较短，但是没有大小的限制。","source":"_posts/session.md","raw":"---\ntitle: session和cookie\ndate: '2/18/2019 11:59:36 AM '\ntag: ['js', 'session', 'cookie']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n\n\n## 无状态的http\n\t\n### http的请求和响应都是对应的，客户端向服务器发送请求数据，服务器端不会记录状态,因此服务器端想知道是哪个客户端提交的请求，通常使用cookie和session来完成\n\n## Cookie【req.cookies】\n\n### cookie是从服务端发送的，服务端给不同的客户端发送不同的标识，这个标识标识该用户的身份，服务器通过这个标识来识别用户的身份，从而将数据发送到该客户端【express使用cookie-parser 】，但是客户端的cookie具有局限性\n\n## 局限性：\n\n### cookie的数量长度限制，每个cookie长度不能超过4kb，最多只能有20条\n\n## Session\n\n### express-session是express的一个中间件来创建session，服务端生成了一个session id，客户端使用cookie保存了session id这个请求的信息，而将用户的请求信息保存到客户端，session记录的客户端与服务端之间的会话状态，该状态是用来确定客户端的身份【req.session】\n\t\n## cookie和session的区别\n\n#### 1、最大的区别应该在于存储的地方不一样，cookie存储在客户端，session存储在服务器；\n\n#### 2、从安全性方面来说，cookie存储在客户端，很容易被窃取，暴露用户信息，而session存储在服务器，被窃取的机会小很多，故session的安全性比cookie高；\n#### 3、从性能方面来说，cookie存储在浏览器端消耗的是用户的资源，相对比较分散，而session消耗的服务器的内存，会造成服务器端的压力；\n#### 4、cookie可以长期的存储在客户端，但是数量和大小都是有限制的；session存在服务器的时间较短，但是没有大小的限制。","slug":"session","published":1,"updated":"2019-02-18T04:00:07.802Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam7h0020n4wdabj9bkcl","content":"<h2 id=\"无状态的http\"><a href=\"#无状态的http\" class=\"headerlink\" title=\"无状态的http\"></a>无状态的http</h2><h3 id=\"http的请求和响应都是对应的，客户端向服务器发送请求数据，服务器端不会记录状态-因此服务器端想知道是哪个客户端提交的请求，通常使用cookie和session来完成\"><a href=\"#http的请求和响应都是对应的，客户端向服务器发送请求数据，服务器端不会记录状态-因此服务器端想知道是哪个客户端提交的请求，通常使用cookie和session来完成\" class=\"headerlink\" title=\"http的请求和响应都是对应的，客户端向服务器发送请求数据，服务器端不会记录状态,因此服务器端想知道是哪个客户端提交的请求，通常使用cookie和session来完成\"></a>http的请求和响应都是对应的，客户端向服务器发送请求数据，服务器端不会记录状态,因此服务器端想知道是哪个客户端提交的请求，通常使用cookie和session来完成</h3><h2 id=\"Cookie【req-cookies】\"><a href=\"#Cookie【req-cookies】\" class=\"headerlink\" title=\"Cookie【req.cookies】\"></a>Cookie【req.cookies】</h2><h3 id=\"cookie是从服务端发送的，服务端给不同的客户端发送不同的标识，这个标识标识该用户的身份，服务器通过这个标识来识别用户的身份，从而将数据发送到该客户端【express使用cookie-parser-】，但是客户端的cookie具有局限性\"><a href=\"#cookie是从服务端发送的，服务端给不同的客户端发送不同的标识，这个标识标识该用户的身份，服务器通过这个标识来识别用户的身份，从而将数据发送到该客户端【express使用cookie-parser-】，但是客户端的cookie具有局限性\" class=\"headerlink\" title=\"cookie是从服务端发送的，服务端给不同的客户端发送不同的标识，这个标识标识该用户的身份，服务器通过这个标识来识别用户的身份，从而将数据发送到该客户端【express使用cookie-parser 】，但是客户端的cookie具有局限性\"></a>cookie是从服务端发送的，服务端给不同的客户端发送不同的标识，这个标识标识该用户的身份，服务器通过这个标识来识别用户的身份，从而将数据发送到该客户端【express使用cookie-parser 】，但是客户端的cookie具有局限性</h3><h2 id=\"局限性：\"><a href=\"#局限性：\" class=\"headerlink\" title=\"局限性：\"></a>局限性：</h2><h3 id=\"cookie的数量长度限制，每个cookie长度不能超过4kb，最多只能有20条\"><a href=\"#cookie的数量长度限制，每个cookie长度不能超过4kb，最多只能有20条\" class=\"headerlink\" title=\"cookie的数量长度限制，每个cookie长度不能超过4kb，最多只能有20条\"></a>cookie的数量长度限制，每个cookie长度不能超过4kb，最多只能有20条</h3><h2 id=\"Session\"><a href=\"#Session\" class=\"headerlink\" title=\"Session\"></a>Session</h2><h3 id=\"express-session是express的一个中间件来创建session，服务端生成了一个session-id，客户端使用cookie保存了session-id这个请求的信息，而将用户的请求信息保存到客户端，session记录的客户端与服务端之间的会话状态，该状态是用来确定客户端的身份【req-session】\"><a href=\"#express-session是express的一个中间件来创建session，服务端生成了一个session-id，客户端使用cookie保存了session-id这个请求的信息，而将用户的请求信息保存到客户端，session记录的客户端与服务端之间的会话状态，该状态是用来确定客户端的身份【req-session】\" class=\"headerlink\" title=\"express-session是express的一个中间件来创建session，服务端生成了一个session id，客户端使用cookie保存了session id这个请求的信息，而将用户的请求信息保存到客户端，session记录的客户端与服务端之间的会话状态，该状态是用来确定客户端的身份【req.session】\"></a>express-session是express的一个中间件来创建session，服务端生成了一个session id，客户端使用cookie保存了session id这个请求的信息，而将用户的请求信息保存到客户端，session记录的客户端与服务端之间的会话状态，该状态是用来确定客户端的身份【req.session】</h3><h2 id=\"cookie和session的区别\"><a href=\"#cookie和session的区别\" class=\"headerlink\" title=\"cookie和session的区别\"></a>cookie和session的区别</h2><h4 id=\"1、最大的区别应该在于存储的地方不一样，cookie存储在客户端，session存储在服务器；\"><a href=\"#1、最大的区别应该在于存储的地方不一样，cookie存储在客户端，session存储在服务器；\" class=\"headerlink\" title=\"1、最大的区别应该在于存储的地方不一样，cookie存储在客户端，session存储在服务器；\"></a>1、最大的区别应该在于存储的地方不一样，cookie存储在客户端，session存储在服务器；</h4><h4 id=\"2、从安全性方面来说，cookie存储在客户端，很容易被窃取，暴露用户信息，而session存储在服务器，被窃取的机会小很多，故session的安全性比cookie高；\"><a href=\"#2、从安全性方面来说，cookie存储在客户端，很容易被窃取，暴露用户信息，而session存储在服务器，被窃取的机会小很多，故session的安全性比cookie高；\" class=\"headerlink\" title=\"2、从安全性方面来说，cookie存储在客户端，很容易被窃取，暴露用户信息，而session存储在服务器，被窃取的机会小很多，故session的安全性比cookie高；\"></a>2、从安全性方面来说，cookie存储在客户端，很容易被窃取，暴露用户信息，而session存储在服务器，被窃取的机会小很多，故session的安全性比cookie高；</h4><h4 id=\"3、从性能方面来说，cookie存储在浏览器端消耗的是用户的资源，相对比较分散，而session消耗的服务器的内存，会造成服务器端的压力；\"><a href=\"#3、从性能方面来说，cookie存储在浏览器端消耗的是用户的资源，相对比较分散，而session消耗的服务器的内存，会造成服务器端的压力；\" class=\"headerlink\" title=\"3、从性能方面来说，cookie存储在浏览器端消耗的是用户的资源，相对比较分散，而session消耗的服务器的内存，会造成服务器端的压力；\"></a>3、从性能方面来说，cookie存储在浏览器端消耗的是用户的资源，相对比较分散，而session消耗的服务器的内存，会造成服务器端的压力；</h4><h4 id=\"4、cookie可以长期的存储在客户端，但是数量和大小都是有限制的；session存在服务器的时间较短，但是没有大小的限制。\"><a href=\"#4、cookie可以长期的存储在客户端，但是数量和大小都是有限制的；session存在服务器的时间较短，但是没有大小的限制。\" class=\"headerlink\" title=\"4、cookie可以长期的存储在客户端，但是数量和大小都是有限制的；session存在服务器的时间较短，但是没有大小的限制。\"></a>4、cookie可以长期的存储在客户端，但是数量和大小都是有限制的；session存在服务器的时间较短，但是没有大小的限制。</h4>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"无状态的http\"><a href=\"#无状态的http\" class=\"headerlink\" title=\"无状态的http\"></a>无状态的http</h2><h3 id=\"http的请求和响应都是对应的，客户端向服务器发送请求数据，服务器端不会记录状态-因此服务器端想知道是哪个客户端提交的请求，通常使用cookie和session来完成\"><a href=\"#http的请求和响应都是对应的，客户端向服务器发送请求数据，服务器端不会记录状态-因此服务器端想知道是哪个客户端提交的请求，通常使用cookie和session来完成\" class=\"headerlink\" title=\"http的请求和响应都是对应的，客户端向服务器发送请求数据，服务器端不会记录状态,因此服务器端想知道是哪个客户端提交的请求，通常使用cookie和session来完成\"></a>http的请求和响应都是对应的，客户端向服务器发送请求数据，服务器端不会记录状态,因此服务器端想知道是哪个客户端提交的请求，通常使用cookie和session来完成</h3><h2 id=\"Cookie【req-cookies】\"><a href=\"#Cookie【req-cookies】\" class=\"headerlink\" title=\"Cookie【req.cookies】\"></a>Cookie【req.cookies】</h2><h3 id=\"cookie是从服务端发送的，服务端给不同的客户端发送不同的标识，这个标识标识该用户的身份，服务器通过这个标识来识别用户的身份，从而将数据发送到该客户端【express使用cookie-parser-】，但是客户端的cookie具有局限性\"><a href=\"#cookie是从服务端发送的，服务端给不同的客户端发送不同的标识，这个标识标识该用户的身份，服务器通过这个标识来识别用户的身份，从而将数据发送到该客户端【express使用cookie-parser-】，但是客户端的cookie具有局限性\" class=\"headerlink\" title=\"cookie是从服务端发送的，服务端给不同的客户端发送不同的标识，这个标识标识该用户的身份，服务器通过这个标识来识别用户的身份，从而将数据发送到该客户端【express使用cookie-parser 】，但是客户端的cookie具有局限性\"></a>cookie是从服务端发送的，服务端给不同的客户端发送不同的标识，这个标识标识该用户的身份，服务器通过这个标识来识别用户的身份，从而将数据发送到该客户端【express使用cookie-parser 】，但是客户端的cookie具有局限性</h3><h2 id=\"局限性：\"><a href=\"#局限性：\" class=\"headerlink\" title=\"局限性：\"></a>局限性：</h2><h3 id=\"cookie的数量长度限制，每个cookie长度不能超过4kb，最多只能有20条\"><a href=\"#cookie的数量长度限制，每个cookie长度不能超过4kb，最多只能有20条\" class=\"headerlink\" title=\"cookie的数量长度限制，每个cookie长度不能超过4kb，最多只能有20条\"></a>cookie的数量长度限制，每个cookie长度不能超过4kb，最多只能有20条</h3><h2 id=\"Session\"><a href=\"#Session\" class=\"headerlink\" title=\"Session\"></a>Session</h2><h3 id=\"express-session是express的一个中间件来创建session，服务端生成了一个session-id，客户端使用cookie保存了session-id这个请求的信息，而将用户的请求信息保存到客户端，session记录的客户端与服务端之间的会话状态，该状态是用来确定客户端的身份【req-session】\"><a href=\"#express-session是express的一个中间件来创建session，服务端生成了一个session-id，客户端使用cookie保存了session-id这个请求的信息，而将用户的请求信息保存到客户端，session记录的客户端与服务端之间的会话状态，该状态是用来确定客户端的身份【req-session】\" class=\"headerlink\" title=\"express-session是express的一个中间件来创建session，服务端生成了一个session id，客户端使用cookie保存了session id这个请求的信息，而将用户的请求信息保存到客户端，session记录的客户端与服务端之间的会话状态，该状态是用来确定客户端的身份【req.session】\"></a>express-session是express的一个中间件来创建session，服务端生成了一个session id，客户端使用cookie保存了session id这个请求的信息，而将用户的请求信息保存到客户端，session记录的客户端与服务端之间的会话状态，该状态是用来确定客户端的身份【req.session】</h3><h2 id=\"cookie和session的区别\"><a href=\"#cookie和session的区别\" class=\"headerlink\" title=\"cookie和session的区别\"></a>cookie和session的区别</h2><h4 id=\"1、最大的区别应该在于存储的地方不一样，cookie存储在客户端，session存储在服务器；\"><a href=\"#1、最大的区别应该在于存储的地方不一样，cookie存储在客户端，session存储在服务器；\" class=\"headerlink\" title=\"1、最大的区别应该在于存储的地方不一样，cookie存储在客户端，session存储在服务器；\"></a>1、最大的区别应该在于存储的地方不一样，cookie存储在客户端，session存储在服务器；</h4><h4 id=\"2、从安全性方面来说，cookie存储在客户端，很容易被窃取，暴露用户信息，而session存储在服务器，被窃取的机会小很多，故session的安全性比cookie高；\"><a href=\"#2、从安全性方面来说，cookie存储在客户端，很容易被窃取，暴露用户信息，而session存储在服务器，被窃取的机会小很多，故session的安全性比cookie高；\" class=\"headerlink\" title=\"2、从安全性方面来说，cookie存储在客户端，很容易被窃取，暴露用户信息，而session存储在服务器，被窃取的机会小很多，故session的安全性比cookie高；\"></a>2、从安全性方面来说，cookie存储在客户端，很容易被窃取，暴露用户信息，而session存储在服务器，被窃取的机会小很多，故session的安全性比cookie高；</h4><h4 id=\"3、从性能方面来说，cookie存储在浏览器端消耗的是用户的资源，相对比较分散，而session消耗的服务器的内存，会造成服务器端的压力；\"><a href=\"#3、从性能方面来说，cookie存储在浏览器端消耗的是用户的资源，相对比较分散，而session消耗的服务器的内存，会造成服务器端的压力；\" class=\"headerlink\" title=\"3、从性能方面来说，cookie存储在浏览器端消耗的是用户的资源，相对比较分散，而session消耗的服务器的内存，会造成服务器端的压力；\"></a>3、从性能方面来说，cookie存储在浏览器端消耗的是用户的资源，相对比较分散，而session消耗的服务器的内存，会造成服务器端的压力；</h4><h4 id=\"4、cookie可以长期的存储在客户端，但是数量和大小都是有限制的；session存在服务器的时间较短，但是没有大小的限制。\"><a href=\"#4、cookie可以长期的存储在客户端，但是数量和大小都是有限制的；session存在服务器的时间较短，但是没有大小的限制。\" class=\"headerlink\" title=\"4、cookie可以长期的存储在客户端，但是数量和大小都是有限制的；session存在服务器的时间较短，但是没有大小的限制。\"></a>4、cookie可以长期的存储在客户端，但是数量和大小都是有限制的；session存在服务器的时间较短，但是没有大小的限制。</h4>"},{"title":"JS 堆&栈","date":"2019-03-04T03:19:27.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"## JS 堆&栈\n\n### 两者都是存放临时数据的地方\n\n### ⊙ 栈是先进后出的，就像一个桶，后进去的先出来，它下面本来有的东西要等其他出来之后才能出来。\n\n### ⊙ 堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。对于堆，我们可以随心所欲的进行增加变量和删除变量，不用遵循次序。\n\n### ◎ 栈区（stack） 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。 \n\n### ◎ 堆区（heap） 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。\n\n\n----------\n \n\n> **堆是动态分配内存，内存大小不一，也不会自动释放。栈是自动分配相对固定大小的内存空间，并由系统自动释放.**\n\n\n----------\n\n## JS数据类型访问\n\n- 基本数据类型\n\n> Undefined、Null、Boolean、String、Number、Symbol都是直接按值直接存在栈中，每种类型的数据占用的内存空间大小都是固定的，并且由系统自动分配自动释放\n\n- 引用数据类型\n\n> Object，Array，Function这样的数据存在堆内存中，但是数据指针是存放在栈内存中的，当我们访问引用数据时，先从栈内存中获取指针，通过指针在堆内存中找到数据\n\n\tvar a = 2;\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/4.0.png)\n\n\tvar b = new Object();\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/4.1.png)\n\n## 传值和传址\n\n> **从一个向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终指向同一个对象。即复制的是栈中的地址而不是堆中的对象。**\n\n> **从一个变量复向另一个变量复制基本类型的值，会创建这个值的副本。**","source":"_posts/stack heap.md","raw":"---\ntitle: JS 堆&栈\ndate: '3/4/2019 11:19:27 AM '\ntag: ['js', '堆&栈']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n## JS 堆&栈\n\n### 两者都是存放临时数据的地方\n\n### ⊙ 栈是先进后出的，就像一个桶，后进去的先出来，它下面本来有的东西要等其他出来之后才能出来。\n\n### ⊙ 堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。对于堆，我们可以随心所欲的进行增加变量和删除变量，不用遵循次序。\n\n### ◎ 栈区（stack） 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。 \n\n### ◎ 堆区（heap） 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。\n\n\n----------\n \n\n> **堆是动态分配内存，内存大小不一，也不会自动释放。栈是自动分配相对固定大小的内存空间，并由系统自动释放.**\n\n\n----------\n\n## JS数据类型访问\n\n- 基本数据类型\n\n> Undefined、Null、Boolean、String、Number、Symbol都是直接按值直接存在栈中，每种类型的数据占用的内存空间大小都是固定的，并且由系统自动分配自动释放\n\n- 引用数据类型\n\n> Object，Array，Function这样的数据存在堆内存中，但是数据指针是存放在栈内存中的，当我们访问引用数据时，先从栈内存中获取指针，通过指针在堆内存中找到数据\n\n\tvar a = 2;\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/4.0.png)\n\n\tvar b = new Object();\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/4.1.png)\n\n## 传值和传址\n\n> **从一个向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终指向同一个对象。即复制的是栈中的地址而不是堆中的对象。**\n\n> **从一个变量复向另一个变量复制基本类型的值，会创建这个值的副本。**","slug":"stack heap","published":1,"updated":"2019-07-09T08:52:24.887Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam7i0022n4wdptfs3c6a","content":"<h2 id=\"JS-堆-amp-栈\"><a href=\"#JS-堆-amp-栈\" class=\"headerlink\" title=\"JS 堆&amp;栈\"></a>JS 堆&amp;栈</h2><h3 id=\"两者都是存放临时数据的地方\"><a href=\"#两者都是存放临时数据的地方\" class=\"headerlink\" title=\"两者都是存放临时数据的地方\"></a>两者都是存放临时数据的地方</h3><h3 id=\"⊙-栈是先进后出的，就像一个桶，后进去的先出来，它下面本来有的东西要等其他出来之后才能出来。\"><a href=\"#⊙-栈是先进后出的，就像一个桶，后进去的先出来，它下面本来有的东西要等其他出来之后才能出来。\" class=\"headerlink\" title=\"⊙ 栈是先进后出的，就像一个桶，后进去的先出来，它下面本来有的东西要等其他出来之后才能出来。\"></a>⊙ 栈是先进后出的，就像一个桶，后进去的先出来，它下面本来有的东西要等其他出来之后才能出来。</h3><h3 id=\"⊙-堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。对于堆，我们可以随心所欲的进行增加变量和删除变量，不用遵循次序。\"><a href=\"#⊙-堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。对于堆，我们可以随心所欲的进行增加变量和删除变量，不用遵循次序。\" class=\"headerlink\" title=\"⊙ 堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。对于堆，我们可以随心所欲的进行增加变量和删除变量，不用遵循次序。\"></a>⊙ 堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。对于堆，我们可以随心所欲的进行增加变量和删除变量，不用遵循次序。</h3><h3 id=\"◎-栈区（stack）-由编译器自动分配释放-，存放函数的参数值，局部变量的值等。\"><a href=\"#◎-栈区（stack）-由编译器自动分配释放-，存放函数的参数值，局部变量的值等。\" class=\"headerlink\" title=\"◎ 栈区（stack） 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。\"></a>◎ 栈区（stack） 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。</h3><h3 id=\"◎-堆区（heap）-一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。\"><a href=\"#◎-堆区（heap）-一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。\" class=\"headerlink\" title=\"◎ 堆区（heap） 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。\"></a>◎ 堆区（heap） 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。</h3><hr>\n<blockquote>\n<p><strong>堆是动态分配内存，内存大小不一，也不会自动释放。栈是自动分配相对固定大小的内存空间，并由系统自动释放.</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"JS数据类型访问\"><a href=\"#JS数据类型访问\" class=\"headerlink\" title=\"JS数据类型访问\"></a>JS数据类型访问</h2><ul>\n<li>基本数据类型</li>\n</ul>\n<blockquote>\n<p>Undefined、Null、Boolean、String、Number、Symbol都是直接按值直接存在栈中，每种类型的数据占用的内存空间大小都是固定的，并且由系统自动分配自动释放</p>\n</blockquote>\n<ul>\n<li>引用数据类型</li>\n</ul>\n<blockquote>\n<p>Object，Array，Function这样的数据存在堆内存中，但是数据指针是存放在栈内存中的，当我们访问引用数据时，先从栈内存中获取指针，通过指针在堆内存中找到数据</p>\n</blockquote>\n<pre><code>var a = 2;\n</code></pre><p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/4.0.png\" alt=\"\"></p>\n<pre><code>var b = new Object();\n</code></pre><p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/4.1.png\" alt=\"\"></p>\n<h2 id=\"传值和传址\"><a href=\"#传值和传址\" class=\"headerlink\" title=\"传值和传址\"></a>传值和传址</h2><blockquote>\n<p><strong>从一个向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终指向同一个对象。即复制的是栈中的地址而不是堆中的对象。</strong></p>\n</blockquote>\n<blockquote>\n<p><strong>从一个变量复向另一个变量复制基本类型的值，会创建这个值的副本。</strong></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"JS-堆-amp-栈\"><a href=\"#JS-堆-amp-栈\" class=\"headerlink\" title=\"JS 堆&amp;栈\"></a>JS 堆&amp;栈</h2><h3 id=\"两者都是存放临时数据的地方\"><a href=\"#两者都是存放临时数据的地方\" class=\"headerlink\" title=\"两者都是存放临时数据的地方\"></a>两者都是存放临时数据的地方</h3><h3 id=\"⊙-栈是先进后出的，就像一个桶，后进去的先出来，它下面本来有的东西要等其他出来之后才能出来。\"><a href=\"#⊙-栈是先进后出的，就像一个桶，后进去的先出来，它下面本来有的东西要等其他出来之后才能出来。\" class=\"headerlink\" title=\"⊙ 栈是先进后出的，就像一个桶，后进去的先出来，它下面本来有的东西要等其他出来之后才能出来。\"></a>⊙ 栈是先进后出的，就像一个桶，后进去的先出来，它下面本来有的东西要等其他出来之后才能出来。</h3><h3 id=\"⊙-堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。对于堆，我们可以随心所欲的进行增加变量和删除变量，不用遵循次序。\"><a href=\"#⊙-堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。对于堆，我们可以随心所欲的进行增加变量和删除变量，不用遵循次序。\" class=\"headerlink\" title=\"⊙ 堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。对于堆，我们可以随心所欲的进行增加变量和删除变量，不用遵循次序。\"></a>⊙ 堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。对于堆，我们可以随心所欲的进行增加变量和删除变量，不用遵循次序。</h3><h3 id=\"◎-栈区（stack）-由编译器自动分配释放-，存放函数的参数值，局部变量的值等。\"><a href=\"#◎-栈区（stack）-由编译器自动分配释放-，存放函数的参数值，局部变量的值等。\" class=\"headerlink\" title=\"◎ 栈区（stack） 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。\"></a>◎ 栈区（stack） 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。</h3><h3 id=\"◎-堆区（heap）-一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。\"><a href=\"#◎-堆区（heap）-一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。\" class=\"headerlink\" title=\"◎ 堆区（heap） 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。\"></a>◎ 堆区（heap） 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。</h3><hr>\n<blockquote>\n<p><strong>堆是动态分配内存，内存大小不一，也不会自动释放。栈是自动分配相对固定大小的内存空间，并由系统自动释放.</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"JS数据类型访问\"><a href=\"#JS数据类型访问\" class=\"headerlink\" title=\"JS数据类型访问\"></a>JS数据类型访问</h2><ul>\n<li>基本数据类型</li>\n</ul>\n<blockquote>\n<p>Undefined、Null、Boolean、String、Number、Symbol都是直接按值直接存在栈中，每种类型的数据占用的内存空间大小都是固定的，并且由系统自动分配自动释放</p>\n</blockquote>\n<ul>\n<li>引用数据类型</li>\n</ul>\n<blockquote>\n<p>Object，Array，Function这样的数据存在堆内存中，但是数据指针是存放在栈内存中的，当我们访问引用数据时，先从栈内存中获取指针，通过指针在堆内存中找到数据</p>\n</blockquote>\n<pre><code>var a = 2;\n</code></pre><p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/4.0.png\" alt=\"\"></p>\n<pre><code>var b = new Object();\n</code></pre><p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/4.1.png\" alt=\"\"></p>\n<h2 id=\"传值和传址\"><a href=\"#传值和传址\" class=\"headerlink\" title=\"传值和传址\"></a>传值和传址</h2><blockquote>\n<p><strong>从一个向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终指向同一个对象。即复制的是栈中的地址而不是堆中的对象。</strong></p>\n</blockquote>\n<blockquote>\n<p><strong>从一个变量复向另一个变量复制基本类型的值，会创建这个值的副本。</strong></p>\n</blockquote>\n"},{"title":"react中的setState的使用和深入理解","date":"2019-04-03T03:58:21.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"## react中的setState的使用和深入理解\n\n**React通过管理状态实现对组件的管理，通过this.state()方法更新state。当this.setState()被调用的时候，React会重新调用render方法来重新渲染UI。**\n\n**在使用state的时候， 如果我们企图直接修改state中的某一个值之后直接打印（使用）他，就会发现，他其实并没有改变。**\n\n**就像下面的例子，企图通过点击事件之后就使用修改之后的state的值，但是会发state中的并没有被立即修改，还是原先的值，我们都知道那是因为setState就相当于是一个异步操作，不能立即被修改**\n\t\n\tClickChangeState () {\n\t\tthis.setState({\n\t\t\tisActive: true,\n\t\t})\n\t\tconsole.log(this.state.isActive) // false\n\t}\n\n**那么我们也都知道为了解决上面的问题会有很多方法例如：**\n\n> 方法一：\n\n\tClickChangeState () {\n\t\tthis.setState({\n\t\t\tisActive: true,\n\t\t}, () => {\n\t\t\tconsole.log(this.state.isActive) // true\n\t\t})\n\t\t\n\t}\n\n**这个回调函数会在修改了state之后才会执行，这就就可以使用修改之后的state的值了**\n\n> 方法二：\n\n\tasync ClickChangeState () {\n\t\tawait this.setState({\n\t\t\tisActive: true,\n\t\t})\n\t\tconsole.log(this.state.isActive) // false\n\t}\n\n**操作异步函数，用的最舒服的还是async / await**\n\n## 在使用setState的时候，有两种格式;\n\n### 第一种setstate（）格式  第一个参数是一个对象，第二个参数是一个回调函数，这个回调函数是在setstate执行完并页面渲染了之后再执行\n\n\tClickChangeState () {\n\t\tthis.setState({\n\t\t\tisActive: true,\n\t\t}, () => {\n\t\t\tconsole.log(this.state.isActive) // true\n\t\t})\n\t\t\n\t}\n\n**但是这种修改的方式不稳妥，因为是直接修改**\n\n### setstate的第二种格式，接收一个回调函数，而不是一个对象，这个回调函数有两个参数，\n\n**一个是接收前一个状态值作为第一个参数，并将更新后的值作为第二个参数**\n\n\tClickChangeState () {\n\t\tthis.setState((prevState) => {\n\t\t\tisActive: !prevState.isActive,\n\t\t}, () => {\n\t\t\tconsole.log(this.state.isActive) // true\n\t\t})\n\t\t\n\t}\n\n\n\n## setState异步更新\n\n\n> setState通过一个队列机制实现state的更新。当执行setState时，会把需要更新的state合并后放入状态队列，而不会立刻更新this.state，利用这个队列机制可以高效的批量的更新state。\n\n\n----------\n> React文档中对setState的说明\n\n\tvoid setState(\n      function|object nextState,\n      [function callback]\n    )\n\n> The second (optional) parameter is a callback function that will be executed once setState is completed and the component is re-rendered. \n\n----------\n> 翻译： 第二个（可选）参数是一个回调函数，它将在setstate完成并重新呈现组件后执行。\n> \n> 也就是说，我们可以通过这个回调来拿到更新的state的值。 \nReact也正是利用状态队列机制实现了setState的异步更新，避免频繁地重复更新state(pending的意思是未定的\n\n\t//将新的state合并到状态更新队列中\n\t   var nextState =  this._processPendingState(nextProps, nextContext);\n\t   //根据更新队列和shouldComponent的状态来判断是否需要更新组件\n\t   var shouldUpdate = \n\t      this._pendingForceUpdate ||\n\t      !inst.shouldComponentUpdate ||\n\t      inst.shouldComponentUpdate(nextProps, nextState, nextContext);\n\n## setState循环调用风险\n\n**如果在shouldComponentUpdate或者componentWillUpdate方法中调用setState，此时this._pending-StateQueue != null，就会造成循环调用，使得浏览器内存占满后崩溃**\n\n## 调用栈\n\n\timport React, { Component } from 'react';\n\t   class Example extends Component {\n\t       constructor(){\n\t           super();\n\t           //在组件初始化可以直接操作this.state\n\t           this.state = {\n\t               val: 0\n\t           }\n\t       }\n\t       componentDidMount(){\n\t           this.setState({\n\t              val: this.state.val + 1\n\t           });\n\t           //第一次输出\n\t           console.log(this.state.val);\n\t           this.setState({\n\t              val: this.state.val + 1\n\t           });\n\t           //第二次输出\n\t           console.log(this.state.val);\n\t           setTimeout(()=>{\n\t              this.setState({val: this.state.val + 1});\n\t               //第三次输出\n\t               console.log(this.state.val);\n\t               this.setState({\n\t                  val: this.state.val + 1\n\t               });\n\t               //第四次输出\n\t               console.log(this.state.val);\n\t           }, 0);  \n\t       }\n\t       render(){\n\t           return null;\n\t       }\n\t   }\n\n\n**上述代码中，4次console.log打印出来的val分别是: 0，0，2 ，3**\n\n**我们来看一个简化的setState的调用栈**\n\n\tthis.setState(newState) =>\n\t   newState存入pending队列 =>\n\t   调用enqueueUpdate =>\n\t   是否处于批量更新模式 =>\n\t   是的话将组件保存到dirtyComponents\n\t   不是的话遍历dirtyComponents，调用updateComponent,更新pending state or props\n\n## 事务(transaction)\n\n**事务就是将需要执行的方法用wrapper封装起来，再通过事务提供的perform方法执行。而再perform之前，先执行所wrapeer中的initialize方法，执行完需要执行的方法后，再执行close方法。一组initialize和close方法称为一个wrapper，事务支持多个wrapper叠加。**\n\n**我们可以将4次setState简单规成两类，componentDidMount是一类，setTimeOut中的又是一类，因为这两次在不同的调用栈中执行。**\n\n> **我们先看看在componentDidMount中setState的调用栈：**\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/3.0.png)\n\n> **再看看在setTimeOut中的调用栈：**\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/3.1.png)\n\n**前两次是整个将React组件渲染到DOM的过程就处于一个大的事务中**\n\n**componentDidMount中调用setState时,两次setState的结果并没有立即生效，而是被放进了dirtyComponents中。因为新的state还没被应用到组件中。**\n\n**setTimeOut中的两次setState，因为没有跟随组件到渲染dom的一个流程，导致了新的state马上生效，也就是说，setTimeOut中的第一次执行，setState时，this.state.val为1，而setState完成后打印时this.state.val变成了2。第二次的setState同理。**\n\n## 总结\n\n### 在执行setState并不是说他是异步的，官方给出的说明是\n\n> 不保证this.state会立即更新，所以在调用这个方法后存取this.state可能会回传旧的值。\n> \n> 不保证调用setState就会同步地执行，而它们也可能最终被被批量调用(多次调用的情况下)。你可以提供额外的回调，回调将会在setState实际被完成时被执行。\n\n### 在执行setState，他是跟随将react组件渲染到dom这个流程走的，会将新的state值放入到一个更新队列中，事务（transaction）会进行下一步操作。在批量调用的情况下，会对多个setState进行合并。\n\n### setTimeout中setState和在生命周期里setState的区别在于，setTimeout中的setState会自己触发一个transaction，而生命周期中的setState已经处于React生命周期的transaction中了。\n","source":"_posts/setState.md","raw":"---\ntitle: react中的setState的使用和深入理解\ndate: '4/3/2019 11:58:21 AM '\ntag: ['js', 'react']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n## react中的setState的使用和深入理解\n\n**React通过管理状态实现对组件的管理，通过this.state()方法更新state。当this.setState()被调用的时候，React会重新调用render方法来重新渲染UI。**\n\n**在使用state的时候， 如果我们企图直接修改state中的某一个值之后直接打印（使用）他，就会发现，他其实并没有改变。**\n\n**就像下面的例子，企图通过点击事件之后就使用修改之后的state的值，但是会发state中的并没有被立即修改，还是原先的值，我们都知道那是因为setState就相当于是一个异步操作，不能立即被修改**\n\t\n\tClickChangeState () {\n\t\tthis.setState({\n\t\t\tisActive: true,\n\t\t})\n\t\tconsole.log(this.state.isActive) // false\n\t}\n\n**那么我们也都知道为了解决上面的问题会有很多方法例如：**\n\n> 方法一：\n\n\tClickChangeState () {\n\t\tthis.setState({\n\t\t\tisActive: true,\n\t\t}, () => {\n\t\t\tconsole.log(this.state.isActive) // true\n\t\t})\n\t\t\n\t}\n\n**这个回调函数会在修改了state之后才会执行，这就就可以使用修改之后的state的值了**\n\n> 方法二：\n\n\tasync ClickChangeState () {\n\t\tawait this.setState({\n\t\t\tisActive: true,\n\t\t})\n\t\tconsole.log(this.state.isActive) // false\n\t}\n\n**操作异步函数，用的最舒服的还是async / await**\n\n## 在使用setState的时候，有两种格式;\n\n### 第一种setstate（）格式  第一个参数是一个对象，第二个参数是一个回调函数，这个回调函数是在setstate执行完并页面渲染了之后再执行\n\n\tClickChangeState () {\n\t\tthis.setState({\n\t\t\tisActive: true,\n\t\t}, () => {\n\t\t\tconsole.log(this.state.isActive) // true\n\t\t})\n\t\t\n\t}\n\n**但是这种修改的方式不稳妥，因为是直接修改**\n\n### setstate的第二种格式，接收一个回调函数，而不是一个对象，这个回调函数有两个参数，\n\n**一个是接收前一个状态值作为第一个参数，并将更新后的值作为第二个参数**\n\n\tClickChangeState () {\n\t\tthis.setState((prevState) => {\n\t\t\tisActive: !prevState.isActive,\n\t\t}, () => {\n\t\t\tconsole.log(this.state.isActive) // true\n\t\t})\n\t\t\n\t}\n\n\n\n## setState异步更新\n\n\n> setState通过一个队列机制实现state的更新。当执行setState时，会把需要更新的state合并后放入状态队列，而不会立刻更新this.state，利用这个队列机制可以高效的批量的更新state。\n\n\n----------\n> React文档中对setState的说明\n\n\tvoid setState(\n      function|object nextState,\n      [function callback]\n    )\n\n> The second (optional) parameter is a callback function that will be executed once setState is completed and the component is re-rendered. \n\n----------\n> 翻译： 第二个（可选）参数是一个回调函数，它将在setstate完成并重新呈现组件后执行。\n> \n> 也就是说，我们可以通过这个回调来拿到更新的state的值。 \nReact也正是利用状态队列机制实现了setState的异步更新，避免频繁地重复更新state(pending的意思是未定的\n\n\t//将新的state合并到状态更新队列中\n\t   var nextState =  this._processPendingState(nextProps, nextContext);\n\t   //根据更新队列和shouldComponent的状态来判断是否需要更新组件\n\t   var shouldUpdate = \n\t      this._pendingForceUpdate ||\n\t      !inst.shouldComponentUpdate ||\n\t      inst.shouldComponentUpdate(nextProps, nextState, nextContext);\n\n## setState循环调用风险\n\n**如果在shouldComponentUpdate或者componentWillUpdate方法中调用setState，此时this._pending-StateQueue != null，就会造成循环调用，使得浏览器内存占满后崩溃**\n\n## 调用栈\n\n\timport React, { Component } from 'react';\n\t   class Example extends Component {\n\t       constructor(){\n\t           super();\n\t           //在组件初始化可以直接操作this.state\n\t           this.state = {\n\t               val: 0\n\t           }\n\t       }\n\t       componentDidMount(){\n\t           this.setState({\n\t              val: this.state.val + 1\n\t           });\n\t           //第一次输出\n\t           console.log(this.state.val);\n\t           this.setState({\n\t              val: this.state.val + 1\n\t           });\n\t           //第二次输出\n\t           console.log(this.state.val);\n\t           setTimeout(()=>{\n\t              this.setState({val: this.state.val + 1});\n\t               //第三次输出\n\t               console.log(this.state.val);\n\t               this.setState({\n\t                  val: this.state.val + 1\n\t               });\n\t               //第四次输出\n\t               console.log(this.state.val);\n\t           }, 0);  \n\t       }\n\t       render(){\n\t           return null;\n\t       }\n\t   }\n\n\n**上述代码中，4次console.log打印出来的val分别是: 0，0，2 ，3**\n\n**我们来看一个简化的setState的调用栈**\n\n\tthis.setState(newState) =>\n\t   newState存入pending队列 =>\n\t   调用enqueueUpdate =>\n\t   是否处于批量更新模式 =>\n\t   是的话将组件保存到dirtyComponents\n\t   不是的话遍历dirtyComponents，调用updateComponent,更新pending state or props\n\n## 事务(transaction)\n\n**事务就是将需要执行的方法用wrapper封装起来，再通过事务提供的perform方法执行。而再perform之前，先执行所wrapeer中的initialize方法，执行完需要执行的方法后，再执行close方法。一组initialize和close方法称为一个wrapper，事务支持多个wrapper叠加。**\n\n**我们可以将4次setState简单规成两类，componentDidMount是一类，setTimeOut中的又是一类，因为这两次在不同的调用栈中执行。**\n\n> **我们先看看在componentDidMount中setState的调用栈：**\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/3.0.png)\n\n> **再看看在setTimeOut中的调用栈：**\n\n![](https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/3.1.png)\n\n**前两次是整个将React组件渲染到DOM的过程就处于一个大的事务中**\n\n**componentDidMount中调用setState时,两次setState的结果并没有立即生效，而是被放进了dirtyComponents中。因为新的state还没被应用到组件中。**\n\n**setTimeOut中的两次setState，因为没有跟随组件到渲染dom的一个流程，导致了新的state马上生效，也就是说，setTimeOut中的第一次执行，setState时，this.state.val为1，而setState完成后打印时this.state.val变成了2。第二次的setState同理。**\n\n## 总结\n\n### 在执行setState并不是说他是异步的，官方给出的说明是\n\n> 不保证this.state会立即更新，所以在调用这个方法后存取this.state可能会回传旧的值。\n> \n> 不保证调用setState就会同步地执行，而它们也可能最终被被批量调用(多次调用的情况下)。你可以提供额外的回调，回调将会在setState实际被完成时被执行。\n\n### 在执行setState，他是跟随将react组件渲染到dom这个流程走的，会将新的state值放入到一个更新队列中，事务（transaction）会进行下一步操作。在批量调用的情况下，会对多个setState进行合并。\n\n### setTimeout中setState和在生命周期里setState的区别在于，setTimeout中的setState会自己触发一个transaction，而生命周期中的setState已经处于React生命周期的transaction中了。\n","slug":"setState","published":1,"updated":"2019-07-09T08:50:54.881Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam7k0024n4wd9ekrjp1r","content":"<h2 id=\"react中的setState的使用和深入理解\"><a href=\"#react中的setState的使用和深入理解\" class=\"headerlink\" title=\"react中的setState的使用和深入理解\"></a>react中的setState的使用和深入理解</h2><p><strong>React通过管理状态实现对组件的管理，通过this.state()方法更新state。当this.setState()被调用的时候，React会重新调用render方法来重新渲染UI。</strong></p>\n<p><strong>在使用state的时候， 如果我们企图直接修改state中的某一个值之后直接打印（使用）他，就会发现，他其实并没有改变。</strong></p>\n<p><strong>就像下面的例子，企图通过点击事件之后就使用修改之后的state的值，但是会发state中的并没有被立即修改，还是原先的值，我们都知道那是因为setState就相当于是一个异步操作，不能立即被修改</strong></p>\n<pre><code>ClickChangeState () {\n    this.setState({\n        isActive: true,\n    })\n    console.log(this.state.isActive) // false\n}\n</code></pre><p><strong>那么我们也都知道为了解决上面的问题会有很多方法例如：</strong></p>\n<blockquote>\n<p>方法一：</p>\n</blockquote>\n<pre><code>ClickChangeState () {\n    this.setState({\n        isActive: true,\n    }, () =&gt; {\n        console.log(this.state.isActive) // true\n    })\n\n}\n</code></pre><p><strong>这个回调函数会在修改了state之后才会执行，这就就可以使用修改之后的state的值了</strong></p>\n<blockquote>\n<p>方法二：</p>\n</blockquote>\n<pre><code>async ClickChangeState () {\n    await this.setState({\n        isActive: true,\n    })\n    console.log(this.state.isActive) // false\n}\n</code></pre><p><strong>操作异步函数，用的最舒服的还是async / await</strong></p>\n<h2 id=\"在使用setState的时候，有两种格式\"><a href=\"#在使用setState的时候，有两种格式\" class=\"headerlink\" title=\"在使用setState的时候，有两种格式;\"></a>在使用setState的时候，有两种格式;</h2><h3 id=\"第一种setstate（）格式-第一个参数是一个对象，第二个参数是一个回调函数，这个回调函数是在setstate执行完并页面渲染了之后再执行\"><a href=\"#第一种setstate（）格式-第一个参数是一个对象，第二个参数是一个回调函数，这个回调函数是在setstate执行完并页面渲染了之后再执行\" class=\"headerlink\" title=\"第一种setstate（）格式  第一个参数是一个对象，第二个参数是一个回调函数，这个回调函数是在setstate执行完并页面渲染了之后再执行\"></a>第一种setstate（）格式  第一个参数是一个对象，第二个参数是一个回调函数，这个回调函数是在setstate执行完并页面渲染了之后再执行</h3><pre><code>ClickChangeState () {\n    this.setState({\n        isActive: true,\n    }, () =&gt; {\n        console.log(this.state.isActive) // true\n    })\n\n}\n</code></pre><p><strong>但是这种修改的方式不稳妥，因为是直接修改</strong></p>\n<h3 id=\"setstate的第二种格式，接收一个回调函数，而不是一个对象，这个回调函数有两个参数，\"><a href=\"#setstate的第二种格式，接收一个回调函数，而不是一个对象，这个回调函数有两个参数，\" class=\"headerlink\" title=\"setstate的第二种格式，接收一个回调函数，而不是一个对象，这个回调函数有两个参数，\"></a>setstate的第二种格式，接收一个回调函数，而不是一个对象，这个回调函数有两个参数，</h3><p><strong>一个是接收前一个状态值作为第一个参数，并将更新后的值作为第二个参数</strong></p>\n<pre><code>ClickChangeState () {\n    this.setState((prevState) =&gt; {\n        isActive: !prevState.isActive,\n    }, () =&gt; {\n        console.log(this.state.isActive) // true\n    })\n\n}\n</code></pre><h2 id=\"setState异步更新\"><a href=\"#setState异步更新\" class=\"headerlink\" title=\"setState异步更新\"></a>setState异步更新</h2><blockquote>\n<p>setState通过一个队列机制实现state的更新。当执行setState时，会把需要更新的state合并后放入状态队列，而不会立刻更新this.state，利用这个队列机制可以高效的批量的更新state。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>React文档中对setState的说明</p>\n</blockquote>\n<pre><code>void setState(\n  function|object nextState,\n  [function callback]\n)\n</code></pre><blockquote>\n<p>The second (optional) parameter is a callback function that will be executed once setState is completed and the component is re-rendered. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>翻译： 第二个（可选）参数是一个回调函数，它将在setstate完成并重新呈现组件后执行。</p>\n<p>也就是说，我们可以通过这个回调来拿到更新的state的值。<br>React也正是利用状态队列机制实现了setState的异步更新，避免频繁地重复更新state(pending的意思是未定的</p>\n</blockquote>\n<pre><code>//将新的state合并到状态更新队列中\n   var nextState =  this._processPendingState(nextProps, nextContext);\n   //根据更新队列和shouldComponent的状态来判断是否需要更新组件\n   var shouldUpdate = \n      this._pendingForceUpdate ||\n      !inst.shouldComponentUpdate ||\n      inst.shouldComponentUpdate(nextProps, nextState, nextContext);\n</code></pre><h2 id=\"setState循环调用风险\"><a href=\"#setState循环调用风险\" class=\"headerlink\" title=\"setState循环调用风险\"></a>setState循环调用风险</h2><p><strong>如果在shouldComponentUpdate或者componentWillUpdate方法中调用setState，此时this._pending-StateQueue != null，就会造成循环调用，使得浏览器内存占满后崩溃</strong></p>\n<h2 id=\"调用栈\"><a href=\"#调用栈\" class=\"headerlink\" title=\"调用栈\"></a>调用栈</h2><pre><code>import React, { Component } from &#39;react&#39;;\n   class Example extends Component {\n       constructor(){\n           super();\n           //在组件初始化可以直接操作this.state\n           this.state = {\n               val: 0\n           }\n       }\n       componentDidMount(){\n           this.setState({\n              val: this.state.val + 1\n           });\n           //第一次输出\n           console.log(this.state.val);\n           this.setState({\n              val: this.state.val + 1\n           });\n           //第二次输出\n           console.log(this.state.val);\n           setTimeout(()=&gt;{\n              this.setState({val: this.state.val + 1});\n               //第三次输出\n               console.log(this.state.val);\n               this.setState({\n                  val: this.state.val + 1\n               });\n               //第四次输出\n               console.log(this.state.val);\n           }, 0);  \n       }\n       render(){\n           return null;\n       }\n   }\n</code></pre><p><strong>上述代码中，4次console.log打印出来的val分别是: 0，0，2 ，3</strong></p>\n<p><strong>我们来看一个简化的setState的调用栈</strong></p>\n<pre><code>this.setState(newState) =&gt;\n   newState存入pending队列 =&gt;\n   调用enqueueUpdate =&gt;\n   是否处于批量更新模式 =&gt;\n   是的话将组件保存到dirtyComponents\n   不是的话遍历dirtyComponents，调用updateComponent,更新pending state or props\n</code></pre><h2 id=\"事务-transaction\"><a href=\"#事务-transaction\" class=\"headerlink\" title=\"事务(transaction)\"></a>事务(transaction)</h2><p><strong>事务就是将需要执行的方法用wrapper封装起来，再通过事务提供的perform方法执行。而再perform之前，先执行所wrapeer中的initialize方法，执行完需要执行的方法后，再执行close方法。一组initialize和close方法称为一个wrapper，事务支持多个wrapper叠加。</strong></p>\n<p><strong>我们可以将4次setState简单规成两类，componentDidMount是一类，setTimeOut中的又是一类，因为这两次在不同的调用栈中执行。</strong></p>\n<blockquote>\n<p><strong>我们先看看在componentDidMount中setState的调用栈：</strong></p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/3.0.png\" alt=\"\"></p>\n<blockquote>\n<p><strong>再看看在setTimeOut中的调用栈：</strong></p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/3.1.png\" alt=\"\"></p>\n<p><strong>前两次是整个将React组件渲染到DOM的过程就处于一个大的事务中</strong></p>\n<p><strong>componentDidMount中调用setState时,两次setState的结果并没有立即生效，而是被放进了dirtyComponents中。因为新的state还没被应用到组件中。</strong></p>\n<p><strong>setTimeOut中的两次setState，因为没有跟随组件到渲染dom的一个流程，导致了新的state马上生效，也就是说，setTimeOut中的第一次执行，setState时，this.state.val为1，而setState完成后打印时this.state.val变成了2。第二次的setState同理。</strong></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h3 id=\"在执行setState并不是说他是异步的，官方给出的说明是\"><a href=\"#在执行setState并不是说他是异步的，官方给出的说明是\" class=\"headerlink\" title=\"在执行setState并不是说他是异步的，官方给出的说明是\"></a>在执行setState并不是说他是异步的，官方给出的说明是</h3><blockquote>\n<p>不保证this.state会立即更新，所以在调用这个方法后存取this.state可能会回传旧的值。</p>\n<p>不保证调用setState就会同步地执行，而它们也可能最终被被批量调用(多次调用的情况下)。你可以提供额外的回调，回调将会在setState实际被完成时被执行。</p>\n</blockquote>\n<h3 id=\"在执行setState，他是跟随将react组件渲染到dom这个流程走的，会将新的state值放入到一个更新队列中，事务（transaction）会进行下一步操作。在批量调用的情况下，会对多个setState进行合并。\"><a href=\"#在执行setState，他是跟随将react组件渲染到dom这个流程走的，会将新的state值放入到一个更新队列中，事务（transaction）会进行下一步操作。在批量调用的情况下，会对多个setState进行合并。\" class=\"headerlink\" title=\"在执行setState，他是跟随将react组件渲染到dom这个流程走的，会将新的state值放入到一个更新队列中，事务（transaction）会进行下一步操作。在批量调用的情况下，会对多个setState进行合并。\"></a>在执行setState，他是跟随将react组件渲染到dom这个流程走的，会将新的state值放入到一个更新队列中，事务（transaction）会进行下一步操作。在批量调用的情况下，会对多个setState进行合并。</h3><h3 id=\"setTimeout中setState和在生命周期里setState的区别在于，setTimeout中的setState会自己触发一个transaction，而生命周期中的setState已经处于React生命周期的transaction中了。\"><a href=\"#setTimeout中setState和在生命周期里setState的区别在于，setTimeout中的setState会自己触发一个transaction，而生命周期中的setState已经处于React生命周期的transaction中了。\" class=\"headerlink\" title=\"setTimeout中setState和在生命周期里setState的区别在于，setTimeout中的setState会自己触发一个transaction，而生命周期中的setState已经处于React生命周期的transaction中了。\"></a>setTimeout中setState和在生命周期里setState的区别在于，setTimeout中的setState会自己触发一个transaction，而生命周期中的setState已经处于React生命周期的transaction中了。</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"react中的setState的使用和深入理解\"><a href=\"#react中的setState的使用和深入理解\" class=\"headerlink\" title=\"react中的setState的使用和深入理解\"></a>react中的setState的使用和深入理解</h2><p><strong>React通过管理状态实现对组件的管理，通过this.state()方法更新state。当this.setState()被调用的时候，React会重新调用render方法来重新渲染UI。</strong></p>\n<p><strong>在使用state的时候， 如果我们企图直接修改state中的某一个值之后直接打印（使用）他，就会发现，他其实并没有改变。</strong></p>\n<p><strong>就像下面的例子，企图通过点击事件之后就使用修改之后的state的值，但是会发state中的并没有被立即修改，还是原先的值，我们都知道那是因为setState就相当于是一个异步操作，不能立即被修改</strong></p>\n<pre><code>ClickChangeState () {\n    this.setState({\n        isActive: true,\n    })\n    console.log(this.state.isActive) // false\n}\n</code></pre><p><strong>那么我们也都知道为了解决上面的问题会有很多方法例如：</strong></p>\n<blockquote>\n<p>方法一：</p>\n</blockquote>\n<pre><code>ClickChangeState () {\n    this.setState({\n        isActive: true,\n    }, () =&gt; {\n        console.log(this.state.isActive) // true\n    })\n\n}\n</code></pre><p><strong>这个回调函数会在修改了state之后才会执行，这就就可以使用修改之后的state的值了</strong></p>\n<blockquote>\n<p>方法二：</p>\n</blockquote>\n<pre><code>async ClickChangeState () {\n    await this.setState({\n        isActive: true,\n    })\n    console.log(this.state.isActive) // false\n}\n</code></pre><p><strong>操作异步函数，用的最舒服的还是async / await</strong></p>\n<h2 id=\"在使用setState的时候，有两种格式\"><a href=\"#在使用setState的时候，有两种格式\" class=\"headerlink\" title=\"在使用setState的时候，有两种格式;\"></a>在使用setState的时候，有两种格式;</h2><h3 id=\"第一种setstate（）格式-第一个参数是一个对象，第二个参数是一个回调函数，这个回调函数是在setstate执行完并页面渲染了之后再执行\"><a href=\"#第一种setstate（）格式-第一个参数是一个对象，第二个参数是一个回调函数，这个回调函数是在setstate执行完并页面渲染了之后再执行\" class=\"headerlink\" title=\"第一种setstate（）格式  第一个参数是一个对象，第二个参数是一个回调函数，这个回调函数是在setstate执行完并页面渲染了之后再执行\"></a>第一种setstate（）格式  第一个参数是一个对象，第二个参数是一个回调函数，这个回调函数是在setstate执行完并页面渲染了之后再执行</h3><pre><code>ClickChangeState () {\n    this.setState({\n        isActive: true,\n    }, () =&gt; {\n        console.log(this.state.isActive) // true\n    })\n\n}\n</code></pre><p><strong>但是这种修改的方式不稳妥，因为是直接修改</strong></p>\n<h3 id=\"setstate的第二种格式，接收一个回调函数，而不是一个对象，这个回调函数有两个参数，\"><a href=\"#setstate的第二种格式，接收一个回调函数，而不是一个对象，这个回调函数有两个参数，\" class=\"headerlink\" title=\"setstate的第二种格式，接收一个回调函数，而不是一个对象，这个回调函数有两个参数，\"></a>setstate的第二种格式，接收一个回调函数，而不是一个对象，这个回调函数有两个参数，</h3><p><strong>一个是接收前一个状态值作为第一个参数，并将更新后的值作为第二个参数</strong></p>\n<pre><code>ClickChangeState () {\n    this.setState((prevState) =&gt; {\n        isActive: !prevState.isActive,\n    }, () =&gt; {\n        console.log(this.state.isActive) // true\n    })\n\n}\n</code></pre><h2 id=\"setState异步更新\"><a href=\"#setState异步更新\" class=\"headerlink\" title=\"setState异步更新\"></a>setState异步更新</h2><blockquote>\n<p>setState通过一个队列机制实现state的更新。当执行setState时，会把需要更新的state合并后放入状态队列，而不会立刻更新this.state，利用这个队列机制可以高效的批量的更新state。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>React文档中对setState的说明</p>\n</blockquote>\n<pre><code>void setState(\n  function|object nextState,\n  [function callback]\n)\n</code></pre><blockquote>\n<p>The second (optional) parameter is a callback function that will be executed once setState is completed and the component is re-rendered. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p>翻译： 第二个（可选）参数是一个回调函数，它将在setstate完成并重新呈现组件后执行。</p>\n<p>也就是说，我们可以通过这个回调来拿到更新的state的值。<br>React也正是利用状态队列机制实现了setState的异步更新，避免频繁地重复更新state(pending的意思是未定的</p>\n</blockquote>\n<pre><code>//将新的state合并到状态更新队列中\n   var nextState =  this._processPendingState(nextProps, nextContext);\n   //根据更新队列和shouldComponent的状态来判断是否需要更新组件\n   var shouldUpdate = \n      this._pendingForceUpdate ||\n      !inst.shouldComponentUpdate ||\n      inst.shouldComponentUpdate(nextProps, nextState, nextContext);\n</code></pre><h2 id=\"setState循环调用风险\"><a href=\"#setState循环调用风险\" class=\"headerlink\" title=\"setState循环调用风险\"></a>setState循环调用风险</h2><p><strong>如果在shouldComponentUpdate或者componentWillUpdate方法中调用setState，此时this._pending-StateQueue != null，就会造成循环调用，使得浏览器内存占满后崩溃</strong></p>\n<h2 id=\"调用栈\"><a href=\"#调用栈\" class=\"headerlink\" title=\"调用栈\"></a>调用栈</h2><pre><code>import React, { Component } from &#39;react&#39;;\n   class Example extends Component {\n       constructor(){\n           super();\n           //在组件初始化可以直接操作this.state\n           this.state = {\n               val: 0\n           }\n       }\n       componentDidMount(){\n           this.setState({\n              val: this.state.val + 1\n           });\n           //第一次输出\n           console.log(this.state.val);\n           this.setState({\n              val: this.state.val + 1\n           });\n           //第二次输出\n           console.log(this.state.val);\n           setTimeout(()=&gt;{\n              this.setState({val: this.state.val + 1});\n               //第三次输出\n               console.log(this.state.val);\n               this.setState({\n                  val: this.state.val + 1\n               });\n               //第四次输出\n               console.log(this.state.val);\n           }, 0);  \n       }\n       render(){\n           return null;\n       }\n   }\n</code></pre><p><strong>上述代码中，4次console.log打印出来的val分别是: 0，0，2 ，3</strong></p>\n<p><strong>我们来看一个简化的setState的调用栈</strong></p>\n<pre><code>this.setState(newState) =&gt;\n   newState存入pending队列 =&gt;\n   调用enqueueUpdate =&gt;\n   是否处于批量更新模式 =&gt;\n   是的话将组件保存到dirtyComponents\n   不是的话遍历dirtyComponents，调用updateComponent,更新pending state or props\n</code></pre><h2 id=\"事务-transaction\"><a href=\"#事务-transaction\" class=\"headerlink\" title=\"事务(transaction)\"></a>事务(transaction)</h2><p><strong>事务就是将需要执行的方法用wrapper封装起来，再通过事务提供的perform方法执行。而再perform之前，先执行所wrapeer中的initialize方法，执行完需要执行的方法后，再执行close方法。一组initialize和close方法称为一个wrapper，事务支持多个wrapper叠加。</strong></p>\n<p><strong>我们可以将4次setState简单规成两类，componentDidMount是一类，setTimeOut中的又是一类，因为这两次在不同的调用栈中执行。</strong></p>\n<blockquote>\n<p><strong>我们先看看在componentDidMount中setState的调用栈：</strong></p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/3.0.png\" alt=\"\"></p>\n<blockquote>\n<p><strong>再看看在setTimeOut中的调用栈：</strong></p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/3.1.png\" alt=\"\"></p>\n<p><strong>前两次是整个将React组件渲染到DOM的过程就处于一个大的事务中</strong></p>\n<p><strong>componentDidMount中调用setState时,两次setState的结果并没有立即生效，而是被放进了dirtyComponents中。因为新的state还没被应用到组件中。</strong></p>\n<p><strong>setTimeOut中的两次setState，因为没有跟随组件到渲染dom的一个流程，导致了新的state马上生效，也就是说，setTimeOut中的第一次执行，setState时，this.state.val为1，而setState完成后打印时this.state.val变成了2。第二次的setState同理。</strong></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h3 id=\"在执行setState并不是说他是异步的，官方给出的说明是\"><a href=\"#在执行setState并不是说他是异步的，官方给出的说明是\" class=\"headerlink\" title=\"在执行setState并不是说他是异步的，官方给出的说明是\"></a>在执行setState并不是说他是异步的，官方给出的说明是</h3><blockquote>\n<p>不保证this.state会立即更新，所以在调用这个方法后存取this.state可能会回传旧的值。</p>\n<p>不保证调用setState就会同步地执行，而它们也可能最终被被批量调用(多次调用的情况下)。你可以提供额外的回调，回调将会在setState实际被完成时被执行。</p>\n</blockquote>\n<h3 id=\"在执行setState，他是跟随将react组件渲染到dom这个流程走的，会将新的state值放入到一个更新队列中，事务（transaction）会进行下一步操作。在批量调用的情况下，会对多个setState进行合并。\"><a href=\"#在执行setState，他是跟随将react组件渲染到dom这个流程走的，会将新的state值放入到一个更新队列中，事务（transaction）会进行下一步操作。在批量调用的情况下，会对多个setState进行合并。\" class=\"headerlink\" title=\"在执行setState，他是跟随将react组件渲染到dom这个流程走的，会将新的state值放入到一个更新队列中，事务（transaction）会进行下一步操作。在批量调用的情况下，会对多个setState进行合并。\"></a>在执行setState，他是跟随将react组件渲染到dom这个流程走的，会将新的state值放入到一个更新队列中，事务（transaction）会进行下一步操作。在批量调用的情况下，会对多个setState进行合并。</h3><h3 id=\"setTimeout中setState和在生命周期里setState的区别在于，setTimeout中的setState会自己触发一个transaction，而生命周期中的setState已经处于React生命周期的transaction中了。\"><a href=\"#setTimeout中setState和在生命周期里setState的区别在于，setTimeout中的setState会自己触发一个transaction，而生命周期中的setState已经处于React生命周期的transaction中了。\" class=\"headerlink\" title=\"setTimeout中setState和在生命周期里setState的区别在于，setTimeout中的setState会自己触发一个transaction，而生命周期中的setState已经处于React生命周期的transaction中了。\"></a>setTimeout中setState和在生命周期里setState的区别在于，setTimeout中的setState会自己触发一个transaction，而生命周期中的setState已经处于React生命周期的transaction中了。</h3>"},{"title":"Vue transfrom属性","date":"2019-01-27T05:40:31.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"# Vue transfrom属性\n\n## vue中的动画可以使用transfrom组件完成\n\n### transfrom组件提供两个过渡状态\n\n> 进入 enter\n\n> 离开 leave\n\n### 每个状态有三个步骤【自动添加类名 v代表的是transfrom组件上的name属性指定的值】\n- v-enter v-enter-active v-enter-to\n- v-leave v-leave-active v-leave-to\n\n> ### 通过结合css过渡动画和关键帧动画可以实现切换动画\n\n### 动画触发场景\n\n1. 跟组件初始化渲染\n2. v-show，v-if，component动态组件切换的时候\n3. router-view 路由切换的时候\n\n### transfrom 组件还可以通过属性去改变不同状态自动添加的class类名\n\n- enter-active-class=\"animated slideInDown\"\n- leave-active-class=\"animated bounceOutDown\"\n\n### 这种方式适合配合第三方动画库实现动画\n\n\t<transition\n\tv-on:before-enter=\"berforeEnter\"\t\t\t//可以做一些初始化样式设置\n\tv-on:enter=\"enter\"\t\t\t\t\t\t\t//执行js操作dom完成的动画效果\n\tv-on:after-enter=\"afterEnter\"\t\t\t\t//动画执行结束（也就是在enter中调用了done函数）\n\tv-on:enter-cancelled=\"enterCancelled\"\t\t动画还没有结束，就执行下一次动画了，这时候不会触发动画结束，而是触发这个时间（取消）\n\tv-on:before-leave=\"beforeLeave\"\n\tv-on:leave=\"leave\"\n\tv-on:after-leave=\"afterLeave\"\n\tv-on:leave-cancelled=\"leaveCancelled\"\t\n\t>\n\t<!--...-->\n\t</transition>","source":"_posts/transition.md","raw":"---\ntitle: Vue transfrom属性\ndate: '2019-01-27 13:40:31'\ntag: ['transfrom', 'vue']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n# Vue transfrom属性\n\n## vue中的动画可以使用transfrom组件完成\n\n### transfrom组件提供两个过渡状态\n\n> 进入 enter\n\n> 离开 leave\n\n### 每个状态有三个步骤【自动添加类名 v代表的是transfrom组件上的name属性指定的值】\n- v-enter v-enter-active v-enter-to\n- v-leave v-leave-active v-leave-to\n\n> ### 通过结合css过渡动画和关键帧动画可以实现切换动画\n\n### 动画触发场景\n\n1. 跟组件初始化渲染\n2. v-show，v-if，component动态组件切换的时候\n3. router-view 路由切换的时候\n\n### transfrom 组件还可以通过属性去改变不同状态自动添加的class类名\n\n- enter-active-class=\"animated slideInDown\"\n- leave-active-class=\"animated bounceOutDown\"\n\n### 这种方式适合配合第三方动画库实现动画\n\n\t<transition\n\tv-on:before-enter=\"berforeEnter\"\t\t\t//可以做一些初始化样式设置\n\tv-on:enter=\"enter\"\t\t\t\t\t\t\t//执行js操作dom完成的动画效果\n\tv-on:after-enter=\"afterEnter\"\t\t\t\t//动画执行结束（也就是在enter中调用了done函数）\n\tv-on:enter-cancelled=\"enterCancelled\"\t\t动画还没有结束，就执行下一次动画了，这时候不会触发动画结束，而是触发这个时间（取消）\n\tv-on:before-leave=\"beforeLeave\"\n\tv-on:leave=\"leave\"\n\tv-on:after-leave=\"afterLeave\"\n\tv-on:leave-cancelled=\"leaveCancelled\"\t\n\t>\n\t<!--...-->\n\t</transition>","slug":"transition","published":1,"updated":"2019-01-27T05:41:06.535Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam7m0027n4wdcv1lcj6x","content":"<h1 id=\"Vue-transfrom属性\"><a href=\"#Vue-transfrom属性\" class=\"headerlink\" title=\"Vue transfrom属性\"></a>Vue transfrom属性</h1><h2 id=\"vue中的动画可以使用transfrom组件完成\"><a href=\"#vue中的动画可以使用transfrom组件完成\" class=\"headerlink\" title=\"vue中的动画可以使用transfrom组件完成\"></a>vue中的动画可以使用transfrom组件完成</h2><h3 id=\"transfrom组件提供两个过渡状态\"><a href=\"#transfrom组件提供两个过渡状态\" class=\"headerlink\" title=\"transfrom组件提供两个过渡状态\"></a>transfrom组件提供两个过渡状态</h3><blockquote>\n<p>进入 enter</p>\n</blockquote>\n<blockquote>\n<p>离开 leave</p>\n</blockquote>\n<h3 id=\"每个状态有三个步骤【自动添加类名-v代表的是transfrom组件上的name属性指定的值】\"><a href=\"#每个状态有三个步骤【自动添加类名-v代表的是transfrom组件上的name属性指定的值】\" class=\"headerlink\" title=\"每个状态有三个步骤【自动添加类名 v代表的是transfrom组件上的name属性指定的值】\"></a>每个状态有三个步骤【自动添加类名 v代表的是transfrom组件上的name属性指定的值】</h3><ul>\n<li>v-enter v-enter-active v-enter-to</li>\n<li>v-leave v-leave-active v-leave-to</li>\n</ul>\n<blockquote>\n<h3 id=\"通过结合css过渡动画和关键帧动画可以实现切换动画\"><a href=\"#通过结合css过渡动画和关键帧动画可以实现切换动画\" class=\"headerlink\" title=\"通过结合css过渡动画和关键帧动画可以实现切换动画\"></a>通过结合css过渡动画和关键帧动画可以实现切换动画</h3></blockquote>\n<h3 id=\"动画触发场景\"><a href=\"#动画触发场景\" class=\"headerlink\" title=\"动画触发场景\"></a>动画触发场景</h3><ol>\n<li>跟组件初始化渲染</li>\n<li>v-show，v-if，component动态组件切换的时候</li>\n<li>router-view 路由切换的时候</li>\n</ol>\n<h3 id=\"transfrom-组件还可以通过属性去改变不同状态自动添加的class类名\"><a href=\"#transfrom-组件还可以通过属性去改变不同状态自动添加的class类名\" class=\"headerlink\" title=\"transfrom 组件还可以通过属性去改变不同状态自动添加的class类名\"></a>transfrom 组件还可以通过属性去改变不同状态自动添加的class类名</h3><ul>\n<li>enter-active-class=”animated slideInDown”</li>\n<li>leave-active-class=”animated bounceOutDown”</li>\n</ul>\n<h3 id=\"这种方式适合配合第三方动画库实现动画\"><a href=\"#这种方式适合配合第三方动画库实现动画\" class=\"headerlink\" title=\"这种方式适合配合第三方动画库实现动画\"></a>这种方式适合配合第三方动画库实现动画</h3><pre><code>&lt;transition\nv-on:before-enter=&quot;berforeEnter&quot;            //可以做一些初始化样式设置\nv-on:enter=&quot;enter&quot;                            //执行js操作dom完成的动画效果\nv-on:after-enter=&quot;afterEnter&quot;                //动画执行结束（也就是在enter中调用了done函数）\nv-on:enter-cancelled=&quot;enterCancelled&quot;        动画还没有结束，就执行下一次动画了，这时候不会触发动画结束，而是触发这个时间（取消）\nv-on:before-leave=&quot;beforeLeave&quot;\nv-on:leave=&quot;leave&quot;\nv-on:after-leave=&quot;afterLeave&quot;\nv-on:leave-cancelled=&quot;leaveCancelled&quot;    \n&gt;\n&lt;!--...--&gt;\n&lt;/transition&gt;\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Vue-transfrom属性\"><a href=\"#Vue-transfrom属性\" class=\"headerlink\" title=\"Vue transfrom属性\"></a>Vue transfrom属性</h1><h2 id=\"vue中的动画可以使用transfrom组件完成\"><a href=\"#vue中的动画可以使用transfrom组件完成\" class=\"headerlink\" title=\"vue中的动画可以使用transfrom组件完成\"></a>vue中的动画可以使用transfrom组件完成</h2><h3 id=\"transfrom组件提供两个过渡状态\"><a href=\"#transfrom组件提供两个过渡状态\" class=\"headerlink\" title=\"transfrom组件提供两个过渡状态\"></a>transfrom组件提供两个过渡状态</h3><blockquote>\n<p>进入 enter</p>\n</blockquote>\n<blockquote>\n<p>离开 leave</p>\n</blockquote>\n<h3 id=\"每个状态有三个步骤【自动添加类名-v代表的是transfrom组件上的name属性指定的值】\"><a href=\"#每个状态有三个步骤【自动添加类名-v代表的是transfrom组件上的name属性指定的值】\" class=\"headerlink\" title=\"每个状态有三个步骤【自动添加类名 v代表的是transfrom组件上的name属性指定的值】\"></a>每个状态有三个步骤【自动添加类名 v代表的是transfrom组件上的name属性指定的值】</h3><ul>\n<li>v-enter v-enter-active v-enter-to</li>\n<li>v-leave v-leave-active v-leave-to</li>\n</ul>\n<blockquote>\n<h3 id=\"通过结合css过渡动画和关键帧动画可以实现切换动画\"><a href=\"#通过结合css过渡动画和关键帧动画可以实现切换动画\" class=\"headerlink\" title=\"通过结合css过渡动画和关键帧动画可以实现切换动画\"></a>通过结合css过渡动画和关键帧动画可以实现切换动画</h3></blockquote>\n<h3 id=\"动画触发场景\"><a href=\"#动画触发场景\" class=\"headerlink\" title=\"动画触发场景\"></a>动画触发场景</h3><ol>\n<li>跟组件初始化渲染</li>\n<li>v-show，v-if，component动态组件切换的时候</li>\n<li>router-view 路由切换的时候</li>\n</ol>\n<h3 id=\"transfrom-组件还可以通过属性去改变不同状态自动添加的class类名\"><a href=\"#transfrom-组件还可以通过属性去改变不同状态自动添加的class类名\" class=\"headerlink\" title=\"transfrom 组件还可以通过属性去改变不同状态自动添加的class类名\"></a>transfrom 组件还可以通过属性去改变不同状态自动添加的class类名</h3><ul>\n<li>enter-active-class=”animated slideInDown”</li>\n<li>leave-active-class=”animated bounceOutDown”</li>\n</ul>\n<h3 id=\"这种方式适合配合第三方动画库实现动画\"><a href=\"#这种方式适合配合第三方动画库实现动画\" class=\"headerlink\" title=\"这种方式适合配合第三方动画库实现动画\"></a>这种方式适合配合第三方动画库实现动画</h3><pre><code>&lt;transition\nv-on:before-enter=&quot;berforeEnter&quot;            //可以做一些初始化样式设置\nv-on:enter=&quot;enter&quot;                            //执行js操作dom完成的动画效果\nv-on:after-enter=&quot;afterEnter&quot;                //动画执行结束（也就是在enter中调用了done函数）\nv-on:enter-cancelled=&quot;enterCancelled&quot;        动画还没有结束，就执行下一次动画了，这时候不会触发动画结束，而是触发这个时间（取消）\nv-on:before-leave=&quot;beforeLeave&quot;\nv-on:leave=&quot;leave&quot;\nv-on:after-leave=&quot;afterLeave&quot;\nv-on:leave-cancelled=&quot;leaveCancelled&quot;    \n&gt;\n&lt;!--...--&gt;\n&lt;/transition&gt;\n</code></pre>"},{"title":"sass基本语法使用","date":"2018-08-04T08:46:31.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"1/26/2019 10:54:49 AM \n----------\n\n\n# sass\n\t\n### 学过CSS的人都知道，它不是一种编程语言。\n\n#### 你可以用它开发网页样式，但是没法用它编程。也就是说，CSS基本上是设计师的工具，不是程序员的工具。在程序员眼里，CSS是一件很麻烦的东西。它没有变量，也没有条件语句，只是一行行单纯的描述，写起来相当费事。\n\n## 基本语法\n\n- ## 变量\n\n\t#### SASS允许使用变量，所有变量以$开头。\n\n\t\t$blue : #1875e7;　\n\n\t\t　　div {\n\t\t　　　color : $blue;\n\t\t　　}\n\n\t#### 如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。\n\n\t\t$side : left;\n\t\t　　.rounded {\n\t\t　　　　border-#{$side}-radius: 5px;\n\t\t　　}\n\n- ## 计算功能\n\n\t#### SASS允许在代码中使用算式：\n\n\t\tbody {\n\t\t　　　　margin: (14px/2);\n\t\t　　　　top: 50px + 100px;\n\t\t　　　　right: $var * 10%;\n\t\t　　}\n\n- ## 嵌套\n\n\t#### SASS允许选择器嵌套。比如，下面的CSS代码：\n\n\t\tdiv h1 {\n\t\t　　　　color : red;\n\t\t　　}\n\n\t可以写成：\n\n\t\tdiv {\n\t\t　　　　hi {\n\t\t　　　　　　color:red;\n\t\t　　　　}\n\t\t　　}\n\n- ## 代码的重用 \n\n----------\n【继承】\n\n#### SASS允许一个选择器，继承另一个选择器。比如，现有class1：\n\n\t\t.class1 {\n\t\t　　　　border: 1px solid #ddd;\n\t\t　　}\n#### class2要继承class1，就要使用@extend命令：\n\n\t\t.class2 {\n\t\t　　　　@extend .class1;\n\t\t　　　　font-size:120%;\n\t\t　　}\n\n- ## Mixin\n\n\t#### Mixin有点像C语言的宏（macro），是可以重用的代码块。\n\n\t#### 使用@mixin命令，定义一个代码块。\n\n\t\t@mixin left {\n\t\t　　　　float: left;\n\t\t　　　　margin-left: 10px;\n\t\t　　}\n\n\t#### 使用@include命令，调用这个mixin。\n\n\t\tdiv {\n\t\t　　　　@include left;\n\t\t　　}\n\n\t#### mixin的强大之处，在于可以指定参数和缺省值。\n\n\t\t@mixin left($value: 10px) {\n\t\t　　　　float: left;\n\t\t　　　　margin-right: $value;\n\t\t　　}\n\n\t#### 使用的时候，根据需要加入参数：\n\n\t\tdiv {\n\t\t　　　　@include left(20px);\n\t\t　　}\n\n\t#### 下面是一个mixin的实例，用来生成浏览器前缀。\n\n\t\t@mixin rounded($vert, $horz, $radius: 10px) {\n\t\t　　　　border-#{$vert}-#{$horz}-radius: $radius;\n\t\t　　　　-moz-border-radius-#{$vert}#{$horz}: $radius;\n\t\t　　　　-webkit-border-#{$vert}-#{$horz}-radius: $radius;\n\t\t　　}\n\t#### 使用的时候，可以像下面这样调用：\n\n\t\t\t.navbar li { @include rounded(top, left); }\n\n\t\t    .footer { @include rounded(top, left, 5px); }\n\n- ## 插入文件\n\n\t#### @import命令，用来插入外部文件。\n\n\t\t@import \"path/filename.scss\";\n\n\t#### 如果插入的是.css文件，则等同于css的import命令。\n\n\t\t@import \"foo.css\";\n\n- ## 高级用法\n\n\t\t\n\t### 1. 条件语句\n\n\t#### @if可以用来判断：\n\n\t\tp {\n\t\t　　　　@if 1 + 1 == 2 { border: 1px solid; }\n\t\t　　　　@if 5 < 3 { border: 2px dotted; }\n\t\t　　}\n\n\t#### 配套的还有@else命令：\n\n\t\t@if lightness($color) > 30% {\n\t\t　　　　background-color: #000;\n\t\t　　} @else {\n\t\t　　　　background-color: #fff;\n\t\t　　}\n\n\t### 2. 循环语句\n\n\t#### SASS支持for循环：\n\n\t\t@for $i from 1 to 10 {\n\t\t　　　　.border-#{$i} {\n\t\t　　　　　　border: #{$i}px solid blue;\n\t\t　　　　}\n\t\t　　}\n\n\t#### 也支持while循环：\n\n\t\t$i: 6;\n\n\t\t　　@while $i > 0 {\n\t\t　　　　.item-#{$i} { width: 2em * $i; }\n\t\t　　　　$i: $i - 2;\n\t\t　　}\n\n\t#### each命令，作用与for类似：\n\n\t\t@each $member in a, b, c, d {\n\t\t　　　　.#{$member} {\n\t\t　　　　　　background-image: url(\"/image/#{$member}.jpg\");\n\t\t　　　　}\n\t\t　　}\n\n\t### 3. 自定义函数\n\n\t#### SASS允许用户编写自己的函数。\n\n\t\t@function double($n) {\n\t\t　　　　@return $n * 2;\n\t\t　　}\n\t\t\n\t\t　　#sidebar {\n\t\t　　　　width: double(5px);\n\t\t　　}\n","source":"_posts/sass.md","raw":"---\ntitle: sass基本语法使用\ndate: '2018-08-04 16:46:31'\ntag: ['css', 'scss', sass]\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n1/26/2019 10:54:49 AM \n----------\n\n\n# sass\n\t\n### 学过CSS的人都知道，它不是一种编程语言。\n\n#### 你可以用它开发网页样式，但是没法用它编程。也就是说，CSS基本上是设计师的工具，不是程序员的工具。在程序员眼里，CSS是一件很麻烦的东西。它没有变量，也没有条件语句，只是一行行单纯的描述，写起来相当费事。\n\n## 基本语法\n\n- ## 变量\n\n\t#### SASS允许使用变量，所有变量以$开头。\n\n\t\t$blue : #1875e7;　\n\n\t\t　　div {\n\t\t　　　color : $blue;\n\t\t　　}\n\n\t#### 如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。\n\n\t\t$side : left;\n\t\t　　.rounded {\n\t\t　　　　border-#{$side}-radius: 5px;\n\t\t　　}\n\n- ## 计算功能\n\n\t#### SASS允许在代码中使用算式：\n\n\t\tbody {\n\t\t　　　　margin: (14px/2);\n\t\t　　　　top: 50px + 100px;\n\t\t　　　　right: $var * 10%;\n\t\t　　}\n\n- ## 嵌套\n\n\t#### SASS允许选择器嵌套。比如，下面的CSS代码：\n\n\t\tdiv h1 {\n\t\t　　　　color : red;\n\t\t　　}\n\n\t可以写成：\n\n\t\tdiv {\n\t\t　　　　hi {\n\t\t　　　　　　color:red;\n\t\t　　　　}\n\t\t　　}\n\n- ## 代码的重用 \n\n----------\n【继承】\n\n#### SASS允许一个选择器，继承另一个选择器。比如，现有class1：\n\n\t\t.class1 {\n\t\t　　　　border: 1px solid #ddd;\n\t\t　　}\n#### class2要继承class1，就要使用@extend命令：\n\n\t\t.class2 {\n\t\t　　　　@extend .class1;\n\t\t　　　　font-size:120%;\n\t\t　　}\n\n- ## Mixin\n\n\t#### Mixin有点像C语言的宏（macro），是可以重用的代码块。\n\n\t#### 使用@mixin命令，定义一个代码块。\n\n\t\t@mixin left {\n\t\t　　　　float: left;\n\t\t　　　　margin-left: 10px;\n\t\t　　}\n\n\t#### 使用@include命令，调用这个mixin。\n\n\t\tdiv {\n\t\t　　　　@include left;\n\t\t　　}\n\n\t#### mixin的强大之处，在于可以指定参数和缺省值。\n\n\t\t@mixin left($value: 10px) {\n\t\t　　　　float: left;\n\t\t　　　　margin-right: $value;\n\t\t　　}\n\n\t#### 使用的时候，根据需要加入参数：\n\n\t\tdiv {\n\t\t　　　　@include left(20px);\n\t\t　　}\n\n\t#### 下面是一个mixin的实例，用来生成浏览器前缀。\n\n\t\t@mixin rounded($vert, $horz, $radius: 10px) {\n\t\t　　　　border-#{$vert}-#{$horz}-radius: $radius;\n\t\t　　　　-moz-border-radius-#{$vert}#{$horz}: $radius;\n\t\t　　　　-webkit-border-#{$vert}-#{$horz}-radius: $radius;\n\t\t　　}\n\t#### 使用的时候，可以像下面这样调用：\n\n\t\t\t.navbar li { @include rounded(top, left); }\n\n\t\t    .footer { @include rounded(top, left, 5px); }\n\n- ## 插入文件\n\n\t#### @import命令，用来插入外部文件。\n\n\t\t@import \"path/filename.scss\";\n\n\t#### 如果插入的是.css文件，则等同于css的import命令。\n\n\t\t@import \"foo.css\";\n\n- ## 高级用法\n\n\t\t\n\t### 1. 条件语句\n\n\t#### @if可以用来判断：\n\n\t\tp {\n\t\t　　　　@if 1 + 1 == 2 { border: 1px solid; }\n\t\t　　　　@if 5 < 3 { border: 2px dotted; }\n\t\t　　}\n\n\t#### 配套的还有@else命令：\n\n\t\t@if lightness($color) > 30% {\n\t\t　　　　background-color: #000;\n\t\t　　} @else {\n\t\t　　　　background-color: #fff;\n\t\t　　}\n\n\t### 2. 循环语句\n\n\t#### SASS支持for循环：\n\n\t\t@for $i from 1 to 10 {\n\t\t　　　　.border-#{$i} {\n\t\t　　　　　　border: #{$i}px solid blue;\n\t\t　　　　}\n\t\t　　}\n\n\t#### 也支持while循环：\n\n\t\t$i: 6;\n\n\t\t　　@while $i > 0 {\n\t\t　　　　.item-#{$i} { width: 2em * $i; }\n\t\t　　　　$i: $i - 2;\n\t\t　　}\n\n\t#### each命令，作用与for类似：\n\n\t\t@each $member in a, b, c, d {\n\t\t　　　　.#{$member} {\n\t\t　　　　　　background-image: url(\"/image/#{$member}.jpg\");\n\t\t　　　　}\n\t\t　　}\n\n\t### 3. 自定义函数\n\n\t#### SASS允许用户编写自己的函数。\n\n\t\t@function double($n) {\n\t\t　　　　@return $n * 2;\n\t\t　　}\n\t\t\n\t\t　　#sidebar {\n\t\t　　　　width: double(5px);\n\t\t　　}\n","slug":"sass","published":1,"updated":"2019-01-26T06:11:28.195Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam7n0029n4wdstwbgr1s","content":"<h2 id=\"1-26-2019-10-54-49-AM\"><a href=\"#1-26-2019-10-54-49-AM\" class=\"headerlink\" title=\"1/26/2019 10:54:49 AM \"></a>1/26/2019 10:54:49 AM </h2><h1 id=\"sass\"><a href=\"#sass\" class=\"headerlink\" title=\"sass\"></a>sass</h1><h3 id=\"学过CSS的人都知道，它不是一种编程语言。\"><a href=\"#学过CSS的人都知道，它不是一种编程语言。\" class=\"headerlink\" title=\"学过CSS的人都知道，它不是一种编程语言。\"></a>学过CSS的人都知道，它不是一种编程语言。</h3><h4 id=\"你可以用它开发网页样式，但是没法用它编程。也就是说，CSS基本上是设计师的工具，不是程序员的工具。在程序员眼里，CSS是一件很麻烦的东西。它没有变量，也没有条件语句，只是一行行单纯的描述，写起来相当费事。\"><a href=\"#你可以用它开发网页样式，但是没法用它编程。也就是说，CSS基本上是设计师的工具，不是程序员的工具。在程序员眼里，CSS是一件很麻烦的东西。它没有变量，也没有条件语句，只是一行行单纯的描述，写起来相当费事。\" class=\"headerlink\" title=\"你可以用它开发网页样式，但是没法用它编程。也就是说，CSS基本上是设计师的工具，不是程序员的工具。在程序员眼里，CSS是一件很麻烦的东西。它没有变量，也没有条件语句，只是一行行单纯的描述，写起来相当费事。\"></a>你可以用它开发网页样式，但是没法用它编程。也就是说，CSS基本上是设计师的工具，不是程序员的工具。在程序员眼里，CSS是一件很麻烦的东西。它没有变量，也没有条件语句，只是一行行单纯的描述，写起来相当费事。</h4><h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><ul>\n<li><h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><h4 id=\"SASS允许使用变量，所有变量以-开头。\"><a href=\"#SASS允许使用变量，所有变量以-开头。\" class=\"headerlink\" title=\"SASS允许使用变量，所有变量以$开头。\"></a>SASS允许使用变量，所有变量以$开头。</h4><pre><code>  $blue : #1875e7;　\n\n  　　div {\n  　　　color : $blue;\n  　　}\n</code></pre><h4 id=\"如果变量需要镶嵌在字符串之中，就必须需要写在-之中。\"><a href=\"#如果变量需要镶嵌在字符串之中，就必须需要写在-之中。\" class=\"headerlink\" title=\"如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。\"></a>如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。</h4><pre><code>  $side : left;\n  　　.rounded {\n  　　　　border-#{$side}-radius: 5px;\n  　　}\n</code></pre></li>\n<li><h2 id=\"计算功能\"><a href=\"#计算功能\" class=\"headerlink\" title=\"计算功能\"></a>计算功能</h2><h4 id=\"SASS允许在代码中使用算式：\"><a href=\"#SASS允许在代码中使用算式：\" class=\"headerlink\" title=\"SASS允许在代码中使用算式：\"></a>SASS允许在代码中使用算式：</h4><pre><code>  body {\n  　　　　margin: (14px/2);\n  　　　　top: 50px + 100px;\n  　　　　right: $var * 10%;\n  　　}\n</code></pre></li>\n<li><h2 id=\"嵌套\"><a href=\"#嵌套\" class=\"headerlink\" title=\"嵌套\"></a>嵌套</h2><h4 id=\"SASS允许选择器嵌套。比如，下面的CSS代码：\"><a href=\"#SASS允许选择器嵌套。比如，下面的CSS代码：\" class=\"headerlink\" title=\"SASS允许选择器嵌套。比如，下面的CSS代码：\"></a>SASS允许选择器嵌套。比如，下面的CSS代码：</h4><pre><code>  div h1 {\n  　　　　color : red;\n  　　}\n</code></pre><p>  可以写成：</p>\n<pre><code>  div {\n  　　　　hi {\n  　　　　　　color:red;\n  　　　　}\n  　　}\n</code></pre></li>\n<li><h2 id=\"代码的重用\"><a href=\"#代码的重用\" class=\"headerlink\" title=\"代码的重用\"></a>代码的重用</h2></li>\n</ul>\n<hr>\n<p>【继承】</p>\n<h4 id=\"SASS允许一个选择器，继承另一个选择器。比如，现有class1：\"><a href=\"#SASS允许一个选择器，继承另一个选择器。比如，现有class1：\" class=\"headerlink\" title=\"SASS允许一个选择器，继承另一个选择器。比如，现有class1：\"></a>SASS允许一个选择器，继承另一个选择器。比如，现有class1：</h4><pre><code>    .class1 {\n    　　　　border: 1px solid #ddd;\n    　　}\n</code></pre><h4 id=\"class2要继承class1，就要使用-extend命令：\"><a href=\"#class2要继承class1，就要使用-extend命令：\" class=\"headerlink\" title=\"class2要继承class1，就要使用@extend命令：\"></a>class2要继承class1，就要使用@extend命令：</h4><pre><code>    .class2 {\n    　　　　@extend .class1;\n    　　　　font-size:120%;\n    　　}\n</code></pre><ul>\n<li><h2 id=\"Mixin\"><a href=\"#Mixin\" class=\"headerlink\" title=\"Mixin\"></a>Mixin</h2><h4 id=\"Mixin有点像C语言的宏（macro），是可以重用的代码块。\"><a href=\"#Mixin有点像C语言的宏（macro），是可以重用的代码块。\" class=\"headerlink\" title=\"Mixin有点像C语言的宏（macro），是可以重用的代码块。\"></a>Mixin有点像C语言的宏（macro），是可以重用的代码块。</h4><h4 id=\"使用-mixin命令，定义一个代码块。\"><a href=\"#使用-mixin命令，定义一个代码块。\" class=\"headerlink\" title=\"使用@mixin命令，定义一个代码块。\"></a>使用@mixin命令，定义一个代码块。</h4><pre><code>  @mixin left {\n  　　　　float: left;\n  　　　　margin-left: 10px;\n  　　}\n</code></pre><h4 id=\"使用-include命令，调用这个mixin。\"><a href=\"#使用-include命令，调用这个mixin。\" class=\"headerlink\" title=\"使用@include命令，调用这个mixin。\"></a>使用@include命令，调用这个mixin。</h4><pre><code>  div {\n  　　　　@include left;\n  　　}\n</code></pre><h4 id=\"mixin的强大之处，在于可以指定参数和缺省值。\"><a href=\"#mixin的强大之处，在于可以指定参数和缺省值。\" class=\"headerlink\" title=\"mixin的强大之处，在于可以指定参数和缺省值。\"></a>mixin的强大之处，在于可以指定参数和缺省值。</h4><pre><code>  @mixin left($value: 10px) {\n  　　　　float: left;\n  　　　　margin-right: $value;\n  　　}\n</code></pre><h4 id=\"使用的时候，根据需要加入参数：\"><a href=\"#使用的时候，根据需要加入参数：\" class=\"headerlink\" title=\"使用的时候，根据需要加入参数：\"></a>使用的时候，根据需要加入参数：</h4><pre><code>  div {\n  　　　　@include left(20px);\n  　　}\n</code></pre><h4 id=\"下面是一个mixin的实例，用来生成浏览器前缀。\"><a href=\"#下面是一个mixin的实例，用来生成浏览器前缀。\" class=\"headerlink\" title=\"下面是一个mixin的实例，用来生成浏览器前缀。\"></a>下面是一个mixin的实例，用来生成浏览器前缀。</h4><pre><code>  @mixin rounded($vert, $horz, $radius: 10px) {\n  　　　　border-#{$vert}-#{$horz}-radius: $radius;\n  　　　　-moz-border-radius-#{$vert}#{$horz}: $radius;\n  　　　　-webkit-border-#{$vert}-#{$horz}-radius: $radius;\n  　　}\n</code></pre><h4 id=\"使用的时候，可以像下面这样调用：\"><a href=\"#使用的时候，可以像下面这样调用：\" class=\"headerlink\" title=\"使用的时候，可以像下面这样调用：\"></a>使用的时候，可以像下面这样调用：</h4><pre><code>      .navbar li { @include rounded(top, left); }\n\n      .footer { @include rounded(top, left, 5px); }\n</code></pre></li>\n<li><h2 id=\"插入文件\"><a href=\"#插入文件\" class=\"headerlink\" title=\"插入文件\"></a>插入文件</h2><h4 id=\"import命令，用来插入外部文件。\"><a href=\"#import命令，用来插入外部文件。\" class=\"headerlink\" title=\"@import命令，用来插入外部文件。\"></a>@import命令，用来插入外部文件。</h4><pre><code>  @import &quot;path/filename.scss&quot;;\n</code></pre><h4 id=\"如果插入的是-css文件，则等同于css的import命令。\"><a href=\"#如果插入的是-css文件，则等同于css的import命令。\" class=\"headerlink\" title=\"如果插入的是.css文件，则等同于css的import命令。\"></a>如果插入的是.css文件，则等同于css的import命令。</h4><pre><code>  @import &quot;foo.css&quot;;\n</code></pre></li>\n<li><h2 id=\"高级用法\"><a href=\"#高级用法\" class=\"headerlink\" title=\"高级用法\"></a>高级用法</h2></li>\n</ul>\n<pre><code>### 1. 条件语句\n\n#### @if可以用来判断：\n\n    p {\n    　　　　@if 1 + 1 == 2 { border: 1px solid; }\n    　　　　@if 5 &lt; 3 { border: 2px dotted; }\n    　　}\n\n#### 配套的还有@else命令：\n\n    @if lightness($color) &gt; 30% {\n    　　　　background-color: #000;\n    　　} @else {\n    　　　　background-color: #fff;\n    　　}\n\n### 2. 循环语句\n\n#### SASS支持for循环：\n\n    @for $i from 1 to 10 {\n    　　　　.border-#{$i} {\n    　　　　　　border: #{$i}px solid blue;\n    　　　　}\n    　　}\n\n#### 也支持while循环：\n\n    $i: 6;\n\n    　　@while $i &gt; 0 {\n    　　　　.item-#{$i} { width: 2em * $i; }\n    　　　　$i: $i - 2;\n    　　}\n\n#### each命令，作用与for类似：\n\n    @each $member in a, b, c, d {\n    　　　　.#{$member} {\n    　　　　　　background-image: url(&quot;/image/#{$member}.jpg&quot;);\n    　　　　}\n    　　}\n\n### 3. 自定义函数\n\n#### SASS允许用户编写自己的函数。\n\n    @function double($n) {\n    　　　　@return $n * 2;\n    　　}\n\n    　　#sidebar {\n    　　　　width: double(5px);\n    　　}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-26-2019-10-54-49-AM\"><a href=\"#1-26-2019-10-54-49-AM\" class=\"headerlink\" title=\"1/26/2019 10:54:49 AM \"></a>1/26/2019 10:54:49 AM </h2><h1 id=\"sass\"><a href=\"#sass\" class=\"headerlink\" title=\"sass\"></a>sass</h1><h3 id=\"学过CSS的人都知道，它不是一种编程语言。\"><a href=\"#学过CSS的人都知道，它不是一种编程语言。\" class=\"headerlink\" title=\"学过CSS的人都知道，它不是一种编程语言。\"></a>学过CSS的人都知道，它不是一种编程语言。</h3><h4 id=\"你可以用它开发网页样式，但是没法用它编程。也就是说，CSS基本上是设计师的工具，不是程序员的工具。在程序员眼里，CSS是一件很麻烦的东西。它没有变量，也没有条件语句，只是一行行单纯的描述，写起来相当费事。\"><a href=\"#你可以用它开发网页样式，但是没法用它编程。也就是说，CSS基本上是设计师的工具，不是程序员的工具。在程序员眼里，CSS是一件很麻烦的东西。它没有变量，也没有条件语句，只是一行行单纯的描述，写起来相当费事。\" class=\"headerlink\" title=\"你可以用它开发网页样式，但是没法用它编程。也就是说，CSS基本上是设计师的工具，不是程序员的工具。在程序员眼里，CSS是一件很麻烦的东西。它没有变量，也没有条件语句，只是一行行单纯的描述，写起来相当费事。\"></a>你可以用它开发网页样式，但是没法用它编程。也就是说，CSS基本上是设计师的工具，不是程序员的工具。在程序员眼里，CSS是一件很麻烦的东西。它没有变量，也没有条件语句，只是一行行单纯的描述，写起来相当费事。</h4><h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><ul>\n<li><h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><h4 id=\"SASS允许使用变量，所有变量以-开头。\"><a href=\"#SASS允许使用变量，所有变量以-开头。\" class=\"headerlink\" title=\"SASS允许使用变量，所有变量以$开头。\"></a>SASS允许使用变量，所有变量以$开头。</h4><pre><code>  $blue : #1875e7;　\n\n  　　div {\n  　　　color : $blue;\n  　　}\n</code></pre><h4 id=\"如果变量需要镶嵌在字符串之中，就必须需要写在-之中。\"><a href=\"#如果变量需要镶嵌在字符串之中，就必须需要写在-之中。\" class=\"headerlink\" title=\"如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。\"></a>如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。</h4><pre><code>  $side : left;\n  　　.rounded {\n  　　　　border-#{$side}-radius: 5px;\n  　　}\n</code></pre></li>\n<li><h2 id=\"计算功能\"><a href=\"#计算功能\" class=\"headerlink\" title=\"计算功能\"></a>计算功能</h2><h4 id=\"SASS允许在代码中使用算式：\"><a href=\"#SASS允许在代码中使用算式：\" class=\"headerlink\" title=\"SASS允许在代码中使用算式：\"></a>SASS允许在代码中使用算式：</h4><pre><code>  body {\n  　　　　margin: (14px/2);\n  　　　　top: 50px + 100px;\n  　　　　right: $var * 10%;\n  　　}\n</code></pre></li>\n<li><h2 id=\"嵌套\"><a href=\"#嵌套\" class=\"headerlink\" title=\"嵌套\"></a>嵌套</h2><h4 id=\"SASS允许选择器嵌套。比如，下面的CSS代码：\"><a href=\"#SASS允许选择器嵌套。比如，下面的CSS代码：\" class=\"headerlink\" title=\"SASS允许选择器嵌套。比如，下面的CSS代码：\"></a>SASS允许选择器嵌套。比如，下面的CSS代码：</h4><pre><code>  div h1 {\n  　　　　color : red;\n  　　}\n</code></pre><p>  可以写成：</p>\n<pre><code>  div {\n  　　　　hi {\n  　　　　　　color:red;\n  　　　　}\n  　　}\n</code></pre></li>\n<li><h2 id=\"代码的重用\"><a href=\"#代码的重用\" class=\"headerlink\" title=\"代码的重用\"></a>代码的重用</h2></li>\n</ul>\n<hr>\n<p>【继承】</p>\n<h4 id=\"SASS允许一个选择器，继承另一个选择器。比如，现有class1：\"><a href=\"#SASS允许一个选择器，继承另一个选择器。比如，现有class1：\" class=\"headerlink\" title=\"SASS允许一个选择器，继承另一个选择器。比如，现有class1：\"></a>SASS允许一个选择器，继承另一个选择器。比如，现有class1：</h4><pre><code>    .class1 {\n    　　　　border: 1px solid #ddd;\n    　　}\n</code></pre><h4 id=\"class2要继承class1，就要使用-extend命令：\"><a href=\"#class2要继承class1，就要使用-extend命令：\" class=\"headerlink\" title=\"class2要继承class1，就要使用@extend命令：\"></a>class2要继承class1，就要使用@extend命令：</h4><pre><code>    .class2 {\n    　　　　@extend .class1;\n    　　　　font-size:120%;\n    　　}\n</code></pre><ul>\n<li><h2 id=\"Mixin\"><a href=\"#Mixin\" class=\"headerlink\" title=\"Mixin\"></a>Mixin</h2><h4 id=\"Mixin有点像C语言的宏（macro），是可以重用的代码块。\"><a href=\"#Mixin有点像C语言的宏（macro），是可以重用的代码块。\" class=\"headerlink\" title=\"Mixin有点像C语言的宏（macro），是可以重用的代码块。\"></a>Mixin有点像C语言的宏（macro），是可以重用的代码块。</h4><h4 id=\"使用-mixin命令，定义一个代码块。\"><a href=\"#使用-mixin命令，定义一个代码块。\" class=\"headerlink\" title=\"使用@mixin命令，定义一个代码块。\"></a>使用@mixin命令，定义一个代码块。</h4><pre><code>  @mixin left {\n  　　　　float: left;\n  　　　　margin-left: 10px;\n  　　}\n</code></pre><h4 id=\"使用-include命令，调用这个mixin。\"><a href=\"#使用-include命令，调用这个mixin。\" class=\"headerlink\" title=\"使用@include命令，调用这个mixin。\"></a>使用@include命令，调用这个mixin。</h4><pre><code>  div {\n  　　　　@include left;\n  　　}\n</code></pre><h4 id=\"mixin的强大之处，在于可以指定参数和缺省值。\"><a href=\"#mixin的强大之处，在于可以指定参数和缺省值。\" class=\"headerlink\" title=\"mixin的强大之处，在于可以指定参数和缺省值。\"></a>mixin的强大之处，在于可以指定参数和缺省值。</h4><pre><code>  @mixin left($value: 10px) {\n  　　　　float: left;\n  　　　　margin-right: $value;\n  　　}\n</code></pre><h4 id=\"使用的时候，根据需要加入参数：\"><a href=\"#使用的时候，根据需要加入参数：\" class=\"headerlink\" title=\"使用的时候，根据需要加入参数：\"></a>使用的时候，根据需要加入参数：</h4><pre><code>  div {\n  　　　　@include left(20px);\n  　　}\n</code></pre><h4 id=\"下面是一个mixin的实例，用来生成浏览器前缀。\"><a href=\"#下面是一个mixin的实例，用来生成浏览器前缀。\" class=\"headerlink\" title=\"下面是一个mixin的实例，用来生成浏览器前缀。\"></a>下面是一个mixin的实例，用来生成浏览器前缀。</h4><pre><code>  @mixin rounded($vert, $horz, $radius: 10px) {\n  　　　　border-#{$vert}-#{$horz}-radius: $radius;\n  　　　　-moz-border-radius-#{$vert}#{$horz}: $radius;\n  　　　　-webkit-border-#{$vert}-#{$horz}-radius: $radius;\n  　　}\n</code></pre><h4 id=\"使用的时候，可以像下面这样调用：\"><a href=\"#使用的时候，可以像下面这样调用：\" class=\"headerlink\" title=\"使用的时候，可以像下面这样调用：\"></a>使用的时候，可以像下面这样调用：</h4><pre><code>      .navbar li { @include rounded(top, left); }\n\n      .footer { @include rounded(top, left, 5px); }\n</code></pre></li>\n<li><h2 id=\"插入文件\"><a href=\"#插入文件\" class=\"headerlink\" title=\"插入文件\"></a>插入文件</h2><h4 id=\"import命令，用来插入外部文件。\"><a href=\"#import命令，用来插入外部文件。\" class=\"headerlink\" title=\"@import命令，用来插入外部文件。\"></a>@import命令，用来插入外部文件。</h4><pre><code>  @import &quot;path/filename.scss&quot;;\n</code></pre><h4 id=\"如果插入的是-css文件，则等同于css的import命令。\"><a href=\"#如果插入的是-css文件，则等同于css的import命令。\" class=\"headerlink\" title=\"如果插入的是.css文件，则等同于css的import命令。\"></a>如果插入的是.css文件，则等同于css的import命令。</h4><pre><code>  @import &quot;foo.css&quot;;\n</code></pre></li>\n<li><h2 id=\"高级用法\"><a href=\"#高级用法\" class=\"headerlink\" title=\"高级用法\"></a>高级用法</h2></li>\n</ul>\n<pre><code>### 1. 条件语句\n\n#### @if可以用来判断：\n\n    p {\n    　　　　@if 1 + 1 == 2 { border: 1px solid; }\n    　　　　@if 5 &lt; 3 { border: 2px dotted; }\n    　　}\n\n#### 配套的还有@else命令：\n\n    @if lightness($color) &gt; 30% {\n    　　　　background-color: #000;\n    　　} @else {\n    　　　　background-color: #fff;\n    　　}\n\n### 2. 循环语句\n\n#### SASS支持for循环：\n\n    @for $i from 1 to 10 {\n    　　　　.border-#{$i} {\n    　　　　　　border: #{$i}px solid blue;\n    　　　　}\n    　　}\n\n#### 也支持while循环：\n\n    $i: 6;\n\n    　　@while $i &gt; 0 {\n    　　　　.item-#{$i} { width: 2em * $i; }\n    　　　　$i: $i - 2;\n    　　}\n\n#### each命令，作用与for类似：\n\n    @each $member in a, b, c, d {\n    　　　　.#{$member} {\n    　　　　　　background-image: url(&quot;/image/#{$member}.jpg&quot;);\n    　　　　}\n    　　}\n\n### 3. 自定义函数\n\n#### SASS允许用户编写自己的函数。\n\n    @function double($n) {\n    　　　　@return $n * 2;\n    　　}\n\n    　　#sidebar {\n    　　　　width: double(5px);\n    　　}\n</code></pre>"},{"title":"ts的学习历程 -- 01","date":"2019-05-10T01:38:37.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"## ts的学习历程 -- 01\n\n## ts是什么？\n\n> TypeScript 是 JavaScript 的一个超集，支持 ECMAScript 6 标准。\n\n----------\n\n> TypeScript 由微软开发的自由和开源的编程语言。\n\n----------\n\n> TypeScript 设计目标是开发大型应用，它可以编译成纯 JavaScript，编译出来的 JavaScript 可以运行在任何浏览器上。\n\n## 语言特性\n\n### ts是一种给js添加特性的扩展性语言，扩展功能如下：\n\n- 基础类型\n- 接口\n- 类\n- 函数\n- 泛型\n- 类型兼容性\n- 高级类型\n- 模块\n- 命名空间\n- 混入\n\n\n## 基础类型\n\n### js是弱语言类型，而ts类似c++这种强语言，可以对变量进行处理，规定变量的类型，让程序变得可维护性强，有价值。\n\n### 布尔值\n\n我们可以在ts中进行如下声明：\n\n    let isDone: boolean = false\n    \n### 数字\n\n和js一样，ts中的数字都是浮点数，类型为number.\n\n    let num: number = 6\n    \n### 字符串\n\n    let str: string = \"26\"\n    \n### 数组\n\n有两种可以定义数组的方式\n\n    let list: number[] = [1, 2, 3]   // 表示由此类型元素组成的一个数组\n    \n---------------\n    \n    let list: Array<number> = [1, 2, 3] // 使用数组泛型Array<元素类型>\n    \n### 元组 Tuple\n\n元组类型表示允许一个已知元素数量和类型的数组，各元素的类型不必相同\n\n    let x: [string, number];\n    \n    x = ['hello', 10];\n    \n### 枚举 enum\n    \n类型是对JavaScript标准数据类型的一个补充\n    \n    enum Color {Red, Green, Blue}\n    \n    let c: Color = Color.Green;\n    \n默认情况下，从0开始为元素编号。你也可以手动的指定成员的数值\n    \n    enum Color {Red = 1, Green, Blue}\n    \n    let c: Color = Color.Green;\n    \n或者，全部都采用手动赋值：\n    \n    enum Color {Red = 1, Green = 2, Blue = 4}\n    \n    let c: Color = Color.Green;\n    \n枚举类型提供的一个便利是你可以由枚举的值得到它的名字\n    \n    enum Color {Red = 1, Green, Blue}\n    \n    let colorName: string = Color[2]; // Green\n    \n### 任意值 any\n\n有的时候我们或许还不知到该变量到底该赋什么类型的值，比如对象\n\n    let notSure: any = 4;\n    \n当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：\n\n    let list: any[] = [1, true, \"free\"];\n    \n    list[1] = 100;\n    \n### 空值 void\n\n你可以理解为和any相反的类型，他表示没有任何类型\n\n    function warnUser(): void {\n        alert(\"This is my warning message\");\n    }\n    \n在声明变量的时候，你只能赋予它undefined和null\n\n    let unusable: void = undefined;\n                ||或\n    let unusable: void = null;\n    \n### Null 和 Undefined\n\nundefined和null两者各自有自己的类型分别叫做undefined和null。 和void相似\n\n    let u: undefined = undefined;\n    \n    let n: null = null;\n    \n### Never\n\nnever类型表示的是那些永不存在的值的类型。\n\n**返回never的函数必须存在无法达到的终点**\n\n    function infiniteLoop(): never {\n        while (true) {\n        \n        }\n    }\n    \n### 类型断言\n\n有的时候会或许更了解你的一些变量【两种写法】\n\n**尖括号**\n\n    let someValue: any = \"this is a string\";\n\n    let strLength: number = (<string>someValue).length;\n    \n**as语法**\n\n    let someValue: any = \"this is a string\";\n\n    let strLength: number = (someValue as string).length;\n\n### ！\n\n表示非null的意思\n\n> 有时候获取的节点有可能为null，但是我们可以明确的使用ts表达自己的意向，明确自己想要的值\n\n\tconst a = document.getElementById('id')!\n    \n    \n","source":"_posts/ts-01.md","raw":"---\ntitle: ts的学习历程 -- 01\ndate: '5/10/2019 9:38:37 AM'\ntag: ['ts']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n## ts的学习历程 -- 01\n\n## ts是什么？\n\n> TypeScript 是 JavaScript 的一个超集，支持 ECMAScript 6 标准。\n\n----------\n\n> TypeScript 由微软开发的自由和开源的编程语言。\n\n----------\n\n> TypeScript 设计目标是开发大型应用，它可以编译成纯 JavaScript，编译出来的 JavaScript 可以运行在任何浏览器上。\n\n## 语言特性\n\n### ts是一种给js添加特性的扩展性语言，扩展功能如下：\n\n- 基础类型\n- 接口\n- 类\n- 函数\n- 泛型\n- 类型兼容性\n- 高级类型\n- 模块\n- 命名空间\n- 混入\n\n\n## 基础类型\n\n### js是弱语言类型，而ts类似c++这种强语言，可以对变量进行处理，规定变量的类型，让程序变得可维护性强，有价值。\n\n### 布尔值\n\n我们可以在ts中进行如下声明：\n\n    let isDone: boolean = false\n    \n### 数字\n\n和js一样，ts中的数字都是浮点数，类型为number.\n\n    let num: number = 6\n    \n### 字符串\n\n    let str: string = \"26\"\n    \n### 数组\n\n有两种可以定义数组的方式\n\n    let list: number[] = [1, 2, 3]   // 表示由此类型元素组成的一个数组\n    \n---------------\n    \n    let list: Array<number> = [1, 2, 3] // 使用数组泛型Array<元素类型>\n    \n### 元组 Tuple\n\n元组类型表示允许一个已知元素数量和类型的数组，各元素的类型不必相同\n\n    let x: [string, number];\n    \n    x = ['hello', 10];\n    \n### 枚举 enum\n    \n类型是对JavaScript标准数据类型的一个补充\n    \n    enum Color {Red, Green, Blue}\n    \n    let c: Color = Color.Green;\n    \n默认情况下，从0开始为元素编号。你也可以手动的指定成员的数值\n    \n    enum Color {Red = 1, Green, Blue}\n    \n    let c: Color = Color.Green;\n    \n或者，全部都采用手动赋值：\n    \n    enum Color {Red = 1, Green = 2, Blue = 4}\n    \n    let c: Color = Color.Green;\n    \n枚举类型提供的一个便利是你可以由枚举的值得到它的名字\n    \n    enum Color {Red = 1, Green, Blue}\n    \n    let colorName: string = Color[2]; // Green\n    \n### 任意值 any\n\n有的时候我们或许还不知到该变量到底该赋什么类型的值，比如对象\n\n    let notSure: any = 4;\n    \n当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：\n\n    let list: any[] = [1, true, \"free\"];\n    \n    list[1] = 100;\n    \n### 空值 void\n\n你可以理解为和any相反的类型，他表示没有任何类型\n\n    function warnUser(): void {\n        alert(\"This is my warning message\");\n    }\n    \n在声明变量的时候，你只能赋予它undefined和null\n\n    let unusable: void = undefined;\n                ||或\n    let unusable: void = null;\n    \n### Null 和 Undefined\n\nundefined和null两者各自有自己的类型分别叫做undefined和null。 和void相似\n\n    let u: undefined = undefined;\n    \n    let n: null = null;\n    \n### Never\n\nnever类型表示的是那些永不存在的值的类型。\n\n**返回never的函数必须存在无法达到的终点**\n\n    function infiniteLoop(): never {\n        while (true) {\n        \n        }\n    }\n    \n### 类型断言\n\n有的时候会或许更了解你的一些变量【两种写法】\n\n**尖括号**\n\n    let someValue: any = \"this is a string\";\n\n    let strLength: number = (<string>someValue).length;\n    \n**as语法**\n\n    let someValue: any = \"this is a string\";\n\n    let strLength: number = (someValue as string).length;\n\n### ！\n\n表示非null的意思\n\n> 有时候获取的节点有可能为null，但是我们可以明确的使用ts表达自己的意向，明确自己想要的值\n\n\tconst a = document.getElementById('id')!\n    \n    \n","slug":"ts-01","published":1,"updated":"2019-05-16T09:36:27.642Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam7p002cn4wdaapl0zux","content":"<h2 id=\"ts的学习历程-–-01\"><a href=\"#ts的学习历程-–-01\" class=\"headerlink\" title=\"ts的学习历程 – 01\"></a>ts的学习历程 – 01</h2><h2 id=\"ts是什么？\"><a href=\"#ts是什么？\" class=\"headerlink\" title=\"ts是什么？\"></a>ts是什么？</h2><blockquote>\n<p>TypeScript 是 JavaScript 的一个超集，支持 ECMAScript 6 标准。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>TypeScript 由微软开发的自由和开源的编程语言。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>TypeScript 设计目标是开发大型应用，它可以编译成纯 JavaScript，编译出来的 JavaScript 可以运行在任何浏览器上。</p>\n</blockquote>\n<h2 id=\"语言特性\"><a href=\"#语言特性\" class=\"headerlink\" title=\"语言特性\"></a>语言特性</h2><h3 id=\"ts是一种给js添加特性的扩展性语言，扩展功能如下：\"><a href=\"#ts是一种给js添加特性的扩展性语言，扩展功能如下：\" class=\"headerlink\" title=\"ts是一种给js添加特性的扩展性语言，扩展功能如下：\"></a>ts是一种给js添加特性的扩展性语言，扩展功能如下：</h3><ul>\n<li>基础类型</li>\n<li>接口</li>\n<li>类</li>\n<li>函数</li>\n<li>泛型</li>\n<li>类型兼容性</li>\n<li>高级类型</li>\n<li>模块</li>\n<li>命名空间</li>\n<li>混入</li>\n</ul>\n<h2 id=\"基础类型\"><a href=\"#基础类型\" class=\"headerlink\" title=\"基础类型\"></a>基础类型</h2><h3 id=\"js是弱语言类型，而ts类似c-这种强语言，可以对变量进行处理，规定变量的类型，让程序变得可维护性强，有价值。\"><a href=\"#js是弱语言类型，而ts类似c-这种强语言，可以对变量进行处理，规定变量的类型，让程序变得可维护性强，有价值。\" class=\"headerlink\" title=\"js是弱语言类型，而ts类似c++这种强语言，可以对变量进行处理，规定变量的类型，让程序变得可维护性强，有价值。\"></a>js是弱语言类型，而ts类似c++这种强语言，可以对变量进行处理，规定变量的类型，让程序变得可维护性强，有价值。</h3><h3 id=\"布尔值\"><a href=\"#布尔值\" class=\"headerlink\" title=\"布尔值\"></a>布尔值</h3><p>我们可以在ts中进行如下声明：</p>\n<pre><code>let isDone: boolean = false\n</code></pre><h3 id=\"数字\"><a href=\"#数字\" class=\"headerlink\" title=\"数字\"></a>数字</h3><p>和js一样，ts中的数字都是浮点数，类型为number.</p>\n<pre><code>let num: number = 6\n</code></pre><h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><pre><code>let str: string = &quot;26&quot;\n</code></pre><h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>有两种可以定义数组的方式</p>\n<pre><code>let list: number[] = [1, 2, 3]   // 表示由此类型元素组成的一个数组\n</code></pre><hr>\n<pre><code>let list: Array&lt;number&gt; = [1, 2, 3] // 使用数组泛型Array&lt;元素类型&gt;\n</code></pre><h3 id=\"元组-Tuple\"><a href=\"#元组-Tuple\" class=\"headerlink\" title=\"元组 Tuple\"></a>元组 Tuple</h3><p>元组类型表示允许一个已知元素数量和类型的数组，各元素的类型不必相同</p>\n<pre><code>let x: [string, number];\n\nx = [&#39;hello&#39;, 10];\n</code></pre><h3 id=\"枚举-enum\"><a href=\"#枚举-enum\" class=\"headerlink\" title=\"枚举 enum\"></a>枚举 enum</h3><p>类型是对JavaScript标准数据类型的一个补充</p>\n<pre><code>enum Color {Red, Green, Blue}\n\nlet c: Color = Color.Green;\n</code></pre><p>默认情况下，从0开始为元素编号。你也可以手动的指定成员的数值</p>\n<pre><code>enum Color {Red = 1, Green, Blue}\n\nlet c: Color = Color.Green;\n</code></pre><p>或者，全部都采用手动赋值：</p>\n<pre><code>enum Color {Red = 1, Green = 2, Blue = 4}\n\nlet c: Color = Color.Green;\n</code></pre><p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字</p>\n<pre><code>enum Color {Red = 1, Green, Blue}\n\nlet colorName: string = Color[2]; // Green\n</code></pre><h3 id=\"任意值-any\"><a href=\"#任意值-any\" class=\"headerlink\" title=\"任意值 any\"></a>任意值 any</h3><p>有的时候我们或许还不知到该变量到底该赋什么类型的值，比如对象</p>\n<pre><code>let notSure: any = 4;\n</code></pre><p>当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p>\n<pre><code>let list: any[] = [1, true, &quot;free&quot;];\n\nlist[1] = 100;\n</code></pre><h3 id=\"空值-void\"><a href=\"#空值-void\" class=\"headerlink\" title=\"空值 void\"></a>空值 void</h3><p>你可以理解为和any相反的类型，他表示没有任何类型</p>\n<pre><code>function warnUser(): void {\n    alert(&quot;This is my warning message&quot;);\n}\n</code></pre><p>在声明变量的时候，你只能赋予它undefined和null</p>\n<pre><code>let unusable: void = undefined;\n            ||或\nlet unusable: void = null;\n</code></pre><h3 id=\"Null-和-Undefined\"><a href=\"#Null-和-Undefined\" class=\"headerlink\" title=\"Null 和 Undefined\"></a>Null 和 Undefined</h3><p>undefined和null两者各自有自己的类型分别叫做undefined和null。 和void相似</p>\n<pre><code>let u: undefined = undefined;\n\nlet n: null = null;\n</code></pre><h3 id=\"Never\"><a href=\"#Never\" class=\"headerlink\" title=\"Never\"></a>Never</h3><p>never类型表示的是那些永不存在的值的类型。</p>\n<p><strong>返回never的函数必须存在无法达到的终点</strong></p>\n<pre><code>function infiniteLoop(): never {\n    while (true) {\n\n    }\n}\n</code></pre><h3 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h3><p>有的时候会或许更了解你的一些变量【两种写法】</p>\n<p><strong>尖括号</strong></p>\n<pre><code>let someValue: any = &quot;this is a string&quot;;\n\nlet strLength: number = (&lt;string&gt;someValue).length;\n</code></pre><p><strong>as语法</strong></p>\n<pre><code>let someValue: any = &quot;this is a string&quot;;\n\nlet strLength: number = (someValue as string).length;\n</code></pre><h3 id=\"！\"><a href=\"#！\" class=\"headerlink\" title=\"！\"></a>！</h3><p>表示非null的意思</p>\n<blockquote>\n<p>有时候获取的节点有可能为null，但是我们可以明确的使用ts表达自己的意向，明确自己想要的值</p>\n</blockquote>\n<pre><code>const a = document.getElementById(&#39;id&#39;)!\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ts的学习历程-–-01\"><a href=\"#ts的学习历程-–-01\" class=\"headerlink\" title=\"ts的学习历程 – 01\"></a>ts的学习历程 – 01</h2><h2 id=\"ts是什么？\"><a href=\"#ts是什么？\" class=\"headerlink\" title=\"ts是什么？\"></a>ts是什么？</h2><blockquote>\n<p>TypeScript 是 JavaScript 的一个超集，支持 ECMAScript 6 标准。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>TypeScript 由微软开发的自由和开源的编程语言。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>TypeScript 设计目标是开发大型应用，它可以编译成纯 JavaScript，编译出来的 JavaScript 可以运行在任何浏览器上。</p>\n</blockquote>\n<h2 id=\"语言特性\"><a href=\"#语言特性\" class=\"headerlink\" title=\"语言特性\"></a>语言特性</h2><h3 id=\"ts是一种给js添加特性的扩展性语言，扩展功能如下：\"><a href=\"#ts是一种给js添加特性的扩展性语言，扩展功能如下：\" class=\"headerlink\" title=\"ts是一种给js添加特性的扩展性语言，扩展功能如下：\"></a>ts是一种给js添加特性的扩展性语言，扩展功能如下：</h3><ul>\n<li>基础类型</li>\n<li>接口</li>\n<li>类</li>\n<li>函数</li>\n<li>泛型</li>\n<li>类型兼容性</li>\n<li>高级类型</li>\n<li>模块</li>\n<li>命名空间</li>\n<li>混入</li>\n</ul>\n<h2 id=\"基础类型\"><a href=\"#基础类型\" class=\"headerlink\" title=\"基础类型\"></a>基础类型</h2><h3 id=\"js是弱语言类型，而ts类似c-这种强语言，可以对变量进行处理，规定变量的类型，让程序变得可维护性强，有价值。\"><a href=\"#js是弱语言类型，而ts类似c-这种强语言，可以对变量进行处理，规定变量的类型，让程序变得可维护性强，有价值。\" class=\"headerlink\" title=\"js是弱语言类型，而ts类似c++这种强语言，可以对变量进行处理，规定变量的类型，让程序变得可维护性强，有价值。\"></a>js是弱语言类型，而ts类似c++这种强语言，可以对变量进行处理，规定变量的类型，让程序变得可维护性强，有价值。</h3><h3 id=\"布尔值\"><a href=\"#布尔值\" class=\"headerlink\" title=\"布尔值\"></a>布尔值</h3><p>我们可以在ts中进行如下声明：</p>\n<pre><code>let isDone: boolean = false\n</code></pre><h3 id=\"数字\"><a href=\"#数字\" class=\"headerlink\" title=\"数字\"></a>数字</h3><p>和js一样，ts中的数字都是浮点数，类型为number.</p>\n<pre><code>let num: number = 6\n</code></pre><h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><pre><code>let str: string = &quot;26&quot;\n</code></pre><h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>有两种可以定义数组的方式</p>\n<pre><code>let list: number[] = [1, 2, 3]   // 表示由此类型元素组成的一个数组\n</code></pre><hr>\n<pre><code>let list: Array&lt;number&gt; = [1, 2, 3] // 使用数组泛型Array&lt;元素类型&gt;\n</code></pre><h3 id=\"元组-Tuple\"><a href=\"#元组-Tuple\" class=\"headerlink\" title=\"元组 Tuple\"></a>元组 Tuple</h3><p>元组类型表示允许一个已知元素数量和类型的数组，各元素的类型不必相同</p>\n<pre><code>let x: [string, number];\n\nx = [&#39;hello&#39;, 10];\n</code></pre><h3 id=\"枚举-enum\"><a href=\"#枚举-enum\" class=\"headerlink\" title=\"枚举 enum\"></a>枚举 enum</h3><p>类型是对JavaScript标准数据类型的一个补充</p>\n<pre><code>enum Color {Red, Green, Blue}\n\nlet c: Color = Color.Green;\n</code></pre><p>默认情况下，从0开始为元素编号。你也可以手动的指定成员的数值</p>\n<pre><code>enum Color {Red = 1, Green, Blue}\n\nlet c: Color = Color.Green;\n</code></pre><p>或者，全部都采用手动赋值：</p>\n<pre><code>enum Color {Red = 1, Green = 2, Blue = 4}\n\nlet c: Color = Color.Green;\n</code></pre><p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字</p>\n<pre><code>enum Color {Red = 1, Green, Blue}\n\nlet colorName: string = Color[2]; // Green\n</code></pre><h3 id=\"任意值-any\"><a href=\"#任意值-any\" class=\"headerlink\" title=\"任意值 any\"></a>任意值 any</h3><p>有的时候我们或许还不知到该变量到底该赋什么类型的值，比如对象</p>\n<pre><code>let notSure: any = 4;\n</code></pre><p>当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p>\n<pre><code>let list: any[] = [1, true, &quot;free&quot;];\n\nlist[1] = 100;\n</code></pre><h3 id=\"空值-void\"><a href=\"#空值-void\" class=\"headerlink\" title=\"空值 void\"></a>空值 void</h3><p>你可以理解为和any相反的类型，他表示没有任何类型</p>\n<pre><code>function warnUser(): void {\n    alert(&quot;This is my warning message&quot;);\n}\n</code></pre><p>在声明变量的时候，你只能赋予它undefined和null</p>\n<pre><code>let unusable: void = undefined;\n            ||或\nlet unusable: void = null;\n</code></pre><h3 id=\"Null-和-Undefined\"><a href=\"#Null-和-Undefined\" class=\"headerlink\" title=\"Null 和 Undefined\"></a>Null 和 Undefined</h3><p>undefined和null两者各自有自己的类型分别叫做undefined和null。 和void相似</p>\n<pre><code>let u: undefined = undefined;\n\nlet n: null = null;\n</code></pre><h3 id=\"Never\"><a href=\"#Never\" class=\"headerlink\" title=\"Never\"></a>Never</h3><p>never类型表示的是那些永不存在的值的类型。</p>\n<p><strong>返回never的函数必须存在无法达到的终点</strong></p>\n<pre><code>function infiniteLoop(): never {\n    while (true) {\n\n    }\n}\n</code></pre><h3 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h3><p>有的时候会或许更了解你的一些变量【两种写法】</p>\n<p><strong>尖括号</strong></p>\n<pre><code>let someValue: any = &quot;this is a string&quot;;\n\nlet strLength: number = (&lt;string&gt;someValue).length;\n</code></pre><p><strong>as语法</strong></p>\n<pre><code>let someValue: any = &quot;this is a string&quot;;\n\nlet strLength: number = (someValue as string).length;\n</code></pre><h3 id=\"！\"><a href=\"#！\" class=\"headerlink\" title=\"！\"></a>！</h3><p>表示非null的意思</p>\n<blockquote>\n<p>有时候获取的节点有可能为null，但是我们可以明确的使用ts表达自己的意向，明确自己想要的值</p>\n</blockquote>\n<pre><code>const a = document.getElementById(&#39;id&#39;)!\n</code></pre>"},{"title":"ts的学习历程 -- 02","date":"2019-05-16T09:36:21.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"\n## ts的学习历程 -- 02\n\n## ts接口\n\n**ts的核心原则之一是对该值所对应的数据类型进行一个检测**\n\n> 作用：为你规定的这些类型命名，【签订契约】\n\n\t/**\n\t * 通过ts对函数的参数进行检测\n\t */\n\tfunction lable(lable: {lable: string}){\n\t  console.log(lable)\n\t}\n\t\n\tlet lables = {\n\t  lable: 'storing',\n\t  mine: 1\n\t}\n\t\n\tlable(lables)\n\n> 对参数lable进行检测，必须包括一个lable属性，并且值为string类型\n\n**使用接口进行描述**\n\n\tinterface lableV {\n\t  lable: string;\n\t}\n\tfunction lable(lable: lableV){\n\t  console.log(lable)\n\t}\n\t\n\tlet lables = {\n\t  lable: 'storing',\n\t  mine: 1\n\t}\n\t\n\tlable(lables)\n\n> lableV此接口就相当于一个名字，用来描述参数的要求【它代表了有一个label属性且类型为string的对象】\n\n## 可选属性\n\n> 接口里面的属性不全是必须的，根据页面需求，有些参数可传可不传：\n\n\tinterface lableV {\n\t  lable?: string;\n\t  mine?: number\n\t}\n\tfunction lable(lable: lableV){\n\t  console.log(lable)\n\t}\n\t\n\tlet lables = {\n\t  lable: 'storing',\n\t  mine: 1\n\t}\n\t\n\tlable(lables)\n\n## 只读属性\n\n**一些对象属性只能在对象创建的时候进行创建的时候修改他的值，你可以使用readonly指定只读属性**\n\n\tinterface lableV {\n\t  readonly a?: string;\n\t  readonly b?: number\n\t}\n\t\n\tlet str: lableV = {\n\t  a: '1',\n\t  b: 1\n\t}\n\t\n\tstr.a = 1  // 报错 。 Cannot assign to 'a' because it is a read-only property.ts(2540)\n\n> 确保创建完以后不能再修改\n\n\n> typeScript具有ReadonlyArray<T>类型，它与Array<T>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：\n\n\n\tlet a: number[] = [1, 2, 3, 4];\n\tlet ro: ReadonlyArray<number> = a;\n\tro[0] = 12; // error!         类型“readonly number[]”中的索引签名仅允许读取。ts(2542)\n\tro.push(5); // error!         类型“readonly number[]”上不存在属性“push”。ts(2339)\n\tro.length = 100; // error!    Cannot assign to 'length' because it is a read-only property.ts(2540)\n\ta = ro; // error!             Type 'readonly number[]' is missing the following properties from type 'number[]': pop, push, reverse, shift, and 6 more.ts(2740)\n\t\n\t    ||\n\t\n\t  //使用类型断言重写\n\ta = ro as number[];\n\n> 最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用const，若做为属性则使用readonly。\n\n\n## 额外的属性检测\n\n**当我们在传参的过程中，对于某个属性，写错的时候，如下**\n\n\tinterface lableV {\n\t    lable?: string;\n\t    mine?: number;\n\t    maxs: number;\n\t  }\n\t  function lable(lable: lableV){\n\t    console.log(lable)\n\t  }\n\t  \n\t  let lables = {\n\t    lable: 'storing',\n\t    mine: 1,\n\t    max: 20,\n\t    min: 10,\n\t    array: [1,2,3,5]\n\t  }\n\t  \n\t  lable(lables)\n\t\n\t  //类型“{ lable: string; mine: number; max: number; min: number; array: number[]; }”的参数不能赋给类型“lableV”的参数。\n\t  //Property 'maxs' is missing in type '{ lable: string; mine: number; max: number; min: number; array: number[]; }' but required in type 'lableV'.ts(2345)\n\t  //type.ts(50, 5): 'maxs' is declared here\n\n> 在js中没什么问题，如果传递的参数在函数中没有使用到，则可以正确执行，但是在ts中会认为这段代码存在bug，最佳的解决方法如下\n\n\tinterface SquareConfig {\n\t    color?: string;\n\t    width?: number;\n\t    [propName: string]: any;\n\t}\n\n## 函数类型\n\n**接口也可以用来描述函数类型**\n\n\tinterface SearchFunc {\n\t    (source: string, subString: string): boolean;\n\t}\n\n\n    let mySearch: SearchFunc;\n    mySearch = function(source: string, subString: string) {\n      let result = source.search(subString);\n      return result > -1;\n    }\n\n\t //不能将类型“(source: string, subString: string) => string”分配给类型“SearchFunc”。\n  \t //不能将类型“string”分配给类型“boolean”。ts(2322)\n\n> SearchFunc 该接口规定了函数的参数类型，以及该函数的返回值，如果与接口中定义的不匹配，则会出错\n\n## 可索引类型\n\n**接口可以描述那些能够通过索引得到的类型，可索引类型具有一个索引签名，它描述了对象索引的类型，还有相应的索引值类型，索引签名支持两种类型：number 和 string，但是由于 number 实际上会被转化为 string 类型（根据对象 key 的性质），所以需要遵守：number 索引的返回值类型是 string 索引的返回值类型的子类型。**\n\n\tinterface IPerson {\n\t    [index: string]: string;\n    }\n    let me: IPerson = {love: 'TS'}\n    me.name = 'funlee';\n    me.age = 18; // error 不能将类型“18”分配给类型“string”。ts(2322)\n\n> 如果 interface 里还声明了一个和索引签名索引返回值类型不匹配的属性，会报错\n\n\tinterface ITest {\n\t    [index: string]: string;\n\t    name: string;\n\t    age: 18; // 报错，因为返回值类型是number，不符合string类型  [类型“18”的属性“age”不能赋给字符串索引类型“string”。ts(2411)]\n\t }\n\n> 还可以声明一个 readonly 的索引签名\n\n\t  interface IPerson {\n\t    readonly [index: string]: string;\n\t  }\n\t  let p: IPerson = {name: 'funlee'};\n\t  p.love = 'TS'; // error   类型“IPerson”中的索引签名仅允许读取。ts(2542)\n\n## 类类型\n\n**typeScript也可以使用class来实现一个接口，只不过他描述得是类的公共部分，因此不会检查类是否具有某些私有成员**\n\n\tinterface ISome {\n\t  prop: string // 描述一个属性\n\t  method(paramA: string, paramB: number) // 描述一个方法\n\t}\n\tclass A implements ISome {\n\t  prop: 'propValue'\n\t  method(a: string, b: number) {\n\t    // ...\n\t  }\n\t  constructor(paramA: number){\n\t    // ...\n\t  }\n\t}\n\n## 继承接口\n\n**和类一样，接口也可以互相继承**\n\n\t\n\tinterface Shape {\n\t  color: string;\n\t}\n\tinterface Square extends Shape {\n\t  sideLength: number;\n\t}\n\tconst square = <Square>{};\n\tsquare.color = 'blue';\n\tsquare.sideLength = 10;\n\n**同时，一个接口也可以继承多个接口，创建出多个接口的合成接口，如：**\n\n\n\n\tinterface Shape {\n\t  color: string;\n\t}\n\tinterface PenStroke {\n\t  penWidth: number;\n\t}\n\tinterface Square extends Shape, PenStroke {\n\t  sideLength\n\t}\n\tconst square = <Square>{};\n\tsquare.color = 'blue';\n\tsquare.sideLength = 10;\n\tsquare.penWidth = 5.0;\n","source":"_posts/ts-02.md","raw":"---\ntitle: ts的学习历程 -- 02\ndate: '5/16/2019 5:36:21 PM '\ntag: ['ts']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n\n## ts的学习历程 -- 02\n\n## ts接口\n\n**ts的核心原则之一是对该值所对应的数据类型进行一个检测**\n\n> 作用：为你规定的这些类型命名，【签订契约】\n\n\t/**\n\t * 通过ts对函数的参数进行检测\n\t */\n\tfunction lable(lable: {lable: string}){\n\t  console.log(lable)\n\t}\n\t\n\tlet lables = {\n\t  lable: 'storing',\n\t  mine: 1\n\t}\n\t\n\tlable(lables)\n\n> 对参数lable进行检测，必须包括一个lable属性，并且值为string类型\n\n**使用接口进行描述**\n\n\tinterface lableV {\n\t  lable: string;\n\t}\n\tfunction lable(lable: lableV){\n\t  console.log(lable)\n\t}\n\t\n\tlet lables = {\n\t  lable: 'storing',\n\t  mine: 1\n\t}\n\t\n\tlable(lables)\n\n> lableV此接口就相当于一个名字，用来描述参数的要求【它代表了有一个label属性且类型为string的对象】\n\n## 可选属性\n\n> 接口里面的属性不全是必须的，根据页面需求，有些参数可传可不传：\n\n\tinterface lableV {\n\t  lable?: string;\n\t  mine?: number\n\t}\n\tfunction lable(lable: lableV){\n\t  console.log(lable)\n\t}\n\t\n\tlet lables = {\n\t  lable: 'storing',\n\t  mine: 1\n\t}\n\t\n\tlable(lables)\n\n## 只读属性\n\n**一些对象属性只能在对象创建的时候进行创建的时候修改他的值，你可以使用readonly指定只读属性**\n\n\tinterface lableV {\n\t  readonly a?: string;\n\t  readonly b?: number\n\t}\n\t\n\tlet str: lableV = {\n\t  a: '1',\n\t  b: 1\n\t}\n\t\n\tstr.a = 1  // 报错 。 Cannot assign to 'a' because it is a read-only property.ts(2540)\n\n> 确保创建完以后不能再修改\n\n\n> typeScript具有ReadonlyArray<T>类型，它与Array<T>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：\n\n\n\tlet a: number[] = [1, 2, 3, 4];\n\tlet ro: ReadonlyArray<number> = a;\n\tro[0] = 12; // error!         类型“readonly number[]”中的索引签名仅允许读取。ts(2542)\n\tro.push(5); // error!         类型“readonly number[]”上不存在属性“push”。ts(2339)\n\tro.length = 100; // error!    Cannot assign to 'length' because it is a read-only property.ts(2540)\n\ta = ro; // error!             Type 'readonly number[]' is missing the following properties from type 'number[]': pop, push, reverse, shift, and 6 more.ts(2740)\n\t\n\t    ||\n\t\n\t  //使用类型断言重写\n\ta = ro as number[];\n\n> 最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用const，若做为属性则使用readonly。\n\n\n## 额外的属性检测\n\n**当我们在传参的过程中，对于某个属性，写错的时候，如下**\n\n\tinterface lableV {\n\t    lable?: string;\n\t    mine?: number;\n\t    maxs: number;\n\t  }\n\t  function lable(lable: lableV){\n\t    console.log(lable)\n\t  }\n\t  \n\t  let lables = {\n\t    lable: 'storing',\n\t    mine: 1,\n\t    max: 20,\n\t    min: 10,\n\t    array: [1,2,3,5]\n\t  }\n\t  \n\t  lable(lables)\n\t\n\t  //类型“{ lable: string; mine: number; max: number; min: number; array: number[]; }”的参数不能赋给类型“lableV”的参数。\n\t  //Property 'maxs' is missing in type '{ lable: string; mine: number; max: number; min: number; array: number[]; }' but required in type 'lableV'.ts(2345)\n\t  //type.ts(50, 5): 'maxs' is declared here\n\n> 在js中没什么问题，如果传递的参数在函数中没有使用到，则可以正确执行，但是在ts中会认为这段代码存在bug，最佳的解决方法如下\n\n\tinterface SquareConfig {\n\t    color?: string;\n\t    width?: number;\n\t    [propName: string]: any;\n\t}\n\n## 函数类型\n\n**接口也可以用来描述函数类型**\n\n\tinterface SearchFunc {\n\t    (source: string, subString: string): boolean;\n\t}\n\n\n    let mySearch: SearchFunc;\n    mySearch = function(source: string, subString: string) {\n      let result = source.search(subString);\n      return result > -1;\n    }\n\n\t //不能将类型“(source: string, subString: string) => string”分配给类型“SearchFunc”。\n  \t //不能将类型“string”分配给类型“boolean”。ts(2322)\n\n> SearchFunc 该接口规定了函数的参数类型，以及该函数的返回值，如果与接口中定义的不匹配，则会出错\n\n## 可索引类型\n\n**接口可以描述那些能够通过索引得到的类型，可索引类型具有一个索引签名，它描述了对象索引的类型，还有相应的索引值类型，索引签名支持两种类型：number 和 string，但是由于 number 实际上会被转化为 string 类型（根据对象 key 的性质），所以需要遵守：number 索引的返回值类型是 string 索引的返回值类型的子类型。**\n\n\tinterface IPerson {\n\t    [index: string]: string;\n    }\n    let me: IPerson = {love: 'TS'}\n    me.name = 'funlee';\n    me.age = 18; // error 不能将类型“18”分配给类型“string”。ts(2322)\n\n> 如果 interface 里还声明了一个和索引签名索引返回值类型不匹配的属性，会报错\n\n\tinterface ITest {\n\t    [index: string]: string;\n\t    name: string;\n\t    age: 18; // 报错，因为返回值类型是number，不符合string类型  [类型“18”的属性“age”不能赋给字符串索引类型“string”。ts(2411)]\n\t }\n\n> 还可以声明一个 readonly 的索引签名\n\n\t  interface IPerson {\n\t    readonly [index: string]: string;\n\t  }\n\t  let p: IPerson = {name: 'funlee'};\n\t  p.love = 'TS'; // error   类型“IPerson”中的索引签名仅允许读取。ts(2542)\n\n## 类类型\n\n**typeScript也可以使用class来实现一个接口，只不过他描述得是类的公共部分，因此不会检查类是否具有某些私有成员**\n\n\tinterface ISome {\n\t  prop: string // 描述一个属性\n\t  method(paramA: string, paramB: number) // 描述一个方法\n\t}\n\tclass A implements ISome {\n\t  prop: 'propValue'\n\t  method(a: string, b: number) {\n\t    // ...\n\t  }\n\t  constructor(paramA: number){\n\t    // ...\n\t  }\n\t}\n\n## 继承接口\n\n**和类一样，接口也可以互相继承**\n\n\t\n\tinterface Shape {\n\t  color: string;\n\t}\n\tinterface Square extends Shape {\n\t  sideLength: number;\n\t}\n\tconst square = <Square>{};\n\tsquare.color = 'blue';\n\tsquare.sideLength = 10;\n\n**同时，一个接口也可以继承多个接口，创建出多个接口的合成接口，如：**\n\n\n\n\tinterface Shape {\n\t  color: string;\n\t}\n\tinterface PenStroke {\n\t  penWidth: number;\n\t}\n\tinterface Square extends Shape, PenStroke {\n\t  sideLength\n\t}\n\tconst square = <Square>{};\n\tsquare.color = 'blue';\n\tsquare.sideLength = 10;\n\tsquare.penWidth = 5.0;\n","slug":"ts-02","published":1,"updated":"2019-05-16T09:36:47.159Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam7q002en4wdfvc7runm","content":"<h2 id=\"ts的学习历程-–-02\"><a href=\"#ts的学习历程-–-02\" class=\"headerlink\" title=\"ts的学习历程 – 02\"></a>ts的学习历程 – 02</h2><h2 id=\"ts接口\"><a href=\"#ts接口\" class=\"headerlink\" title=\"ts接口\"></a>ts接口</h2><p><strong>ts的核心原则之一是对该值所对应的数据类型进行一个检测</strong></p>\n<blockquote>\n<p>作用：为你规定的这些类型命名，【签订契约】</p>\n</blockquote>\n<pre><code>/**\n * 通过ts对函数的参数进行检测\n */\nfunction lable(lable: {lable: string}){\n  console.log(lable)\n}\n\nlet lables = {\n  lable: &#39;storing&#39;,\n  mine: 1\n}\n\nlable(lables)\n</code></pre><blockquote>\n<p>对参数lable进行检测，必须包括一个lable属性，并且值为string类型</p>\n</blockquote>\n<p><strong>使用接口进行描述</strong></p>\n<pre><code>interface lableV {\n  lable: string;\n}\nfunction lable(lable: lableV){\n  console.log(lable)\n}\n\nlet lables = {\n  lable: &#39;storing&#39;,\n  mine: 1\n}\n\nlable(lables)\n</code></pre><blockquote>\n<p>lableV此接口就相当于一个名字，用来描述参数的要求【它代表了有一个label属性且类型为string的对象】</p>\n</blockquote>\n<h2 id=\"可选属性\"><a href=\"#可选属性\" class=\"headerlink\" title=\"可选属性\"></a>可选属性</h2><blockquote>\n<p>接口里面的属性不全是必须的，根据页面需求，有些参数可传可不传：</p>\n</blockquote>\n<pre><code>interface lableV {\n  lable?: string;\n  mine?: number\n}\nfunction lable(lable: lableV){\n  console.log(lable)\n}\n\nlet lables = {\n  lable: &#39;storing&#39;,\n  mine: 1\n}\n\nlable(lables)\n</code></pre><h2 id=\"只读属性\"><a href=\"#只读属性\" class=\"headerlink\" title=\"只读属性\"></a>只读属性</h2><p><strong>一些对象属性只能在对象创建的时候进行创建的时候修改他的值，你可以使用readonly指定只读属性</strong></p>\n<pre><code>interface lableV {\n  readonly a?: string;\n  readonly b?: number\n}\n\nlet str: lableV = {\n  a: &#39;1&#39;,\n  b: 1\n}\n\nstr.a = 1  // 报错 。 Cannot assign to &#39;a&#39; because it is a read-only property.ts(2540)\n</code></pre><blockquote>\n<p>确保创建完以后不能再修改</p>\n</blockquote>\n<blockquote>\n<p>typeScript具有ReadonlyArray<t>类型，它与Array<t>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</t></t></p>\n</blockquote>\n<pre><code>let a: number[] = [1, 2, 3, 4];\nlet ro: ReadonlyArray&lt;number&gt; = a;\nro[0] = 12; // error!         类型“readonly number[]”中的索引签名仅允许读取。ts(2542)\nro.push(5); // error!         类型“readonly number[]”上不存在属性“push”。ts(2339)\nro.length = 100; // error!    Cannot assign to &#39;length&#39; because it is a read-only property.ts(2540)\na = ro; // error!             Type &#39;readonly number[]&#39; is missing the following properties from type &#39;number[]&#39;: pop, push, reverse, shift, and 6 more.ts(2740)\n\n    ||\n\n  //使用类型断言重写\na = ro as number[];\n</code></pre><blockquote>\n<p>最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用const，若做为属性则使用readonly。</p>\n</blockquote>\n<h2 id=\"额外的属性检测\"><a href=\"#额外的属性检测\" class=\"headerlink\" title=\"额外的属性检测\"></a>额外的属性检测</h2><p><strong>当我们在传参的过程中，对于某个属性，写错的时候，如下</strong></p>\n<pre><code>interface lableV {\n    lable?: string;\n    mine?: number;\n    maxs: number;\n  }\n  function lable(lable: lableV){\n    console.log(lable)\n  }\n\n  let lables = {\n    lable: &#39;storing&#39;,\n    mine: 1,\n    max: 20,\n    min: 10,\n    array: [1,2,3,5]\n  }\n\n  lable(lables)\n\n  //类型“{ lable: string; mine: number; max: number; min: number; array: number[]; }”的参数不能赋给类型“lableV”的参数。\n  //Property &#39;maxs&#39; is missing in type &#39;{ lable: string; mine: number; max: number; min: number; array: number[]; }&#39; but required in type &#39;lableV&#39;.ts(2345)\n  //type.ts(50, 5): &#39;maxs&#39; is declared here\n</code></pre><blockquote>\n<p>在js中没什么问题，如果传递的参数在函数中没有使用到，则可以正确执行，但是在ts中会认为这段代码存在bug，最佳的解决方法如下</p>\n</blockquote>\n<pre><code>interface SquareConfig {\n    color?: string;\n    width?: number;\n    [propName: string]: any;\n}\n</code></pre><h2 id=\"函数类型\"><a href=\"#函数类型\" class=\"headerlink\" title=\"函数类型\"></a>函数类型</h2><p><strong>接口也可以用来描述函数类型</strong></p>\n<pre><code>interface SearchFunc {\n    (source: string, subString: string): boolean;\n}\n\n\nlet mySearch: SearchFunc;\nmySearch = function(source: string, subString: string) {\n  let result = source.search(subString);\n  return result &gt; -1;\n}\n\n //不能将类型“(source: string, subString: string) =&gt; string”分配给类型“SearchFunc”。\n   //不能将类型“string”分配给类型“boolean”。ts(2322)\n</code></pre><blockquote>\n<p>SearchFunc 该接口规定了函数的参数类型，以及该函数的返回值，如果与接口中定义的不匹配，则会出错</p>\n</blockquote>\n<h2 id=\"可索引类型\"><a href=\"#可索引类型\" class=\"headerlink\" title=\"可索引类型\"></a>可索引类型</h2><p><strong>接口可以描述那些能够通过索引得到的类型，可索引类型具有一个索引签名，它描述了对象索引的类型，还有相应的索引值类型，索引签名支持两种类型：number 和 string，但是由于 number 实际上会被转化为 string 类型（根据对象 key 的性质），所以需要遵守：number 索引的返回值类型是 string 索引的返回值类型的子类型。</strong></p>\n<pre><code>interface IPerson {\n    [index: string]: string;\n}\nlet me: IPerson = {love: &#39;TS&#39;}\nme.name = &#39;funlee&#39;;\nme.age = 18; // error 不能将类型“18”分配给类型“string”。ts(2322)\n</code></pre><blockquote>\n<p>如果 interface 里还声明了一个和索引签名索引返回值类型不匹配的属性，会报错</p>\n</blockquote>\n<pre><code>interface ITest {\n    [index: string]: string;\n    name: string;\n    age: 18; // 报错，因为返回值类型是number，不符合string类型  [类型“18”的属性“age”不能赋给字符串索引类型“string”。ts(2411)]\n }\n</code></pre><blockquote>\n<p>还可以声明一个 readonly 的索引签名</p>\n</blockquote>\n<pre><code>  interface IPerson {\n    readonly [index: string]: string;\n  }\n  let p: IPerson = {name: &#39;funlee&#39;};\n  p.love = &#39;TS&#39;; // error   类型“IPerson”中的索引签名仅允许读取。ts(2542)\n</code></pre><h2 id=\"类类型\"><a href=\"#类类型\" class=\"headerlink\" title=\"类类型\"></a>类类型</h2><p><strong>typeScript也可以使用class来实现一个接口，只不过他描述得是类的公共部分，因此不会检查类是否具有某些私有成员</strong></p>\n<pre><code>interface ISome {\n  prop: string // 描述一个属性\n  method(paramA: string, paramB: number) // 描述一个方法\n}\nclass A implements ISome {\n  prop: &#39;propValue&#39;\n  method(a: string, b: number) {\n    // ...\n  }\n  constructor(paramA: number){\n    // ...\n  }\n}\n</code></pre><h2 id=\"继承接口\"><a href=\"#继承接口\" class=\"headerlink\" title=\"继承接口\"></a>继承接口</h2><p><strong>和类一样，接口也可以互相继承</strong></p>\n<pre><code>interface Shape {\n  color: string;\n}\ninterface Square extends Shape {\n  sideLength: number;\n}\nconst square = &lt;Square&gt;{};\nsquare.color = &#39;blue&#39;;\nsquare.sideLength = 10;\n</code></pre><p><strong>同时，一个接口也可以继承多个接口，创建出多个接口的合成接口，如：</strong></p>\n<pre><code>interface Shape {\n  color: string;\n}\ninterface PenStroke {\n  penWidth: number;\n}\ninterface Square extends Shape, PenStroke {\n  sideLength\n}\nconst square = &lt;Square&gt;{};\nsquare.color = &#39;blue&#39;;\nsquare.sideLength = 10;\nsquare.penWidth = 5.0;\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ts的学习历程-–-02\"><a href=\"#ts的学习历程-–-02\" class=\"headerlink\" title=\"ts的学习历程 – 02\"></a>ts的学习历程 – 02</h2><h2 id=\"ts接口\"><a href=\"#ts接口\" class=\"headerlink\" title=\"ts接口\"></a>ts接口</h2><p><strong>ts的核心原则之一是对该值所对应的数据类型进行一个检测</strong></p>\n<blockquote>\n<p>作用：为你规定的这些类型命名，【签订契约】</p>\n</blockquote>\n<pre><code>/**\n * 通过ts对函数的参数进行检测\n */\nfunction lable(lable: {lable: string}){\n  console.log(lable)\n}\n\nlet lables = {\n  lable: &#39;storing&#39;,\n  mine: 1\n}\n\nlable(lables)\n</code></pre><blockquote>\n<p>对参数lable进行检测，必须包括一个lable属性，并且值为string类型</p>\n</blockquote>\n<p><strong>使用接口进行描述</strong></p>\n<pre><code>interface lableV {\n  lable: string;\n}\nfunction lable(lable: lableV){\n  console.log(lable)\n}\n\nlet lables = {\n  lable: &#39;storing&#39;,\n  mine: 1\n}\n\nlable(lables)\n</code></pre><blockquote>\n<p>lableV此接口就相当于一个名字，用来描述参数的要求【它代表了有一个label属性且类型为string的对象】</p>\n</blockquote>\n<h2 id=\"可选属性\"><a href=\"#可选属性\" class=\"headerlink\" title=\"可选属性\"></a>可选属性</h2><blockquote>\n<p>接口里面的属性不全是必须的，根据页面需求，有些参数可传可不传：</p>\n</blockquote>\n<pre><code>interface lableV {\n  lable?: string;\n  mine?: number\n}\nfunction lable(lable: lableV){\n  console.log(lable)\n}\n\nlet lables = {\n  lable: &#39;storing&#39;,\n  mine: 1\n}\n\nlable(lables)\n</code></pre><h2 id=\"只读属性\"><a href=\"#只读属性\" class=\"headerlink\" title=\"只读属性\"></a>只读属性</h2><p><strong>一些对象属性只能在对象创建的时候进行创建的时候修改他的值，你可以使用readonly指定只读属性</strong></p>\n<pre><code>interface lableV {\n  readonly a?: string;\n  readonly b?: number\n}\n\nlet str: lableV = {\n  a: &#39;1&#39;,\n  b: 1\n}\n\nstr.a = 1  // 报错 。 Cannot assign to &#39;a&#39; because it is a read-only property.ts(2540)\n</code></pre><blockquote>\n<p>确保创建完以后不能再修改</p>\n</blockquote>\n<blockquote>\n<p>typeScript具有ReadonlyArray<t>类型，它与Array<t>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</t></t></p>\n</blockquote>\n<pre><code>let a: number[] = [1, 2, 3, 4];\nlet ro: ReadonlyArray&lt;number&gt; = a;\nro[0] = 12; // error!         类型“readonly number[]”中的索引签名仅允许读取。ts(2542)\nro.push(5); // error!         类型“readonly number[]”上不存在属性“push”。ts(2339)\nro.length = 100; // error!    Cannot assign to &#39;length&#39; because it is a read-only property.ts(2540)\na = ro; // error!             Type &#39;readonly number[]&#39; is missing the following properties from type &#39;number[]&#39;: pop, push, reverse, shift, and 6 more.ts(2740)\n\n    ||\n\n  //使用类型断言重写\na = ro as number[];\n</code></pre><blockquote>\n<p>最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用const，若做为属性则使用readonly。</p>\n</blockquote>\n<h2 id=\"额外的属性检测\"><a href=\"#额外的属性检测\" class=\"headerlink\" title=\"额外的属性检测\"></a>额外的属性检测</h2><p><strong>当我们在传参的过程中，对于某个属性，写错的时候，如下</strong></p>\n<pre><code>interface lableV {\n    lable?: string;\n    mine?: number;\n    maxs: number;\n  }\n  function lable(lable: lableV){\n    console.log(lable)\n  }\n\n  let lables = {\n    lable: &#39;storing&#39;,\n    mine: 1,\n    max: 20,\n    min: 10,\n    array: [1,2,3,5]\n  }\n\n  lable(lables)\n\n  //类型“{ lable: string; mine: number; max: number; min: number; array: number[]; }”的参数不能赋给类型“lableV”的参数。\n  //Property &#39;maxs&#39; is missing in type &#39;{ lable: string; mine: number; max: number; min: number; array: number[]; }&#39; but required in type &#39;lableV&#39;.ts(2345)\n  //type.ts(50, 5): &#39;maxs&#39; is declared here\n</code></pre><blockquote>\n<p>在js中没什么问题，如果传递的参数在函数中没有使用到，则可以正确执行，但是在ts中会认为这段代码存在bug，最佳的解决方法如下</p>\n</blockquote>\n<pre><code>interface SquareConfig {\n    color?: string;\n    width?: number;\n    [propName: string]: any;\n}\n</code></pre><h2 id=\"函数类型\"><a href=\"#函数类型\" class=\"headerlink\" title=\"函数类型\"></a>函数类型</h2><p><strong>接口也可以用来描述函数类型</strong></p>\n<pre><code>interface SearchFunc {\n    (source: string, subString: string): boolean;\n}\n\n\nlet mySearch: SearchFunc;\nmySearch = function(source: string, subString: string) {\n  let result = source.search(subString);\n  return result &gt; -1;\n}\n\n //不能将类型“(source: string, subString: string) =&gt; string”分配给类型“SearchFunc”。\n   //不能将类型“string”分配给类型“boolean”。ts(2322)\n</code></pre><blockquote>\n<p>SearchFunc 该接口规定了函数的参数类型，以及该函数的返回值，如果与接口中定义的不匹配，则会出错</p>\n</blockquote>\n<h2 id=\"可索引类型\"><a href=\"#可索引类型\" class=\"headerlink\" title=\"可索引类型\"></a>可索引类型</h2><p><strong>接口可以描述那些能够通过索引得到的类型，可索引类型具有一个索引签名，它描述了对象索引的类型，还有相应的索引值类型，索引签名支持两种类型：number 和 string，但是由于 number 实际上会被转化为 string 类型（根据对象 key 的性质），所以需要遵守：number 索引的返回值类型是 string 索引的返回值类型的子类型。</strong></p>\n<pre><code>interface IPerson {\n    [index: string]: string;\n}\nlet me: IPerson = {love: &#39;TS&#39;}\nme.name = &#39;funlee&#39;;\nme.age = 18; // error 不能将类型“18”分配给类型“string”。ts(2322)\n</code></pre><blockquote>\n<p>如果 interface 里还声明了一个和索引签名索引返回值类型不匹配的属性，会报错</p>\n</blockquote>\n<pre><code>interface ITest {\n    [index: string]: string;\n    name: string;\n    age: 18; // 报错，因为返回值类型是number，不符合string类型  [类型“18”的属性“age”不能赋给字符串索引类型“string”。ts(2411)]\n }\n</code></pre><blockquote>\n<p>还可以声明一个 readonly 的索引签名</p>\n</blockquote>\n<pre><code>  interface IPerson {\n    readonly [index: string]: string;\n  }\n  let p: IPerson = {name: &#39;funlee&#39;};\n  p.love = &#39;TS&#39;; // error   类型“IPerson”中的索引签名仅允许读取。ts(2542)\n</code></pre><h2 id=\"类类型\"><a href=\"#类类型\" class=\"headerlink\" title=\"类类型\"></a>类类型</h2><p><strong>typeScript也可以使用class来实现一个接口，只不过他描述得是类的公共部分，因此不会检查类是否具有某些私有成员</strong></p>\n<pre><code>interface ISome {\n  prop: string // 描述一个属性\n  method(paramA: string, paramB: number) // 描述一个方法\n}\nclass A implements ISome {\n  prop: &#39;propValue&#39;\n  method(a: string, b: number) {\n    // ...\n  }\n  constructor(paramA: number){\n    // ...\n  }\n}\n</code></pre><h2 id=\"继承接口\"><a href=\"#继承接口\" class=\"headerlink\" title=\"继承接口\"></a>继承接口</h2><p><strong>和类一样，接口也可以互相继承</strong></p>\n<pre><code>interface Shape {\n  color: string;\n}\ninterface Square extends Shape {\n  sideLength: number;\n}\nconst square = &lt;Square&gt;{};\nsquare.color = &#39;blue&#39;;\nsquare.sideLength = 10;\n</code></pre><p><strong>同时，一个接口也可以继承多个接口，创建出多个接口的合成接口，如：</strong></p>\n<pre><code>interface Shape {\n  color: string;\n}\ninterface PenStroke {\n  penWidth: number;\n}\ninterface Square extends Shape, PenStroke {\n  sideLength\n}\nconst square = &lt;Square&gt;{};\nsquare.color = &#39;blue&#39;;\nsquare.sideLength = 10;\nsquare.penWidth = 5.0;\n</code></pre>"},{"title":"关于Vue全局的扩展","date":"2019-01-28T12:03:34.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"\n# 关于Vue全局的扩展\n\n----------\n\n\n## Vue的全局组件\n\n### 我们平时使用组件，需要经过引入，绑定两个步骤。那么，如果我们需要使用一些全局组件或者第三方的组件库怎么办呢？\n\n#### 在Vue官方文档中介绍的是使用Vue.component(tagName, options)来创建一个全局组件。但是这种方法是与根实例写在同一个文件中，如果要同时注册多个全局组件，就会使根实例文件过重，因此使用Vue.use()来“安装”全局组件，就显得更轻一些。 \n\n#### 方法：\n\n- 1.新建一个plugins文件夹 \n- 2.在文件夹中创建放置全局组件的文件components.js \n- 3.在components.js文件中引入所有要注册的全局组件 \n- 4.在app.js根实例文件中，引入components.js\n\n### 以login组件为例\n\n### login.js\n\n    import Login from '../components/eg.vue';\n\texport default (Vue)=>{\n    \tVue.component(\"Login\",Login);\n\t}\n\n\n### app.js\n\n    import components from './plugins/components.js';\n\tVue.use(components);\n\n### 经过上述编写后，就注册了全局组件Login。\n\n## Vue全局指令\n\n### 对于全局指令的注册，官方文档给出的方法是使用Vue.directive()，位置同样是在根实例文件下，那么问题来了，如果多个全局指令，再加上多个全局组件，那么app.js文件将变得臃肿无比。 \n#### 因此，同上面的注册全局组件方法相似，也是使用Vue.use()来“安装”全局指令。 \n\n#### 方法：\n- 1.新建一个plugins文件夹 \n- 2.在文件夹中创建放置全局组件的文件directives.js \n- 3.在directives.js文件中引入所有要注册的全局指令 \n- 4.在app.js根实例文件中，引入directives.js\n\n#### 以v-focus指令为例： \n#### directives.js:\n\t    export default (Vue)=>{\n\t\t    Vue.directive(\"focus\",{\n\t\t        inserted:function(el){\n\t\t            el.focus();\n\t\t        }\n\t\t    })\n\t\t}\n\n#### app.js\n\n    import directives from \"./plugins/directives.js\"\n\tVue.use(directives);\n\n### 这样就注册了全局指令\n\n## 扩展Vue类方法\n\n### 很简单再此不做更多描述.....\n\n#### 直接看代码。》 。\n\n    Vue.coke = function () {\n\t\tconsole.log(\"扩展了coke类方法\")\n\t}\n\n### 简单吧！！！！！\n\n## 扩展Vue原型，在vue组件中就可以通过this来访问\n\n### 废话不多说上代码\n\n\tVue.prototype.$api = function () {\n\t\tconsole.log(\"扩展了$api方法\")\n\t}\n\n### ...................\n\n## Vue过滤器\n\n### Vue.js允许自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和v-bind表达式。过滤器应该被添加在JavaScript表达式的尾部，由“管道”符号指示：|\n    <!-- 在双花括号中 -->\n\t{{ message | capitalize }}\n\t\n\t<!-- 在 `v-bind` 中 -->\n\t<div v-bind:id=\"rawId | formatId\"></div>\n\n### 可以在一个组件的选项中定义本地的过滤器：\n\n### 以截取手机为例\n\n\tfilters: {\n\t  \tphones (num) {\n\t\t\tlet phoneStr = num.toString()\n\t\t\tlet res = /(\\d{1,})(\\d{4})/\n\t\t\twhile (reg.test(phoneStr.replace)) {\n\t\t\t\tphoneStr = phoneStr.replace(reg, '$1-$2')\n\t\t\t}\n\t\t\treturn phoneStr\n\t\t}\n\t}\n\n\n\t//调用\n\n\t{{17603446842 | phones}}\n\n\t//返回结果\n\n\t176-0344-6842\n\n### 全局过滤器\n\n\tVue.filter(\"phones\",function(num){\n\t  \tlet phoneStr = num.toString()\n\t\tlet res = /(\\d{1,})(\\d{4})/\n\t\twhile (reg.test(phoneStr.replace)) {\n\t\t\tphoneStr = phoneStr.replace(reg, '$1-$2')\n\t\t}\n\t\treturn phoneStr\n\t})\n\n### 来吧，举一个实用一点的例子\n\n### 上代码\n\n\tvar app5 = new Vue({\n    \tel: '#app5',\n\t    data: {\n\t        shoppingList: [\n\t            \"Milk\", \"Donuts\", \"Cookies\", \"Chocolate\", \"Peanut Butter\", \"Pepto Bismol\", \"Pepto Bismol (Chocolate flavor)\", \"Pepto Bismol (Cookie flavor)\"\n\t        ],\n\t        key: \"\"\n\t    },\n\t    computed: {\n\t        filterShoppingList: function () {\n\t            // `this` points to the vm instance\n\t            var key = this.key;\n\t            var shoppingList = this.shoppingList;\n\t            //在使用filter时需要注意的是，前面调用的是需要使用filter的数组，而给filter函数传入的是数组中的每个item，也就是说filter里面的函数，是每个item要去做的，并将每个结果返回。\n\t            return shoppingList.filter(function (item) {\n\t                return item.toLowerCase().indexOf(key.toLowerCase()) != -1\n\t            });;\n        \t}\n    \t}\n\t})\n\n### template\n\n\t\t<ul>\n\t\t    Filter Key\n\t\t\t<input type=\"text\" v-model=\"key\">   \n\t       \t<li v-for=\"item in filterShoppingList\">\n\t           {{ item }}\n\t       \t</li>\n   \t\t</ul> \n\n### 最终效果实现了根据关键字来过滤列表的功能。   \n\n     \t","source":"_posts/vue block.md","raw":"---\ntitle: 关于Vue全局的扩展\ndate: '1/28/2019 8:03:34 PM '\ntag: ['vue全局组件', 'vue', 'vue指令', 'vue过滤器','directive']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n\n# 关于Vue全局的扩展\n\n----------\n\n\n## Vue的全局组件\n\n### 我们平时使用组件，需要经过引入，绑定两个步骤。那么，如果我们需要使用一些全局组件或者第三方的组件库怎么办呢？\n\n#### 在Vue官方文档中介绍的是使用Vue.component(tagName, options)来创建一个全局组件。但是这种方法是与根实例写在同一个文件中，如果要同时注册多个全局组件，就会使根实例文件过重，因此使用Vue.use()来“安装”全局组件，就显得更轻一些。 \n\n#### 方法：\n\n- 1.新建一个plugins文件夹 \n- 2.在文件夹中创建放置全局组件的文件components.js \n- 3.在components.js文件中引入所有要注册的全局组件 \n- 4.在app.js根实例文件中，引入components.js\n\n### 以login组件为例\n\n### login.js\n\n    import Login from '../components/eg.vue';\n\texport default (Vue)=>{\n    \tVue.component(\"Login\",Login);\n\t}\n\n\n### app.js\n\n    import components from './plugins/components.js';\n\tVue.use(components);\n\n### 经过上述编写后，就注册了全局组件Login。\n\n## Vue全局指令\n\n### 对于全局指令的注册，官方文档给出的方法是使用Vue.directive()，位置同样是在根实例文件下，那么问题来了，如果多个全局指令，再加上多个全局组件，那么app.js文件将变得臃肿无比。 \n#### 因此，同上面的注册全局组件方法相似，也是使用Vue.use()来“安装”全局指令。 \n\n#### 方法：\n- 1.新建一个plugins文件夹 \n- 2.在文件夹中创建放置全局组件的文件directives.js \n- 3.在directives.js文件中引入所有要注册的全局指令 \n- 4.在app.js根实例文件中，引入directives.js\n\n#### 以v-focus指令为例： \n#### directives.js:\n\t    export default (Vue)=>{\n\t\t    Vue.directive(\"focus\",{\n\t\t        inserted:function(el){\n\t\t            el.focus();\n\t\t        }\n\t\t    })\n\t\t}\n\n#### app.js\n\n    import directives from \"./plugins/directives.js\"\n\tVue.use(directives);\n\n### 这样就注册了全局指令\n\n## 扩展Vue类方法\n\n### 很简单再此不做更多描述.....\n\n#### 直接看代码。》 。\n\n    Vue.coke = function () {\n\t\tconsole.log(\"扩展了coke类方法\")\n\t}\n\n### 简单吧！！！！！\n\n## 扩展Vue原型，在vue组件中就可以通过this来访问\n\n### 废话不多说上代码\n\n\tVue.prototype.$api = function () {\n\t\tconsole.log(\"扩展了$api方法\")\n\t}\n\n### ...................\n\n## Vue过滤器\n\n### Vue.js允许自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和v-bind表达式。过滤器应该被添加在JavaScript表达式的尾部，由“管道”符号指示：|\n    <!-- 在双花括号中 -->\n\t{{ message | capitalize }}\n\t\n\t<!-- 在 `v-bind` 中 -->\n\t<div v-bind:id=\"rawId | formatId\"></div>\n\n### 可以在一个组件的选项中定义本地的过滤器：\n\n### 以截取手机为例\n\n\tfilters: {\n\t  \tphones (num) {\n\t\t\tlet phoneStr = num.toString()\n\t\t\tlet res = /(\\d{1,})(\\d{4})/\n\t\t\twhile (reg.test(phoneStr.replace)) {\n\t\t\t\tphoneStr = phoneStr.replace(reg, '$1-$2')\n\t\t\t}\n\t\t\treturn phoneStr\n\t\t}\n\t}\n\n\n\t//调用\n\n\t{{17603446842 | phones}}\n\n\t//返回结果\n\n\t176-0344-6842\n\n### 全局过滤器\n\n\tVue.filter(\"phones\",function(num){\n\t  \tlet phoneStr = num.toString()\n\t\tlet res = /(\\d{1,})(\\d{4})/\n\t\twhile (reg.test(phoneStr.replace)) {\n\t\t\tphoneStr = phoneStr.replace(reg, '$1-$2')\n\t\t}\n\t\treturn phoneStr\n\t})\n\n### 来吧，举一个实用一点的例子\n\n### 上代码\n\n\tvar app5 = new Vue({\n    \tel: '#app5',\n\t    data: {\n\t        shoppingList: [\n\t            \"Milk\", \"Donuts\", \"Cookies\", \"Chocolate\", \"Peanut Butter\", \"Pepto Bismol\", \"Pepto Bismol (Chocolate flavor)\", \"Pepto Bismol (Cookie flavor)\"\n\t        ],\n\t        key: \"\"\n\t    },\n\t    computed: {\n\t        filterShoppingList: function () {\n\t            // `this` points to the vm instance\n\t            var key = this.key;\n\t            var shoppingList = this.shoppingList;\n\t            //在使用filter时需要注意的是，前面调用的是需要使用filter的数组，而给filter函数传入的是数组中的每个item，也就是说filter里面的函数，是每个item要去做的，并将每个结果返回。\n\t            return shoppingList.filter(function (item) {\n\t                return item.toLowerCase().indexOf(key.toLowerCase()) != -1\n\t            });;\n        \t}\n    \t}\n\t})\n\n### template\n\n\t\t<ul>\n\t\t    Filter Key\n\t\t\t<input type=\"text\" v-model=\"key\">   \n\t       \t<li v-for=\"item in filterShoppingList\">\n\t           {{ item }}\n\t       \t</li>\n   \t\t</ul> \n\n### 最终效果实现了根据关键字来过滤列表的功能。   \n\n     \t","slug":"vue block","published":1,"updated":"2019-01-28T12:46:28.506Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam7s002hn4wdc2yatsv6","content":"<h1 id=\"关于Vue全局的扩展\"><a href=\"#关于Vue全局的扩展\" class=\"headerlink\" title=\"关于Vue全局的扩展\"></a>关于Vue全局的扩展</h1><hr>\n<h2 id=\"Vue的全局组件\"><a href=\"#Vue的全局组件\" class=\"headerlink\" title=\"Vue的全局组件\"></a>Vue的全局组件</h2><h3 id=\"我们平时使用组件，需要经过引入，绑定两个步骤。那么，如果我们需要使用一些全局组件或者第三方的组件库怎么办呢？\"><a href=\"#我们平时使用组件，需要经过引入，绑定两个步骤。那么，如果我们需要使用一些全局组件或者第三方的组件库怎么办呢？\" class=\"headerlink\" title=\"我们平时使用组件，需要经过引入，绑定两个步骤。那么，如果我们需要使用一些全局组件或者第三方的组件库怎么办呢？\"></a>我们平时使用组件，需要经过引入，绑定两个步骤。那么，如果我们需要使用一些全局组件或者第三方的组件库怎么办呢？</h3><h4 id=\"在Vue官方文档中介绍的是使用Vue-component-tagName-options-来创建一个全局组件。但是这种方法是与根实例写在同一个文件中，如果要同时注册多个全局组件，就会使根实例文件过重，因此使用Vue-use-来“安装”全局组件，就显得更轻一些。\"><a href=\"#在Vue官方文档中介绍的是使用Vue-component-tagName-options-来创建一个全局组件。但是这种方法是与根实例写在同一个文件中，如果要同时注册多个全局组件，就会使根实例文件过重，因此使用Vue-use-来“安装”全局组件，就显得更轻一些。\" class=\"headerlink\" title=\"在Vue官方文档中介绍的是使用Vue.component(tagName, options)来创建一个全局组件。但是这种方法是与根实例写在同一个文件中，如果要同时注册多个全局组件，就会使根实例文件过重，因此使用Vue.use()来“安装”全局组件，就显得更轻一些。\"></a>在Vue官方文档中介绍的是使用Vue.component(tagName, options)来创建一个全局组件。但是这种方法是与根实例写在同一个文件中，如果要同时注册多个全局组件，就会使根实例文件过重，因此使用Vue.use()来“安装”全局组件，就显得更轻一些。</h4><h4 id=\"方法：\"><a href=\"#方法：\" class=\"headerlink\" title=\"方法：\"></a>方法：</h4><ul>\n<li>1.新建一个plugins文件夹 </li>\n<li>2.在文件夹中创建放置全局组件的文件components.js </li>\n<li>3.在components.js文件中引入所有要注册的全局组件 </li>\n<li>4.在app.js根实例文件中，引入components.js</li>\n</ul>\n<h3 id=\"以login组件为例\"><a href=\"#以login组件为例\" class=\"headerlink\" title=\"以login组件为例\"></a>以login组件为例</h3><h3 id=\"login-js\"><a href=\"#login-js\" class=\"headerlink\" title=\"login.js\"></a>login.js</h3><pre><code>import Login from &#39;../components/eg.vue&#39;;\nexport default (Vue)=&gt;{\n    Vue.component(&quot;Login&quot;,Login);\n}\n</code></pre><h3 id=\"app-js\"><a href=\"#app-js\" class=\"headerlink\" title=\"app.js\"></a>app.js</h3><pre><code>import components from &#39;./plugins/components.js&#39;;\nVue.use(components);\n</code></pre><h3 id=\"经过上述编写后，就注册了全局组件Login。\"><a href=\"#经过上述编写后，就注册了全局组件Login。\" class=\"headerlink\" title=\"经过上述编写后，就注册了全局组件Login。\"></a>经过上述编写后，就注册了全局组件Login。</h3><h2 id=\"Vue全局指令\"><a href=\"#Vue全局指令\" class=\"headerlink\" title=\"Vue全局指令\"></a>Vue全局指令</h2><h3 id=\"对于全局指令的注册，官方文档给出的方法是使用Vue-directive-，位置同样是在根实例文件下，那么问题来了，如果多个全局指令，再加上多个全局组件，那么app-js文件将变得臃肿无比。\"><a href=\"#对于全局指令的注册，官方文档给出的方法是使用Vue-directive-，位置同样是在根实例文件下，那么问题来了，如果多个全局指令，再加上多个全局组件，那么app-js文件将变得臃肿无比。\" class=\"headerlink\" title=\"对于全局指令的注册，官方文档给出的方法是使用Vue.directive()，位置同样是在根实例文件下，那么问题来了，如果多个全局指令，再加上多个全局组件，那么app.js文件将变得臃肿无比。\"></a>对于全局指令的注册，官方文档给出的方法是使用Vue.directive()，位置同样是在根实例文件下，那么问题来了，如果多个全局指令，再加上多个全局组件，那么app.js文件将变得臃肿无比。</h3><h4 id=\"因此，同上面的注册全局组件方法相似，也是使用Vue-use-来“安装”全局指令。\"><a href=\"#因此，同上面的注册全局组件方法相似，也是使用Vue-use-来“安装”全局指令。\" class=\"headerlink\" title=\"因此，同上面的注册全局组件方法相似，也是使用Vue.use()来“安装”全局指令。\"></a>因此，同上面的注册全局组件方法相似，也是使用Vue.use()来“安装”全局指令。</h4><h4 id=\"方法：-1\"><a href=\"#方法：-1\" class=\"headerlink\" title=\"方法：\"></a>方法：</h4><ul>\n<li>1.新建一个plugins文件夹 </li>\n<li>2.在文件夹中创建放置全局组件的文件directives.js </li>\n<li>3.在directives.js文件中引入所有要注册的全局指令 </li>\n<li>4.在app.js根实例文件中，引入directives.js</li>\n</ul>\n<h4 id=\"以v-focus指令为例：\"><a href=\"#以v-focus指令为例：\" class=\"headerlink\" title=\"以v-focus指令为例：\"></a>以v-focus指令为例：</h4><h4 id=\"directives-js\"><a href=\"#directives-js\" class=\"headerlink\" title=\"directives.js:\"></a>directives.js:</h4><pre><code>    export default (Vue)=&gt;{\n        Vue.directive(&quot;focus&quot;,{\n            inserted:function(el){\n                el.focus();\n            }\n        })\n    }\n</code></pre><h4 id=\"app-js-1\"><a href=\"#app-js-1\" class=\"headerlink\" title=\"app.js\"></a>app.js</h4><pre><code>import directives from &quot;./plugins/directives.js&quot;\nVue.use(directives);\n</code></pre><h3 id=\"这样就注册了全局指令\"><a href=\"#这样就注册了全局指令\" class=\"headerlink\" title=\"这样就注册了全局指令\"></a>这样就注册了全局指令</h3><h2 id=\"扩展Vue类方法\"><a href=\"#扩展Vue类方法\" class=\"headerlink\" title=\"扩展Vue类方法\"></a>扩展Vue类方法</h2><h3 id=\"很简单再此不做更多描述…\"><a href=\"#很简单再此不做更多描述…\" class=\"headerlink\" title=\"很简单再此不做更多描述…..\"></a>很简单再此不做更多描述…..</h3><h4 id=\"直接看代码。》-。\"><a href=\"#直接看代码。》-。\" class=\"headerlink\" title=\"直接看代码。》 。\"></a>直接看代码。》 。</h4><pre><code>Vue.coke = function () {\n    console.log(&quot;扩展了coke类方法&quot;)\n}\n</code></pre><h3 id=\"简单吧！！！！！\"><a href=\"#简单吧！！！！！\" class=\"headerlink\" title=\"简单吧！！！！！\"></a>简单吧！！！！！</h3><h2 id=\"扩展Vue原型，在vue组件中就可以通过this来访问\"><a href=\"#扩展Vue原型，在vue组件中就可以通过this来访问\" class=\"headerlink\" title=\"扩展Vue原型，在vue组件中就可以通过this来访问\"></a>扩展Vue原型，在vue组件中就可以通过this来访问</h2><h3 id=\"废话不多说上代码\"><a href=\"#废话不多说上代码\" class=\"headerlink\" title=\"废话不多说上代码\"></a>废话不多说上代码</h3><pre><code>Vue.prototype.$api = function () {\n    console.log(&quot;扩展了$api方法&quot;)\n}\n</code></pre><h3 id=\"………………\"><a href=\"#………………\" class=\"headerlink\" title=\"……………….\"></a>……………….</h3><h2 id=\"Vue过滤器\"><a href=\"#Vue过滤器\" class=\"headerlink\" title=\"Vue过滤器\"></a>Vue过滤器</h2><h3 id=\"Vue-js允许自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和v-bind表达式。过滤器应该被添加在JavaScript表达式的尾部，由“管道”符号指示：\"><a href=\"#Vue-js允许自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和v-bind表达式。过滤器应该被添加在JavaScript表达式的尾部，由“管道”符号指示：\" class=\"headerlink\" title=\"Vue.js允许自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和v-bind表达式。过滤器应该被添加在JavaScript表达式的尾部，由“管道”符号指示：|\"></a>Vue.js允许自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和v-bind表达式。过滤器应该被添加在JavaScript表达式的尾部，由“管道”符号指示：|</h3><pre><code>&lt;!-- 在双花括号中 --&gt;\n{{ message | capitalize }}\n\n&lt;!-- 在 `v-bind` 中 --&gt;\n&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;\n</code></pre><h3 id=\"可以在一个组件的选项中定义本地的过滤器：\"><a href=\"#可以在一个组件的选项中定义本地的过滤器：\" class=\"headerlink\" title=\"可以在一个组件的选项中定义本地的过滤器：\"></a>可以在一个组件的选项中定义本地的过滤器：</h3><h3 id=\"以截取手机为例\"><a href=\"#以截取手机为例\" class=\"headerlink\" title=\"以截取手机为例\"></a>以截取手机为例</h3><pre><code>filters: {\n      phones (num) {\n        let phoneStr = num.toString()\n        let res = /(\\d{1,})(\\d{4})/\n        while (reg.test(phoneStr.replace)) {\n            phoneStr = phoneStr.replace(reg, &#39;$1-$2&#39;)\n        }\n        return phoneStr\n    }\n}\n\n\n//调用\n\n{{17603446842 | phones}}\n\n//返回结果\n\n176-0344-6842\n</code></pre><h3 id=\"全局过滤器\"><a href=\"#全局过滤器\" class=\"headerlink\" title=\"全局过滤器\"></a>全局过滤器</h3><pre><code>Vue.filter(&quot;phones&quot;,function(num){\n      let phoneStr = num.toString()\n    let res = /(\\d{1,})(\\d{4})/\n    while (reg.test(phoneStr.replace)) {\n        phoneStr = phoneStr.replace(reg, &#39;$1-$2&#39;)\n    }\n    return phoneStr\n})\n</code></pre><h3 id=\"来吧，举一个实用一点的例子\"><a href=\"#来吧，举一个实用一点的例子\" class=\"headerlink\" title=\"来吧，举一个实用一点的例子\"></a>来吧，举一个实用一点的例子</h3><h3 id=\"上代码\"><a href=\"#上代码\" class=\"headerlink\" title=\"上代码\"></a>上代码</h3><pre><code>var app5 = new Vue({\n    el: &#39;#app5&#39;,\n    data: {\n        shoppingList: [\n            &quot;Milk&quot;, &quot;Donuts&quot;, &quot;Cookies&quot;, &quot;Chocolate&quot;, &quot;Peanut Butter&quot;, &quot;Pepto Bismol&quot;, &quot;Pepto Bismol (Chocolate flavor)&quot;, &quot;Pepto Bismol (Cookie flavor)&quot;\n        ],\n        key: &quot;&quot;\n    },\n    computed: {\n        filterShoppingList: function () {\n            // `this` points to the vm instance\n            var key = this.key;\n            var shoppingList = this.shoppingList;\n            //在使用filter时需要注意的是，前面调用的是需要使用filter的数组，而给filter函数传入的是数组中的每个item，也就是说filter里面的函数，是每个item要去做的，并将每个结果返回。\n            return shoppingList.filter(function (item) {\n                return item.toLowerCase().indexOf(key.toLowerCase()) != -1\n            });;\n        }\n    }\n})\n</code></pre><h3 id=\"template\"><a href=\"#template\" class=\"headerlink\" title=\"template\"></a>template</h3><pre><code>    &lt;ul&gt;\n        Filter Key\n        &lt;input type=&quot;text&quot; v-model=&quot;key&quot;&gt;   \n           &lt;li v-for=&quot;item in filterShoppingList&quot;&gt;\n           {{ item }}\n           &lt;/li&gt;\n       &lt;/ul&gt; \n</code></pre><h3 id=\"最终效果实现了根据关键字来过滤列表的功能。\"><a href=\"#最终效果实现了根据关键字来过滤列表的功能。\" class=\"headerlink\" title=\"最终效果实现了根据关键字来过滤列表的功能。\"></a>最终效果实现了根据关键字来过滤列表的功能。</h3>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"关于Vue全局的扩展\"><a href=\"#关于Vue全局的扩展\" class=\"headerlink\" title=\"关于Vue全局的扩展\"></a>关于Vue全局的扩展</h1><hr>\n<h2 id=\"Vue的全局组件\"><a href=\"#Vue的全局组件\" class=\"headerlink\" title=\"Vue的全局组件\"></a>Vue的全局组件</h2><h3 id=\"我们平时使用组件，需要经过引入，绑定两个步骤。那么，如果我们需要使用一些全局组件或者第三方的组件库怎么办呢？\"><a href=\"#我们平时使用组件，需要经过引入，绑定两个步骤。那么，如果我们需要使用一些全局组件或者第三方的组件库怎么办呢？\" class=\"headerlink\" title=\"我们平时使用组件，需要经过引入，绑定两个步骤。那么，如果我们需要使用一些全局组件或者第三方的组件库怎么办呢？\"></a>我们平时使用组件，需要经过引入，绑定两个步骤。那么，如果我们需要使用一些全局组件或者第三方的组件库怎么办呢？</h3><h4 id=\"在Vue官方文档中介绍的是使用Vue-component-tagName-options-来创建一个全局组件。但是这种方法是与根实例写在同一个文件中，如果要同时注册多个全局组件，就会使根实例文件过重，因此使用Vue-use-来“安装”全局组件，就显得更轻一些。\"><a href=\"#在Vue官方文档中介绍的是使用Vue-component-tagName-options-来创建一个全局组件。但是这种方法是与根实例写在同一个文件中，如果要同时注册多个全局组件，就会使根实例文件过重，因此使用Vue-use-来“安装”全局组件，就显得更轻一些。\" class=\"headerlink\" title=\"在Vue官方文档中介绍的是使用Vue.component(tagName, options)来创建一个全局组件。但是这种方法是与根实例写在同一个文件中，如果要同时注册多个全局组件，就会使根实例文件过重，因此使用Vue.use()来“安装”全局组件，就显得更轻一些。\"></a>在Vue官方文档中介绍的是使用Vue.component(tagName, options)来创建一个全局组件。但是这种方法是与根实例写在同一个文件中，如果要同时注册多个全局组件，就会使根实例文件过重，因此使用Vue.use()来“安装”全局组件，就显得更轻一些。</h4><h4 id=\"方法：\"><a href=\"#方法：\" class=\"headerlink\" title=\"方法：\"></a>方法：</h4><ul>\n<li>1.新建一个plugins文件夹 </li>\n<li>2.在文件夹中创建放置全局组件的文件components.js </li>\n<li>3.在components.js文件中引入所有要注册的全局组件 </li>\n<li>4.在app.js根实例文件中，引入components.js</li>\n</ul>\n<h3 id=\"以login组件为例\"><a href=\"#以login组件为例\" class=\"headerlink\" title=\"以login组件为例\"></a>以login组件为例</h3><h3 id=\"login-js\"><a href=\"#login-js\" class=\"headerlink\" title=\"login.js\"></a>login.js</h3><pre><code>import Login from &#39;../components/eg.vue&#39;;\nexport default (Vue)=&gt;{\n    Vue.component(&quot;Login&quot;,Login);\n}\n</code></pre><h3 id=\"app-js\"><a href=\"#app-js\" class=\"headerlink\" title=\"app.js\"></a>app.js</h3><pre><code>import components from &#39;./plugins/components.js&#39;;\nVue.use(components);\n</code></pre><h3 id=\"经过上述编写后，就注册了全局组件Login。\"><a href=\"#经过上述编写后，就注册了全局组件Login。\" class=\"headerlink\" title=\"经过上述编写后，就注册了全局组件Login。\"></a>经过上述编写后，就注册了全局组件Login。</h3><h2 id=\"Vue全局指令\"><a href=\"#Vue全局指令\" class=\"headerlink\" title=\"Vue全局指令\"></a>Vue全局指令</h2><h3 id=\"对于全局指令的注册，官方文档给出的方法是使用Vue-directive-，位置同样是在根实例文件下，那么问题来了，如果多个全局指令，再加上多个全局组件，那么app-js文件将变得臃肿无比。\"><a href=\"#对于全局指令的注册，官方文档给出的方法是使用Vue-directive-，位置同样是在根实例文件下，那么问题来了，如果多个全局指令，再加上多个全局组件，那么app-js文件将变得臃肿无比。\" class=\"headerlink\" title=\"对于全局指令的注册，官方文档给出的方法是使用Vue.directive()，位置同样是在根实例文件下，那么问题来了，如果多个全局指令，再加上多个全局组件，那么app.js文件将变得臃肿无比。\"></a>对于全局指令的注册，官方文档给出的方法是使用Vue.directive()，位置同样是在根实例文件下，那么问题来了，如果多个全局指令，再加上多个全局组件，那么app.js文件将变得臃肿无比。</h3><h4 id=\"因此，同上面的注册全局组件方法相似，也是使用Vue-use-来“安装”全局指令。\"><a href=\"#因此，同上面的注册全局组件方法相似，也是使用Vue-use-来“安装”全局指令。\" class=\"headerlink\" title=\"因此，同上面的注册全局组件方法相似，也是使用Vue.use()来“安装”全局指令。\"></a>因此，同上面的注册全局组件方法相似，也是使用Vue.use()来“安装”全局指令。</h4><h4 id=\"方法：-1\"><a href=\"#方法：-1\" class=\"headerlink\" title=\"方法：\"></a>方法：</h4><ul>\n<li>1.新建一个plugins文件夹 </li>\n<li>2.在文件夹中创建放置全局组件的文件directives.js </li>\n<li>3.在directives.js文件中引入所有要注册的全局指令 </li>\n<li>4.在app.js根实例文件中，引入directives.js</li>\n</ul>\n<h4 id=\"以v-focus指令为例：\"><a href=\"#以v-focus指令为例：\" class=\"headerlink\" title=\"以v-focus指令为例：\"></a>以v-focus指令为例：</h4><h4 id=\"directives-js\"><a href=\"#directives-js\" class=\"headerlink\" title=\"directives.js:\"></a>directives.js:</h4><pre><code>    export default (Vue)=&gt;{\n        Vue.directive(&quot;focus&quot;,{\n            inserted:function(el){\n                el.focus();\n            }\n        })\n    }\n</code></pre><h4 id=\"app-js-1\"><a href=\"#app-js-1\" class=\"headerlink\" title=\"app.js\"></a>app.js</h4><pre><code>import directives from &quot;./plugins/directives.js&quot;\nVue.use(directives);\n</code></pre><h3 id=\"这样就注册了全局指令\"><a href=\"#这样就注册了全局指令\" class=\"headerlink\" title=\"这样就注册了全局指令\"></a>这样就注册了全局指令</h3><h2 id=\"扩展Vue类方法\"><a href=\"#扩展Vue类方法\" class=\"headerlink\" title=\"扩展Vue类方法\"></a>扩展Vue类方法</h2><h3 id=\"很简单再此不做更多描述…\"><a href=\"#很简单再此不做更多描述…\" class=\"headerlink\" title=\"很简单再此不做更多描述…..\"></a>很简单再此不做更多描述…..</h3><h4 id=\"直接看代码。》-。\"><a href=\"#直接看代码。》-。\" class=\"headerlink\" title=\"直接看代码。》 。\"></a>直接看代码。》 。</h4><pre><code>Vue.coke = function () {\n    console.log(&quot;扩展了coke类方法&quot;)\n}\n</code></pre><h3 id=\"简单吧！！！！！\"><a href=\"#简单吧！！！！！\" class=\"headerlink\" title=\"简单吧！！！！！\"></a>简单吧！！！！！</h3><h2 id=\"扩展Vue原型，在vue组件中就可以通过this来访问\"><a href=\"#扩展Vue原型，在vue组件中就可以通过this来访问\" class=\"headerlink\" title=\"扩展Vue原型，在vue组件中就可以通过this来访问\"></a>扩展Vue原型，在vue组件中就可以通过this来访问</h2><h3 id=\"废话不多说上代码\"><a href=\"#废话不多说上代码\" class=\"headerlink\" title=\"废话不多说上代码\"></a>废话不多说上代码</h3><pre><code>Vue.prototype.$api = function () {\n    console.log(&quot;扩展了$api方法&quot;)\n}\n</code></pre><h3 id=\"………………\"><a href=\"#………………\" class=\"headerlink\" title=\"……………….\"></a>……………….</h3><h2 id=\"Vue过滤器\"><a href=\"#Vue过滤器\" class=\"headerlink\" title=\"Vue过滤器\"></a>Vue过滤器</h2><h3 id=\"Vue-js允许自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和v-bind表达式。过滤器应该被添加在JavaScript表达式的尾部，由“管道”符号指示：\"><a href=\"#Vue-js允许自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和v-bind表达式。过滤器应该被添加在JavaScript表达式的尾部，由“管道”符号指示：\" class=\"headerlink\" title=\"Vue.js允许自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和v-bind表达式。过滤器应该被添加在JavaScript表达式的尾部，由“管道”符号指示：|\"></a>Vue.js允许自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和v-bind表达式。过滤器应该被添加在JavaScript表达式的尾部，由“管道”符号指示：|</h3><pre><code>&lt;!-- 在双花括号中 --&gt;\n{{ message | capitalize }}\n\n&lt;!-- 在 `v-bind` 中 --&gt;\n&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;\n</code></pre><h3 id=\"可以在一个组件的选项中定义本地的过滤器：\"><a href=\"#可以在一个组件的选项中定义本地的过滤器：\" class=\"headerlink\" title=\"可以在一个组件的选项中定义本地的过滤器：\"></a>可以在一个组件的选项中定义本地的过滤器：</h3><h3 id=\"以截取手机为例\"><a href=\"#以截取手机为例\" class=\"headerlink\" title=\"以截取手机为例\"></a>以截取手机为例</h3><pre><code>filters: {\n      phones (num) {\n        let phoneStr = num.toString()\n        let res = /(\\d{1,})(\\d{4})/\n        while (reg.test(phoneStr.replace)) {\n            phoneStr = phoneStr.replace(reg, &#39;$1-$2&#39;)\n        }\n        return phoneStr\n    }\n}\n\n\n//调用\n\n{{17603446842 | phones}}\n\n//返回结果\n\n176-0344-6842\n</code></pre><h3 id=\"全局过滤器\"><a href=\"#全局过滤器\" class=\"headerlink\" title=\"全局过滤器\"></a>全局过滤器</h3><pre><code>Vue.filter(&quot;phones&quot;,function(num){\n      let phoneStr = num.toString()\n    let res = /(\\d{1,})(\\d{4})/\n    while (reg.test(phoneStr.replace)) {\n        phoneStr = phoneStr.replace(reg, &#39;$1-$2&#39;)\n    }\n    return phoneStr\n})\n</code></pre><h3 id=\"来吧，举一个实用一点的例子\"><a href=\"#来吧，举一个实用一点的例子\" class=\"headerlink\" title=\"来吧，举一个实用一点的例子\"></a>来吧，举一个实用一点的例子</h3><h3 id=\"上代码\"><a href=\"#上代码\" class=\"headerlink\" title=\"上代码\"></a>上代码</h3><pre><code>var app5 = new Vue({\n    el: &#39;#app5&#39;,\n    data: {\n        shoppingList: [\n            &quot;Milk&quot;, &quot;Donuts&quot;, &quot;Cookies&quot;, &quot;Chocolate&quot;, &quot;Peanut Butter&quot;, &quot;Pepto Bismol&quot;, &quot;Pepto Bismol (Chocolate flavor)&quot;, &quot;Pepto Bismol (Cookie flavor)&quot;\n        ],\n        key: &quot;&quot;\n    },\n    computed: {\n        filterShoppingList: function () {\n            // `this` points to the vm instance\n            var key = this.key;\n            var shoppingList = this.shoppingList;\n            //在使用filter时需要注意的是，前面调用的是需要使用filter的数组，而给filter函数传入的是数组中的每个item，也就是说filter里面的函数，是每个item要去做的，并将每个结果返回。\n            return shoppingList.filter(function (item) {\n                return item.toLowerCase().indexOf(key.toLowerCase()) != -1\n            });;\n        }\n    }\n})\n</code></pre><h3 id=\"template\"><a href=\"#template\" class=\"headerlink\" title=\"template\"></a>template</h3><pre><code>    &lt;ul&gt;\n        Filter Key\n        &lt;input type=&quot;text&quot; v-model=&quot;key&quot;&gt;   \n           &lt;li v-for=&quot;item in filterShoppingList&quot;&gt;\n           {{ item }}\n           &lt;/li&gt;\n       &lt;/ul&gt; \n</code></pre><h3 id=\"最终效果实现了根据关键字来过滤列表的功能。\"><a href=\"#最终效果实现了根据关键字来过滤列表的功能。\" class=\"headerlink\" title=\"最终效果实现了根据关键字来过滤列表的功能。\"></a>最终效果实现了根据关键字来过滤列表的功能。</h3>"},{"title":"Vue构造器及其实例化概念","date":"2019-01-28T12:25:44.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"# Vue构造器及其实例化概念\n\n----------\n\n\n## Vue构造器\n\n## [附官方文档](https://cn.vuejs.org/v2/api/#Vue-extend)\n\n> ### 简单介绍\n\n### Vue.extend(options)\n\n#### **参数**: 对象\n\n#### **用法**: 使用Vue构造器，创建一个“子类”，参数是一个包含组件选项的对象，其中,data选项中必须是函数\n\n#### **描述**：Vue.extend返回的是一个“扩展实例构造器”，也就是预设了部分选项的Vue的实例构造器，它常常服务于Vue.component用来生成组件，可以简单理解为当在模板中遇到该组件作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂在到自定义元素上\n\n\n> ### 简单举例\n\n#### 自定义无参数标签\n\n下面的代码中的author就是返回的“扩展实例构造器”\n\n\tvar author = Vue.extend({\n\t template: \"<p><a :href='url'>{{author}}</a></p>\",\n\t data : function() {\n\t  return {\n\t   author : 'vamous',\n\t   url : 'http://blog.csdn.net/Dear_Mr/article/details/72614370'\n\t  }\n\t }\n\t});\n\n###对应的html如下：\n\n\t<author></author>\n\n### 此时的页面必然是没有任何效果的，因为扩展实例构造器还需要挂载，如下\n\n\tnew author().$mount('author');\n\n### 使用propsData\n\n\tvar author = Vue.extend({\n\t template: \"<p><a :href='url'>{{author}} & {{name}}</a></p>\",\n\t data : function() {\n\t  return {\n\t   author : 'vamous',\n\t   url : 'http://blog.csdn.net/Dear_Mr/article/details/72614370'\n\t  }\n\t },\n\t props : ['name']\n\t});\n\t \n\tnew author({propsData: {name : 'dear_mr'}}).$mount('#author');\n\n### 可以利用propsData传递参数\n\n**挂载在普通标签上**\n\n返回的扩展实例构造器的方式和上面还是一样的，只是html里不再是自定义标签，而是一个普通标签，比如div\n\n\t<div id=\"author\"></div>\n\n\tnew author().$mount('author');\n\n其实对于同一个扩展构造器而言，它的每一个实例其实是可以挂载到不同的标签上的，比如我可以这样\n\n\tnew author().$mount('#author');\n\n\tnew author().$mount('author');\n\n这两个标签的内容会一同显示，结果一样\n\n## 总结\n\n> **Vue。extend(object)//扩展的子类需要Vue实例化才能使用，如果需要传递props，需要在new的时候通过propsData传递**\n\n\n----------\n\n\n> \n> $mount()手动执行组件的渲染，如果传递一个选择器，就会渲染选择器内部，如果传递只会生成dom不会执行渲染，需要手动将el挂载到页面\n\n\n----------\n\n\n> **$destroy()手动销毁组件，但是如果将dom移动将不会销毁dom，需要手动销毁**\n> \n\n----------\n\n\n> **$nextTick()生命周期updated的替代方案，因为在updated中只是得知组件需要重新渲染，但并不知道是哪个属性改变了，而nextTick()当属性改变并且渲染完成的回调，类似于react中的setState的回调函数**\n> \n\n----------\n\n\n    适用场景\n    \n    使用扩展子类方式创建的组件适合开发使用api的方法调用\n\n## 以上就是对Vue.extend构造器的实例详解","source":"_posts/vue extend.md","raw":"---\ntitle: Vue构造器及其实例化概念\ndate: '1/28/2019 8:25:44 PM '\ntag: ['vue构造器', 'vue', 'vue extend']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n# Vue构造器及其实例化概念\n\n----------\n\n\n## Vue构造器\n\n## [附官方文档](https://cn.vuejs.org/v2/api/#Vue-extend)\n\n> ### 简单介绍\n\n### Vue.extend(options)\n\n#### **参数**: 对象\n\n#### **用法**: 使用Vue构造器，创建一个“子类”，参数是一个包含组件选项的对象，其中,data选项中必须是函数\n\n#### **描述**：Vue.extend返回的是一个“扩展实例构造器”，也就是预设了部分选项的Vue的实例构造器，它常常服务于Vue.component用来生成组件，可以简单理解为当在模板中遇到该组件作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂在到自定义元素上\n\n\n> ### 简单举例\n\n#### 自定义无参数标签\n\n下面的代码中的author就是返回的“扩展实例构造器”\n\n\tvar author = Vue.extend({\n\t template: \"<p><a :href='url'>{{author}}</a></p>\",\n\t data : function() {\n\t  return {\n\t   author : 'vamous',\n\t   url : 'http://blog.csdn.net/Dear_Mr/article/details/72614370'\n\t  }\n\t }\n\t});\n\n###对应的html如下：\n\n\t<author></author>\n\n### 此时的页面必然是没有任何效果的，因为扩展实例构造器还需要挂载，如下\n\n\tnew author().$mount('author');\n\n### 使用propsData\n\n\tvar author = Vue.extend({\n\t template: \"<p><a :href='url'>{{author}} & {{name}}</a></p>\",\n\t data : function() {\n\t  return {\n\t   author : 'vamous',\n\t   url : 'http://blog.csdn.net/Dear_Mr/article/details/72614370'\n\t  }\n\t },\n\t props : ['name']\n\t});\n\t \n\tnew author({propsData: {name : 'dear_mr'}}).$mount('#author');\n\n### 可以利用propsData传递参数\n\n**挂载在普通标签上**\n\n返回的扩展实例构造器的方式和上面还是一样的，只是html里不再是自定义标签，而是一个普通标签，比如div\n\n\t<div id=\"author\"></div>\n\n\tnew author().$mount('author');\n\n其实对于同一个扩展构造器而言，它的每一个实例其实是可以挂载到不同的标签上的，比如我可以这样\n\n\tnew author().$mount('#author');\n\n\tnew author().$mount('author');\n\n这两个标签的内容会一同显示，结果一样\n\n## 总结\n\n> **Vue。extend(object)//扩展的子类需要Vue实例化才能使用，如果需要传递props，需要在new的时候通过propsData传递**\n\n\n----------\n\n\n> \n> $mount()手动执行组件的渲染，如果传递一个选择器，就会渲染选择器内部，如果传递只会生成dom不会执行渲染，需要手动将el挂载到页面\n\n\n----------\n\n\n> **$destroy()手动销毁组件，但是如果将dom移动将不会销毁dom，需要手动销毁**\n> \n\n----------\n\n\n> **$nextTick()生命周期updated的替代方案，因为在updated中只是得知组件需要重新渲染，但并不知道是哪个属性改变了，而nextTick()当属性改变并且渲染完成的回调，类似于react中的setState的回调函数**\n> \n\n----------\n\n\n    适用场景\n    \n    使用扩展子类方式创建的组件适合开发使用api的方法调用\n\n## 以上就是对Vue.extend构造器的实例详解","slug":"vue extend","published":1,"updated":"2019-01-29T03:30:10.135Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam7t002jn4wdnszez2dt","content":"<h1 id=\"Vue构造器及其实例化概念\"><a href=\"#Vue构造器及其实例化概念\" class=\"headerlink\" title=\"Vue构造器及其实例化概念\"></a>Vue构造器及其实例化概念</h1><hr>\n<h2 id=\"Vue构造器\"><a href=\"#Vue构造器\" class=\"headerlink\" title=\"Vue构造器\"></a>Vue构造器</h2><h2 id=\"附官方文档\"><a href=\"#附官方文档\" class=\"headerlink\" title=\"附官方文档\"></a><a href=\"https://cn.vuejs.org/v2/api/#Vue-extend\" target=\"_blank\" rel=\"noopener\">附官方文档</a></h2><blockquote>\n<h3 id=\"简单介绍\"><a href=\"#简单介绍\" class=\"headerlink\" title=\"简单介绍\"></a>简单介绍</h3></blockquote>\n<h3 id=\"Vue-extend-options\"><a href=\"#Vue-extend-options\" class=\"headerlink\" title=\"Vue.extend(options)\"></a>Vue.extend(options)</h3><h4 id=\"参数-对象\"><a href=\"#参数-对象\" class=\"headerlink\" title=\"参数: 对象\"></a><strong>参数</strong>: 对象</h4><h4 id=\"用法-使用Vue构造器，创建一个“子类”，参数是一个包含组件选项的对象，其中-data选项中必须是函数\"><a href=\"#用法-使用Vue构造器，创建一个“子类”，参数是一个包含组件选项的对象，其中-data选项中必须是函数\" class=\"headerlink\" title=\"用法: 使用Vue构造器，创建一个“子类”，参数是一个包含组件选项的对象，其中,data选项中必须是函数\"></a><strong>用法</strong>: 使用Vue构造器，创建一个“子类”，参数是一个包含组件选项的对象，其中,data选项中必须是函数</h4><h4 id=\"描述：Vue-extend返回的是一个“扩展实例构造器”，也就是预设了部分选项的Vue的实例构造器，它常常服务于Vue-component用来生成组件，可以简单理解为当在模板中遇到该组件作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂在到自定义元素上\"><a href=\"#描述：Vue-extend返回的是一个“扩展实例构造器”，也就是预设了部分选项的Vue的实例构造器，它常常服务于Vue-component用来生成组件，可以简单理解为当在模板中遇到该组件作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂在到自定义元素上\" class=\"headerlink\" title=\"描述：Vue.extend返回的是一个“扩展实例构造器”，也就是预设了部分选项的Vue的实例构造器，它常常服务于Vue.component用来生成组件，可以简单理解为当在模板中遇到该组件作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂在到自定义元素上\"></a><strong>描述</strong>：Vue.extend返回的是一个“扩展实例构造器”，也就是预设了部分选项的Vue的实例构造器，它常常服务于Vue.component用来生成组件，可以简单理解为当在模板中遇到该组件作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂在到自定义元素上</h4><blockquote>\n<h3 id=\"简单举例\"><a href=\"#简单举例\" class=\"headerlink\" title=\"简单举例\"></a>简单举例</h3></blockquote>\n<h4 id=\"自定义无参数标签\"><a href=\"#自定义无参数标签\" class=\"headerlink\" title=\"自定义无参数标签\"></a>自定义无参数标签</h4><p>下面的代码中的author就是返回的“扩展实例构造器”</p>\n<pre><code>var author = Vue.extend({\n template: &quot;&lt;p&gt;&lt;a :href=&#39;url&#39;&gt;{{author}}&lt;/a&gt;&lt;/p&gt;&quot;,\n data : function() {\n  return {\n   author : &#39;vamous&#39;,\n   url : &#39;http://blog.csdn.net/Dear_Mr/article/details/72614370&#39;\n  }\n }\n});\n</code></pre><p>###对应的html如下：</p>\n<pre><code>&lt;author&gt;&lt;/author&gt;\n</code></pre><h3 id=\"此时的页面必然是没有任何效果的，因为扩展实例构造器还需要挂载，如下\"><a href=\"#此时的页面必然是没有任何效果的，因为扩展实例构造器还需要挂载，如下\" class=\"headerlink\" title=\"此时的页面必然是没有任何效果的，因为扩展实例构造器还需要挂载，如下\"></a>此时的页面必然是没有任何效果的，因为扩展实例构造器还需要挂载，如下</h3><pre><code>new author().$mount(&#39;author&#39;);\n</code></pre><h3 id=\"使用propsData\"><a href=\"#使用propsData\" class=\"headerlink\" title=\"使用propsData\"></a>使用propsData</h3><pre><code>var author = Vue.extend({\n template: &quot;&lt;p&gt;&lt;a :href=&#39;url&#39;&gt;{{author}} &amp; {{name}}&lt;/a&gt;&lt;/p&gt;&quot;,\n data : function() {\n  return {\n   author : &#39;vamous&#39;,\n   url : &#39;http://blog.csdn.net/Dear_Mr/article/details/72614370&#39;\n  }\n },\n props : [&#39;name&#39;]\n});\n\nnew author({propsData: {name : &#39;dear_mr&#39;}}).$mount(&#39;#author&#39;);\n</code></pre><h3 id=\"可以利用propsData传递参数\"><a href=\"#可以利用propsData传递参数\" class=\"headerlink\" title=\"可以利用propsData传递参数\"></a>可以利用propsData传递参数</h3><p><strong>挂载在普通标签上</strong></p>\n<p>返回的扩展实例构造器的方式和上面还是一样的，只是html里不再是自定义标签，而是一个普通标签，比如div</p>\n<pre><code>&lt;div id=&quot;author&quot;&gt;&lt;/div&gt;\n\nnew author().$mount(&#39;author&#39;);\n</code></pre><p>其实对于同一个扩展构造器而言，它的每一个实例其实是可以挂载到不同的标签上的，比如我可以这样</p>\n<pre><code>new author().$mount(&#39;#author&#39;);\n\nnew author().$mount(&#39;author&#39;);\n</code></pre><p>这两个标签的内容会一同显示，结果一样</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><blockquote>\n<p><strong>Vue。extend(object)//扩展的子类需要Vue实例化才能使用，如果需要传递props，需要在new的时候通过propsData传递</strong></p>\n</blockquote>\n<hr>\n<blockquote>\n<p>$mount()手动执行组件的渲染，如果传递一个选择器，就会渲染选择器内部，如果传递只会生成dom不会执行渲染，需要手动将el挂载到页面</p>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>$destroy()手动销毁组件，但是如果将dom移动将不会销毁dom，需要手动销毁</strong></p>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>$nextTick()生命周期updated的替代方案，因为在updated中只是得知组件需要重新渲染，但并不知道是哪个属性改变了，而nextTick()当属性改变并且渲染完成的回调，类似于react中的setState的回调函数</strong></p>\n</blockquote>\n<hr>\n<pre><code>适用场景\n\n使用扩展子类方式创建的组件适合开发使用api的方法调用\n</code></pre><h2 id=\"以上就是对Vue-extend构造器的实例详解\"><a href=\"#以上就是对Vue-extend构造器的实例详解\" class=\"headerlink\" title=\"以上就是对Vue.extend构造器的实例详解\"></a>以上就是对Vue.extend构造器的实例详解</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Vue构造器及其实例化概念\"><a href=\"#Vue构造器及其实例化概念\" class=\"headerlink\" title=\"Vue构造器及其实例化概念\"></a>Vue构造器及其实例化概念</h1><hr>\n<h2 id=\"Vue构造器\"><a href=\"#Vue构造器\" class=\"headerlink\" title=\"Vue构造器\"></a>Vue构造器</h2><h2 id=\"附官方文档\"><a href=\"#附官方文档\" class=\"headerlink\" title=\"附官方文档\"></a><a href=\"https://cn.vuejs.org/v2/api/#Vue-extend\" target=\"_blank\" rel=\"noopener\">附官方文档</a></h2><blockquote>\n<h3 id=\"简单介绍\"><a href=\"#简单介绍\" class=\"headerlink\" title=\"简单介绍\"></a>简单介绍</h3></blockquote>\n<h3 id=\"Vue-extend-options\"><a href=\"#Vue-extend-options\" class=\"headerlink\" title=\"Vue.extend(options)\"></a>Vue.extend(options)</h3><h4 id=\"参数-对象\"><a href=\"#参数-对象\" class=\"headerlink\" title=\"参数: 对象\"></a><strong>参数</strong>: 对象</h4><h4 id=\"用法-使用Vue构造器，创建一个“子类”，参数是一个包含组件选项的对象，其中-data选项中必须是函数\"><a href=\"#用法-使用Vue构造器，创建一个“子类”，参数是一个包含组件选项的对象，其中-data选项中必须是函数\" class=\"headerlink\" title=\"用法: 使用Vue构造器，创建一个“子类”，参数是一个包含组件选项的对象，其中,data选项中必须是函数\"></a><strong>用法</strong>: 使用Vue构造器，创建一个“子类”，参数是一个包含组件选项的对象，其中,data选项中必须是函数</h4><h4 id=\"描述：Vue-extend返回的是一个“扩展实例构造器”，也就是预设了部分选项的Vue的实例构造器，它常常服务于Vue-component用来生成组件，可以简单理解为当在模板中遇到该组件作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂在到自定义元素上\"><a href=\"#描述：Vue-extend返回的是一个“扩展实例构造器”，也就是预设了部分选项的Vue的实例构造器，它常常服务于Vue-component用来生成组件，可以简单理解为当在模板中遇到该组件作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂在到自定义元素上\" class=\"headerlink\" title=\"描述：Vue.extend返回的是一个“扩展实例构造器”，也就是预设了部分选项的Vue的实例构造器，它常常服务于Vue.component用来生成组件，可以简单理解为当在模板中遇到该组件作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂在到自定义元素上\"></a><strong>描述</strong>：Vue.extend返回的是一个“扩展实例构造器”，也就是预设了部分选项的Vue的实例构造器，它常常服务于Vue.component用来生成组件，可以简单理解为当在模板中遇到该组件作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂在到自定义元素上</h4><blockquote>\n<h3 id=\"简单举例\"><a href=\"#简单举例\" class=\"headerlink\" title=\"简单举例\"></a>简单举例</h3></blockquote>\n<h4 id=\"自定义无参数标签\"><a href=\"#自定义无参数标签\" class=\"headerlink\" title=\"自定义无参数标签\"></a>自定义无参数标签</h4><p>下面的代码中的author就是返回的“扩展实例构造器”</p>\n<pre><code>var author = Vue.extend({\n template: &quot;&lt;p&gt;&lt;a :href=&#39;url&#39;&gt;{{author}}&lt;/a&gt;&lt;/p&gt;&quot;,\n data : function() {\n  return {\n   author : &#39;vamous&#39;,\n   url : &#39;http://blog.csdn.net/Dear_Mr/article/details/72614370&#39;\n  }\n }\n});\n</code></pre><p>###对应的html如下：</p>\n<pre><code>&lt;author&gt;&lt;/author&gt;\n</code></pre><h3 id=\"此时的页面必然是没有任何效果的，因为扩展实例构造器还需要挂载，如下\"><a href=\"#此时的页面必然是没有任何效果的，因为扩展实例构造器还需要挂载，如下\" class=\"headerlink\" title=\"此时的页面必然是没有任何效果的，因为扩展实例构造器还需要挂载，如下\"></a>此时的页面必然是没有任何效果的，因为扩展实例构造器还需要挂载，如下</h3><pre><code>new author().$mount(&#39;author&#39;);\n</code></pre><h3 id=\"使用propsData\"><a href=\"#使用propsData\" class=\"headerlink\" title=\"使用propsData\"></a>使用propsData</h3><pre><code>var author = Vue.extend({\n template: &quot;&lt;p&gt;&lt;a :href=&#39;url&#39;&gt;{{author}} &amp; {{name}}&lt;/a&gt;&lt;/p&gt;&quot;,\n data : function() {\n  return {\n   author : &#39;vamous&#39;,\n   url : &#39;http://blog.csdn.net/Dear_Mr/article/details/72614370&#39;\n  }\n },\n props : [&#39;name&#39;]\n});\n\nnew author({propsData: {name : &#39;dear_mr&#39;}}).$mount(&#39;#author&#39;);\n</code></pre><h3 id=\"可以利用propsData传递参数\"><a href=\"#可以利用propsData传递参数\" class=\"headerlink\" title=\"可以利用propsData传递参数\"></a>可以利用propsData传递参数</h3><p><strong>挂载在普通标签上</strong></p>\n<p>返回的扩展实例构造器的方式和上面还是一样的，只是html里不再是自定义标签，而是一个普通标签，比如div</p>\n<pre><code>&lt;div id=&quot;author&quot;&gt;&lt;/div&gt;\n\nnew author().$mount(&#39;author&#39;);\n</code></pre><p>其实对于同一个扩展构造器而言，它的每一个实例其实是可以挂载到不同的标签上的，比如我可以这样</p>\n<pre><code>new author().$mount(&#39;#author&#39;);\n\nnew author().$mount(&#39;author&#39;);\n</code></pre><p>这两个标签的内容会一同显示，结果一样</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><blockquote>\n<p><strong>Vue。extend(object)//扩展的子类需要Vue实例化才能使用，如果需要传递props，需要在new的时候通过propsData传递</strong></p>\n</blockquote>\n<hr>\n<blockquote>\n<p>$mount()手动执行组件的渲染，如果传递一个选择器，就会渲染选择器内部，如果传递只会生成dom不会执行渲染，需要手动将el挂载到页面</p>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>$destroy()手动销毁组件，但是如果将dom移动将不会销毁dom，需要手动销毁</strong></p>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>$nextTick()生命周期updated的替代方案，因为在updated中只是得知组件需要重新渲染，但并不知道是哪个属性改变了，而nextTick()当属性改变并且渲染完成的回调，类似于react中的setState的回调函数</strong></p>\n</blockquote>\n<hr>\n<pre><code>适用场景\n\n使用扩展子类方式创建的组件适合开发使用api的方法调用\n</code></pre><h2 id=\"以上就是对Vue-extend构造器的实例详解\"><a href=\"#以上就是对Vue-extend构造器的实例详解\" class=\"headerlink\" title=\"以上就是对Vue.extend构造器的实例详解\"></a>以上就是对Vue.extend构造器的实例详解</h2>"},{"title":"Vue slot-scope的理解（适合初学者）","date":"2018-08-04T08:46:31.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"\n\n# Vue slot-scope的理解（适合初学者）\n\n> 1/26/2019 2:58:04 PM \n\n----------\n\n> ##### Vue中关于插槽的文档说明很短，语言又写的很凝练，再加上其和方法，数据，计算机等常用选项在使用频率，使用先后上的差别，这就有可能造成初次接触插槽的开发者容易产生“算了吧，回头再学，反正已经可以写基础组件了”的想法，于是就关闭了VUE的说明文档。\n\n\n> ### 实际上，插槽的概念很简单\n\n### slot \n\n- **概念：插槽，也就是槽，是组件的一块HTML模板，这块模板显示不显示，以及怎样显示由父组件来决定。**\n\n### 插槽可以分为3部分来说\n\n- **单个插槽**\n\n\t-------------------------\n\t- #### 首先是单个插槽，单个插槽的英文VUE的官方叫法，但是其实也可以叫它默认插槽，或者与具名插槽相对，我们可以叫它匿名插槽。因为它不用设置名称属性。\n\n\t- #### 单个插槽可以放置在组件的任意位置，但是就像它的名字一样，一个组件中只能有一个该类插槽。相对应的，具名插槽就可以有很多个，只要名字（名称属性）不同就可以了。\n\n> \t下面通过一个例子来展示。\n\n**父组件：**\n\n\t\t<div class=\"slot-righ\">\n                    <p>22222</p>\n                    <Slo>\n                        <div class=\"con\">\n                            111111\n                        </div>\n                    </Slo>\n                </div>\n\n**子组件：**\n\n\t\t<div class=\"sol\">\n\t\t    <p>11111</p>\n\t\t    <slot></slot>\n\t\t  </div>\n\n\n- **具名插槽**\n\t- 匿名插槽没有名称属性，所以是匿名插槽，那么，插槽加了名称属性，就变成了具名插槽。具名插槽可以在一个组件中出现Ñ次，出现在不同的位置。下面的例子，一个就是有两个具名插槽状语从句：单个插槽的组件，这三个插槽被父组件用同一套的CSS样式显示了出来，不同的是内容上略有区别。\n\n> \t\n> 下面通过一个例子来展示。\n\n**父组件：**\t\n\t\n\t<div class=\"slot-righ\">\n                <p>22222</p>\n                <Slo>\n                    <div class=\"con\" slot=\"up\">\n                        111111\n                    </div>\n                </Slo>\n            </div>\n\t\t\n**子组件：**\n\t\n\t<div class=\"sol\">\n        <p>11111</p>\n        <slot name=\"up\"></slot>//具名插槽\n      </div>\n\n- **作用域插槽| 带数据的插槽**\n\n\t- 最后，就是我们的作用域插槽。这个稍微难理解一点。官方叫它作用域插槽，实际上，对比前面两种插槽，我们可以叫它带数据的插槽。什么意思呢，就是前面两种，都是在组件的模板里面写\n\n> 下面通过一个例子来展示。\n\n**父组件：**\t\n\n\t<div class=\"slot-righ\">\n                    <p>22222</p>\n                    <Slo>\n                        <div class=\"con\" slot-scope=\"user\">//父组件拿到数据\n                            {{user.data}}\n                        </div>\n                    </Slo>\n                </div>\n\n**子组件：**\n\n\t<template>\n\t  <div class=\"sol\">\n\t    <p>11111</p>\n\t    <slot :data=\"data\"></slot>//这里再插槽上绑定数据\n\t  </div>\n\t</template>\n\t<script>\n\t\texport default {\n\t\t  data(){\n\t\t    return {\n\t\t      data:11111111\n\t\t    }\n\t\t  }\n\t\t}\n\t</script>\n\n> #### 正因为作用域插槽绑定了一套数据，父组件可以拿来用于是，情况就变成了这样：样式父组件说了算，但内容可以显示子组件插槽绑定的。\n","source":"_posts/vue slot-scope.md","raw":"---\ntitle: Vue slot-scope的理解（适合初学者）\ndate: '2018-08-04 16:46:31'\ntag: ['js', 'vue', 'slot']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n\n\n# Vue slot-scope的理解（适合初学者）\n\n> 1/26/2019 2:58:04 PM \n\n----------\n\n> ##### Vue中关于插槽的文档说明很短，语言又写的很凝练，再加上其和方法，数据，计算机等常用选项在使用频率，使用先后上的差别，这就有可能造成初次接触插槽的开发者容易产生“算了吧，回头再学，反正已经可以写基础组件了”的想法，于是就关闭了VUE的说明文档。\n\n\n> ### 实际上，插槽的概念很简单\n\n### slot \n\n- **概念：插槽，也就是槽，是组件的一块HTML模板，这块模板显示不显示，以及怎样显示由父组件来决定。**\n\n### 插槽可以分为3部分来说\n\n- **单个插槽**\n\n\t-------------------------\n\t- #### 首先是单个插槽，单个插槽的英文VUE的官方叫法，但是其实也可以叫它默认插槽，或者与具名插槽相对，我们可以叫它匿名插槽。因为它不用设置名称属性。\n\n\t- #### 单个插槽可以放置在组件的任意位置，但是就像它的名字一样，一个组件中只能有一个该类插槽。相对应的，具名插槽就可以有很多个，只要名字（名称属性）不同就可以了。\n\n> \t下面通过一个例子来展示。\n\n**父组件：**\n\n\t\t<div class=\"slot-righ\">\n                    <p>22222</p>\n                    <Slo>\n                        <div class=\"con\">\n                            111111\n                        </div>\n                    </Slo>\n                </div>\n\n**子组件：**\n\n\t\t<div class=\"sol\">\n\t\t    <p>11111</p>\n\t\t    <slot></slot>\n\t\t  </div>\n\n\n- **具名插槽**\n\t- 匿名插槽没有名称属性，所以是匿名插槽，那么，插槽加了名称属性，就变成了具名插槽。具名插槽可以在一个组件中出现Ñ次，出现在不同的位置。下面的例子，一个就是有两个具名插槽状语从句：单个插槽的组件，这三个插槽被父组件用同一套的CSS样式显示了出来，不同的是内容上略有区别。\n\n> \t\n> 下面通过一个例子来展示。\n\n**父组件：**\t\n\t\n\t<div class=\"slot-righ\">\n                <p>22222</p>\n                <Slo>\n                    <div class=\"con\" slot=\"up\">\n                        111111\n                    </div>\n                </Slo>\n            </div>\n\t\t\n**子组件：**\n\t\n\t<div class=\"sol\">\n        <p>11111</p>\n        <slot name=\"up\"></slot>//具名插槽\n      </div>\n\n- **作用域插槽| 带数据的插槽**\n\n\t- 最后，就是我们的作用域插槽。这个稍微难理解一点。官方叫它作用域插槽，实际上，对比前面两种插槽，我们可以叫它带数据的插槽。什么意思呢，就是前面两种，都是在组件的模板里面写\n\n> 下面通过一个例子来展示。\n\n**父组件：**\t\n\n\t<div class=\"slot-righ\">\n                    <p>22222</p>\n                    <Slo>\n                        <div class=\"con\" slot-scope=\"user\">//父组件拿到数据\n                            {{user.data}}\n                        </div>\n                    </Slo>\n                </div>\n\n**子组件：**\n\n\t<template>\n\t  <div class=\"sol\">\n\t    <p>11111</p>\n\t    <slot :data=\"data\"></slot>//这里再插槽上绑定数据\n\t  </div>\n\t</template>\n\t<script>\n\t\texport default {\n\t\t  data(){\n\t\t    return {\n\t\t      data:11111111\n\t\t    }\n\t\t  }\n\t\t}\n\t</script>\n\n> #### 正因为作用域插槽绑定了一套数据，父组件可以拿来用于是，情况就变成了这样：样式父组件说了算，但内容可以显示子组件插槽绑定的。\n","slug":"vue slot-scope","published":1,"updated":"2019-01-26T06:58:37.138Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam7u002mn4wd0qxnl7mr","content":"<h1 id=\"Vue-slot-scope的理解（适合初学者）\"><a href=\"#Vue-slot-scope的理解（适合初学者）\" class=\"headerlink\" title=\"Vue slot-scope的理解（适合初学者）\"></a>Vue slot-scope的理解（适合初学者）</h1><blockquote>\n<p>1/26/2019 2:58:04 PM </p>\n</blockquote>\n<hr>\n<blockquote>\n<h5 id=\"Vue中关于插槽的文档说明很短，语言又写的很凝练，再加上其和方法，数据，计算机等常用选项在使用频率，使用先后上的差别，这就有可能造成初次接触插槽的开发者容易产生“算了吧，回头再学，反正已经可以写基础组件了”的想法，于是就关闭了VUE的说明文档。\"><a href=\"#Vue中关于插槽的文档说明很短，语言又写的很凝练，再加上其和方法，数据，计算机等常用选项在使用频率，使用先后上的差别，这就有可能造成初次接触插槽的开发者容易产生“算了吧，回头再学，反正已经可以写基础组件了”的想法，于是就关闭了VUE的说明文档。\" class=\"headerlink\" title=\"Vue中关于插槽的文档说明很短，语言又写的很凝练，再加上其和方法，数据，计算机等常用选项在使用频率，使用先后上的差别，这就有可能造成初次接触插槽的开发者容易产生“算了吧，回头再学，反正已经可以写基础组件了”的想法，于是就关闭了VUE的说明文档。\"></a>Vue中关于插槽的文档说明很短，语言又写的很凝练，再加上其和方法，数据，计算机等常用选项在使用频率，使用先后上的差别，这就有可能造成初次接触插槽的开发者容易产生“算了吧，回头再学，反正已经可以写基础组件了”的想法，于是就关闭了VUE的说明文档。</h5></blockquote>\n<blockquote>\n<h3 id=\"实际上，插槽的概念很简单\"><a href=\"#实际上，插槽的概念很简单\" class=\"headerlink\" title=\"实际上，插槽的概念很简单\"></a>实际上，插槽的概念很简单</h3></blockquote>\n<h3 id=\"slot\"><a href=\"#slot\" class=\"headerlink\" title=\"slot\"></a>slot</h3><ul>\n<li><strong>概念：插槽，也就是槽，是组件的一块HTML模板，这块模板显示不显示，以及怎样显示由父组件来决定。</strong></li>\n</ul>\n<h3 id=\"插槽可以分为3部分来说\"><a href=\"#插槽可以分为3部分来说\" class=\"headerlink\" title=\"插槽可以分为3部分来说\"></a>插槽可以分为3部分来说</h3><ul>\n<li><p><strong>单个插槽</strong></p>\n<hr>\n<ul>\n<li><h4 id=\"首先是单个插槽，单个插槽的英文VUE的官方叫法，但是其实也可以叫它默认插槽，或者与具名插槽相对，我们可以叫它匿名插槽。因为它不用设置名称属性。\"><a href=\"#首先是单个插槽，单个插槽的英文VUE的官方叫法，但是其实也可以叫它默认插槽，或者与具名插槽相对，我们可以叫它匿名插槽。因为它不用设置名称属性。\" class=\"headerlink\" title=\"首先是单个插槽，单个插槽的英文VUE的官方叫法，但是其实也可以叫它默认插槽，或者与具名插槽相对，我们可以叫它匿名插槽。因为它不用设置名称属性。\"></a>首先是单个插槽，单个插槽的英文VUE的官方叫法，但是其实也可以叫它默认插槽，或者与具名插槽相对，我们可以叫它匿名插槽。因为它不用设置名称属性。</h4></li>\n<li><h4 id=\"单个插槽可以放置在组件的任意位置，但是就像它的名字一样，一个组件中只能有一个该类插槽。相对应的，具名插槽就可以有很多个，只要名字（名称属性）不同就可以了。\"><a href=\"#单个插槽可以放置在组件的任意位置，但是就像它的名字一样，一个组件中只能有一个该类插槽。相对应的，具名插槽就可以有很多个，只要名字（名称属性）不同就可以了。\" class=\"headerlink\" title=\"单个插槽可以放置在组件的任意位置，但是就像它的名字一样，一个组件中只能有一个该类插槽。相对应的，具名插槽就可以有很多个，只要名字（名称属性）不同就可以了。\"></a>单个插槽可以放置在组件的任意位置，但是就像它的名字一样，一个组件中只能有一个该类插槽。相对应的，具名插槽就可以有很多个，只要名字（名称属性）不同就可以了。</h4></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<pre><code>下面通过一个例子来展示。\n</code></pre></blockquote>\n<p><strong>父组件：</strong></p>\n<pre><code>    &lt;div class=&quot;slot-righ&quot;&gt;\n                &lt;p&gt;22222&lt;/p&gt;\n                &lt;Slo&gt;\n                    &lt;div class=&quot;con&quot;&gt;\n                        111111\n                    &lt;/div&gt;\n                &lt;/Slo&gt;\n            &lt;/div&gt;\n</code></pre><p><strong>子组件：</strong></p>\n<pre><code>    &lt;div class=&quot;sol&quot;&gt;\n        &lt;p&gt;11111&lt;/p&gt;\n        &lt;slot&gt;&lt;/slot&gt;\n      &lt;/div&gt;\n</code></pre><ul>\n<li><strong>具名插槽</strong><ul>\n<li>匿名插槽没有名称属性，所以是匿名插槽，那么，插槽加了名称属性，就变成了具名插槽。具名插槽可以在一个组件中出现Ñ次，出现在不同的位置。下面的例子，一个就是有两个具名插槽状语从句：单个插槽的组件，这三个插槽被父组件用同一套的CSS样式显示了出来，不同的是内容上略有区别。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>下面通过一个例子来展示。</p>\n</blockquote>\n<p><strong>父组件：</strong>    </p>\n<pre><code>&lt;div class=&quot;slot-righ&quot;&gt;\n            &lt;p&gt;22222&lt;/p&gt;\n            &lt;Slo&gt;\n                &lt;div class=&quot;con&quot; slot=&quot;up&quot;&gt;\n                    111111\n                &lt;/div&gt;\n            &lt;/Slo&gt;\n        &lt;/div&gt;\n</code></pre><p><strong>子组件：</strong></p>\n<pre><code>&lt;div class=&quot;sol&quot;&gt;\n    &lt;p&gt;11111&lt;/p&gt;\n    &lt;slot name=&quot;up&quot;&gt;&lt;/slot&gt;//具名插槽\n  &lt;/div&gt;\n</code></pre><ul>\n<li><p><strong>作用域插槽| 带数据的插槽</strong></p>\n<ul>\n<li>最后，就是我们的作用域插槽。这个稍微难理解一点。官方叫它作用域插槽，实际上，对比前面两种插槽，我们可以叫它带数据的插槽。什么意思呢，就是前面两种，都是在组件的模板里面写</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>下面通过一个例子来展示。</p>\n</blockquote>\n<p><strong>父组件：</strong>    </p>\n<pre><code>&lt;div class=&quot;slot-righ&quot;&gt;\n                &lt;p&gt;22222&lt;/p&gt;\n                &lt;Slo&gt;\n                    &lt;div class=&quot;con&quot; slot-scope=&quot;user&quot;&gt;//父组件拿到数据\n                        {{user.data}}\n                    &lt;/div&gt;\n                &lt;/Slo&gt;\n            &lt;/div&gt;\n</code></pre><p><strong>子组件：</strong></p>\n<pre><code>&lt;template&gt;\n  &lt;div class=&quot;sol&quot;&gt;\n    &lt;p&gt;11111&lt;/p&gt;\n    &lt;slot :data=&quot;data&quot;&gt;&lt;/slot&gt;//这里再插槽上绑定数据\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\n    export default {\n      data(){\n        return {\n          data:11111111\n        }\n      }\n    }\n&lt;/script&gt;\n</code></pre><blockquote>\n<h4 id=\"正因为作用域插槽绑定了一套数据，父组件可以拿来用于是，情况就变成了这样：样式父组件说了算，但内容可以显示子组件插槽绑定的。\"><a href=\"#正因为作用域插槽绑定了一套数据，父组件可以拿来用于是，情况就变成了这样：样式父组件说了算，但内容可以显示子组件插槽绑定的。\" class=\"headerlink\" title=\"正因为作用域插槽绑定了一套数据，父组件可以拿来用于是，情况就变成了这样：样式父组件说了算，但内容可以显示子组件插槽绑定的。\"></a>正因为作用域插槽绑定了一套数据，父组件可以拿来用于是，情况就变成了这样：样式父组件说了算，但内容可以显示子组件插槽绑定的。</h4></blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Vue-slot-scope的理解（适合初学者）\"><a href=\"#Vue-slot-scope的理解（适合初学者）\" class=\"headerlink\" title=\"Vue slot-scope的理解（适合初学者）\"></a>Vue slot-scope的理解（适合初学者）</h1><blockquote>\n<p>1/26/2019 2:58:04 PM </p>\n</blockquote>\n<hr>\n<blockquote>\n<h5 id=\"Vue中关于插槽的文档说明很短，语言又写的很凝练，再加上其和方法，数据，计算机等常用选项在使用频率，使用先后上的差别，这就有可能造成初次接触插槽的开发者容易产生“算了吧，回头再学，反正已经可以写基础组件了”的想法，于是就关闭了VUE的说明文档。\"><a href=\"#Vue中关于插槽的文档说明很短，语言又写的很凝练，再加上其和方法，数据，计算机等常用选项在使用频率，使用先后上的差别，这就有可能造成初次接触插槽的开发者容易产生“算了吧，回头再学，反正已经可以写基础组件了”的想法，于是就关闭了VUE的说明文档。\" class=\"headerlink\" title=\"Vue中关于插槽的文档说明很短，语言又写的很凝练，再加上其和方法，数据，计算机等常用选项在使用频率，使用先后上的差别，这就有可能造成初次接触插槽的开发者容易产生“算了吧，回头再学，反正已经可以写基础组件了”的想法，于是就关闭了VUE的说明文档。\"></a>Vue中关于插槽的文档说明很短，语言又写的很凝练，再加上其和方法，数据，计算机等常用选项在使用频率，使用先后上的差别，这就有可能造成初次接触插槽的开发者容易产生“算了吧，回头再学，反正已经可以写基础组件了”的想法，于是就关闭了VUE的说明文档。</h5></blockquote>\n<blockquote>\n<h3 id=\"实际上，插槽的概念很简单\"><a href=\"#实际上，插槽的概念很简单\" class=\"headerlink\" title=\"实际上，插槽的概念很简单\"></a>实际上，插槽的概念很简单</h3></blockquote>\n<h3 id=\"slot\"><a href=\"#slot\" class=\"headerlink\" title=\"slot\"></a>slot</h3><ul>\n<li><strong>概念：插槽，也就是槽，是组件的一块HTML模板，这块模板显示不显示，以及怎样显示由父组件来决定。</strong></li>\n</ul>\n<h3 id=\"插槽可以分为3部分来说\"><a href=\"#插槽可以分为3部分来说\" class=\"headerlink\" title=\"插槽可以分为3部分来说\"></a>插槽可以分为3部分来说</h3><ul>\n<li><p><strong>单个插槽</strong></p>\n<hr>\n<ul>\n<li><h4 id=\"首先是单个插槽，单个插槽的英文VUE的官方叫法，但是其实也可以叫它默认插槽，或者与具名插槽相对，我们可以叫它匿名插槽。因为它不用设置名称属性。\"><a href=\"#首先是单个插槽，单个插槽的英文VUE的官方叫法，但是其实也可以叫它默认插槽，或者与具名插槽相对，我们可以叫它匿名插槽。因为它不用设置名称属性。\" class=\"headerlink\" title=\"首先是单个插槽，单个插槽的英文VUE的官方叫法，但是其实也可以叫它默认插槽，或者与具名插槽相对，我们可以叫它匿名插槽。因为它不用设置名称属性。\"></a>首先是单个插槽，单个插槽的英文VUE的官方叫法，但是其实也可以叫它默认插槽，或者与具名插槽相对，我们可以叫它匿名插槽。因为它不用设置名称属性。</h4></li>\n<li><h4 id=\"单个插槽可以放置在组件的任意位置，但是就像它的名字一样，一个组件中只能有一个该类插槽。相对应的，具名插槽就可以有很多个，只要名字（名称属性）不同就可以了。\"><a href=\"#单个插槽可以放置在组件的任意位置，但是就像它的名字一样，一个组件中只能有一个该类插槽。相对应的，具名插槽就可以有很多个，只要名字（名称属性）不同就可以了。\" class=\"headerlink\" title=\"单个插槽可以放置在组件的任意位置，但是就像它的名字一样，一个组件中只能有一个该类插槽。相对应的，具名插槽就可以有很多个，只要名字（名称属性）不同就可以了。\"></a>单个插槽可以放置在组件的任意位置，但是就像它的名字一样，一个组件中只能有一个该类插槽。相对应的，具名插槽就可以有很多个，只要名字（名称属性）不同就可以了。</h4></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<pre><code>下面通过一个例子来展示。\n</code></pre></blockquote>\n<p><strong>父组件：</strong></p>\n<pre><code>    &lt;div class=&quot;slot-righ&quot;&gt;\n                &lt;p&gt;22222&lt;/p&gt;\n                &lt;Slo&gt;\n                    &lt;div class=&quot;con&quot;&gt;\n                        111111\n                    &lt;/div&gt;\n                &lt;/Slo&gt;\n            &lt;/div&gt;\n</code></pre><p><strong>子组件：</strong></p>\n<pre><code>    &lt;div class=&quot;sol&quot;&gt;\n        &lt;p&gt;11111&lt;/p&gt;\n        &lt;slot&gt;&lt;/slot&gt;\n      &lt;/div&gt;\n</code></pre><ul>\n<li><strong>具名插槽</strong><ul>\n<li>匿名插槽没有名称属性，所以是匿名插槽，那么，插槽加了名称属性，就变成了具名插槽。具名插槽可以在一个组件中出现Ñ次，出现在不同的位置。下面的例子，一个就是有两个具名插槽状语从句：单个插槽的组件，这三个插槽被父组件用同一套的CSS样式显示了出来，不同的是内容上略有区别。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>下面通过一个例子来展示。</p>\n</blockquote>\n<p><strong>父组件：</strong>    </p>\n<pre><code>&lt;div class=&quot;slot-righ&quot;&gt;\n            &lt;p&gt;22222&lt;/p&gt;\n            &lt;Slo&gt;\n                &lt;div class=&quot;con&quot; slot=&quot;up&quot;&gt;\n                    111111\n                &lt;/div&gt;\n            &lt;/Slo&gt;\n        &lt;/div&gt;\n</code></pre><p><strong>子组件：</strong></p>\n<pre><code>&lt;div class=&quot;sol&quot;&gt;\n    &lt;p&gt;11111&lt;/p&gt;\n    &lt;slot name=&quot;up&quot;&gt;&lt;/slot&gt;//具名插槽\n  &lt;/div&gt;\n</code></pre><ul>\n<li><p><strong>作用域插槽| 带数据的插槽</strong></p>\n<ul>\n<li>最后，就是我们的作用域插槽。这个稍微难理解一点。官方叫它作用域插槽，实际上，对比前面两种插槽，我们可以叫它带数据的插槽。什么意思呢，就是前面两种，都是在组件的模板里面写</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>下面通过一个例子来展示。</p>\n</blockquote>\n<p><strong>父组件：</strong>    </p>\n<pre><code>&lt;div class=&quot;slot-righ&quot;&gt;\n                &lt;p&gt;22222&lt;/p&gt;\n                &lt;Slo&gt;\n                    &lt;div class=&quot;con&quot; slot-scope=&quot;user&quot;&gt;//父组件拿到数据\n                        {{user.data}}\n                    &lt;/div&gt;\n                &lt;/Slo&gt;\n            &lt;/div&gt;\n</code></pre><p><strong>子组件：</strong></p>\n<pre><code>&lt;template&gt;\n  &lt;div class=&quot;sol&quot;&gt;\n    &lt;p&gt;11111&lt;/p&gt;\n    &lt;slot :data=&quot;data&quot;&gt;&lt;/slot&gt;//这里再插槽上绑定数据\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\n    export default {\n      data(){\n        return {\n          data:11111111\n        }\n      }\n    }\n&lt;/script&gt;\n</code></pre><blockquote>\n<h4 id=\"正因为作用域插槽绑定了一套数据，父组件可以拿来用于是，情况就变成了这样：样式父组件说了算，但内容可以显示子组件插槽绑定的。\"><a href=\"#正因为作用域插槽绑定了一套数据，父组件可以拿来用于是，情况就变成了这样：样式父组件说了算，但内容可以显示子组件插槽绑定的。\" class=\"headerlink\" title=\"正因为作用域插槽绑定了一套数据，父组件可以拿来用于是，情况就变成了这样：样式父组件说了算，但内容可以显示子组件插槽绑定的。\"></a>正因为作用域插槽绑定了一套数据，父组件可以拿来用于是，情况就变成了这样：样式父组件说了算，但内容可以显示子组件插槽绑定的。</h4></blockquote>\n"},{"title":"vue自定义指令","date":"2019-04-02T02:28:46.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"## vue自定义指令\n\n> 注册全局指令\n\n\t// 注册一个全局自定义指令 `v-focus`\n\tVue.directive('focus', {\n\t  // 当被绑定的元素插入到 DOM 中时……\n\t  inserted: function (el) {\n\t    // 聚焦元素\n\t    el.focus()\n\t  }\n\t})\n\n> 注册局部指令\n\n\tdirectives: {\n\t  focus: {\n\t    // 指令的定义\n\t    inserted: function (el) {\n\t      el.focus()\n\t    }\n\t  }\n\t}\n\n> 使用方式\n\n\t<input v-focus>\n\n## 钩子函数\n\n**一个指令定义对象可以提供如下几个钩子函数 (均为可选)：**\n\n> bind\n\n**只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。**\n\n> inserted\n\n**被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。**\n\n> update\n\n**所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。**\n\n> componentUpdated\n\n**指令所在组件的 VNode 及其子 VNode 全部更新后调用。**\n\n> unbind\n\n**只调用一次，指令与元素解绑时调用。**","source":"_posts/vue-directive.md","raw":"---\ntitle: vue自定义指令\ndate: '4/2/2019 10:28:46 AM '\ntag: ['js', 'vue']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n## vue自定义指令\n\n> 注册全局指令\n\n\t// 注册一个全局自定义指令 `v-focus`\n\tVue.directive('focus', {\n\t  // 当被绑定的元素插入到 DOM 中时……\n\t  inserted: function (el) {\n\t    // 聚焦元素\n\t    el.focus()\n\t  }\n\t})\n\n> 注册局部指令\n\n\tdirectives: {\n\t  focus: {\n\t    // 指令的定义\n\t    inserted: function (el) {\n\t      el.focus()\n\t    }\n\t  }\n\t}\n\n> 使用方式\n\n\t<input v-focus>\n\n## 钩子函数\n\n**一个指令定义对象可以提供如下几个钩子函数 (均为可选)：**\n\n> bind\n\n**只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。**\n\n> inserted\n\n**被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。**\n\n> update\n\n**所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。**\n\n> componentUpdated\n\n**指令所在组件的 VNode 及其子 VNode 全部更新后调用。**\n\n> unbind\n\n**只调用一次，指令与元素解绑时调用。**","slug":"vue-directive","published":1,"updated":"2019-04-02T02:42:58.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam7v002on4wdnva3m3er","content":"<h2 id=\"vue自定义指令\"><a href=\"#vue自定义指令\" class=\"headerlink\" title=\"vue自定义指令\"></a>vue自定义指令</h2><blockquote>\n<p>注册全局指令</p>\n</blockquote>\n<pre><code>// 注册一个全局自定义指令 `v-focus`\nVue.directive(&#39;focus&#39;, {\n  // 当被绑定的元素插入到 DOM 中时……\n  inserted: function (el) {\n    // 聚焦元素\n    el.focus()\n  }\n})\n</code></pre><blockquote>\n<p>注册局部指令</p>\n</blockquote>\n<pre><code>directives: {\n  focus: {\n    // 指令的定义\n    inserted: function (el) {\n      el.focus()\n    }\n  }\n}\n</code></pre><blockquote>\n<p>使用方式</p>\n</blockquote>\n<pre><code>&lt;input v-focus&gt;\n</code></pre><h2 id=\"钩子函数\"><a href=\"#钩子函数\" class=\"headerlink\" title=\"钩子函数\"></a>钩子函数</h2><p><strong>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</strong></p>\n<blockquote>\n<p>bind</p>\n</blockquote>\n<p><strong>只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</strong></p>\n<blockquote>\n<p>inserted</p>\n</blockquote>\n<p><strong>被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</strong></p>\n<blockquote>\n<p>update</p>\n</blockquote>\n<p><strong>所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</strong></p>\n<blockquote>\n<p>componentUpdated</p>\n</blockquote>\n<p><strong>指令所在组件的 VNode 及其子 VNode 全部更新后调用。</strong></p>\n<blockquote>\n<p>unbind</p>\n</blockquote>\n<p><strong>只调用一次，指令与元素解绑时调用。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"vue自定义指令\"><a href=\"#vue自定义指令\" class=\"headerlink\" title=\"vue自定义指令\"></a>vue自定义指令</h2><blockquote>\n<p>注册全局指令</p>\n</blockquote>\n<pre><code>// 注册一个全局自定义指令 `v-focus`\nVue.directive(&#39;focus&#39;, {\n  // 当被绑定的元素插入到 DOM 中时……\n  inserted: function (el) {\n    // 聚焦元素\n    el.focus()\n  }\n})\n</code></pre><blockquote>\n<p>注册局部指令</p>\n</blockquote>\n<pre><code>directives: {\n  focus: {\n    // 指令的定义\n    inserted: function (el) {\n      el.focus()\n    }\n  }\n}\n</code></pre><blockquote>\n<p>使用方式</p>\n</blockquote>\n<pre><code>&lt;input v-focus&gt;\n</code></pre><h2 id=\"钩子函数\"><a href=\"#钩子函数\" class=\"headerlink\" title=\"钩子函数\"></a>钩子函数</h2><p><strong>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</strong></p>\n<blockquote>\n<p>bind</p>\n</blockquote>\n<p><strong>只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</strong></p>\n<blockquote>\n<p>inserted</p>\n</blockquote>\n<p><strong>被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</strong></p>\n<blockquote>\n<p>update</p>\n</blockquote>\n<p><strong>所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</strong></p>\n<blockquote>\n<p>componentUpdated</p>\n</blockquote>\n<p><strong>指令所在组件的 VNode 及其子 VNode 全部更新后调用。</strong></p>\n<blockquote>\n<p>unbind</p>\n</blockquote>\n<p><strong>只调用一次，指令与元素解绑时调用。</strong></p>\n"},{"title":"vue的路由导航守卫","date":"2019-04-02T01:26:50.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"## vue的路由导航守卫\n\n**vue-router提供的导航守卫主要是用来通过跳转和取消的方式守卫导航。一共有三种植入路由导航的过程**\n\n> 全局前置(后置)守卫\n\n\tconst router = new VueRouter({ ... })\n\n\trouter.beforeEach((to, from, next) => { // 前置\n\t  // ...\n\t})\n\n\trouter.afterEach((to, from) => { // 后置\n\t  // ...\n\t})\n\n> 路由独享守卫\n\n\n\tconst router = new VueRouter({\n\t  routes: [\n\t    {\n\t      path: '/foo',\n\t      component: Foo,\n\t      beforeEnter: (to, from, next) => {\n\t        // ...\n\t      }\n\t    }\n\t  ]\n\t})\n\n> 组件内的守卫\n\n- beforeRouteEnter\n- beforeRouteUpdate\n- beforeRouteLeave\n\n----------\n\n\n\tconst Foo = {\n\t  template: `...`,\n\t  beforeRouteEnter (to, from, next) {\n\t    // 在渲染该组件的对应路由被 confirm 前调用\n\t    // 不！能！获取组件实例 `this`\n\t    // 因为当守卫执行前，组件实例还没被创建\n\t  },\n\t  beforeRouteUpdate (to, from, next) {\n\t    // 在当前路由改变，但是该组件被复用时调用\n\t    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，\n\t    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。\n\t    // 可以访问组件实例 `this`\n\t  },\n\t  beforeRouteLeave (to, from, next) {\n\t    // 导航离开该组件的对应路由时调用\n\t    // 可以访问组件实例 `this`\n\t  }\n\t}\n\n\n**beforeRouteEnter 守卫 不能 访问 this，因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。**\n\n**不过，你可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。**\n\n\tbeforeRouteEnter (to, from, next) {\n\t  next(vm => {\n\t    // 通过 `vm` 访问组件实例\n\t  })\n\t}\n\n**注意 beforeRouteEnter 是支持给 next 传递回调的唯一守卫。对于 beforeRouteUpdate 和 beforeRouteLeave 来说，this 已经可用了，所以不支持传递回调，因为没有必要了。**\n\n\tbeforeRouteUpdate (to, from, next) {\n\t  // just use `this`\n\t  this.name = to.params.name\n\t  next()\n\t}\n\n**这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消。**\n\n\tbeforeRouteLeave (to, from , next) {\n\t  const answer = window.confirm('Do you really want to leave? you have unsaved changes!')\n\t  if (answer) {\n\t    next()\n\t  } else {\n\t    next(false)\n\t  }\n\t}","source":"_posts/vue-router-beforeEach.md","raw":"---\ntitle: vue的路由导航守卫\ndate: '4/2/2019 9:26:50 AM '\ntag: ['js', 'vue']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n## vue的路由导航守卫\n\n**vue-router提供的导航守卫主要是用来通过跳转和取消的方式守卫导航。一共有三种植入路由导航的过程**\n\n> 全局前置(后置)守卫\n\n\tconst router = new VueRouter({ ... })\n\n\trouter.beforeEach((to, from, next) => { // 前置\n\t  // ...\n\t})\n\n\trouter.afterEach((to, from) => { // 后置\n\t  // ...\n\t})\n\n> 路由独享守卫\n\n\n\tconst router = new VueRouter({\n\t  routes: [\n\t    {\n\t      path: '/foo',\n\t      component: Foo,\n\t      beforeEnter: (to, from, next) => {\n\t        // ...\n\t      }\n\t    }\n\t  ]\n\t})\n\n> 组件内的守卫\n\n- beforeRouteEnter\n- beforeRouteUpdate\n- beforeRouteLeave\n\n----------\n\n\n\tconst Foo = {\n\t  template: `...`,\n\t  beforeRouteEnter (to, from, next) {\n\t    // 在渲染该组件的对应路由被 confirm 前调用\n\t    // 不！能！获取组件实例 `this`\n\t    // 因为当守卫执行前，组件实例还没被创建\n\t  },\n\t  beforeRouteUpdate (to, from, next) {\n\t    // 在当前路由改变，但是该组件被复用时调用\n\t    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，\n\t    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。\n\t    // 可以访问组件实例 `this`\n\t  },\n\t  beforeRouteLeave (to, from, next) {\n\t    // 导航离开该组件的对应路由时调用\n\t    // 可以访问组件实例 `this`\n\t  }\n\t}\n\n\n**beforeRouteEnter 守卫 不能 访问 this，因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。**\n\n**不过，你可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。**\n\n\tbeforeRouteEnter (to, from, next) {\n\t  next(vm => {\n\t    // 通过 `vm` 访问组件实例\n\t  })\n\t}\n\n**注意 beforeRouteEnter 是支持给 next 传递回调的唯一守卫。对于 beforeRouteUpdate 和 beforeRouteLeave 来说，this 已经可用了，所以不支持传递回调，因为没有必要了。**\n\n\tbeforeRouteUpdate (to, from, next) {\n\t  // just use `this`\n\t  this.name = to.params.name\n\t  next()\n\t}\n\n**这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消。**\n\n\tbeforeRouteLeave (to, from , next) {\n\t  const answer = window.confirm('Do you really want to leave? you have unsaved changes!')\n\t  if (answer) {\n\t    next()\n\t  } else {\n\t    next(false)\n\t  }\n\t}","slug":"vue-router-beforeEach","published":1,"updated":"2019-04-02T01:26:52.783Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam7x002rn4wd3jw98hum","content":"<h2 id=\"vue的路由导航守卫\"><a href=\"#vue的路由导航守卫\" class=\"headerlink\" title=\"vue的路由导航守卫\"></a>vue的路由导航守卫</h2><p><strong>vue-router提供的导航守卫主要是用来通过跳转和取消的方式守卫导航。一共有三种植入路由导航的过程</strong></p>\n<blockquote>\n<p>全局前置(后置)守卫</p>\n</blockquote>\n<pre><code>const router = new VueRouter({ ... })\n\nrouter.beforeEach((to, from, next) =&gt; { // 前置\n  // ...\n})\n\nrouter.afterEach((to, from) =&gt; { // 后置\n  // ...\n})\n</code></pre><blockquote>\n<p>路由独享守卫</p>\n</blockquote>\n<pre><code>const router = new VueRouter({\n  routes: [\n    {\n      path: &#39;/foo&#39;,\n      component: Foo,\n      beforeEnter: (to, from, next) =&gt; {\n        // ...\n      }\n    }\n  ]\n})\n</code></pre><blockquote>\n<p>组件内的守卫</p>\n</blockquote>\n<ul>\n<li>beforeRouteEnter</li>\n<li>beforeRouteUpdate</li>\n<li>beforeRouteLeave</li>\n</ul>\n<hr>\n<pre><code>const Foo = {\n  template: `...`,\n  beforeRouteEnter (to, from, next) {\n    // 在渲染该组件的对应路由被 confirm 前调用\n    // 不！能！获取组件实例 `this`\n    // 因为当守卫执行前，组件实例还没被创建\n  },\n  beforeRouteUpdate (to, from, next) {\n    // 在当前路由改变，但是该组件被复用时调用\n    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，\n    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。\n    // 可以访问组件实例 `this`\n  },\n  beforeRouteLeave (to, from, next) {\n    // 导航离开该组件的对应路由时调用\n    // 可以访问组件实例 `this`\n  }\n}\n</code></pre><p><strong>beforeRouteEnter 守卫 不能 访问 this，因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。</strong></p>\n<p><strong>不过，你可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</strong></p>\n<pre><code>beforeRouteEnter (to, from, next) {\n  next(vm =&gt; {\n    // 通过 `vm` 访问组件实例\n  })\n}\n</code></pre><p><strong>注意 beforeRouteEnter 是支持给 next 传递回调的唯一守卫。对于 beforeRouteUpdate 和 beforeRouteLeave 来说，this 已经可用了，所以不支持传递回调，因为没有必要了。</strong></p>\n<pre><code>beforeRouteUpdate (to, from, next) {\n  // just use `this`\n  this.name = to.params.name\n  next()\n}\n</code></pre><p><strong>这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消。</strong></p>\n<pre><code>beforeRouteLeave (to, from , next) {\n  const answer = window.confirm(&#39;Do you really want to leave? you have unsaved changes!&#39;)\n  if (answer) {\n    next()\n  } else {\n    next(false)\n  }\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"vue的路由导航守卫\"><a href=\"#vue的路由导航守卫\" class=\"headerlink\" title=\"vue的路由导航守卫\"></a>vue的路由导航守卫</h2><p><strong>vue-router提供的导航守卫主要是用来通过跳转和取消的方式守卫导航。一共有三种植入路由导航的过程</strong></p>\n<blockquote>\n<p>全局前置(后置)守卫</p>\n</blockquote>\n<pre><code>const router = new VueRouter({ ... })\n\nrouter.beforeEach((to, from, next) =&gt; { // 前置\n  // ...\n})\n\nrouter.afterEach((to, from) =&gt; { // 后置\n  // ...\n})\n</code></pre><blockquote>\n<p>路由独享守卫</p>\n</blockquote>\n<pre><code>const router = new VueRouter({\n  routes: [\n    {\n      path: &#39;/foo&#39;,\n      component: Foo,\n      beforeEnter: (to, from, next) =&gt; {\n        // ...\n      }\n    }\n  ]\n})\n</code></pre><blockquote>\n<p>组件内的守卫</p>\n</blockquote>\n<ul>\n<li>beforeRouteEnter</li>\n<li>beforeRouteUpdate</li>\n<li>beforeRouteLeave</li>\n</ul>\n<hr>\n<pre><code>const Foo = {\n  template: `...`,\n  beforeRouteEnter (to, from, next) {\n    // 在渲染该组件的对应路由被 confirm 前调用\n    // 不！能！获取组件实例 `this`\n    // 因为当守卫执行前，组件实例还没被创建\n  },\n  beforeRouteUpdate (to, from, next) {\n    // 在当前路由改变，但是该组件被复用时调用\n    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，\n    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。\n    // 可以访问组件实例 `this`\n  },\n  beforeRouteLeave (to, from, next) {\n    // 导航离开该组件的对应路由时调用\n    // 可以访问组件实例 `this`\n  }\n}\n</code></pre><p><strong>beforeRouteEnter 守卫 不能 访问 this，因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。</strong></p>\n<p><strong>不过，你可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</strong></p>\n<pre><code>beforeRouteEnter (to, from, next) {\n  next(vm =&gt; {\n    // 通过 `vm` 访问组件实例\n  })\n}\n</code></pre><p><strong>注意 beforeRouteEnter 是支持给 next 传递回调的唯一守卫。对于 beforeRouteUpdate 和 beforeRouteLeave 来说，this 已经可用了，所以不支持传递回调，因为没有必要了。</strong></p>\n<pre><code>beforeRouteUpdate (to, from, next) {\n  // just use `this`\n  this.name = to.params.name\n  next()\n}\n</code></pre><p><strong>这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消。</strong></p>\n<pre><code>beforeRouteLeave (to, from , next) {\n  const answer = window.confirm(&#39;Do you really want to leave? you have unsaved changes!&#39;)\n  if (answer) {\n    next()\n  } else {\n    next(false)\n  }\n}\n</code></pre>"},{"title":"vue和react的区别","date":"2019-04-01T04:00:53.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"## vue和react的区别\n\n> react和vue都是组件化，整体功能类似，但是设计思路有有所不同，\n\n\n### 出身\n\n> react\n\n**React是由Facebook创建的JavaScript UI框架，它的诞生改变了JavaScript世界，最大的一个改变就是React推广了Virtual DOM， 并且创造了新的语法 – JSX，JSX 允许在JavaScript中写html代码。**\n\n> vue\n\n**Vue是由尤大大开发的一个MVVM框架，它采用的是模板系统而不是JSX。**\n\n### 模板渲染方式不同\n\n> react\n\n**React是通过JSX来渲染模板，React通过原生JS实现模板中的常见语法，比如说条件啊、循环啊、三元运算符啊等，都是通过JS语法实现**\n\n> vue\n\n**vue是通过扩展的HTML来进行模板的渲染，Vue是在和组件代码分离的单独模板中，通过指令v-if、v-for等实现**\n\n### Virtual DOM\n\n> react\n\n**React默认是通过比较引用得方式进行，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。如果想避免不必要的子组件重新渲染，你需要在所有可能的地方使用PureComponent，或者手动实现shouldComponentUpdate方法。但是Vue中，你可以认定它是默认的优化。**\n\n> vue\n\n**Vue可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，由于vue会跟踪每一个组件的依赖收集，通过setter / getter 以及一些函数的劫持，能够精确地知道变化，并在编译过程标记了static静态节点，在接下来新的Virtual DOM 并且和原来旧的 Virtual DOM进行比较时候，跳过static静态节点。所以不需要重新渲染整个组件树。**\n\n### 数据流\n\n### Vuex 和 Redux\n\n> react\n\n**在React中，我们需要每一个组件都引入connect，目的就是把props和dispatch连接起来。redux只能通过dispatch，然后在reducer里，接收到action，通过判断action的type，从而进行对应的操作，redux不能直接调用reducer进行修改！！**\n\n> vue\n\n**在vuex中，我们可以通过在main.js中，引入 store文件夹，并把store挂载到new Vue实例中，这样我们可以直接通过$store灵活使用。**\n\n> - 你可以通过dispatch和commit进行更新数据，\n> - 通过this.$store.state.xx读取数据\n> - 你可以通过mapState / mapActions 进行vuex的操作\n\n\n## 总结\n\n----------\n\n\n> - 组件的创建方式不一样\n> \t- react使用class和函数创建组件【只有局部】\n> \t- vue则使用vue的实例的components方法和components属性【有局部和全局一说】\n> - 在react中没有指令，计算属性，watch监听，computed，这些内容\n> - 在react组件中只有几个概念，生命周期，state。props。合成事件\n> - 在vue中可以使用v-modle完成数据的双向绑定，而在react并没有指令的概念，所以使用受控组件代替\n> - 在vue中使用getter，setter拦截器，处理数据的绑定，而react则使用的是setState手动触发\n\n----------\n\n\n\n\n","source":"_posts/vue-react-diff.md","raw":"---\ntitle: vue和react的区别\ndate: '4/1/2019 12:00:53 PM '\ntag: ['react', 'vue']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n## vue和react的区别\n\n> react和vue都是组件化，整体功能类似，但是设计思路有有所不同，\n\n\n### 出身\n\n> react\n\n**React是由Facebook创建的JavaScript UI框架，它的诞生改变了JavaScript世界，最大的一个改变就是React推广了Virtual DOM， 并且创造了新的语法 – JSX，JSX 允许在JavaScript中写html代码。**\n\n> vue\n\n**Vue是由尤大大开发的一个MVVM框架，它采用的是模板系统而不是JSX。**\n\n### 模板渲染方式不同\n\n> react\n\n**React是通过JSX来渲染模板，React通过原生JS实现模板中的常见语法，比如说条件啊、循环啊、三元运算符啊等，都是通过JS语法实现**\n\n> vue\n\n**vue是通过扩展的HTML来进行模板的渲染，Vue是在和组件代码分离的单独模板中，通过指令v-if、v-for等实现**\n\n### Virtual DOM\n\n> react\n\n**React默认是通过比较引用得方式进行，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。如果想避免不必要的子组件重新渲染，你需要在所有可能的地方使用PureComponent，或者手动实现shouldComponentUpdate方法。但是Vue中，你可以认定它是默认的优化。**\n\n> vue\n\n**Vue可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，由于vue会跟踪每一个组件的依赖收集，通过setter / getter 以及一些函数的劫持，能够精确地知道变化，并在编译过程标记了static静态节点，在接下来新的Virtual DOM 并且和原来旧的 Virtual DOM进行比较时候，跳过static静态节点。所以不需要重新渲染整个组件树。**\n\n### 数据流\n\n### Vuex 和 Redux\n\n> react\n\n**在React中，我们需要每一个组件都引入connect，目的就是把props和dispatch连接起来。redux只能通过dispatch，然后在reducer里，接收到action，通过判断action的type，从而进行对应的操作，redux不能直接调用reducer进行修改！！**\n\n> vue\n\n**在vuex中，我们可以通过在main.js中，引入 store文件夹，并把store挂载到new Vue实例中，这样我们可以直接通过$store灵活使用。**\n\n> - 你可以通过dispatch和commit进行更新数据，\n> - 通过this.$store.state.xx读取数据\n> - 你可以通过mapState / mapActions 进行vuex的操作\n\n\n## 总结\n\n----------\n\n\n> - 组件的创建方式不一样\n> \t- react使用class和函数创建组件【只有局部】\n> \t- vue则使用vue的实例的components方法和components属性【有局部和全局一说】\n> - 在react中没有指令，计算属性，watch监听，computed，这些内容\n> - 在react组件中只有几个概念，生命周期，state。props。合成事件\n> - 在vue中可以使用v-modle完成数据的双向绑定，而在react并没有指令的概念，所以使用受控组件代替\n> - 在vue中使用getter，setter拦截器，处理数据的绑定，而react则使用的是setState手动触发\n\n----------\n\n\n\n\n","slug":"vue-react-diff","published":1,"updated":"2019-04-02T03:48:02.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam7y002tn4wdh92jqgk5","content":"<h2 id=\"vue和react的区别\"><a href=\"#vue和react的区别\" class=\"headerlink\" title=\"vue和react的区别\"></a>vue和react的区别</h2><blockquote>\n<p>react和vue都是组件化，整体功能类似，但是设计思路有有所不同，</p>\n</blockquote>\n<h3 id=\"出身\"><a href=\"#出身\" class=\"headerlink\" title=\"出身\"></a>出身</h3><blockquote>\n<p>react</p>\n</blockquote>\n<p><strong>React是由Facebook创建的JavaScript UI框架，它的诞生改变了JavaScript世界，最大的一个改变就是React推广了Virtual DOM， 并且创造了新的语法 – JSX，JSX 允许在JavaScript中写html代码。</strong></p>\n<blockquote>\n<p>vue</p>\n</blockquote>\n<p><strong>Vue是由尤大大开发的一个MVVM框架，它采用的是模板系统而不是JSX。</strong></p>\n<h3 id=\"模板渲染方式不同\"><a href=\"#模板渲染方式不同\" class=\"headerlink\" title=\"模板渲染方式不同\"></a>模板渲染方式不同</h3><blockquote>\n<p>react</p>\n</blockquote>\n<p><strong>React是通过JSX来渲染模板，React通过原生JS实现模板中的常见语法，比如说条件啊、循环啊、三元运算符啊等，都是通过JS语法实现</strong></p>\n<blockquote>\n<p>vue</p>\n</blockquote>\n<p><strong>vue是通过扩展的HTML来进行模板的渲染，Vue是在和组件代码分离的单独模板中，通过指令v-if、v-for等实现</strong></p>\n<h3 id=\"Virtual-DOM\"><a href=\"#Virtual-DOM\" class=\"headerlink\" title=\"Virtual DOM\"></a>Virtual DOM</h3><blockquote>\n<p>react</p>\n</blockquote>\n<p><strong>React默认是通过比较引用得方式进行，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。如果想避免不必要的子组件重新渲染，你需要在所有可能的地方使用PureComponent，或者手动实现shouldComponentUpdate方法。但是Vue中，你可以认定它是默认的优化。</strong></p>\n<blockquote>\n<p>vue</p>\n</blockquote>\n<p><strong>Vue可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，由于vue会跟踪每一个组件的依赖收集，通过setter / getter 以及一些函数的劫持，能够精确地知道变化，并在编译过程标记了static静态节点，在接下来新的Virtual DOM 并且和原来旧的 Virtual DOM进行比较时候，跳过static静态节点。所以不需要重新渲染整个组件树。</strong></p>\n<h3 id=\"数据流\"><a href=\"#数据流\" class=\"headerlink\" title=\"数据流\"></a>数据流</h3><h3 id=\"Vuex-和-Redux\"><a href=\"#Vuex-和-Redux\" class=\"headerlink\" title=\"Vuex 和 Redux\"></a>Vuex 和 Redux</h3><blockquote>\n<p>react</p>\n</blockquote>\n<p><strong>在React中，我们需要每一个组件都引入connect，目的就是把props和dispatch连接起来。redux只能通过dispatch，然后在reducer里，接收到action，通过判断action的type，从而进行对应的操作，redux不能直接调用reducer进行修改！！</strong></p>\n<blockquote>\n<p>vue</p>\n</blockquote>\n<p><strong>在vuex中，我们可以通过在main.js中，引入 store文件夹，并把store挂载到new Vue实例中，这样我们可以直接通过$store灵活使用。</strong></p>\n<blockquote>\n<ul>\n<li>你可以通过dispatch和commit进行更新数据，</li>\n<li>通过this.$store.state.xx读取数据</li>\n<li>你可以通过mapState / mapActions 进行vuex的操作</li>\n</ul>\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><hr>\n<blockquote>\n<ul>\n<li>组件的创建方式不一样<ul>\n<li>react使用class和函数创建组件【只有局部】</li>\n<li>vue则使用vue的实例的components方法和components属性【有局部和全局一说】</li>\n</ul>\n</li>\n<li>在react中没有指令，计算属性，watch监听，computed，这些内容</li>\n<li>在react组件中只有几个概念，生命周期，state。props。合成事件</li>\n<li>在vue中可以使用v-modle完成数据的双向绑定，而在react并没有指令的概念，所以使用受控组件代替</li>\n<li>在vue中使用getter，setter拦截器，处理数据的绑定，而react则使用的是setState手动触发</li>\n</ul>\n</blockquote>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"vue和react的区别\"><a href=\"#vue和react的区别\" class=\"headerlink\" title=\"vue和react的区别\"></a>vue和react的区别</h2><blockquote>\n<p>react和vue都是组件化，整体功能类似，但是设计思路有有所不同，</p>\n</blockquote>\n<h3 id=\"出身\"><a href=\"#出身\" class=\"headerlink\" title=\"出身\"></a>出身</h3><blockquote>\n<p>react</p>\n</blockquote>\n<p><strong>React是由Facebook创建的JavaScript UI框架，它的诞生改变了JavaScript世界，最大的一个改变就是React推广了Virtual DOM， 并且创造了新的语法 – JSX，JSX 允许在JavaScript中写html代码。</strong></p>\n<blockquote>\n<p>vue</p>\n</blockquote>\n<p><strong>Vue是由尤大大开发的一个MVVM框架，它采用的是模板系统而不是JSX。</strong></p>\n<h3 id=\"模板渲染方式不同\"><a href=\"#模板渲染方式不同\" class=\"headerlink\" title=\"模板渲染方式不同\"></a>模板渲染方式不同</h3><blockquote>\n<p>react</p>\n</blockquote>\n<p><strong>React是通过JSX来渲染模板，React通过原生JS实现模板中的常见语法，比如说条件啊、循环啊、三元运算符啊等，都是通过JS语法实现</strong></p>\n<blockquote>\n<p>vue</p>\n</blockquote>\n<p><strong>vue是通过扩展的HTML来进行模板的渲染，Vue是在和组件代码分离的单独模板中，通过指令v-if、v-for等实现</strong></p>\n<h3 id=\"Virtual-DOM\"><a href=\"#Virtual-DOM\" class=\"headerlink\" title=\"Virtual DOM\"></a>Virtual DOM</h3><blockquote>\n<p>react</p>\n</blockquote>\n<p><strong>React默认是通过比较引用得方式进行，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。如果想避免不必要的子组件重新渲染，你需要在所有可能的地方使用PureComponent，或者手动实现shouldComponentUpdate方法。但是Vue中，你可以认定它是默认的优化。</strong></p>\n<blockquote>\n<p>vue</p>\n</blockquote>\n<p><strong>Vue可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，由于vue会跟踪每一个组件的依赖收集，通过setter / getter 以及一些函数的劫持，能够精确地知道变化，并在编译过程标记了static静态节点，在接下来新的Virtual DOM 并且和原来旧的 Virtual DOM进行比较时候，跳过static静态节点。所以不需要重新渲染整个组件树。</strong></p>\n<h3 id=\"数据流\"><a href=\"#数据流\" class=\"headerlink\" title=\"数据流\"></a>数据流</h3><h3 id=\"Vuex-和-Redux\"><a href=\"#Vuex-和-Redux\" class=\"headerlink\" title=\"Vuex 和 Redux\"></a>Vuex 和 Redux</h3><blockquote>\n<p>react</p>\n</blockquote>\n<p><strong>在React中，我们需要每一个组件都引入connect，目的就是把props和dispatch连接起来。redux只能通过dispatch，然后在reducer里，接收到action，通过判断action的type，从而进行对应的操作，redux不能直接调用reducer进行修改！！</strong></p>\n<blockquote>\n<p>vue</p>\n</blockquote>\n<p><strong>在vuex中，我们可以通过在main.js中，引入 store文件夹，并把store挂载到new Vue实例中，这样我们可以直接通过$store灵活使用。</strong></p>\n<blockquote>\n<ul>\n<li>你可以通过dispatch和commit进行更新数据，</li>\n<li>通过this.$store.state.xx读取数据</li>\n<li>你可以通过mapState / mapActions 进行vuex的操作</li>\n</ul>\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><hr>\n<blockquote>\n<ul>\n<li>组件的创建方式不一样<ul>\n<li>react使用class和函数创建组件【只有局部】</li>\n<li>vue则使用vue的实例的components方法和components属性【有局部和全局一说】</li>\n</ul>\n</li>\n<li>在react中没有指令，计算属性，watch监听，computed，这些内容</li>\n<li>在react组件中只有几个概念，生命周期，state。props。合成事件</li>\n<li>在vue中可以使用v-modle完成数据的双向绑定，而在react并没有指令的概念，所以使用受控组件代替</li>\n<li>在vue中使用getter，setter拦截器，处理数据的绑定，而react则使用的是setState手动触发</li>\n</ul>\n</blockquote>\n<hr>\n"},{"title":"vue中的Dom操作","date":"2019-01-27T05:40:31.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"## vue中的Dom操作\n\n### 在vue，react，。。。。以数据驱动视图的框架，都是通过数据更新视图，一般不使用dom操作，但是也有一些特定的时候需要用到dom操作\n\n\n## dom操作的方法\n\n----------\n\n> \n> \n1. transition:组件中的钩子函数可以接受一个el属性，作用动画的dom，可以多dom添加实现动画效果\n2. ref：ref可以作用在dom元素和组件元素上，作用在dom元素上通过refs获取到就是dom节点，作用在组件元素上获取到组件实例\n3. 在mounted生命周期中我们可以使用document的dom的操作方法，比如添加一些滚动事件...\n4. #el：可以获取组件的根节点元素\n5. ￥mount()：可以手动渲染组件，成为真实的dom节点\n6. 事件中的e.target可以获取都绑定事件的dom，但不准确，因为获取到的是点击最内层的元素，当然如果作用在表单元素就无所谓\n7. 指令也可以操作dom的\n>  \n\n\n----------\n\n","source":"_posts/vue-dom.md","raw":"---\ntitle: vue中的Dom操作\ndate: '2019-01-27 13:40:31'\ntag: ['dom', 'vue']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n## vue中的Dom操作\n\n### 在vue，react，。。。。以数据驱动视图的框架，都是通过数据更新视图，一般不使用dom操作，但是也有一些特定的时候需要用到dom操作\n\n\n## dom操作的方法\n\n----------\n\n> \n> \n1. transition:组件中的钩子函数可以接受一个el属性，作用动画的dom，可以多dom添加实现动画效果\n2. ref：ref可以作用在dom元素和组件元素上，作用在dom元素上通过refs获取到就是dom节点，作用在组件元素上获取到组件实例\n3. 在mounted生命周期中我们可以使用document的dom的操作方法，比如添加一些滚动事件...\n4. #el：可以获取组件的根节点元素\n5. ￥mount()：可以手动渲染组件，成为真实的dom节点\n6. 事件中的e.target可以获取都绑定事件的dom，但不准确，因为获取到的是点击最内层的元素，当然如果作用在表单元素就无所谓\n7. 指令也可以操作dom的\n>  \n\n\n----------\n\n","slug":"vue-dom","published":1,"updated":"2019-01-27T05:41:00.239Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam80002wn4wdxwep66ju","content":"<h2 id=\"vue中的Dom操作\"><a href=\"#vue中的Dom操作\" class=\"headerlink\" title=\"vue中的Dom操作\"></a>vue中的Dom操作</h2><h3 id=\"在vue，react，。。。。以数据驱动视图的框架，都是通过数据更新视图，一般不使用dom操作，但是也有一些特定的时候需要用到dom操作\"><a href=\"#在vue，react，。。。。以数据驱动视图的框架，都是通过数据更新视图，一般不使用dom操作，但是也有一些特定的时候需要用到dom操作\" class=\"headerlink\" title=\"在vue，react，。。。。以数据驱动视图的框架，都是通过数据更新视图，一般不使用dom操作，但是也有一些特定的时候需要用到dom操作\"></a>在vue，react，。。。。以数据驱动视图的框架，都是通过数据更新视图，一般不使用dom操作，但是也有一些特定的时候需要用到dom操作</h3><h2 id=\"dom操作的方法\"><a href=\"#dom操作的方法\" class=\"headerlink\" title=\"dom操作的方法\"></a>dom操作的方法</h2><hr>\n<blockquote>\n</blockquote>\n<ol>\n<li>transition:组件中的钩子函数可以接受一个el属性，作用动画的dom，可以多dom添加实现动画效果</li>\n<li>ref：ref可以作用在dom元素和组件元素上，作用在dom元素上通过refs获取到就是dom节点，作用在组件元素上获取到组件实例</li>\n<li>在mounted生命周期中我们可以使用document的dom的操作方法，比如添加一些滚动事件…</li>\n<li>#el：可以获取组件的根节点元素</li>\n<li>￥mount()：可以手动渲染组件，成为真实的dom节点</li>\n<li>事件中的e.target可以获取都绑定事件的dom，但不准确，因为获取到的是点击最内层的元素，当然如果作用在表单元素就无所谓</li>\n<li>指令也可以操作dom的<blockquote>\n</blockquote>\n</li>\n</ol>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"vue中的Dom操作\"><a href=\"#vue中的Dom操作\" class=\"headerlink\" title=\"vue中的Dom操作\"></a>vue中的Dom操作</h2><h3 id=\"在vue，react，。。。。以数据驱动视图的框架，都是通过数据更新视图，一般不使用dom操作，但是也有一些特定的时候需要用到dom操作\"><a href=\"#在vue，react，。。。。以数据驱动视图的框架，都是通过数据更新视图，一般不使用dom操作，但是也有一些特定的时候需要用到dom操作\" class=\"headerlink\" title=\"在vue，react，。。。。以数据驱动视图的框架，都是通过数据更新视图，一般不使用dom操作，但是也有一些特定的时候需要用到dom操作\"></a>在vue，react，。。。。以数据驱动视图的框架，都是通过数据更新视图，一般不使用dom操作，但是也有一些特定的时候需要用到dom操作</h3><h2 id=\"dom操作的方法\"><a href=\"#dom操作的方法\" class=\"headerlink\" title=\"dom操作的方法\"></a>dom操作的方法</h2><hr>\n<blockquote>\n</blockquote>\n<ol>\n<li>transition:组件中的钩子函数可以接受一个el属性，作用动画的dom，可以多dom添加实现动画效果</li>\n<li>ref：ref可以作用在dom元素和组件元素上，作用在dom元素上通过refs获取到就是dom节点，作用在组件元素上获取到组件实例</li>\n<li>在mounted生命周期中我们可以使用document的dom的操作方法，比如添加一些滚动事件…</li>\n<li>#el：可以获取组件的根节点元素</li>\n<li>￥mount()：可以手动渲染组件，成为真实的dom节点</li>\n<li>事件中的e.target可以获取都绑定事件的dom，但不准确，因为获取到的是点击最内层的元素，当然如果作用在表单元素就无所谓</li>\n<li>指令也可以操作dom的<blockquote>\n</blockquote>\n</li>\n</ol>\n<hr>\n"},{"title":"vue概述","date":"2019-01-25T08:34:55.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"----------\n1/25/2019 4:34:55 PM\n### 此文章只是对VUE常用的知识进行了一个简述，详情请[访问官方文档](https://cn.vuejs.org/)\n\n----------\n\n# 什么是vue？\n\n### vue是一个框架(`渐进式开发框架`),其实就是一个框架的名称，其特点是(数据双向绑定，组件开发，单页面路由，指令，插件)\n\n## 什么叫渐进式框架\n\n### 通过开发组件的形式，进行组件的组件的组合，来组合出来的一个页面而已\n\n## 最重要的特性就是组件\n\n### 组件类似于模块，设计组建的目的是为了更好的解耦业务，和模块化的区别就在于(组件的组成包含了(结构，逻辑，样式))而模块只是逻辑\n\n## 组件的特性\n- 组建的状态(data,props)\n- 组件和组件的通讯\n- 自己的生命周期\n- 组件的渲染和组件的创建方式\n\n## 设计组件\n\n**组件一般分为，展示组件和受控组件**\n\n----------\n\n\n> 展示组件：纯粹的展示功能\n\n----------\n\n> 业务组件：单个的业务功能独立出来的组件\n\n----------\n\n> 控件：内置表单元素不能满足网页开发，有一些特殊需要自定义的表单组件，称为控制，一般需要结合v-model去做数据双向绑定的控制\n\n----------\n\n> 容器组件：作为页面的容器，用来管理当前页面的数据，通过数据去控制展示组件的显示\n\n----------\n\n> api组件：通过api形式调用的组件（提示，loading，验证等之类的需要通过js调用方法控制的组件。vue.extend创建）\n\n----------\n\n> 组合式组件：组件和组件之间有特定关系的组件（slot元素作为插槽）\n\n----------\n\n## 如何拆分组件\n\n> 按照设计ui提供的ui图，提取公共展示功能，作为展示组件的提取，在页面开发过程中提取页面中独立业务单独出来业务组件，在表单页面提取公共的非内置表单元素作为控件处理（地区选择，选择日期，选择.....）\n\n## 组件的创建方式\n- vue.component(componnetName,option)           (自动渲染)\n- 在每一个组件中都有component选项，用来注册局部组件\t(自动渲染)\n- 通过Vue.extends()扩展子类的形式创建\t\t\t\t(手动渲染)\n\n## 组建的实例选项\n- @[function] data\n- @[object] method\n- @[object] compoted\n- @[object] watch\n- @[object] conponents\n- @[function] 生命周期 \n\n\t\tbeforeCreated () {}\t\t// 初始化数据之前\n\t\tcreated () {} \t\t\t// 数据初始化之后\n\t\tbeforeMout () {} \t\t// 开始渲染\n\t\tmounted () {} \t\t\t// 渲染完成\n\t\tbeforeUpdate () {} \t\t// 开始更新 当一个数据的改变引起了视图的重新的渲染才会执行，单独的一个数据改变是不会执行的\n\t\tuppdated () {} \t\t\t// 更新完成\n\n\t\t//当使用keep-alive组件时才会 执行\n\t\tactivated () {} \t\t// 组件启用时\n\t\tdeactivated () {} \t\t// 组件停用时\n\n\t\t//组件销毁 v-if销毁组件，或者切换路由(在没有启用缓存的前提)，或者手动执行this.$destroy () {}\t\t\t// 清理组件中绑定的data，通过v-on绑定事件，如果有手动绑定的内容需要，在这个生命周期中手动销毁\n\t\tbeforeDestroy () {}\n\t\tdestroyed () {}\n\n\t\t\n\t\terrorCaptured () {}\t\t// 当组件中发生错误时\n\n\n## 组件的通讯方式\n\n### 通讯创建：父子，子父，同级，跨级\n\n### 通讯其实就是谁用谁的数据\n\n- 父子：子组件使用父组件数据，props(常用)，子组件内部通过$parent\n- 子父：父组件使用子组件数据，通过自定事件，子组件通过$emit(事件名称，发送数据)给父组件传递数据(常用)$children $refs\n- 同级：代理(一个子组件将数据发送到父级，父在发送到另一个子级)，eventBus vuex\n- 跨级：逐层传递，vuex eventsBus\n\n## 组件的嵌套\n\n### 组件内部通过slot内置组件，可以用来承载嵌套组件(单个slot，和命名slot)\n\n## 内置组件\n\n- template 单文件组件中代替了template选项，可以用作一个包裹元素，不会被渲染\n- component 动态组件，通过is属性动态渲染某一个组件\n- slot 插槽，用来承载组件潜逃的子组件\n- transition vue用来实现动画的组件(提供了，进入和离开两个状态)\n- transitions-group 用来实现多动画(列表动画，排序，添加，删除)\n- keep-alive 用来启动vue缓存功能，缓存组件的状态\n\n## vue的实例属性\n\n\t实例属性\n\tvm.$data \t\t\t\t// 访问定义的data\n\tvm.$props \t\t\t\t// 访问props对象\n\tvm.$el \t\t\t\t\t// 访问组件的根节点\n\tvm.$options \t\t\t// 访问所有配置项\n\tvm.$parent \t\t\t\t// 访问父组件实例\n\tvm.$root\n\tvm.$children\n\tvm.$slots\n\tvm.$scopedSlots\n\tvm.$refs\n\tvm.$isServer\n\tvm.$attrs\n\tvm.$listeners\n\t实例方法 / 数据\n\tvm.$watch\n\tvm.$set\n\tvm.$delete\n\t实例方法 / 事件\n\tvm.$on\n\tvm.$once\n\tvm.$off\n\tvm.$emit\n\t实例方法 / 生命周期\n\tvm.$mount\n\tvm.$forceUpdate\n\tvm.$nextTick\t//数据改变后回调\n\tvm.$destroy //手动渲染\n\n\n","source":"_posts/vue.md","raw":"---\ntitle: vue概述\ndate: ' 1/25/2019 4:34:55 PM '\ntag: ['js', 'vue']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n----------\n1/25/2019 4:34:55 PM\n### 此文章只是对VUE常用的知识进行了一个简述，详情请[访问官方文档](https://cn.vuejs.org/)\n\n----------\n\n# 什么是vue？\n\n### vue是一个框架(`渐进式开发框架`),其实就是一个框架的名称，其特点是(数据双向绑定，组件开发，单页面路由，指令，插件)\n\n## 什么叫渐进式框架\n\n### 通过开发组件的形式，进行组件的组件的组合，来组合出来的一个页面而已\n\n## 最重要的特性就是组件\n\n### 组件类似于模块，设计组建的目的是为了更好的解耦业务，和模块化的区别就在于(组件的组成包含了(结构，逻辑，样式))而模块只是逻辑\n\n## 组件的特性\n- 组建的状态(data,props)\n- 组件和组件的通讯\n- 自己的生命周期\n- 组件的渲染和组件的创建方式\n\n## 设计组件\n\n**组件一般分为，展示组件和受控组件**\n\n----------\n\n\n> 展示组件：纯粹的展示功能\n\n----------\n\n> 业务组件：单个的业务功能独立出来的组件\n\n----------\n\n> 控件：内置表单元素不能满足网页开发，有一些特殊需要自定义的表单组件，称为控制，一般需要结合v-model去做数据双向绑定的控制\n\n----------\n\n> 容器组件：作为页面的容器，用来管理当前页面的数据，通过数据去控制展示组件的显示\n\n----------\n\n> api组件：通过api形式调用的组件（提示，loading，验证等之类的需要通过js调用方法控制的组件。vue.extend创建）\n\n----------\n\n> 组合式组件：组件和组件之间有特定关系的组件（slot元素作为插槽）\n\n----------\n\n## 如何拆分组件\n\n> 按照设计ui提供的ui图，提取公共展示功能，作为展示组件的提取，在页面开发过程中提取页面中独立业务单独出来业务组件，在表单页面提取公共的非内置表单元素作为控件处理（地区选择，选择日期，选择.....）\n\n## 组件的创建方式\n- vue.component(componnetName,option)           (自动渲染)\n- 在每一个组件中都有component选项，用来注册局部组件\t(自动渲染)\n- 通过Vue.extends()扩展子类的形式创建\t\t\t\t(手动渲染)\n\n## 组建的实例选项\n- @[function] data\n- @[object] method\n- @[object] compoted\n- @[object] watch\n- @[object] conponents\n- @[function] 生命周期 \n\n\t\tbeforeCreated () {}\t\t// 初始化数据之前\n\t\tcreated () {} \t\t\t// 数据初始化之后\n\t\tbeforeMout () {} \t\t// 开始渲染\n\t\tmounted () {} \t\t\t// 渲染完成\n\t\tbeforeUpdate () {} \t\t// 开始更新 当一个数据的改变引起了视图的重新的渲染才会执行，单独的一个数据改变是不会执行的\n\t\tuppdated () {} \t\t\t// 更新完成\n\n\t\t//当使用keep-alive组件时才会 执行\n\t\tactivated () {} \t\t// 组件启用时\n\t\tdeactivated () {} \t\t// 组件停用时\n\n\t\t//组件销毁 v-if销毁组件，或者切换路由(在没有启用缓存的前提)，或者手动执行this.$destroy () {}\t\t\t// 清理组件中绑定的data，通过v-on绑定事件，如果有手动绑定的内容需要，在这个生命周期中手动销毁\n\t\tbeforeDestroy () {}\n\t\tdestroyed () {}\n\n\t\t\n\t\terrorCaptured () {}\t\t// 当组件中发生错误时\n\n\n## 组件的通讯方式\n\n### 通讯创建：父子，子父，同级，跨级\n\n### 通讯其实就是谁用谁的数据\n\n- 父子：子组件使用父组件数据，props(常用)，子组件内部通过$parent\n- 子父：父组件使用子组件数据，通过自定事件，子组件通过$emit(事件名称，发送数据)给父组件传递数据(常用)$children $refs\n- 同级：代理(一个子组件将数据发送到父级，父在发送到另一个子级)，eventBus vuex\n- 跨级：逐层传递，vuex eventsBus\n\n## 组件的嵌套\n\n### 组件内部通过slot内置组件，可以用来承载嵌套组件(单个slot，和命名slot)\n\n## 内置组件\n\n- template 单文件组件中代替了template选项，可以用作一个包裹元素，不会被渲染\n- component 动态组件，通过is属性动态渲染某一个组件\n- slot 插槽，用来承载组件潜逃的子组件\n- transition vue用来实现动画的组件(提供了，进入和离开两个状态)\n- transitions-group 用来实现多动画(列表动画，排序，添加，删除)\n- keep-alive 用来启动vue缓存功能，缓存组件的状态\n\n## vue的实例属性\n\n\t实例属性\n\tvm.$data \t\t\t\t// 访问定义的data\n\tvm.$props \t\t\t\t// 访问props对象\n\tvm.$el \t\t\t\t\t// 访问组件的根节点\n\tvm.$options \t\t\t// 访问所有配置项\n\tvm.$parent \t\t\t\t// 访问父组件实例\n\tvm.$root\n\tvm.$children\n\tvm.$slots\n\tvm.$scopedSlots\n\tvm.$refs\n\tvm.$isServer\n\tvm.$attrs\n\tvm.$listeners\n\t实例方法 / 数据\n\tvm.$watch\n\tvm.$set\n\tvm.$delete\n\t实例方法 / 事件\n\tvm.$on\n\tvm.$once\n\tvm.$off\n\tvm.$emit\n\t实例方法 / 生命周期\n\tvm.$mount\n\tvm.$forceUpdate\n\tvm.$nextTick\t//数据改变后回调\n\tvm.$destroy //手动渲染\n\n\n","slug":"vue","published":1,"updated":"2019-04-02T07:48:35.373Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam82002yn4wdxsqkkaic","content":"<hr>\n<p>1/25/2019 4:34:55 PM</p>\n<h3 id=\"此文章只是对VUE常用的知识进行了一个简述，详情请访问官方文档\"><a href=\"#此文章只是对VUE常用的知识进行了一个简述，详情请访问官方文档\" class=\"headerlink\" title=\"此文章只是对VUE常用的知识进行了一个简述，详情请访问官方文档\"></a>此文章只是对VUE常用的知识进行了一个简述，详情请<a href=\"https://cn.vuejs.org/\" target=\"_blank\" rel=\"noopener\">访问官方文档</a></h3><hr>\n<h1 id=\"什么是vue？\"><a href=\"#什么是vue？\" class=\"headerlink\" title=\"什么是vue？\"></a>什么是vue？</h1><h3 id=\"vue是一个框架-渐进式开发框架-其实就是一个框架的名称，其特点是-数据双向绑定，组件开发，单页面路由，指令，插件\"><a href=\"#vue是一个框架-渐进式开发框架-其实就是一个框架的名称，其特点是-数据双向绑定，组件开发，单页面路由，指令，插件\" class=\"headerlink\" title=\"vue是一个框架(渐进式开发框架),其实就是一个框架的名称，其特点是(数据双向绑定，组件开发，单页面路由，指令，插件)\"></a>vue是一个框架(<code>渐进式开发框架</code>),其实就是一个框架的名称，其特点是(数据双向绑定，组件开发，单页面路由，指令，插件)</h3><h2 id=\"什么叫渐进式框架\"><a href=\"#什么叫渐进式框架\" class=\"headerlink\" title=\"什么叫渐进式框架\"></a>什么叫渐进式框架</h2><h3 id=\"通过开发组件的形式，进行组件的组件的组合，来组合出来的一个页面而已\"><a href=\"#通过开发组件的形式，进行组件的组件的组合，来组合出来的一个页面而已\" class=\"headerlink\" title=\"通过开发组件的形式，进行组件的组件的组合，来组合出来的一个页面而已\"></a>通过开发组件的形式，进行组件的组件的组合，来组合出来的一个页面而已</h3><h2 id=\"最重要的特性就是组件\"><a href=\"#最重要的特性就是组件\" class=\"headerlink\" title=\"最重要的特性就是组件\"></a>最重要的特性就是组件</h2><h3 id=\"组件类似于模块，设计组建的目的是为了更好的解耦业务，和模块化的区别就在于-组件的组成包含了-结构，逻辑，样式-而模块只是逻辑\"><a href=\"#组件类似于模块，设计组建的目的是为了更好的解耦业务，和模块化的区别就在于-组件的组成包含了-结构，逻辑，样式-而模块只是逻辑\" class=\"headerlink\" title=\"组件类似于模块，设计组建的目的是为了更好的解耦业务，和模块化的区别就在于(组件的组成包含了(结构，逻辑，样式))而模块只是逻辑\"></a>组件类似于模块，设计组建的目的是为了更好的解耦业务，和模块化的区别就在于(组件的组成包含了(结构，逻辑，样式))而模块只是逻辑</h3><h2 id=\"组件的特性\"><a href=\"#组件的特性\" class=\"headerlink\" title=\"组件的特性\"></a>组件的特性</h2><ul>\n<li>组建的状态(data,props)</li>\n<li>组件和组件的通讯</li>\n<li>自己的生命周期</li>\n<li>组件的渲染和组件的创建方式</li>\n</ul>\n<h2 id=\"设计组件\"><a href=\"#设计组件\" class=\"headerlink\" title=\"设计组件\"></a>设计组件</h2><p><strong>组件一般分为，展示组件和受控组件</strong></p>\n<hr>\n<blockquote>\n<p>展示组件：纯粹的展示功能</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>业务组件：单个的业务功能独立出来的组件</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>控件：内置表单元素不能满足网页开发，有一些特殊需要自定义的表单组件，称为控制，一般需要结合v-model去做数据双向绑定的控制</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>容器组件：作为页面的容器，用来管理当前页面的数据，通过数据去控制展示组件的显示</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>api组件：通过api形式调用的组件（提示，loading，验证等之类的需要通过js调用方法控制的组件。vue.extend创建）</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>组合式组件：组件和组件之间有特定关系的组件（slot元素作为插槽）</p>\n</blockquote>\n<hr>\n<h2 id=\"如何拆分组件\"><a href=\"#如何拆分组件\" class=\"headerlink\" title=\"如何拆分组件\"></a>如何拆分组件</h2><blockquote>\n<p>按照设计ui提供的ui图，提取公共展示功能，作为展示组件的提取，在页面开发过程中提取页面中独立业务单独出来业务组件，在表单页面提取公共的非内置表单元素作为控件处理（地区选择，选择日期，选择…..）</p>\n</blockquote>\n<h2 id=\"组件的创建方式\"><a href=\"#组件的创建方式\" class=\"headerlink\" title=\"组件的创建方式\"></a>组件的创建方式</h2><ul>\n<li>vue.component(componnetName,option)           (自动渲染)</li>\n<li>在每一个组件中都有component选项，用来注册局部组件    (自动渲染)</li>\n<li>通过Vue.extends()扩展子类的形式创建                (手动渲染)</li>\n</ul>\n<h2 id=\"组建的实例选项\"><a href=\"#组建的实例选项\" class=\"headerlink\" title=\"组建的实例选项\"></a>组建的实例选项</h2><ul>\n<li>@[function] data</li>\n<li>@[object] method</li>\n<li>@[object] compoted</li>\n<li>@[object] watch</li>\n<li>@[object] conponents</li>\n<li><p>@[function] 生命周期 </p>\n<pre><code>  beforeCreated () {}        // 初始化数据之前\n  created () {}             // 数据初始化之后\n  beforeMout () {}         // 开始渲染\n  mounted () {}             // 渲染完成\n  beforeUpdate () {}         // 开始更新 当一个数据的改变引起了视图的重新的渲染才会执行，单独的一个数据改变是不会执行的\n  uppdated () {}             // 更新完成\n\n  //当使用keep-alive组件时才会 执行\n  activated () {}         // 组件启用时\n  deactivated () {}         // 组件停用时\n\n  //组件销毁 v-if销毁组件，或者切换路由(在没有启用缓存的前提)，或者手动执行this.$destroy () {}            // 清理组件中绑定的data，通过v-on绑定事件，如果有手动绑定的内容需要，在这个生命周期中手动销毁\n  beforeDestroy () {}\n  destroyed () {}\n</code></pre></li>\n</ul>\n<pre><code>    errorCaptured () {}        // 当组件中发生错误时\n</code></pre><h2 id=\"组件的通讯方式\"><a href=\"#组件的通讯方式\" class=\"headerlink\" title=\"组件的通讯方式\"></a>组件的通讯方式</h2><h3 id=\"通讯创建：父子，子父，同级，跨级\"><a href=\"#通讯创建：父子，子父，同级，跨级\" class=\"headerlink\" title=\"通讯创建：父子，子父，同级，跨级\"></a>通讯创建：父子，子父，同级，跨级</h3><h3 id=\"通讯其实就是谁用谁的数据\"><a href=\"#通讯其实就是谁用谁的数据\" class=\"headerlink\" title=\"通讯其实就是谁用谁的数据\"></a>通讯其实就是谁用谁的数据</h3><ul>\n<li>父子：子组件使用父组件数据，props(常用)，子组件内部通过$parent</li>\n<li>子父：父组件使用子组件数据，通过自定事件，子组件通过$emit(事件名称，发送数据)给父组件传递数据(常用)$children $refs</li>\n<li>同级：代理(一个子组件将数据发送到父级，父在发送到另一个子级)，eventBus vuex</li>\n<li>跨级：逐层传递，vuex eventsBus</li>\n</ul>\n<h2 id=\"组件的嵌套\"><a href=\"#组件的嵌套\" class=\"headerlink\" title=\"组件的嵌套\"></a>组件的嵌套</h2><h3 id=\"组件内部通过slot内置组件，可以用来承载嵌套组件-单个slot，和命名slot\"><a href=\"#组件内部通过slot内置组件，可以用来承载嵌套组件-单个slot，和命名slot\" class=\"headerlink\" title=\"组件内部通过slot内置组件，可以用来承载嵌套组件(单个slot，和命名slot)\"></a>组件内部通过slot内置组件，可以用来承载嵌套组件(单个slot，和命名slot)</h3><h2 id=\"内置组件\"><a href=\"#内置组件\" class=\"headerlink\" title=\"内置组件\"></a>内置组件</h2><ul>\n<li>template 单文件组件中代替了template选项，可以用作一个包裹元素，不会被渲染</li>\n<li>component 动态组件，通过is属性动态渲染某一个组件</li>\n<li>slot 插槽，用来承载组件潜逃的子组件</li>\n<li>transition vue用来实现动画的组件(提供了，进入和离开两个状态)</li>\n<li>transitions-group 用来实现多动画(列表动画，排序，添加，删除)</li>\n<li>keep-alive 用来启动vue缓存功能，缓存组件的状态</li>\n</ul>\n<h2 id=\"vue的实例属性\"><a href=\"#vue的实例属性\" class=\"headerlink\" title=\"vue的实例属性\"></a>vue的实例属性</h2><pre><code>实例属性\nvm.$data                 // 访问定义的data\nvm.$props                 // 访问props对象\nvm.$el                     // 访问组件的根节点\nvm.$options             // 访问所有配置项\nvm.$parent                 // 访问父组件实例\nvm.$root\nvm.$children\nvm.$slots\nvm.$scopedSlots\nvm.$refs\nvm.$isServer\nvm.$attrs\nvm.$listeners\n实例方法 / 数据\nvm.$watch\nvm.$set\nvm.$delete\n实例方法 / 事件\nvm.$on\nvm.$once\nvm.$off\nvm.$emit\n实例方法 / 生命周期\nvm.$mount\nvm.$forceUpdate\nvm.$nextTick    //数据改变后回调\nvm.$destroy //手动渲染\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<hr>\n<p>1/25/2019 4:34:55 PM</p>\n<h3 id=\"此文章只是对VUE常用的知识进行了一个简述，详情请访问官方文档\"><a href=\"#此文章只是对VUE常用的知识进行了一个简述，详情请访问官方文档\" class=\"headerlink\" title=\"此文章只是对VUE常用的知识进行了一个简述，详情请访问官方文档\"></a>此文章只是对VUE常用的知识进行了一个简述，详情请<a href=\"https://cn.vuejs.org/\" target=\"_blank\" rel=\"noopener\">访问官方文档</a></h3><hr>\n<h1 id=\"什么是vue？\"><a href=\"#什么是vue？\" class=\"headerlink\" title=\"什么是vue？\"></a>什么是vue？</h1><h3 id=\"vue是一个框架-渐进式开发框架-其实就是一个框架的名称，其特点是-数据双向绑定，组件开发，单页面路由，指令，插件\"><a href=\"#vue是一个框架-渐进式开发框架-其实就是一个框架的名称，其特点是-数据双向绑定，组件开发，单页面路由，指令，插件\" class=\"headerlink\" title=\"vue是一个框架(渐进式开发框架),其实就是一个框架的名称，其特点是(数据双向绑定，组件开发，单页面路由，指令，插件)\"></a>vue是一个框架(<code>渐进式开发框架</code>),其实就是一个框架的名称，其特点是(数据双向绑定，组件开发，单页面路由，指令，插件)</h3><h2 id=\"什么叫渐进式框架\"><a href=\"#什么叫渐进式框架\" class=\"headerlink\" title=\"什么叫渐进式框架\"></a>什么叫渐进式框架</h2><h3 id=\"通过开发组件的形式，进行组件的组件的组合，来组合出来的一个页面而已\"><a href=\"#通过开发组件的形式，进行组件的组件的组合，来组合出来的一个页面而已\" class=\"headerlink\" title=\"通过开发组件的形式，进行组件的组件的组合，来组合出来的一个页面而已\"></a>通过开发组件的形式，进行组件的组件的组合，来组合出来的一个页面而已</h3><h2 id=\"最重要的特性就是组件\"><a href=\"#最重要的特性就是组件\" class=\"headerlink\" title=\"最重要的特性就是组件\"></a>最重要的特性就是组件</h2><h3 id=\"组件类似于模块，设计组建的目的是为了更好的解耦业务，和模块化的区别就在于-组件的组成包含了-结构，逻辑，样式-而模块只是逻辑\"><a href=\"#组件类似于模块，设计组建的目的是为了更好的解耦业务，和模块化的区别就在于-组件的组成包含了-结构，逻辑，样式-而模块只是逻辑\" class=\"headerlink\" title=\"组件类似于模块，设计组建的目的是为了更好的解耦业务，和模块化的区别就在于(组件的组成包含了(结构，逻辑，样式))而模块只是逻辑\"></a>组件类似于模块，设计组建的目的是为了更好的解耦业务，和模块化的区别就在于(组件的组成包含了(结构，逻辑，样式))而模块只是逻辑</h3><h2 id=\"组件的特性\"><a href=\"#组件的特性\" class=\"headerlink\" title=\"组件的特性\"></a>组件的特性</h2><ul>\n<li>组建的状态(data,props)</li>\n<li>组件和组件的通讯</li>\n<li>自己的生命周期</li>\n<li>组件的渲染和组件的创建方式</li>\n</ul>\n<h2 id=\"设计组件\"><a href=\"#设计组件\" class=\"headerlink\" title=\"设计组件\"></a>设计组件</h2><p><strong>组件一般分为，展示组件和受控组件</strong></p>\n<hr>\n<blockquote>\n<p>展示组件：纯粹的展示功能</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>业务组件：单个的业务功能独立出来的组件</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>控件：内置表单元素不能满足网页开发，有一些特殊需要自定义的表单组件，称为控制，一般需要结合v-model去做数据双向绑定的控制</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>容器组件：作为页面的容器，用来管理当前页面的数据，通过数据去控制展示组件的显示</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>api组件：通过api形式调用的组件（提示，loading，验证等之类的需要通过js调用方法控制的组件。vue.extend创建）</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>组合式组件：组件和组件之间有特定关系的组件（slot元素作为插槽）</p>\n</blockquote>\n<hr>\n<h2 id=\"如何拆分组件\"><a href=\"#如何拆分组件\" class=\"headerlink\" title=\"如何拆分组件\"></a>如何拆分组件</h2><blockquote>\n<p>按照设计ui提供的ui图，提取公共展示功能，作为展示组件的提取，在页面开发过程中提取页面中独立业务单独出来业务组件，在表单页面提取公共的非内置表单元素作为控件处理（地区选择，选择日期，选择…..）</p>\n</blockquote>\n<h2 id=\"组件的创建方式\"><a href=\"#组件的创建方式\" class=\"headerlink\" title=\"组件的创建方式\"></a>组件的创建方式</h2><ul>\n<li>vue.component(componnetName,option)           (自动渲染)</li>\n<li>在每一个组件中都有component选项，用来注册局部组件    (自动渲染)</li>\n<li>通过Vue.extends()扩展子类的形式创建                (手动渲染)</li>\n</ul>\n<h2 id=\"组建的实例选项\"><a href=\"#组建的实例选项\" class=\"headerlink\" title=\"组建的实例选项\"></a>组建的实例选项</h2><ul>\n<li>@[function] data</li>\n<li>@[object] method</li>\n<li>@[object] compoted</li>\n<li>@[object] watch</li>\n<li>@[object] conponents</li>\n<li><p>@[function] 生命周期 </p>\n<pre><code>  beforeCreated () {}        // 初始化数据之前\n  created () {}             // 数据初始化之后\n  beforeMout () {}         // 开始渲染\n  mounted () {}             // 渲染完成\n  beforeUpdate () {}         // 开始更新 当一个数据的改变引起了视图的重新的渲染才会执行，单独的一个数据改变是不会执行的\n  uppdated () {}             // 更新完成\n\n  //当使用keep-alive组件时才会 执行\n  activated () {}         // 组件启用时\n  deactivated () {}         // 组件停用时\n\n  //组件销毁 v-if销毁组件，或者切换路由(在没有启用缓存的前提)，或者手动执行this.$destroy () {}            // 清理组件中绑定的data，通过v-on绑定事件，如果有手动绑定的内容需要，在这个生命周期中手动销毁\n  beforeDestroy () {}\n  destroyed () {}\n</code></pre></li>\n</ul>\n<pre><code>    errorCaptured () {}        // 当组件中发生错误时\n</code></pre><h2 id=\"组件的通讯方式\"><a href=\"#组件的通讯方式\" class=\"headerlink\" title=\"组件的通讯方式\"></a>组件的通讯方式</h2><h3 id=\"通讯创建：父子，子父，同级，跨级\"><a href=\"#通讯创建：父子，子父，同级，跨级\" class=\"headerlink\" title=\"通讯创建：父子，子父，同级，跨级\"></a>通讯创建：父子，子父，同级，跨级</h3><h3 id=\"通讯其实就是谁用谁的数据\"><a href=\"#通讯其实就是谁用谁的数据\" class=\"headerlink\" title=\"通讯其实就是谁用谁的数据\"></a>通讯其实就是谁用谁的数据</h3><ul>\n<li>父子：子组件使用父组件数据，props(常用)，子组件内部通过$parent</li>\n<li>子父：父组件使用子组件数据，通过自定事件，子组件通过$emit(事件名称，发送数据)给父组件传递数据(常用)$children $refs</li>\n<li>同级：代理(一个子组件将数据发送到父级，父在发送到另一个子级)，eventBus vuex</li>\n<li>跨级：逐层传递，vuex eventsBus</li>\n</ul>\n<h2 id=\"组件的嵌套\"><a href=\"#组件的嵌套\" class=\"headerlink\" title=\"组件的嵌套\"></a>组件的嵌套</h2><h3 id=\"组件内部通过slot内置组件，可以用来承载嵌套组件-单个slot，和命名slot\"><a href=\"#组件内部通过slot内置组件，可以用来承载嵌套组件-单个slot，和命名slot\" class=\"headerlink\" title=\"组件内部通过slot内置组件，可以用来承载嵌套组件(单个slot，和命名slot)\"></a>组件内部通过slot内置组件，可以用来承载嵌套组件(单个slot，和命名slot)</h3><h2 id=\"内置组件\"><a href=\"#内置组件\" class=\"headerlink\" title=\"内置组件\"></a>内置组件</h2><ul>\n<li>template 单文件组件中代替了template选项，可以用作一个包裹元素，不会被渲染</li>\n<li>component 动态组件，通过is属性动态渲染某一个组件</li>\n<li>slot 插槽，用来承载组件潜逃的子组件</li>\n<li>transition vue用来实现动画的组件(提供了，进入和离开两个状态)</li>\n<li>transitions-group 用来实现多动画(列表动画，排序，添加，删除)</li>\n<li>keep-alive 用来启动vue缓存功能，缓存组件的状态</li>\n</ul>\n<h2 id=\"vue的实例属性\"><a href=\"#vue的实例属性\" class=\"headerlink\" title=\"vue的实例属性\"></a>vue的实例属性</h2><pre><code>实例属性\nvm.$data                 // 访问定义的data\nvm.$props                 // 访问props对象\nvm.$el                     // 访问组件的根节点\nvm.$options             // 访问所有配置项\nvm.$parent                 // 访问父组件实例\nvm.$root\nvm.$children\nvm.$slots\nvm.$scopedSlots\nvm.$refs\nvm.$isServer\nvm.$attrs\nvm.$listeners\n实例方法 / 数据\nvm.$watch\nvm.$set\nvm.$delete\n实例方法 / 事件\nvm.$on\nvm.$once\nvm.$off\nvm.$emit\n实例方法 / 生命周期\nvm.$mount\nvm.$forceUpdate\nvm.$nextTick    //数据改变后回调\nvm.$destroy //手动渲染\n</code></pre>"},{"title":"RESTful API","date":"2019-02-12T10:38:14.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"\n## 前后端交互？\n\n> #### 以前前后端是不分离的，随着ajax的出现，可以实现异步获取数据，不需要一直刷新页面，可以通过异步的形式获取数据，提升用户体验，后来随着一些前端框架的出现，开始有了前后端分离的开发模式，前端负责页面结构，样式，效果，数据渲染、（逻辑处理）后端只需要提供数据接口，提升了开发效率\n\n## 前后端分离\n\n> #### 前后端分离之后出现的问题，数据结构有时候不会特别便利（不太方便），接口报错的时候，接口描述不清晰，这个时候都需要前端和后台沟通，为了提升开发效率，现在所有的后端需要提供接口文档，描述每一个接口是干什么的，每一个参数是干什么的，但是还是避免不了又不清晰的地方，后端也有可能发生错误，所以现在一般接口都会有接口规范（最常用的[RESTful API](http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html)）\n\n## 后端开发语言？\n\n####php,java,.net,.... 这些语言都可以输出html语言\n\n> php循环\n\n\t<div>\n\t\t<?php\n\t\t\tfor ($x=0; $x<=10; $x++) {\n\t\t\t\texho \"<li> $x </li>\";\n\t\t\t}\n\t\t?>\n\t</div>\n\n\n### 在这个时候前后端的职责就是前端只做页面布局+js效果，写静态页面，将静态页面给后端作为模板，后端开始嵌套数据，这时候前后交互是前端需要协助后端做页面调试，前端会一直配合后台做样式，结构处理，造成工作效率低下的问题\n\n## 全栈工程师\n\n#### 有了node的出现，前端也可以做数据库的操作呢，接口的开发，node开发接口一般用两个框架express。 koa ，数据库mysql ，mongdb （CRUD); 现在一般常用node做中间层处理【就是原有接口的转换】，node在企业开发中也会做一些提升开发效率的工具，node也可以用作桌面应用程序额的开发\n\n\n## RESTful\n\n### 起源：\n\n> REST这个词，是Roy Thomas Fielding在他2000年的博士论文中提出的。\n\n### 名称：\n\n> Fielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer的缩写（表现层状态转化）。\n\n### 理解：\n\n> RE:(表现层)：指的就是资源（把资源呈现出来就叫表现层）\t\n> \t\t\t\n> ST:(转态转换)：访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生\"状态转化”。而这种转化是建立在表现层之上的，所以就是\"表现层状态转化\"。\n\n\n----------\n> 客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：\n> \n\tGET、POST、PUT、DELETE。\n它们分别对应四种基本操作：\n\n> \n- GET用来获取资源，\n> \n- POST用来新建资源（也可以用于更新资源），\n> \n- PUT用来更新资源，\n> \n- DELETE用来删除资源。\n\n\n### 总结RESTful\n\n> **看Url就知道要什么**\n\n> \n>** 看http method就知道干什么**\n> \n> **看http status code就知道结果如何**\n> \n","source":"_posts/web server.md","raw":"---\ntitle: RESTful API\ndate: '2/12/2019 6:38:14 PM '\ntag: ['js', '前后端交互', 'Restful']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n\n## 前后端交互？\n\n> #### 以前前后端是不分离的，随着ajax的出现，可以实现异步获取数据，不需要一直刷新页面，可以通过异步的形式获取数据，提升用户体验，后来随着一些前端框架的出现，开始有了前后端分离的开发模式，前端负责页面结构，样式，效果，数据渲染、（逻辑处理）后端只需要提供数据接口，提升了开发效率\n\n## 前后端分离\n\n> #### 前后端分离之后出现的问题，数据结构有时候不会特别便利（不太方便），接口报错的时候，接口描述不清晰，这个时候都需要前端和后台沟通，为了提升开发效率，现在所有的后端需要提供接口文档，描述每一个接口是干什么的，每一个参数是干什么的，但是还是避免不了又不清晰的地方，后端也有可能发生错误，所以现在一般接口都会有接口规范（最常用的[RESTful API](http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html)）\n\n## 后端开发语言？\n\n####php,java,.net,.... 这些语言都可以输出html语言\n\n> php循环\n\n\t<div>\n\t\t<?php\n\t\t\tfor ($x=0; $x<=10; $x++) {\n\t\t\t\texho \"<li> $x </li>\";\n\t\t\t}\n\t\t?>\n\t</div>\n\n\n### 在这个时候前后端的职责就是前端只做页面布局+js效果，写静态页面，将静态页面给后端作为模板，后端开始嵌套数据，这时候前后交互是前端需要协助后端做页面调试，前端会一直配合后台做样式，结构处理，造成工作效率低下的问题\n\n## 全栈工程师\n\n#### 有了node的出现，前端也可以做数据库的操作呢，接口的开发，node开发接口一般用两个框架express。 koa ，数据库mysql ，mongdb （CRUD); 现在一般常用node做中间层处理【就是原有接口的转换】，node在企业开发中也会做一些提升开发效率的工具，node也可以用作桌面应用程序额的开发\n\n\n## RESTful\n\n### 起源：\n\n> REST这个词，是Roy Thomas Fielding在他2000年的博士论文中提出的。\n\n### 名称：\n\n> Fielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer的缩写（表现层状态转化）。\n\n### 理解：\n\n> RE:(表现层)：指的就是资源（把资源呈现出来就叫表现层）\t\n> \t\t\t\n> ST:(转态转换)：访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生\"状态转化”。而这种转化是建立在表现层之上的，所以就是\"表现层状态转化\"。\n\n\n----------\n> 客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：\n> \n\tGET、POST、PUT、DELETE。\n它们分别对应四种基本操作：\n\n> \n- GET用来获取资源，\n> \n- POST用来新建资源（也可以用于更新资源），\n> \n- PUT用来更新资源，\n> \n- DELETE用来删除资源。\n\n\n### 总结RESTful\n\n> **看Url就知道要什么**\n\n> \n>** 看http method就知道干什么**\n> \n> **看http status code就知道结果如何**\n> \n","slug":"web server","published":1,"updated":"2019-02-18T05:43:32.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam830030n4wd7komr8gx","content":"<h2 id=\"前后端交互？\"><a href=\"#前后端交互？\" class=\"headerlink\" title=\"前后端交互？\"></a>前后端交互？</h2><blockquote>\n<h4 id=\"以前前后端是不分离的，随着ajax的出现，可以实现异步获取数据，不需要一直刷新页面，可以通过异步的形式获取数据，提升用户体验，后来随着一些前端框架的出现，开始有了前后端分离的开发模式，前端负责页面结构，样式，效果，数据渲染、（逻辑处理）后端只需要提供数据接口，提升了开发效率\"><a href=\"#以前前后端是不分离的，随着ajax的出现，可以实现异步获取数据，不需要一直刷新页面，可以通过异步的形式获取数据，提升用户体验，后来随着一些前端框架的出现，开始有了前后端分离的开发模式，前端负责页面结构，样式，效果，数据渲染、（逻辑处理）后端只需要提供数据接口，提升了开发效率\" class=\"headerlink\" title=\"以前前后端是不分离的，随着ajax的出现，可以实现异步获取数据，不需要一直刷新页面，可以通过异步的形式获取数据，提升用户体验，后来随着一些前端框架的出现，开始有了前后端分离的开发模式，前端负责页面结构，样式，效果，数据渲染、（逻辑处理）后端只需要提供数据接口，提升了开发效率\"></a>以前前后端是不分离的，随着ajax的出现，可以实现异步获取数据，不需要一直刷新页面，可以通过异步的形式获取数据，提升用户体验，后来随着一些前端框架的出现，开始有了前后端分离的开发模式，前端负责页面结构，样式，效果，数据渲染、（逻辑处理）后端只需要提供数据接口，提升了开发效率</h4></blockquote>\n<h2 id=\"前后端分离\"><a href=\"#前后端分离\" class=\"headerlink\" title=\"前后端分离\"></a>前后端分离</h2><blockquote>\n<h4 id=\"前后端分离之后出现的问题，数据结构有时候不会特别便利（不太方便），接口报错的时候，接口描述不清晰，这个时候都需要前端和后台沟通，为了提升开发效率，现在所有的后端需要提供接口文档，描述每一个接口是干什么的，每一个参数是干什么的，但是还是避免不了又不清晰的地方，后端也有可能发生错误，所以现在一般接口都会有接口规范（最常用的RESTful-API）\"><a href=\"#前后端分离之后出现的问题，数据结构有时候不会特别便利（不太方便），接口报错的时候，接口描述不清晰，这个时候都需要前端和后台沟通，为了提升开发效率，现在所有的后端需要提供接口文档，描述每一个接口是干什么的，每一个参数是干什么的，但是还是避免不了又不清晰的地方，后端也有可能发生错误，所以现在一般接口都会有接口规范（最常用的RESTful-API）\" class=\"headerlink\" title=\"前后端分离之后出现的问题，数据结构有时候不会特别便利（不太方便），接口报错的时候，接口描述不清晰，这个时候都需要前端和后台沟通，为了提升开发效率，现在所有的后端需要提供接口文档，描述每一个接口是干什么的，每一个参数是干什么的，但是还是避免不了又不清晰的地方，后端也有可能发生错误，所以现在一般接口都会有接口规范（最常用的RESTful API）\"></a>前后端分离之后出现的问题，数据结构有时候不会特别便利（不太方便），接口报错的时候，接口描述不清晰，这个时候都需要前端和后台沟通，为了提升开发效率，现在所有的后端需要提供接口文档，描述每一个接口是干什么的，每一个参数是干什么的，但是还是避免不了又不清晰的地方，后端也有可能发生错误，所以现在一般接口都会有接口规范（最常用的<a href=\"http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html\" target=\"_blank\" rel=\"noopener\">RESTful API</a>）</h4></blockquote>\n<h2 id=\"后端开发语言？\"><a href=\"#后端开发语言？\" class=\"headerlink\" title=\"后端开发语言？\"></a>后端开发语言？</h2><p>####php,java,.net,…. 这些语言都可以输出html语言</p>\n<blockquote>\n<p>php循环</p>\n</blockquote>\n<pre><code>&lt;div&gt;\n    &lt;?php\n        for ($x=0; $x&lt;=10; $x++) {\n            exho &quot;&lt;li&gt; $x &lt;/li&gt;&quot;;\n        }\n    ?&gt;\n&lt;/div&gt;\n</code></pre><h3 id=\"在这个时候前后端的职责就是前端只做页面布局-js效果，写静态页面，将静态页面给后端作为模板，后端开始嵌套数据，这时候前后交互是前端需要协助后端做页面调试，前端会一直配合后台做样式，结构处理，造成工作效率低下的问题\"><a href=\"#在这个时候前后端的职责就是前端只做页面布局-js效果，写静态页面，将静态页面给后端作为模板，后端开始嵌套数据，这时候前后交互是前端需要协助后端做页面调试，前端会一直配合后台做样式，结构处理，造成工作效率低下的问题\" class=\"headerlink\" title=\"在这个时候前后端的职责就是前端只做页面布局+js效果，写静态页面，将静态页面给后端作为模板，后端开始嵌套数据，这时候前后交互是前端需要协助后端做页面调试，前端会一直配合后台做样式，结构处理，造成工作效率低下的问题\"></a>在这个时候前后端的职责就是前端只做页面布局+js效果，写静态页面，将静态页面给后端作为模板，后端开始嵌套数据，这时候前后交互是前端需要协助后端做页面调试，前端会一直配合后台做样式，结构处理，造成工作效率低下的问题</h3><h2 id=\"全栈工程师\"><a href=\"#全栈工程师\" class=\"headerlink\" title=\"全栈工程师\"></a>全栈工程师</h2><h4 id=\"有了node的出现，前端也可以做数据库的操作呢，接口的开发，node开发接口一般用两个框架express。-koa-，数据库mysql-，mongdb-（CRUD-现在一般常用node做中间层处理【就是原有接口的转换】，node在企业开发中也会做一些提升开发效率的工具，node也可以用作桌面应用程序额的开发\"><a href=\"#有了node的出现，前端也可以做数据库的操作呢，接口的开发，node开发接口一般用两个框架express。-koa-，数据库mysql-，mongdb-（CRUD-现在一般常用node做中间层处理【就是原有接口的转换】，node在企业开发中也会做一些提升开发效率的工具，node也可以用作桌面应用程序额的开发\" class=\"headerlink\" title=\"有了node的出现，前端也可以做数据库的操作呢，接口的开发，node开发接口一般用两个框架express。 koa ，数据库mysql ，mongdb （CRUD); 现在一般常用node做中间层处理【就是原有接口的转换】，node在企业开发中也会做一些提升开发效率的工具，node也可以用作桌面应用程序额的开发\"></a>有了node的出现，前端也可以做数据库的操作呢，接口的开发，node开发接口一般用两个框架express。 koa ，数据库mysql ，mongdb （CRUD); 现在一般常用node做中间层处理【就是原有接口的转换】，node在企业开发中也会做一些提升开发效率的工具，node也可以用作桌面应用程序额的开发</h4><h2 id=\"RESTful\"><a href=\"#RESTful\" class=\"headerlink\" title=\"RESTful\"></a>RESTful</h2><h3 id=\"起源：\"><a href=\"#起源：\" class=\"headerlink\" title=\"起源：\"></a>起源：</h3><blockquote>\n<p>REST这个词，是Roy Thomas Fielding在他2000年的博士论文中提出的。</p>\n</blockquote>\n<h3 id=\"名称：\"><a href=\"#名称：\" class=\"headerlink\" title=\"名称：\"></a>名称：</h3><blockquote>\n<p>Fielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer的缩写（表现层状态转化）。</p>\n</blockquote>\n<h3 id=\"理解：\"><a href=\"#理解：\" class=\"headerlink\" title=\"理解：\"></a>理解：</h3><blockquote>\n<p>RE:(表现层)：指的就是资源（把资源呈现出来就叫表现层）    </p>\n<p>ST:(转态转换)：访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：</p>\n</blockquote>\n<pre><code>GET、POST、PUT、DELETE。\n</code></pre><p>它们分别对应四种基本操作：</p>\n<blockquote>\n</blockquote>\n<ul>\n<li>GET用来获取资源，<blockquote>\n</blockquote>\n</li>\n<li>POST用来新建资源（也可以用于更新资源），<blockquote>\n</blockquote>\n</li>\n<li>PUT用来更新资源，<blockquote>\n</blockquote>\n</li>\n<li>DELETE用来删除资源。</li>\n</ul>\n<h3 id=\"总结RESTful\"><a href=\"#总结RESTful\" class=\"headerlink\" title=\"总结RESTful\"></a>总结RESTful</h3><blockquote>\n<p><strong>看Url就知道要什么</strong></p>\n</blockquote>\n<blockquote>\n<p><strong> 看http method就知道干什么</strong></p>\n<p><strong>看http status code就知道结果如何</strong></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前后端交互？\"><a href=\"#前后端交互？\" class=\"headerlink\" title=\"前后端交互？\"></a>前后端交互？</h2><blockquote>\n<h4 id=\"以前前后端是不分离的，随着ajax的出现，可以实现异步获取数据，不需要一直刷新页面，可以通过异步的形式获取数据，提升用户体验，后来随着一些前端框架的出现，开始有了前后端分离的开发模式，前端负责页面结构，样式，效果，数据渲染、（逻辑处理）后端只需要提供数据接口，提升了开发效率\"><a href=\"#以前前后端是不分离的，随着ajax的出现，可以实现异步获取数据，不需要一直刷新页面，可以通过异步的形式获取数据，提升用户体验，后来随着一些前端框架的出现，开始有了前后端分离的开发模式，前端负责页面结构，样式，效果，数据渲染、（逻辑处理）后端只需要提供数据接口，提升了开发效率\" class=\"headerlink\" title=\"以前前后端是不分离的，随着ajax的出现，可以实现异步获取数据，不需要一直刷新页面，可以通过异步的形式获取数据，提升用户体验，后来随着一些前端框架的出现，开始有了前后端分离的开发模式，前端负责页面结构，样式，效果，数据渲染、（逻辑处理）后端只需要提供数据接口，提升了开发效率\"></a>以前前后端是不分离的，随着ajax的出现，可以实现异步获取数据，不需要一直刷新页面，可以通过异步的形式获取数据，提升用户体验，后来随着一些前端框架的出现，开始有了前后端分离的开发模式，前端负责页面结构，样式，效果，数据渲染、（逻辑处理）后端只需要提供数据接口，提升了开发效率</h4></blockquote>\n<h2 id=\"前后端分离\"><a href=\"#前后端分离\" class=\"headerlink\" title=\"前后端分离\"></a>前后端分离</h2><blockquote>\n<h4 id=\"前后端分离之后出现的问题，数据结构有时候不会特别便利（不太方便），接口报错的时候，接口描述不清晰，这个时候都需要前端和后台沟通，为了提升开发效率，现在所有的后端需要提供接口文档，描述每一个接口是干什么的，每一个参数是干什么的，但是还是避免不了又不清晰的地方，后端也有可能发生错误，所以现在一般接口都会有接口规范（最常用的RESTful-API）\"><a href=\"#前后端分离之后出现的问题，数据结构有时候不会特别便利（不太方便），接口报错的时候，接口描述不清晰，这个时候都需要前端和后台沟通，为了提升开发效率，现在所有的后端需要提供接口文档，描述每一个接口是干什么的，每一个参数是干什么的，但是还是避免不了又不清晰的地方，后端也有可能发生错误，所以现在一般接口都会有接口规范（最常用的RESTful-API）\" class=\"headerlink\" title=\"前后端分离之后出现的问题，数据结构有时候不会特别便利（不太方便），接口报错的时候，接口描述不清晰，这个时候都需要前端和后台沟通，为了提升开发效率，现在所有的后端需要提供接口文档，描述每一个接口是干什么的，每一个参数是干什么的，但是还是避免不了又不清晰的地方，后端也有可能发生错误，所以现在一般接口都会有接口规范（最常用的RESTful API）\"></a>前后端分离之后出现的问题，数据结构有时候不会特别便利（不太方便），接口报错的时候，接口描述不清晰，这个时候都需要前端和后台沟通，为了提升开发效率，现在所有的后端需要提供接口文档，描述每一个接口是干什么的，每一个参数是干什么的，但是还是避免不了又不清晰的地方，后端也有可能发生错误，所以现在一般接口都会有接口规范（最常用的<a href=\"http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html\" target=\"_blank\" rel=\"noopener\">RESTful API</a>）</h4></blockquote>\n<h2 id=\"后端开发语言？\"><a href=\"#后端开发语言？\" class=\"headerlink\" title=\"后端开发语言？\"></a>后端开发语言？</h2><p>####php,java,.net,…. 这些语言都可以输出html语言</p>\n<blockquote>\n<p>php循环</p>\n</blockquote>\n<pre><code>&lt;div&gt;\n    &lt;?php\n        for ($x=0; $x&lt;=10; $x++) {\n            exho &quot;&lt;li&gt; $x &lt;/li&gt;&quot;;\n        }\n    ?&gt;\n&lt;/div&gt;\n</code></pre><h3 id=\"在这个时候前后端的职责就是前端只做页面布局-js效果，写静态页面，将静态页面给后端作为模板，后端开始嵌套数据，这时候前后交互是前端需要协助后端做页面调试，前端会一直配合后台做样式，结构处理，造成工作效率低下的问题\"><a href=\"#在这个时候前后端的职责就是前端只做页面布局-js效果，写静态页面，将静态页面给后端作为模板，后端开始嵌套数据，这时候前后交互是前端需要协助后端做页面调试，前端会一直配合后台做样式，结构处理，造成工作效率低下的问题\" class=\"headerlink\" title=\"在这个时候前后端的职责就是前端只做页面布局+js效果，写静态页面，将静态页面给后端作为模板，后端开始嵌套数据，这时候前后交互是前端需要协助后端做页面调试，前端会一直配合后台做样式，结构处理，造成工作效率低下的问题\"></a>在这个时候前后端的职责就是前端只做页面布局+js效果，写静态页面，将静态页面给后端作为模板，后端开始嵌套数据，这时候前后交互是前端需要协助后端做页面调试，前端会一直配合后台做样式，结构处理，造成工作效率低下的问题</h3><h2 id=\"全栈工程师\"><a href=\"#全栈工程师\" class=\"headerlink\" title=\"全栈工程师\"></a>全栈工程师</h2><h4 id=\"有了node的出现，前端也可以做数据库的操作呢，接口的开发，node开发接口一般用两个框架express。-koa-，数据库mysql-，mongdb-（CRUD-现在一般常用node做中间层处理【就是原有接口的转换】，node在企业开发中也会做一些提升开发效率的工具，node也可以用作桌面应用程序额的开发\"><a href=\"#有了node的出现，前端也可以做数据库的操作呢，接口的开发，node开发接口一般用两个框架express。-koa-，数据库mysql-，mongdb-（CRUD-现在一般常用node做中间层处理【就是原有接口的转换】，node在企业开发中也会做一些提升开发效率的工具，node也可以用作桌面应用程序额的开发\" class=\"headerlink\" title=\"有了node的出现，前端也可以做数据库的操作呢，接口的开发，node开发接口一般用两个框架express。 koa ，数据库mysql ，mongdb （CRUD); 现在一般常用node做中间层处理【就是原有接口的转换】，node在企业开发中也会做一些提升开发效率的工具，node也可以用作桌面应用程序额的开发\"></a>有了node的出现，前端也可以做数据库的操作呢，接口的开发，node开发接口一般用两个框架express。 koa ，数据库mysql ，mongdb （CRUD); 现在一般常用node做中间层处理【就是原有接口的转换】，node在企业开发中也会做一些提升开发效率的工具，node也可以用作桌面应用程序额的开发</h4><h2 id=\"RESTful\"><a href=\"#RESTful\" class=\"headerlink\" title=\"RESTful\"></a>RESTful</h2><h3 id=\"起源：\"><a href=\"#起源：\" class=\"headerlink\" title=\"起源：\"></a>起源：</h3><blockquote>\n<p>REST这个词，是Roy Thomas Fielding在他2000年的博士论文中提出的。</p>\n</blockquote>\n<h3 id=\"名称：\"><a href=\"#名称：\" class=\"headerlink\" title=\"名称：\"></a>名称：</h3><blockquote>\n<p>Fielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer的缩写（表现层状态转化）。</p>\n</blockquote>\n<h3 id=\"理解：\"><a href=\"#理解：\" class=\"headerlink\" title=\"理解：\"></a>理解：</h3><blockquote>\n<p>RE:(表现层)：指的就是资源（把资源呈现出来就叫表现层）    </p>\n<p>ST:(转态转换)：访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：</p>\n</blockquote>\n<pre><code>GET、POST、PUT、DELETE。\n</code></pre><p>它们分别对应四种基本操作：</p>\n<blockquote>\n</blockquote>\n<ul>\n<li>GET用来获取资源，<blockquote>\n</blockquote>\n</li>\n<li>POST用来新建资源（也可以用于更新资源），<blockquote>\n</blockquote>\n</li>\n<li>PUT用来更新资源，<blockquote>\n</blockquote>\n</li>\n<li>DELETE用来删除资源。</li>\n</ul>\n<h3 id=\"总结RESTful\"><a href=\"#总结RESTful\" class=\"headerlink\" title=\"总结RESTful\"></a>总结RESTful</h3><blockquote>\n<p><strong>看Url就知道要什么</strong></p>\n</blockquote>\n<blockquote>\n<p><strong> 看http method就知道干什么</strong></p>\n<p><strong>看http status code就知道结果如何</strong></p>\n</blockquote>\n"},{"title":"Vuex简单概述","date":"2019-01-30T11:49:45.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"# Vuex\n\n\n----------\n\n\n## Vuex是什么？\n\n> **引入官方提供的解释，vuex 是专门为 vue.js 设计的一套 状态管理模式 。什么是状态管理模式？说白了就是数据的集中管理。我们在使用 vue.js 时所用到的数据全部抽取出来放在一个state对象下，这样我们在任何组件内都可以访问得到该数据。下面我们通过一个例子来看下 vuex 是如何管理我们的数据的。**\n\n### 首先先通过npm来安装一下vuex：\n\n    npm install vuex --save\n\n## state状态属性\n\n### 在项目src目录下新建一个store文件夹(该文件夹不是必须的，你也可以直接新建一个store.js，只要你引入的路径正确即可)，在该文件夹下新建一个 index.js。store文件夹主要是单独管理我们的数据状态，包括行为触发等等。 \n\n> #### store/index.js\n\n\t\n\timport Vue from 'vue'\n\timport Vuex from 'vuex'\n\tVue.use(Vuex)\n\tlet store = new Vuex.Store({\n\t\tstate: {  //要设置的全局访问的state对象\n\t\t\tname: \"vuex\"\n\t\t}\n\t})\n\n\texport default store\n\n### 为了能在所有的组件中共享我们的数据，我们有必要给根实例下注入我们的store对象，所以我们在main.js文件中 \n\n> #### main.js\n\n\timport Vue from 'vue'\n\timport App from './App.vue'\n\timport \"./commcss/index.scss\"\n\timport store from './store/index'\n\tnew Vue({\n\t  el: '#app',\n\t  render: h => h(App),\n\t  store // 全局注册\n\t})\n\n\n> #### App.vue\n\n\t<template>\n  \t\t<div class=\"app\">\n\t\t\t{{name}}\n\t\t</div>\n\t</template>\n\t<script>\n\timport { mapState} from 'vuex'\n\t/*\n\t *1.mapState 辅助函数\n\t *当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。\n\t *为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键：\n\t */\n\texport default {\n\t  computde: {\n\t\t...mapState(['name'])\n\t\t}\n\t}\n\t</script>\n\n## Getter(store的计算属性，例如对列表进行过滤)\n\n> #### store/index.js\n\n\tstate: {\n    \tcount: 1,\n    \tarr: [\n\t      {\n\t        sex: '男',\n\t\t\tid: 1\n\t      },\n\t      {\n\t        sex: '男',\n\t\t\tid: 2\n\t      },\n\t      {\n\t        sex: '男',\n\t\t\tid: 3\n\t      },\n\t      {\n\t        sex: '男',\n\t\t\tid: 4\n\t      },\n\t      {\n\t        sex: '女',\n\t\t\tid: 5\n\t      },\n\t      {\n\t        sex: '男',\n\t\t\tid: 6\n\t      },\n\t      {\n\t        sex: '男',\n\t\t\tid: 7\n\t      }\n    \t]\n  \t},\n\tgetters: {\n\t    man (state) {\n\t      return state.arr.filter(item=>{return item.sex==='男'})\n\t    }\n  \t},\n> #### App.vue\n\n\t<template>\n  \t\t<div class=\"app\">\n\t\t\t<ul>\n\t\t\t\t<li v-for=\"(item,index) in man\" :key=\"item.id\">{{item.sex}}</li>\n\t\t\t</ul>\n\t\t</div>\n\t</template>\n\t<script>\n\timport { mapGetters } from 'vuex' //mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：\n\texport default {\n\t  computde: {\n\t\t...mapGetters(['man'])\n\t\t}\n\t}\n\t</script>\n\n\n## mutation(更新state的唯一方法)\n\n> #### store/index.js\n\n\tmutation: {\n\t\tchange (state) {\n\t\t\tstate.name = 'vue'\n\t\t}\n\t}\n\n> #### App.vue\n\n\t<template>\n  \t\t<div class=\"app\" @click=\"change\">\n\t\t\t{{name}}\n\t\t</div>\n\t</template>\n\t<script>\n\texport default {\n\t  method: {\n\t\tchange () {\n\t\t\tthis.$store.commit('change')\n\t\t}\n\t  }\n\t}\n\t</script>\t\n\n## 一条重要的原则就是要记住 mutation 必须是同步函数\n\n### 原因：(为什么不能执行一步操作)\n\n> **现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。**\n\n### 因此：【我们需要一个action来进行异步操作】\n\n## Action\n\n### Action 类似于 mutation，不同在于：\n\n- **Action 提交的是 mutation，而不是直接变更状态。**\n- **Action 可以包含任意异步操作。**\n\n> #### store/index.js\n\n\n\tstate: {\n\t\tcount: 0\n\t},\n\tmutations: {\n\t    addcount (state) {\n\t      state.count++\n\t    }\n  \t},\n\tactions: {\n\t    getInfo (context) {\n\t      setTimeout(()=>{\n\t        context.commit('addcount')\n\t      },2000)\n\t    }\n  \t}\n\n> #### App.vue\n\n\t<template>\n  \t\t<div class=\"app\" @click=\"change\">\n\t\t\t{{count}}\n\t\t</div>\n\t</template>\n\t<script>\n\texport default {\n\t  computed: {\n\t    ...mapState(['count'])\n\t  },\n\t  method: {\n\t\tchange () {\n\t\t\tthis.$store.dispatch('getInfo')\n\t\t}\n\t  }\n\t}\n\t</script>\n\n###### 乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 mutation 必须同步执行这个限制么？Action 就不受约束！我们可以在 action 内部执行异步操作：\n\n## Module\n\n### 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。\n\n----------\n\n\n#### 为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：\n\n首先创建module/todo.js\n\n> **module/todo.js**\n\n\texport default {\n\t  namespaced: true,\n\t  state: {\n\t    count: 0\n\t  },\n\t  mutations: {\n\t    addcount (state) {\n\t      state.count++\n\t    }\n\t  },\n\t}\n\n> #### store/index.js\n\n\timport todo from \"./modules/todo\"\n\n\tmodules: {\n    \ttodo\n  \t}\n\n> #### App.vue\n\n\t<template>\n  \t\t<div class=\"app\" @click=\"change\">\n\t\t\t{{count}}\n\t\t</div>\n\t</template>\n\t<script>\n\texport default {\n\t  computed: {\n\t    ...mapState('todo',['count'])\n\t  },\n\t  method: {\n\t\tchange () {\n\t\t\tthis.$store.commit('todo/addcount')\n\t\t}\n\t  }\n\t}\n\t</script>\t","source":"_posts/vuex.md","raw":"---\ntitle: Vuex简单概述\ndate: '1/30/2019 7:49:45 PM '\ntag: ['js', 'vuex', 'vue']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n# Vuex\n\n\n----------\n\n\n## Vuex是什么？\n\n> **引入官方提供的解释，vuex 是专门为 vue.js 设计的一套 状态管理模式 。什么是状态管理模式？说白了就是数据的集中管理。我们在使用 vue.js 时所用到的数据全部抽取出来放在一个state对象下，这样我们在任何组件内都可以访问得到该数据。下面我们通过一个例子来看下 vuex 是如何管理我们的数据的。**\n\n### 首先先通过npm来安装一下vuex：\n\n    npm install vuex --save\n\n## state状态属性\n\n### 在项目src目录下新建一个store文件夹(该文件夹不是必须的，你也可以直接新建一个store.js，只要你引入的路径正确即可)，在该文件夹下新建一个 index.js。store文件夹主要是单独管理我们的数据状态，包括行为触发等等。 \n\n> #### store/index.js\n\n\t\n\timport Vue from 'vue'\n\timport Vuex from 'vuex'\n\tVue.use(Vuex)\n\tlet store = new Vuex.Store({\n\t\tstate: {  //要设置的全局访问的state对象\n\t\t\tname: \"vuex\"\n\t\t}\n\t})\n\n\texport default store\n\n### 为了能在所有的组件中共享我们的数据，我们有必要给根实例下注入我们的store对象，所以我们在main.js文件中 \n\n> #### main.js\n\n\timport Vue from 'vue'\n\timport App from './App.vue'\n\timport \"./commcss/index.scss\"\n\timport store from './store/index'\n\tnew Vue({\n\t  el: '#app',\n\t  render: h => h(App),\n\t  store // 全局注册\n\t})\n\n\n> #### App.vue\n\n\t<template>\n  \t\t<div class=\"app\">\n\t\t\t{{name}}\n\t\t</div>\n\t</template>\n\t<script>\n\timport { mapState} from 'vuex'\n\t/*\n\t *1.mapState 辅助函数\n\t *当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。\n\t *为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键：\n\t */\n\texport default {\n\t  computde: {\n\t\t...mapState(['name'])\n\t\t}\n\t}\n\t</script>\n\n## Getter(store的计算属性，例如对列表进行过滤)\n\n> #### store/index.js\n\n\tstate: {\n    \tcount: 1,\n    \tarr: [\n\t      {\n\t        sex: '男',\n\t\t\tid: 1\n\t      },\n\t      {\n\t        sex: '男',\n\t\t\tid: 2\n\t      },\n\t      {\n\t        sex: '男',\n\t\t\tid: 3\n\t      },\n\t      {\n\t        sex: '男',\n\t\t\tid: 4\n\t      },\n\t      {\n\t        sex: '女',\n\t\t\tid: 5\n\t      },\n\t      {\n\t        sex: '男',\n\t\t\tid: 6\n\t      },\n\t      {\n\t        sex: '男',\n\t\t\tid: 7\n\t      }\n    \t]\n  \t},\n\tgetters: {\n\t    man (state) {\n\t      return state.arr.filter(item=>{return item.sex==='男'})\n\t    }\n  \t},\n> #### App.vue\n\n\t<template>\n  \t\t<div class=\"app\">\n\t\t\t<ul>\n\t\t\t\t<li v-for=\"(item,index) in man\" :key=\"item.id\">{{item.sex}}</li>\n\t\t\t</ul>\n\t\t</div>\n\t</template>\n\t<script>\n\timport { mapGetters } from 'vuex' //mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：\n\texport default {\n\t  computde: {\n\t\t...mapGetters(['man'])\n\t\t}\n\t}\n\t</script>\n\n\n## mutation(更新state的唯一方法)\n\n> #### store/index.js\n\n\tmutation: {\n\t\tchange (state) {\n\t\t\tstate.name = 'vue'\n\t\t}\n\t}\n\n> #### App.vue\n\n\t<template>\n  \t\t<div class=\"app\" @click=\"change\">\n\t\t\t{{name}}\n\t\t</div>\n\t</template>\n\t<script>\n\texport default {\n\t  method: {\n\t\tchange () {\n\t\t\tthis.$store.commit('change')\n\t\t}\n\t  }\n\t}\n\t</script>\t\n\n## 一条重要的原则就是要记住 mutation 必须是同步函数\n\n### 原因：(为什么不能执行一步操作)\n\n> **现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。**\n\n### 因此：【我们需要一个action来进行异步操作】\n\n## Action\n\n### Action 类似于 mutation，不同在于：\n\n- **Action 提交的是 mutation，而不是直接变更状态。**\n- **Action 可以包含任意异步操作。**\n\n> #### store/index.js\n\n\n\tstate: {\n\t\tcount: 0\n\t},\n\tmutations: {\n\t    addcount (state) {\n\t      state.count++\n\t    }\n  \t},\n\tactions: {\n\t    getInfo (context) {\n\t      setTimeout(()=>{\n\t        context.commit('addcount')\n\t      },2000)\n\t    }\n  \t}\n\n> #### App.vue\n\n\t<template>\n  \t\t<div class=\"app\" @click=\"change\">\n\t\t\t{{count}}\n\t\t</div>\n\t</template>\n\t<script>\n\texport default {\n\t  computed: {\n\t    ...mapState(['count'])\n\t  },\n\t  method: {\n\t\tchange () {\n\t\t\tthis.$store.dispatch('getInfo')\n\t\t}\n\t  }\n\t}\n\t</script>\n\n###### 乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 mutation 必须同步执行这个限制么？Action 就不受约束！我们可以在 action 内部执行异步操作：\n\n## Module\n\n### 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。\n\n----------\n\n\n#### 为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：\n\n首先创建module/todo.js\n\n> **module/todo.js**\n\n\texport default {\n\t  namespaced: true,\n\t  state: {\n\t    count: 0\n\t  },\n\t  mutations: {\n\t    addcount (state) {\n\t      state.count++\n\t    }\n\t  },\n\t}\n\n> #### store/index.js\n\n\timport todo from \"./modules/todo\"\n\n\tmodules: {\n    \ttodo\n  \t}\n\n> #### App.vue\n\n\t<template>\n  \t\t<div class=\"app\" @click=\"change\">\n\t\t\t{{count}}\n\t\t</div>\n\t</template>\n\t<script>\n\texport default {\n\t  computed: {\n\t    ...mapState('todo',['count'])\n\t  },\n\t  method: {\n\t\tchange () {\n\t\t\tthis.$store.commit('todo/addcount')\n\t\t}\n\t  }\n\t}\n\t</script>\t","slug":"vuex","published":1,"updated":"2019-01-30T11:50:19.114Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam840033n4wdf2fcmjbr","content":"<h1 id=\"Vuex\"><a href=\"#Vuex\" class=\"headerlink\" title=\"Vuex\"></a>Vuex</h1><hr>\n<h2 id=\"Vuex是什么？\"><a href=\"#Vuex是什么？\" class=\"headerlink\" title=\"Vuex是什么？\"></a>Vuex是什么？</h2><blockquote>\n<p><strong>引入官方提供的解释，vuex 是专门为 vue.js 设计的一套 状态管理模式 。什么是状态管理模式？说白了就是数据的集中管理。我们在使用 vue.js 时所用到的数据全部抽取出来放在一个state对象下，这样我们在任何组件内都可以访问得到该数据。下面我们通过一个例子来看下 vuex 是如何管理我们的数据的。</strong></p>\n</blockquote>\n<h3 id=\"首先先通过npm来安装一下vuex：\"><a href=\"#首先先通过npm来安装一下vuex：\" class=\"headerlink\" title=\"首先先通过npm来安装一下vuex：\"></a>首先先通过npm来安装一下vuex：</h3><pre><code>npm install vuex --save\n</code></pre><h2 id=\"state状态属性\"><a href=\"#state状态属性\" class=\"headerlink\" title=\"state状态属性\"></a>state状态属性</h2><h3 id=\"在项目src目录下新建一个store文件夹-该文件夹不是必须的，你也可以直接新建一个store-js，只要你引入的路径正确即可-，在该文件夹下新建一个-index-js。store文件夹主要是单独管理我们的数据状态，包括行为触发等等。\"><a href=\"#在项目src目录下新建一个store文件夹-该文件夹不是必须的，你也可以直接新建一个store-js，只要你引入的路径正确即可-，在该文件夹下新建一个-index-js。store文件夹主要是单独管理我们的数据状态，包括行为触发等等。\" class=\"headerlink\" title=\"在项目src目录下新建一个store文件夹(该文件夹不是必须的，你也可以直接新建一个store.js，只要你引入的路径正确即可)，在该文件夹下新建一个 index.js。store文件夹主要是单独管理我们的数据状态，包括行为触发等等。\"></a>在项目src目录下新建一个store文件夹(该文件夹不是必须的，你也可以直接新建一个store.js，只要你引入的路径正确即可)，在该文件夹下新建一个 index.js。store文件夹主要是单独管理我们的数据状态，包括行为触发等等。</h3><blockquote>\n<h4 id=\"store-index-js\"><a href=\"#store-index-js\" class=\"headerlink\" title=\"store/index.js\"></a>store/index.js</h4></blockquote>\n<pre><code>import Vue from &#39;vue&#39;\nimport Vuex from &#39;vuex&#39;\nVue.use(Vuex)\nlet store = new Vuex.Store({\n    state: {  //要设置的全局访问的state对象\n        name: &quot;vuex&quot;\n    }\n})\n\nexport default store\n</code></pre><h3 id=\"为了能在所有的组件中共享我们的数据，我们有必要给根实例下注入我们的store对象，所以我们在main-js文件中\"><a href=\"#为了能在所有的组件中共享我们的数据，我们有必要给根实例下注入我们的store对象，所以我们在main-js文件中\" class=\"headerlink\" title=\"为了能在所有的组件中共享我们的数据，我们有必要给根实例下注入我们的store对象，所以我们在main.js文件中\"></a>为了能在所有的组件中共享我们的数据，我们有必要给根实例下注入我们的store对象，所以我们在main.js文件中</h3><blockquote>\n<h4 id=\"main-js\"><a href=\"#main-js\" class=\"headerlink\" title=\"main.js\"></a>main.js</h4></blockquote>\n<pre><code>import Vue from &#39;vue&#39;\nimport App from &#39;./App.vue&#39;\nimport &quot;./commcss/index.scss&quot;\nimport store from &#39;./store/index&#39;\nnew Vue({\n  el: &#39;#app&#39;,\n  render: h =&gt; h(App),\n  store // 全局注册\n})\n</code></pre><blockquote>\n<h4 id=\"App-vue\"><a href=\"#App-vue\" class=\"headerlink\" title=\"App.vue\"></a>App.vue</h4></blockquote>\n<pre><code>&lt;template&gt;\n      &lt;div class=&quot;app&quot;&gt;\n        {{name}}\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport { mapState} from &#39;vuex&#39;\n/*\n *1.mapState 辅助函数\n *当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。\n *为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键：\n */\nexport default {\n  computde: {\n    ...mapState([&#39;name&#39;])\n    }\n}\n&lt;/script&gt;\n</code></pre><h2 id=\"Getter-store的计算属性，例如对列表进行过滤\"><a href=\"#Getter-store的计算属性，例如对列表进行过滤\" class=\"headerlink\" title=\"Getter(store的计算属性，例如对列表进行过滤)\"></a>Getter(store的计算属性，例如对列表进行过滤)</h2><blockquote>\n<h4 id=\"store-index-js-1\"><a href=\"#store-index-js-1\" class=\"headerlink\" title=\"store/index.js\"></a>store/index.js</h4></blockquote>\n<pre><code>state: {\n    count: 1,\n    arr: [\n      {\n        sex: &#39;男&#39;,\n        id: 1\n      },\n      {\n        sex: &#39;男&#39;,\n        id: 2\n      },\n      {\n        sex: &#39;男&#39;,\n        id: 3\n      },\n      {\n        sex: &#39;男&#39;,\n        id: 4\n      },\n      {\n        sex: &#39;女&#39;,\n        id: 5\n      },\n      {\n        sex: &#39;男&#39;,\n        id: 6\n      },\n      {\n        sex: &#39;男&#39;,\n        id: 7\n      }\n    ]\n  },\ngetters: {\n    man (state) {\n      return state.arr.filter(item=&gt;{return item.sex===&#39;男&#39;})\n    }\n  },\n</code></pre><blockquote>\n<h4 id=\"App-vue-1\"><a href=\"#App-vue-1\" class=\"headerlink\" title=\"App.vue\"></a>App.vue</h4></blockquote>\n<pre><code>&lt;template&gt;\n      &lt;div class=&quot;app&quot;&gt;\n        &lt;ul&gt;\n            &lt;li v-for=&quot;(item,index) in man&quot; :key=&quot;item.id&quot;&gt;{{item.sex}}&lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport { mapGetters } from &#39;vuex&#39; //mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：\nexport default {\n  computde: {\n    ...mapGetters([&#39;man&#39;])\n    }\n}\n&lt;/script&gt;\n</code></pre><h2 id=\"mutation-更新state的唯一方法\"><a href=\"#mutation-更新state的唯一方法\" class=\"headerlink\" title=\"mutation(更新state的唯一方法)\"></a>mutation(更新state的唯一方法)</h2><blockquote>\n<h4 id=\"store-index-js-2\"><a href=\"#store-index-js-2\" class=\"headerlink\" title=\"store/index.js\"></a>store/index.js</h4></blockquote>\n<pre><code>mutation: {\n    change (state) {\n        state.name = &#39;vue&#39;\n    }\n}\n</code></pre><blockquote>\n<h4 id=\"App-vue-2\"><a href=\"#App-vue-2\" class=\"headerlink\" title=\"App.vue\"></a>App.vue</h4></blockquote>\n<pre><code>&lt;template&gt;\n      &lt;div class=&quot;app&quot; @click=&quot;change&quot;&gt;\n        {{name}}\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n  method: {\n    change () {\n        this.$store.commit(&#39;change&#39;)\n    }\n  }\n}\n&lt;/script&gt;    \n</code></pre><h2 id=\"一条重要的原则就是要记住-mutation-必须是同步函数\"><a href=\"#一条重要的原则就是要记住-mutation-必须是同步函数\" class=\"headerlink\" title=\"一条重要的原则就是要记住 mutation 必须是同步函数\"></a>一条重要的原则就是要记住 mutation 必须是同步函数</h2><h3 id=\"原因：-为什么不能执行一步操作\"><a href=\"#原因：-为什么不能执行一步操作\" class=\"headerlink\" title=\"原因：(为什么不能执行一步操作)\"></a>原因：(为什么不能执行一步操作)</h3><blockquote>\n<p><strong>现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。</strong></p>\n</blockquote>\n<h3 id=\"因此：【我们需要一个action来进行异步操作】\"><a href=\"#因此：【我们需要一个action来进行异步操作】\" class=\"headerlink\" title=\"因此：【我们需要一个action来进行异步操作】\"></a>因此：【我们需要一个action来进行异步操作】</h3><h2 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action</h2><h3 id=\"Action-类似于-mutation，不同在于：\"><a href=\"#Action-类似于-mutation，不同在于：\" class=\"headerlink\" title=\"Action 类似于 mutation，不同在于：\"></a>Action 类似于 mutation，不同在于：</h3><ul>\n<li><strong>Action 提交的是 mutation，而不是直接变更状态。</strong></li>\n<li><strong>Action 可以包含任意异步操作。</strong></li>\n</ul>\n<blockquote>\n<h4 id=\"store-index-js-3\"><a href=\"#store-index-js-3\" class=\"headerlink\" title=\"store/index.js\"></a>store/index.js</h4></blockquote>\n<pre><code>state: {\n    count: 0\n},\nmutations: {\n    addcount (state) {\n      state.count++\n    }\n  },\nactions: {\n    getInfo (context) {\n      setTimeout(()=&gt;{\n        context.commit(&#39;addcount&#39;)\n      },2000)\n    }\n  }\n</code></pre><blockquote>\n<h4 id=\"App-vue-3\"><a href=\"#App-vue-3\" class=\"headerlink\" title=\"App.vue\"></a>App.vue</h4></blockquote>\n<pre><code>&lt;template&gt;\n      &lt;div class=&quot;app&quot; @click=&quot;change&quot;&gt;\n        {{count}}\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n  computed: {\n    ...mapState([&#39;count&#39;])\n  },\n  method: {\n    change () {\n        this.$store.dispatch(&#39;getInfo&#39;)\n    }\n  }\n}\n&lt;/script&gt;\n</code></pre><h6 id=\"乍一眼看上去感觉多此一举，我们直接分发-mutation-岂不更方便？实际上并非如此，还记得-mutation-必须同步执行这个限制么？Action-就不受约束！我们可以在-action-内部执行异步操作：\"><a href=\"#乍一眼看上去感觉多此一举，我们直接分发-mutation-岂不更方便？实际上并非如此，还记得-mutation-必须同步执行这个限制么？Action-就不受约束！我们可以在-action-内部执行异步操作：\" class=\"headerlink\" title=\"乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 mutation 必须同步执行这个限制么？Action 就不受约束！我们可以在 action 内部执行异步操作：\"></a>乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 mutation 必须同步执行这个限制么？Action 就不受约束！我们可以在 action 内部执行异步操作：</h6><h2 id=\"Module\"><a href=\"#Module\" class=\"headerlink\" title=\"Module\"></a>Module</h2><h3 id=\"由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store-对象就有可能变得相当臃肿。\"><a href=\"#由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store-对象就有可能变得相当臃肿。\" class=\"headerlink\" title=\"由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。\"></a>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</h3><hr>\n<h4 id=\"为了解决以上问题，Vuex-允许我们将-store-分割成模块（module）。每个模块拥有自己的-state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：\"><a href=\"#为了解决以上问题，Vuex-允许我们将-store-分割成模块（module）。每个模块拥有自己的-state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：\" class=\"headerlink\" title=\"为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：\"></a>为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</h4><p>首先创建module/todo.js</p>\n<blockquote>\n<p><strong>module/todo.js</strong></p>\n</blockquote>\n<pre><code>export default {\n  namespaced: true,\n  state: {\n    count: 0\n  },\n  mutations: {\n    addcount (state) {\n      state.count++\n    }\n  },\n}\n</code></pre><blockquote>\n<h4 id=\"store-index-js-4\"><a href=\"#store-index-js-4\" class=\"headerlink\" title=\"store/index.js\"></a>store/index.js</h4></blockquote>\n<pre><code>import todo from &quot;./modules/todo&quot;\n\nmodules: {\n    todo\n  }\n</code></pre><blockquote>\n<h4 id=\"App-vue-4\"><a href=\"#App-vue-4\" class=\"headerlink\" title=\"App.vue\"></a>App.vue</h4></blockquote>\n<pre><code>&lt;template&gt;\n      &lt;div class=&quot;app&quot; @click=&quot;change&quot;&gt;\n        {{count}}\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n  computed: {\n    ...mapState(&#39;todo&#39;,[&#39;count&#39;])\n  },\n  method: {\n    change () {\n        this.$store.commit(&#39;todo/addcount&#39;)\n    }\n  }\n}\n&lt;/script&gt;    \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Vuex\"><a href=\"#Vuex\" class=\"headerlink\" title=\"Vuex\"></a>Vuex</h1><hr>\n<h2 id=\"Vuex是什么？\"><a href=\"#Vuex是什么？\" class=\"headerlink\" title=\"Vuex是什么？\"></a>Vuex是什么？</h2><blockquote>\n<p><strong>引入官方提供的解释，vuex 是专门为 vue.js 设计的一套 状态管理模式 。什么是状态管理模式？说白了就是数据的集中管理。我们在使用 vue.js 时所用到的数据全部抽取出来放在一个state对象下，这样我们在任何组件内都可以访问得到该数据。下面我们通过一个例子来看下 vuex 是如何管理我们的数据的。</strong></p>\n</blockquote>\n<h3 id=\"首先先通过npm来安装一下vuex：\"><a href=\"#首先先通过npm来安装一下vuex：\" class=\"headerlink\" title=\"首先先通过npm来安装一下vuex：\"></a>首先先通过npm来安装一下vuex：</h3><pre><code>npm install vuex --save\n</code></pre><h2 id=\"state状态属性\"><a href=\"#state状态属性\" class=\"headerlink\" title=\"state状态属性\"></a>state状态属性</h2><h3 id=\"在项目src目录下新建一个store文件夹-该文件夹不是必须的，你也可以直接新建一个store-js，只要你引入的路径正确即可-，在该文件夹下新建一个-index-js。store文件夹主要是单独管理我们的数据状态，包括行为触发等等。\"><a href=\"#在项目src目录下新建一个store文件夹-该文件夹不是必须的，你也可以直接新建一个store-js，只要你引入的路径正确即可-，在该文件夹下新建一个-index-js。store文件夹主要是单独管理我们的数据状态，包括行为触发等等。\" class=\"headerlink\" title=\"在项目src目录下新建一个store文件夹(该文件夹不是必须的，你也可以直接新建一个store.js，只要你引入的路径正确即可)，在该文件夹下新建一个 index.js。store文件夹主要是单独管理我们的数据状态，包括行为触发等等。\"></a>在项目src目录下新建一个store文件夹(该文件夹不是必须的，你也可以直接新建一个store.js，只要你引入的路径正确即可)，在该文件夹下新建一个 index.js。store文件夹主要是单独管理我们的数据状态，包括行为触发等等。</h3><blockquote>\n<h4 id=\"store-index-js\"><a href=\"#store-index-js\" class=\"headerlink\" title=\"store/index.js\"></a>store/index.js</h4></blockquote>\n<pre><code>import Vue from &#39;vue&#39;\nimport Vuex from &#39;vuex&#39;\nVue.use(Vuex)\nlet store = new Vuex.Store({\n    state: {  //要设置的全局访问的state对象\n        name: &quot;vuex&quot;\n    }\n})\n\nexport default store\n</code></pre><h3 id=\"为了能在所有的组件中共享我们的数据，我们有必要给根实例下注入我们的store对象，所以我们在main-js文件中\"><a href=\"#为了能在所有的组件中共享我们的数据，我们有必要给根实例下注入我们的store对象，所以我们在main-js文件中\" class=\"headerlink\" title=\"为了能在所有的组件中共享我们的数据，我们有必要给根实例下注入我们的store对象，所以我们在main.js文件中\"></a>为了能在所有的组件中共享我们的数据，我们有必要给根实例下注入我们的store对象，所以我们在main.js文件中</h3><blockquote>\n<h4 id=\"main-js\"><a href=\"#main-js\" class=\"headerlink\" title=\"main.js\"></a>main.js</h4></blockquote>\n<pre><code>import Vue from &#39;vue&#39;\nimport App from &#39;./App.vue&#39;\nimport &quot;./commcss/index.scss&quot;\nimport store from &#39;./store/index&#39;\nnew Vue({\n  el: &#39;#app&#39;,\n  render: h =&gt; h(App),\n  store // 全局注册\n})\n</code></pre><blockquote>\n<h4 id=\"App-vue\"><a href=\"#App-vue\" class=\"headerlink\" title=\"App.vue\"></a>App.vue</h4></blockquote>\n<pre><code>&lt;template&gt;\n      &lt;div class=&quot;app&quot;&gt;\n        {{name}}\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport { mapState} from &#39;vuex&#39;\n/*\n *1.mapState 辅助函数\n *当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。\n *为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键：\n */\nexport default {\n  computde: {\n    ...mapState([&#39;name&#39;])\n    }\n}\n&lt;/script&gt;\n</code></pre><h2 id=\"Getter-store的计算属性，例如对列表进行过滤\"><a href=\"#Getter-store的计算属性，例如对列表进行过滤\" class=\"headerlink\" title=\"Getter(store的计算属性，例如对列表进行过滤)\"></a>Getter(store的计算属性，例如对列表进行过滤)</h2><blockquote>\n<h4 id=\"store-index-js-1\"><a href=\"#store-index-js-1\" class=\"headerlink\" title=\"store/index.js\"></a>store/index.js</h4></blockquote>\n<pre><code>state: {\n    count: 1,\n    arr: [\n      {\n        sex: &#39;男&#39;,\n        id: 1\n      },\n      {\n        sex: &#39;男&#39;,\n        id: 2\n      },\n      {\n        sex: &#39;男&#39;,\n        id: 3\n      },\n      {\n        sex: &#39;男&#39;,\n        id: 4\n      },\n      {\n        sex: &#39;女&#39;,\n        id: 5\n      },\n      {\n        sex: &#39;男&#39;,\n        id: 6\n      },\n      {\n        sex: &#39;男&#39;,\n        id: 7\n      }\n    ]\n  },\ngetters: {\n    man (state) {\n      return state.arr.filter(item=&gt;{return item.sex===&#39;男&#39;})\n    }\n  },\n</code></pre><blockquote>\n<h4 id=\"App-vue-1\"><a href=\"#App-vue-1\" class=\"headerlink\" title=\"App.vue\"></a>App.vue</h4></blockquote>\n<pre><code>&lt;template&gt;\n      &lt;div class=&quot;app&quot;&gt;\n        &lt;ul&gt;\n            &lt;li v-for=&quot;(item,index) in man&quot; :key=&quot;item.id&quot;&gt;{{item.sex}}&lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport { mapGetters } from &#39;vuex&#39; //mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：\nexport default {\n  computde: {\n    ...mapGetters([&#39;man&#39;])\n    }\n}\n&lt;/script&gt;\n</code></pre><h2 id=\"mutation-更新state的唯一方法\"><a href=\"#mutation-更新state的唯一方法\" class=\"headerlink\" title=\"mutation(更新state的唯一方法)\"></a>mutation(更新state的唯一方法)</h2><blockquote>\n<h4 id=\"store-index-js-2\"><a href=\"#store-index-js-2\" class=\"headerlink\" title=\"store/index.js\"></a>store/index.js</h4></blockquote>\n<pre><code>mutation: {\n    change (state) {\n        state.name = &#39;vue&#39;\n    }\n}\n</code></pre><blockquote>\n<h4 id=\"App-vue-2\"><a href=\"#App-vue-2\" class=\"headerlink\" title=\"App.vue\"></a>App.vue</h4></blockquote>\n<pre><code>&lt;template&gt;\n      &lt;div class=&quot;app&quot; @click=&quot;change&quot;&gt;\n        {{name}}\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n  method: {\n    change () {\n        this.$store.commit(&#39;change&#39;)\n    }\n  }\n}\n&lt;/script&gt;    \n</code></pre><h2 id=\"一条重要的原则就是要记住-mutation-必须是同步函数\"><a href=\"#一条重要的原则就是要记住-mutation-必须是同步函数\" class=\"headerlink\" title=\"一条重要的原则就是要记住 mutation 必须是同步函数\"></a>一条重要的原则就是要记住 mutation 必须是同步函数</h2><h3 id=\"原因：-为什么不能执行一步操作\"><a href=\"#原因：-为什么不能执行一步操作\" class=\"headerlink\" title=\"原因：(为什么不能执行一步操作)\"></a>原因：(为什么不能执行一步操作)</h3><blockquote>\n<p><strong>现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。</strong></p>\n</blockquote>\n<h3 id=\"因此：【我们需要一个action来进行异步操作】\"><a href=\"#因此：【我们需要一个action来进行异步操作】\" class=\"headerlink\" title=\"因此：【我们需要一个action来进行异步操作】\"></a>因此：【我们需要一个action来进行异步操作】</h3><h2 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action</h2><h3 id=\"Action-类似于-mutation，不同在于：\"><a href=\"#Action-类似于-mutation，不同在于：\" class=\"headerlink\" title=\"Action 类似于 mutation，不同在于：\"></a>Action 类似于 mutation，不同在于：</h3><ul>\n<li><strong>Action 提交的是 mutation，而不是直接变更状态。</strong></li>\n<li><strong>Action 可以包含任意异步操作。</strong></li>\n</ul>\n<blockquote>\n<h4 id=\"store-index-js-3\"><a href=\"#store-index-js-3\" class=\"headerlink\" title=\"store/index.js\"></a>store/index.js</h4></blockquote>\n<pre><code>state: {\n    count: 0\n},\nmutations: {\n    addcount (state) {\n      state.count++\n    }\n  },\nactions: {\n    getInfo (context) {\n      setTimeout(()=&gt;{\n        context.commit(&#39;addcount&#39;)\n      },2000)\n    }\n  }\n</code></pre><blockquote>\n<h4 id=\"App-vue-3\"><a href=\"#App-vue-3\" class=\"headerlink\" title=\"App.vue\"></a>App.vue</h4></blockquote>\n<pre><code>&lt;template&gt;\n      &lt;div class=&quot;app&quot; @click=&quot;change&quot;&gt;\n        {{count}}\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n  computed: {\n    ...mapState([&#39;count&#39;])\n  },\n  method: {\n    change () {\n        this.$store.dispatch(&#39;getInfo&#39;)\n    }\n  }\n}\n&lt;/script&gt;\n</code></pre><h6 id=\"乍一眼看上去感觉多此一举，我们直接分发-mutation-岂不更方便？实际上并非如此，还记得-mutation-必须同步执行这个限制么？Action-就不受约束！我们可以在-action-内部执行异步操作：\"><a href=\"#乍一眼看上去感觉多此一举，我们直接分发-mutation-岂不更方便？实际上并非如此，还记得-mutation-必须同步执行这个限制么？Action-就不受约束！我们可以在-action-内部执行异步操作：\" class=\"headerlink\" title=\"乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 mutation 必须同步执行这个限制么？Action 就不受约束！我们可以在 action 内部执行异步操作：\"></a>乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 mutation 必须同步执行这个限制么？Action 就不受约束！我们可以在 action 内部执行异步操作：</h6><h2 id=\"Module\"><a href=\"#Module\" class=\"headerlink\" title=\"Module\"></a>Module</h2><h3 id=\"由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store-对象就有可能变得相当臃肿。\"><a href=\"#由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store-对象就有可能变得相当臃肿。\" class=\"headerlink\" title=\"由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。\"></a>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</h3><hr>\n<h4 id=\"为了解决以上问题，Vuex-允许我们将-store-分割成模块（module）。每个模块拥有自己的-state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：\"><a href=\"#为了解决以上问题，Vuex-允许我们将-store-分割成模块（module）。每个模块拥有自己的-state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：\" class=\"headerlink\" title=\"为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：\"></a>为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</h4><p>首先创建module/todo.js</p>\n<blockquote>\n<p><strong>module/todo.js</strong></p>\n</blockquote>\n<pre><code>export default {\n  namespaced: true,\n  state: {\n    count: 0\n  },\n  mutations: {\n    addcount (state) {\n      state.count++\n    }\n  },\n}\n</code></pre><blockquote>\n<h4 id=\"store-index-js-4\"><a href=\"#store-index-js-4\" class=\"headerlink\" title=\"store/index.js\"></a>store/index.js</h4></blockquote>\n<pre><code>import todo from &quot;./modules/todo&quot;\n\nmodules: {\n    todo\n  }\n</code></pre><blockquote>\n<h4 id=\"App-vue-4\"><a href=\"#App-vue-4\" class=\"headerlink\" title=\"App.vue\"></a>App.vue</h4></blockquote>\n<pre><code>&lt;template&gt;\n      &lt;div class=&quot;app&quot; @click=&quot;change&quot;&gt;\n        {{count}}\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n  computed: {\n    ...mapState(&#39;todo&#39;,[&#39;count&#39;])\n  },\n  method: {\n    change () {\n        this.$store.commit(&#39;todo/addcount&#39;)\n    }\n  }\n}\n&lt;/script&gt;    \n</code></pre>"},{"title":"vue路由的实现原理","date":"2019-04-01T03:15:15.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"## vue路由的实现原理\n\n> 在vue中路由主要有 hash与History interface两种方式实现前端路由，单页路由的特点就是采用前端路由系统，通过改变URL，在不重新请求页面的情况下，更新页面视图。目前在浏览器环境中这一功能的实现主要有两种方式\n\n### hash\n\n> 在浏览器的url中hash（“#”）符号的本来作用是加在URL中指示网页中的位置：#符号本身以及它后面的字符称之为hash，可通过window.location.hash属性读取。\n\n#### 特点：\n\n> hash虽然出现在URL中，但不会被包括在HTTP请求中。它是用来指导浏览器动作的，对服务器端完全无用，因此，改变hash不会重新加载页面，并且可以为hash的改变添加hashchange监听事件，在一个就是每一次改变hash（window.location.hash），都会在浏览器的访问历史中增加一个记录，我就可以通过他的这几个特点实现一个hash模式的单页路由，通过对location.hash的修改实现push方法（跳转页面），通过对location.href的修改实现replace()方法，通过对hashchange事件的监听实现页面跳转后的数据更新\n\n### History\n\n> History模式则是完全采用了h5的新特性，从HTML5开始，History interface提供了两个新的方法：pushState(), replaceState()使得我们可以对浏览器历史记录栈进行修改，以及popState事件可以监听到状态的变更\n\n**不过history模式有一个问题就是**\n\n> 对于单页应用来讲，理想的使用场景是仅在进入应用时加载index.html，后续在的网络操作通过Ajax完成，不会根据URL重新请求页面，但是如果用户直接在地址栏中输入并回车，浏览器重启重新加载的时候history模式则会将URL修改得就和正常请求后端的URL一样，在此情况下重新向后端发送请求，如后端没有配置对应 的路由处理，则会返回404错误。这种问题的解决，一般情况下我们都是在后端进行配置，将所有的路由请求都指向index.html文件\n\n\n\n","source":"_posts/vue-router-left.md","raw":"---\ntitle: vue路由的实现原理\ndate: '4/1/2019 11:15:15 AM '\ntag: ['js', 'vue-router', 'vue']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n## vue路由的实现原理\n\n> 在vue中路由主要有 hash与History interface两种方式实现前端路由，单页路由的特点就是采用前端路由系统，通过改变URL，在不重新请求页面的情况下，更新页面视图。目前在浏览器环境中这一功能的实现主要有两种方式\n\n### hash\n\n> 在浏览器的url中hash（“#”）符号的本来作用是加在URL中指示网页中的位置：#符号本身以及它后面的字符称之为hash，可通过window.location.hash属性读取。\n\n#### 特点：\n\n> hash虽然出现在URL中，但不会被包括在HTTP请求中。它是用来指导浏览器动作的，对服务器端完全无用，因此，改变hash不会重新加载页面，并且可以为hash的改变添加hashchange监听事件，在一个就是每一次改变hash（window.location.hash），都会在浏览器的访问历史中增加一个记录，我就可以通过他的这几个特点实现一个hash模式的单页路由，通过对location.hash的修改实现push方法（跳转页面），通过对location.href的修改实现replace()方法，通过对hashchange事件的监听实现页面跳转后的数据更新\n\n### History\n\n> History模式则是完全采用了h5的新特性，从HTML5开始，History interface提供了两个新的方法：pushState(), replaceState()使得我们可以对浏览器历史记录栈进行修改，以及popState事件可以监听到状态的变更\n\n**不过history模式有一个问题就是**\n\n> 对于单页应用来讲，理想的使用场景是仅在进入应用时加载index.html，后续在的网络操作通过Ajax完成，不会根据URL重新请求页面，但是如果用户直接在地址栏中输入并回车，浏览器重启重新加载的时候history模式则会将URL修改得就和正常请求后端的URL一样，在此情况下重新向后端发送请求，如后端没有配置对应 的路由处理，则会返回404错误。这种问题的解决，一般情况下我们都是在后端进行配置，将所有的路由请求都指向index.html文件\n\n\n\n","slug":"vue-router-left","published":1,"updated":"2019-04-02T02:45:11.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam850035n4wdnnxv9mrz","content":"<h2 id=\"vue路由的实现原理\"><a href=\"#vue路由的实现原理\" class=\"headerlink\" title=\"vue路由的实现原理\"></a>vue路由的实现原理</h2><blockquote>\n<p>在vue中路由主要有 hash与History interface两种方式实现前端路由，单页路由的特点就是采用前端路由系统，通过改变URL，在不重新请求页面的情况下，更新页面视图。目前在浏览器环境中这一功能的实现主要有两种方式</p>\n</blockquote>\n<h3 id=\"hash\"><a href=\"#hash\" class=\"headerlink\" title=\"hash\"></a>hash</h3><blockquote>\n<p>在浏览器的url中hash（“#”）符号的本来作用是加在URL中指示网页中的位置：#符号本身以及它后面的字符称之为hash，可通过window.location.hash属性读取。</p>\n</blockquote>\n<h4 id=\"特点：\"><a href=\"#特点：\" class=\"headerlink\" title=\"特点：\"></a>特点：</h4><blockquote>\n<p>hash虽然出现在URL中，但不会被包括在HTTP请求中。它是用来指导浏览器动作的，对服务器端完全无用，因此，改变hash不会重新加载页面，并且可以为hash的改变添加hashchange监听事件，在一个就是每一次改变hash（window.location.hash），都会在浏览器的访问历史中增加一个记录，我就可以通过他的这几个特点实现一个hash模式的单页路由，通过对location.hash的修改实现push方法（跳转页面），通过对location.href的修改实现replace()方法，通过对hashchange事件的监听实现页面跳转后的数据更新</p>\n</blockquote>\n<h3 id=\"History\"><a href=\"#History\" class=\"headerlink\" title=\"History\"></a>History</h3><blockquote>\n<p>History模式则是完全采用了h5的新特性，从HTML5开始，History interface提供了两个新的方法：pushState(), replaceState()使得我们可以对浏览器历史记录栈进行修改，以及popState事件可以监听到状态的变更</p>\n</blockquote>\n<p><strong>不过history模式有一个问题就是</strong></p>\n<blockquote>\n<p>对于单页应用来讲，理想的使用场景是仅在进入应用时加载index.html，后续在的网络操作通过Ajax完成，不会根据URL重新请求页面，但是如果用户直接在地址栏中输入并回车，浏览器重启重新加载的时候history模式则会将URL修改得就和正常请求后端的URL一样，在此情况下重新向后端发送请求，如后端没有配置对应 的路由处理，则会返回404错误。这种问题的解决，一般情况下我们都是在后端进行配置，将所有的路由请求都指向index.html文件</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"vue路由的实现原理\"><a href=\"#vue路由的实现原理\" class=\"headerlink\" title=\"vue路由的实现原理\"></a>vue路由的实现原理</h2><blockquote>\n<p>在vue中路由主要有 hash与History interface两种方式实现前端路由，单页路由的特点就是采用前端路由系统，通过改变URL，在不重新请求页面的情况下，更新页面视图。目前在浏览器环境中这一功能的实现主要有两种方式</p>\n</blockquote>\n<h3 id=\"hash\"><a href=\"#hash\" class=\"headerlink\" title=\"hash\"></a>hash</h3><blockquote>\n<p>在浏览器的url中hash（“#”）符号的本来作用是加在URL中指示网页中的位置：#符号本身以及它后面的字符称之为hash，可通过window.location.hash属性读取。</p>\n</blockquote>\n<h4 id=\"特点：\"><a href=\"#特点：\" class=\"headerlink\" title=\"特点：\"></a>特点：</h4><blockquote>\n<p>hash虽然出现在URL中，但不会被包括在HTTP请求中。它是用来指导浏览器动作的，对服务器端完全无用，因此，改变hash不会重新加载页面，并且可以为hash的改变添加hashchange监听事件，在一个就是每一次改变hash（window.location.hash），都会在浏览器的访问历史中增加一个记录，我就可以通过他的这几个特点实现一个hash模式的单页路由，通过对location.hash的修改实现push方法（跳转页面），通过对location.href的修改实现replace()方法，通过对hashchange事件的监听实现页面跳转后的数据更新</p>\n</blockquote>\n<h3 id=\"History\"><a href=\"#History\" class=\"headerlink\" title=\"History\"></a>History</h3><blockquote>\n<p>History模式则是完全采用了h5的新特性，从HTML5开始，History interface提供了两个新的方法：pushState(), replaceState()使得我们可以对浏览器历史记录栈进行修改，以及popState事件可以监听到状态的变更</p>\n</blockquote>\n<p><strong>不过history模式有一个问题就是</strong></p>\n<blockquote>\n<p>对于单页应用来讲，理想的使用场景是仅在进入应用时加载index.html，后续在的网络操作通过Ajax完成，不会根据URL重新请求页面，但是如果用户直接在地址栏中输入并回车，浏览器重启重新加载的时候history模式则会将URL修改得就和正常请求后端的URL一样，在此情况下重新向后端发送请求，如后端没有配置对应 的路由处理，则会返回404错误。这种问题的解决，一般情况下我们都是在后端进行配置，将所有的路由请求都指向index.html文件</p>\n</blockquote>\n"},{"title":"微信小程序实现瀑布流","date":"2019-03-24T08:36:42.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"# 微信小程序实现瀑布流\n\n### 简单，便捷\n\n> - 无需知道图片宽高（当然要实现懒加载是必须的）\n> - 一个判断\n> - 一句css\n\n----------\n\n>  1. 先用css3中的column-count属性把页面元素分为俩列及多列。\n\n\n----------\n\n### 直接上代码\n\n> **wxml**\n\n\t\n\t<view class=\"free-WaterfallFlow\">\n\t  <block>\n\t    <view class=\"flex-wrap\" wx:for=\"{{images}}\" wx:key='{{item.src}}' \n\t    wx:if=\"{{item.id%2!=''}}\">\n\t      <image mode=\"widthFix\" src=\"{{item.src}}\"></image>\n\t      <view>{{item.name}}</view>\n\t      <view>{{item.data}}</view>\n\t    </view>\n\t  </block>\n\t  <block>\n\t    <view class=\"flex-wrap\" wx:for=\"{{images}}\" wx:key='{{item.src}}'\n\t    wx:if=\"{{item.id%2==''}}\">\n\t      <image mode=\"widthFix\" src=\"{{item.src}}\"></image>\n\t      <view>{{item.name}}</view>\n\t      <view>{{item.data}}</view>\n\t    </view>\n\t  </block>\n\t</view>\n\n\n----------\n> **wxss**\n\n\t.free-WaterfallFlow{\n\t  width:94%;\n\t  column-count:2;/*column-count 属性规定元素应该被分隔的列数：*/\n\t}\n\t.free-WaterfallFlow .flex-wrap{\n\t  display: inline-block;\n\t  width:98%;\n\t  margin-bottom:2%;\n\t  border:1px solid #ccc;\n\t  padding:2%;\n\t  padding-top:5%;\n\t  margin-right:2%;\n\t  box-shadow: 0 1px 2px rgba(34, 25, 25, 0.4);\n\t  text-align: center;\n\t}\n\t.flex-wrap image{\n\t  width:95%;\n\t  margin:0 auto;\n\t}\n\t.flex-wrap view:nth-child(2){\n\t  font-size:15px;\n\t  padding:2% 0;\n\t  color:#717171;\n\t}\n\t.flex-wrap view:nth-child(3){\n\t  font-size:13px;\n\t  padding:2% 0;\n\t  color:#aaa;\n\t  text-align: right;\n\t}\n\n\n----------\n> **js**\n\n\tPage({\n\t  data: {\n\t    images:[\n\t      { \n\t        id:'1',\n\t        src:'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1531825645104&di=0cfede1dd354581e22385b1862375a6a&imgtype=0&src=http%3A%2F%2Fpic.qiantucdn.com%2F58pic%2F13%2F71%2F35%2F24k58PICSiB_1024.jpg',\n\t        name:'照片01',\n\t        data:'2017/11/1'\n\t      }, {\n\t        id: '2',\n\t        src: 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1531825645032&di=826b8cfa4f7c5a8765d5c2156913dcbb&imgtype=0&src=http%3A%2F%2Fimg382.ph.126.net%2Fp4dMCiiHoUGxf2N0VLspkg%3D%3D%2F37436171903673954.jpg',\n\t        name: '照片02',\n\t        data: '2017/11/2'\n\t      }, {\n\t        id: '3',\n\t        src: 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1531825645104&di=2c9e1223e705806967640495e4bac26b&imgtype=0&src=http%3A%2F%2Fimg.zcool.cn%2Fcommunity%2F0147a458783b1ba801219c77f9ec2e.jpg%402o.jpg',\n\t        name: '照片03',\n\t        data: '2017/11/3'\n\t      }, {\n\t        id: '4',\n\t        src: 'http://t1.hxzdhn.com/uploads/tu/bj/slt/yezpvg0x23b.jpg',\n\t        name: '照片04',\n\t        data: '2017/11/4'\n\t      }, {\n\t        id: '5',\n\t        src: 'http://t1.hxzdhn.com/uploads/tu/201807/9999/95ed87388b.jpg',\n\t        name: '照片05',\n\t        data: '2017/11/5'\n\t      }, {\n\t        id: '6',\n\t        src: 'http://t1.hxzdhn.com/uploads/tu/201807/9999/99495c4cf4.jpg',\n\t        name: '照片06',\n\t        data: '2017/11/6'\n\t      }, {\n\t        id: '7',\n\t        src: 'http://t1.hxzdhn.com/uploads/tu/201807/9999/f867c97e25.jpg',\n\t        name: '照片07',\n\t        data: '2017/11/7'\n\t      }, {\n\t        id: '8',\n\t        src: 'http://t1.hxzdhn.com/uploads/tu/201807/9999/2cc7ab0bc5.jpg',\n\t        name: '照片08',\n\t        data: '2017/11/8'\n\t      }, {\n\t        id: '9',\n\t        src: 'http://t1.hxzdhn.com/uploads/tu/201807/9999/2f4435caaf.jpg',\n\t        name: '照片09',\n\t        data: '2017/11/9'\n\t      }, {\n\t        id: '10',\n\t        src: 'http://t1.hxzdhn.com/uploads/tu/201807/9999/ce76898540.jpg',\n\t        name: '照片10',\n\t        data: '2017/11/10'\n\t      }, {\n\t        id: '11',\n\t        src: 'http://t1.hxzdhn.com/uploads/tu/201807/9999/a2ccc41e47.jpg',\n\t        name: '照片11',\n\t        data: '2017/11/11'\n\t      }, {\n\t        id: '12',\n\t        src: 'http://t2.hddhhn.com/uploads/tu/201707/521/83.jpg',\n\t        name: '照片12',\n\t        data: '2017/11/12'\n\t      }, {\n\t        id: '13',\n\t        src: 'http://t2.hddhhn.com/uploads/tu/20150700/2hndrjt0jxe.jpg',\n\t        name: '照片13',\n\t        data: '2017/11/13'\n\t      }, {\n\t        id: '14',\n\t        src: 'http://t2.hddhhn.com/uploads/tu/20150700/2hndrjt0jxe.jpg',\n\t        name: '照片14',\n\t        data: '2017/11/14'\n\t      }\n\t    ]\n\t  }\n\t})\n\n","source":"_posts/wpy-cascade.md","raw":"---\ntitle: 微信小程序实现瀑布流\ndate: '3/24/2019 4:36:42 PM '\ntag: ['wx', '瀑布流']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n# 微信小程序实现瀑布流\n\n### 简单，便捷\n\n> - 无需知道图片宽高（当然要实现懒加载是必须的）\n> - 一个判断\n> - 一句css\n\n----------\n\n>  1. 先用css3中的column-count属性把页面元素分为俩列及多列。\n\n\n----------\n\n### 直接上代码\n\n> **wxml**\n\n\t\n\t<view class=\"free-WaterfallFlow\">\n\t  <block>\n\t    <view class=\"flex-wrap\" wx:for=\"{{images}}\" wx:key='{{item.src}}' \n\t    wx:if=\"{{item.id%2!=''}}\">\n\t      <image mode=\"widthFix\" src=\"{{item.src}}\"></image>\n\t      <view>{{item.name}}</view>\n\t      <view>{{item.data}}</view>\n\t    </view>\n\t  </block>\n\t  <block>\n\t    <view class=\"flex-wrap\" wx:for=\"{{images}}\" wx:key='{{item.src}}'\n\t    wx:if=\"{{item.id%2==''}}\">\n\t      <image mode=\"widthFix\" src=\"{{item.src}}\"></image>\n\t      <view>{{item.name}}</view>\n\t      <view>{{item.data}}</view>\n\t    </view>\n\t  </block>\n\t</view>\n\n\n----------\n> **wxss**\n\n\t.free-WaterfallFlow{\n\t  width:94%;\n\t  column-count:2;/*column-count 属性规定元素应该被分隔的列数：*/\n\t}\n\t.free-WaterfallFlow .flex-wrap{\n\t  display: inline-block;\n\t  width:98%;\n\t  margin-bottom:2%;\n\t  border:1px solid #ccc;\n\t  padding:2%;\n\t  padding-top:5%;\n\t  margin-right:2%;\n\t  box-shadow: 0 1px 2px rgba(34, 25, 25, 0.4);\n\t  text-align: center;\n\t}\n\t.flex-wrap image{\n\t  width:95%;\n\t  margin:0 auto;\n\t}\n\t.flex-wrap view:nth-child(2){\n\t  font-size:15px;\n\t  padding:2% 0;\n\t  color:#717171;\n\t}\n\t.flex-wrap view:nth-child(3){\n\t  font-size:13px;\n\t  padding:2% 0;\n\t  color:#aaa;\n\t  text-align: right;\n\t}\n\n\n----------\n> **js**\n\n\tPage({\n\t  data: {\n\t    images:[\n\t      { \n\t        id:'1',\n\t        src:'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1531825645104&di=0cfede1dd354581e22385b1862375a6a&imgtype=0&src=http%3A%2F%2Fpic.qiantucdn.com%2F58pic%2F13%2F71%2F35%2F24k58PICSiB_1024.jpg',\n\t        name:'照片01',\n\t        data:'2017/11/1'\n\t      }, {\n\t        id: '2',\n\t        src: 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1531825645032&di=826b8cfa4f7c5a8765d5c2156913dcbb&imgtype=0&src=http%3A%2F%2Fimg382.ph.126.net%2Fp4dMCiiHoUGxf2N0VLspkg%3D%3D%2F37436171903673954.jpg',\n\t        name: '照片02',\n\t        data: '2017/11/2'\n\t      }, {\n\t        id: '3',\n\t        src: 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1531825645104&di=2c9e1223e705806967640495e4bac26b&imgtype=0&src=http%3A%2F%2Fimg.zcool.cn%2Fcommunity%2F0147a458783b1ba801219c77f9ec2e.jpg%402o.jpg',\n\t        name: '照片03',\n\t        data: '2017/11/3'\n\t      }, {\n\t        id: '4',\n\t        src: 'http://t1.hxzdhn.com/uploads/tu/bj/slt/yezpvg0x23b.jpg',\n\t        name: '照片04',\n\t        data: '2017/11/4'\n\t      }, {\n\t        id: '5',\n\t        src: 'http://t1.hxzdhn.com/uploads/tu/201807/9999/95ed87388b.jpg',\n\t        name: '照片05',\n\t        data: '2017/11/5'\n\t      }, {\n\t        id: '6',\n\t        src: 'http://t1.hxzdhn.com/uploads/tu/201807/9999/99495c4cf4.jpg',\n\t        name: '照片06',\n\t        data: '2017/11/6'\n\t      }, {\n\t        id: '7',\n\t        src: 'http://t1.hxzdhn.com/uploads/tu/201807/9999/f867c97e25.jpg',\n\t        name: '照片07',\n\t        data: '2017/11/7'\n\t      }, {\n\t        id: '8',\n\t        src: 'http://t1.hxzdhn.com/uploads/tu/201807/9999/2cc7ab0bc5.jpg',\n\t        name: '照片08',\n\t        data: '2017/11/8'\n\t      }, {\n\t        id: '9',\n\t        src: 'http://t1.hxzdhn.com/uploads/tu/201807/9999/2f4435caaf.jpg',\n\t        name: '照片09',\n\t        data: '2017/11/9'\n\t      }, {\n\t        id: '10',\n\t        src: 'http://t1.hxzdhn.com/uploads/tu/201807/9999/ce76898540.jpg',\n\t        name: '照片10',\n\t        data: '2017/11/10'\n\t      }, {\n\t        id: '11',\n\t        src: 'http://t1.hxzdhn.com/uploads/tu/201807/9999/a2ccc41e47.jpg',\n\t        name: '照片11',\n\t        data: '2017/11/11'\n\t      }, {\n\t        id: '12',\n\t        src: 'http://t2.hddhhn.com/uploads/tu/201707/521/83.jpg',\n\t        name: '照片12',\n\t        data: '2017/11/12'\n\t      }, {\n\t        id: '13',\n\t        src: 'http://t2.hddhhn.com/uploads/tu/20150700/2hndrjt0jxe.jpg',\n\t        name: '照片13',\n\t        data: '2017/11/13'\n\t      }, {\n\t        id: '14',\n\t        src: 'http://t2.hddhhn.com/uploads/tu/20150700/2hndrjt0jxe.jpg',\n\t        name: '照片14',\n\t        data: '2017/11/14'\n\t      }\n\t    ]\n\t  }\n\t})\n\n","slug":"wpy-cascade","published":1,"updated":"2019-03-25T05:53:10.676Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iam870038n4wddjah2lgf","content":"<h1 id=\"微信小程序实现瀑布流\"><a href=\"#微信小程序实现瀑布流\" class=\"headerlink\" title=\"微信小程序实现瀑布流\"></a>微信小程序实现瀑布流</h1><h3 id=\"简单，便捷\"><a href=\"#简单，便捷\" class=\"headerlink\" title=\"简单，便捷\"></a>简单，便捷</h3><blockquote>\n<ul>\n<li>无需知道图片宽高（当然要实现懒加载是必须的）</li>\n<li>一个判断</li>\n<li>一句css</li>\n</ul>\n</blockquote>\n<hr>\n<blockquote>\n<ol>\n<li>先用css3中的column-count属性把页面元素分为俩列及多列。</li>\n</ol>\n</blockquote>\n<hr>\n<h3 id=\"直接上代码\"><a href=\"#直接上代码\" class=\"headerlink\" title=\"直接上代码\"></a>直接上代码</h3><blockquote>\n<p><strong>wxml</strong></p>\n</blockquote>\n<pre><code>&lt;view class=&quot;free-WaterfallFlow&quot;&gt;\n  &lt;block&gt;\n    &lt;view class=&quot;flex-wrap&quot; wx:for=&quot;{{images}}&quot; wx:key=&#39;{{item.src}}&#39; \n    wx:if=&quot;{{item.id%2!=''}}&quot;&gt;\n      &lt;image mode=&quot;widthFix&quot; src=&quot;{{item.src}}&quot;&gt;&lt;/image&gt;\n      &lt;view&gt;{{item.name}}&lt;/view&gt;\n      &lt;view&gt;{{item.data}}&lt;/view&gt;\n    &lt;/view&gt;\n  &lt;/block&gt;\n  &lt;block&gt;\n    &lt;view class=&quot;flex-wrap&quot; wx:for=&quot;{{images}}&quot; wx:key=&#39;{{item.src}}&#39;\n    wx:if=&quot;{{item.id%2==''}}&quot;&gt;\n      &lt;image mode=&quot;widthFix&quot; src=&quot;{{item.src}}&quot;&gt;&lt;/image&gt;\n      &lt;view&gt;{{item.name}}&lt;/view&gt;\n      &lt;view&gt;{{item.data}}&lt;/view&gt;\n    &lt;/view&gt;\n  &lt;/block&gt;\n&lt;/view&gt;\n</code></pre><hr>\n<blockquote>\n<p><strong>wxss</strong></p>\n</blockquote>\n<pre><code>.free-WaterfallFlow{\n  width:94%;\n  column-count:2;/*column-count 属性规定元素应该被分隔的列数：*/\n}\n.free-WaterfallFlow .flex-wrap{\n  display: inline-block;\n  width:98%;\n  margin-bottom:2%;\n  border:1px solid #ccc;\n  padding:2%;\n  padding-top:5%;\n  margin-right:2%;\n  box-shadow: 0 1px 2px rgba(34, 25, 25, 0.4);\n  text-align: center;\n}\n.flex-wrap image{\n  width:95%;\n  margin:0 auto;\n}\n.flex-wrap view:nth-child(2){\n  font-size:15px;\n  padding:2% 0;\n  color:#717171;\n}\n.flex-wrap view:nth-child(3){\n  font-size:13px;\n  padding:2% 0;\n  color:#aaa;\n  text-align: right;\n}\n</code></pre><hr>\n<blockquote>\n<p><strong>js</strong></p>\n</blockquote>\n<pre><code>Page({\n  data: {\n    images:[\n      { \n        id:&#39;1&#39;,\n        src:&#39;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1531825645104&amp;di=0cfede1dd354581e22385b1862375a6a&amp;imgtype=0&amp;src=http%3A%2F%2Fpic.qiantucdn.com%2F58pic%2F13%2F71%2F35%2F24k58PICSiB_1024.jpg&#39;,\n        name:&#39;照片01&#39;,\n        data:&#39;2017/11/1&#39;\n      }, {\n        id: &#39;2&#39;,\n        src: &#39;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1531825645032&amp;di=826b8cfa4f7c5a8765d5c2156913dcbb&amp;imgtype=0&amp;src=http%3A%2F%2Fimg382.ph.126.net%2Fp4dMCiiHoUGxf2N0VLspkg%3D%3D%2F37436171903673954.jpg&#39;,\n        name: &#39;照片02&#39;,\n        data: &#39;2017/11/2&#39;\n      }, {\n        id: &#39;3&#39;,\n        src: &#39;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1531825645104&amp;di=2c9e1223e705806967640495e4bac26b&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.zcool.cn%2Fcommunity%2F0147a458783b1ba801219c77f9ec2e.jpg%402o.jpg&#39;,\n        name: &#39;照片03&#39;,\n        data: &#39;2017/11/3&#39;\n      }, {\n        id: &#39;4&#39;,\n        src: &#39;http://t1.hxzdhn.com/uploads/tu/bj/slt/yezpvg0x23b.jpg&#39;,\n        name: &#39;照片04&#39;,\n        data: &#39;2017/11/4&#39;\n      }, {\n        id: &#39;5&#39;,\n        src: &#39;http://t1.hxzdhn.com/uploads/tu/201807/9999/95ed87388b.jpg&#39;,\n        name: &#39;照片05&#39;,\n        data: &#39;2017/11/5&#39;\n      }, {\n        id: &#39;6&#39;,\n        src: &#39;http://t1.hxzdhn.com/uploads/tu/201807/9999/99495c4cf4.jpg&#39;,\n        name: &#39;照片06&#39;,\n        data: &#39;2017/11/6&#39;\n      }, {\n        id: &#39;7&#39;,\n        src: &#39;http://t1.hxzdhn.com/uploads/tu/201807/9999/f867c97e25.jpg&#39;,\n        name: &#39;照片07&#39;,\n        data: &#39;2017/11/7&#39;\n      }, {\n        id: &#39;8&#39;,\n        src: &#39;http://t1.hxzdhn.com/uploads/tu/201807/9999/2cc7ab0bc5.jpg&#39;,\n        name: &#39;照片08&#39;,\n        data: &#39;2017/11/8&#39;\n      }, {\n        id: &#39;9&#39;,\n        src: &#39;http://t1.hxzdhn.com/uploads/tu/201807/9999/2f4435caaf.jpg&#39;,\n        name: &#39;照片09&#39;,\n        data: &#39;2017/11/9&#39;\n      }, {\n        id: &#39;10&#39;,\n        src: &#39;http://t1.hxzdhn.com/uploads/tu/201807/9999/ce76898540.jpg&#39;,\n        name: &#39;照片10&#39;,\n        data: &#39;2017/11/10&#39;\n      }, {\n        id: &#39;11&#39;,\n        src: &#39;http://t1.hxzdhn.com/uploads/tu/201807/9999/a2ccc41e47.jpg&#39;,\n        name: &#39;照片11&#39;,\n        data: &#39;2017/11/11&#39;\n      }, {\n        id: &#39;12&#39;,\n        src: &#39;http://t2.hddhhn.com/uploads/tu/201707/521/83.jpg&#39;,\n        name: &#39;照片12&#39;,\n        data: &#39;2017/11/12&#39;\n      }, {\n        id: &#39;13&#39;,\n        src: &#39;http://t2.hddhhn.com/uploads/tu/20150700/2hndrjt0jxe.jpg&#39;,\n        name: &#39;照片13&#39;,\n        data: &#39;2017/11/13&#39;\n      }, {\n        id: &#39;14&#39;,\n        src: &#39;http://t2.hddhhn.com/uploads/tu/20150700/2hndrjt0jxe.jpg&#39;,\n        name: &#39;照片14&#39;,\n        data: &#39;2017/11/14&#39;\n      }\n    ]\n  }\n})\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"微信小程序实现瀑布流\"><a href=\"#微信小程序实现瀑布流\" class=\"headerlink\" title=\"微信小程序实现瀑布流\"></a>微信小程序实现瀑布流</h1><h3 id=\"简单，便捷\"><a href=\"#简单，便捷\" class=\"headerlink\" title=\"简单，便捷\"></a>简单，便捷</h3><blockquote>\n<ul>\n<li>无需知道图片宽高（当然要实现懒加载是必须的）</li>\n<li>一个判断</li>\n<li>一句css</li>\n</ul>\n</blockquote>\n<hr>\n<blockquote>\n<ol>\n<li>先用css3中的column-count属性把页面元素分为俩列及多列。</li>\n</ol>\n</blockquote>\n<hr>\n<h3 id=\"直接上代码\"><a href=\"#直接上代码\" class=\"headerlink\" title=\"直接上代码\"></a>直接上代码</h3><blockquote>\n<p><strong>wxml</strong></p>\n</blockquote>\n<pre><code>&lt;view class=&quot;free-WaterfallFlow&quot;&gt;\n  &lt;block&gt;\n    &lt;view class=&quot;flex-wrap&quot; wx:for=&quot;{{images}}&quot; wx:key=&#39;{{item.src}}&#39; \n    wx:if=&quot;{{item.id%2!=''}}&quot;&gt;\n      &lt;image mode=&quot;widthFix&quot; src=&quot;{{item.src}}&quot;&gt;&lt;/image&gt;\n      &lt;view&gt;{{item.name}}&lt;/view&gt;\n      &lt;view&gt;{{item.data}}&lt;/view&gt;\n    &lt;/view&gt;\n  &lt;/block&gt;\n  &lt;block&gt;\n    &lt;view class=&quot;flex-wrap&quot; wx:for=&quot;{{images}}&quot; wx:key=&#39;{{item.src}}&#39;\n    wx:if=&quot;{{item.id%2==''}}&quot;&gt;\n      &lt;image mode=&quot;widthFix&quot; src=&quot;{{item.src}}&quot;&gt;&lt;/image&gt;\n      &lt;view&gt;{{item.name}}&lt;/view&gt;\n      &lt;view&gt;{{item.data}}&lt;/view&gt;\n    &lt;/view&gt;\n  &lt;/block&gt;\n&lt;/view&gt;\n</code></pre><hr>\n<blockquote>\n<p><strong>wxss</strong></p>\n</blockquote>\n<pre><code>.free-WaterfallFlow{\n  width:94%;\n  column-count:2;/*column-count 属性规定元素应该被分隔的列数：*/\n}\n.free-WaterfallFlow .flex-wrap{\n  display: inline-block;\n  width:98%;\n  margin-bottom:2%;\n  border:1px solid #ccc;\n  padding:2%;\n  padding-top:5%;\n  margin-right:2%;\n  box-shadow: 0 1px 2px rgba(34, 25, 25, 0.4);\n  text-align: center;\n}\n.flex-wrap image{\n  width:95%;\n  margin:0 auto;\n}\n.flex-wrap view:nth-child(2){\n  font-size:15px;\n  padding:2% 0;\n  color:#717171;\n}\n.flex-wrap view:nth-child(3){\n  font-size:13px;\n  padding:2% 0;\n  color:#aaa;\n  text-align: right;\n}\n</code></pre><hr>\n<blockquote>\n<p><strong>js</strong></p>\n</blockquote>\n<pre><code>Page({\n  data: {\n    images:[\n      { \n        id:&#39;1&#39;,\n        src:&#39;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1531825645104&amp;di=0cfede1dd354581e22385b1862375a6a&amp;imgtype=0&amp;src=http%3A%2F%2Fpic.qiantucdn.com%2F58pic%2F13%2F71%2F35%2F24k58PICSiB_1024.jpg&#39;,\n        name:&#39;照片01&#39;,\n        data:&#39;2017/11/1&#39;\n      }, {\n        id: &#39;2&#39;,\n        src: &#39;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1531825645032&amp;di=826b8cfa4f7c5a8765d5c2156913dcbb&amp;imgtype=0&amp;src=http%3A%2F%2Fimg382.ph.126.net%2Fp4dMCiiHoUGxf2N0VLspkg%3D%3D%2F37436171903673954.jpg&#39;,\n        name: &#39;照片02&#39;,\n        data: &#39;2017/11/2&#39;\n      }, {\n        id: &#39;3&#39;,\n        src: &#39;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1531825645104&amp;di=2c9e1223e705806967640495e4bac26b&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.zcool.cn%2Fcommunity%2F0147a458783b1ba801219c77f9ec2e.jpg%402o.jpg&#39;,\n        name: &#39;照片03&#39;,\n        data: &#39;2017/11/3&#39;\n      }, {\n        id: &#39;4&#39;,\n        src: &#39;http://t1.hxzdhn.com/uploads/tu/bj/slt/yezpvg0x23b.jpg&#39;,\n        name: &#39;照片04&#39;,\n        data: &#39;2017/11/4&#39;\n      }, {\n        id: &#39;5&#39;,\n        src: &#39;http://t1.hxzdhn.com/uploads/tu/201807/9999/95ed87388b.jpg&#39;,\n        name: &#39;照片05&#39;,\n        data: &#39;2017/11/5&#39;\n      }, {\n        id: &#39;6&#39;,\n        src: &#39;http://t1.hxzdhn.com/uploads/tu/201807/9999/99495c4cf4.jpg&#39;,\n        name: &#39;照片06&#39;,\n        data: &#39;2017/11/6&#39;\n      }, {\n        id: &#39;7&#39;,\n        src: &#39;http://t1.hxzdhn.com/uploads/tu/201807/9999/f867c97e25.jpg&#39;,\n        name: &#39;照片07&#39;,\n        data: &#39;2017/11/7&#39;\n      }, {\n        id: &#39;8&#39;,\n        src: &#39;http://t1.hxzdhn.com/uploads/tu/201807/9999/2cc7ab0bc5.jpg&#39;,\n        name: &#39;照片08&#39;,\n        data: &#39;2017/11/8&#39;\n      }, {\n        id: &#39;9&#39;,\n        src: &#39;http://t1.hxzdhn.com/uploads/tu/201807/9999/2f4435caaf.jpg&#39;,\n        name: &#39;照片09&#39;,\n        data: &#39;2017/11/9&#39;\n      }, {\n        id: &#39;10&#39;,\n        src: &#39;http://t1.hxzdhn.com/uploads/tu/201807/9999/ce76898540.jpg&#39;,\n        name: &#39;照片10&#39;,\n        data: &#39;2017/11/10&#39;\n      }, {\n        id: &#39;11&#39;,\n        src: &#39;http://t1.hxzdhn.com/uploads/tu/201807/9999/a2ccc41e47.jpg&#39;,\n        name: &#39;照片11&#39;,\n        data: &#39;2017/11/11&#39;\n      }, {\n        id: &#39;12&#39;,\n        src: &#39;http://t2.hddhhn.com/uploads/tu/201707/521/83.jpg&#39;,\n        name: &#39;照片12&#39;,\n        data: &#39;2017/11/12&#39;\n      }, {\n        id: &#39;13&#39;,\n        src: &#39;http://t2.hddhhn.com/uploads/tu/20150700/2hndrjt0jxe.jpg&#39;,\n        name: &#39;照片13&#39;,\n        data: &#39;2017/11/13&#39;\n      }, {\n        id: &#39;14&#39;,\n        src: &#39;http://t2.hddhhn.com/uploads/tu/20150700/2hndrjt0jxe.jpg&#39;,\n        name: &#39;照片14&#39;,\n        data: &#39;2017/11/14&#39;\n      }\n    ]\n  }\n})\n</code></pre>"},{"title":"React Hook","date":"2019-08-08T03:03:27.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"# Hook \n\n\n\n**有状态的组件没有渲染，有渲染的组件没有状态。在现在回过头来看，这个原则会为我们后续向Hooks的迁移提供非常大的便利。**\n\n\n\n## 🔥 Hook简介\n\n> Hook是react16.8的新增特性，可以在不编写class类的情况下使用state以及react的其他特性\n> React Hooks要解决的问题是状态共享，不会产生jsx嵌套问题\n\n## 🏆 Hooks的运行规则\n\n- 不能再循环中，条件语句和嵌套函数中调用hooks\n- 只在react中函数组件中的hooks\n\n## 🌟 React Hooks的特点\n\n- 多个状态不会产生嵌套\n- Hooks还可以引用其他Hooks\n- 更容易【更清晰】将组件的UI和状态进行分离\n- Hooks函数必须使用‘use’命名开头\n\n## 📌 State Hook\n\n```\n  import React, { useState } from 'react';\n\n  function Example() {\n    // 声明一个叫 “count” 的 state 变量。\n    const [count, setCount] = useState(0); // 使用useState来定义state [参数名字, 改变参数的方法]\n\n    // 也可以多个声明state 【但是必须保证调用的顺序一样】\n\n    const [tods, settods] = useState('this is count')\n\n    return (\n      <div>\n        <p>You clicked {count} times</p>\n        <button onClick={() => setCount(count + 1)}>\n          Click me\n        </button>\n      </div>\n    );\n  }\n\n```\n\n- 函数组件会有特殊的处理方式\n- 在render阶段，再将函数Fiber内容的实例化的时候去处理全局中的Hooks对象的指向\n- 最终userState是调用内部函数mountState去设置state的stringif\n- 在mountState会对传入的参数如果是函数会对其先执行，得出返回值在继续运行\n- 在mountState中会创建一个闭包事件，将当前的Hooks所在的Fiber节点以及Hooks队列对象作为参数绑定在函数，并返回0\n\n## ⚡️ Effect Hook\n\n> useEffect 给函数组件添加副作用，他和class组件中的componentDidMount、componentDidUpdate 和 componentWillUnmount具有相同的用途\n\n### 实现componentDidMount 副作用函数\n\n```\n  useEffect(() => {\n    // 使用浏览器的 API 更新页面标题\n    document.title = `You clicked ${count} times`;\n  });\n\n```\n\n### 实现componentDidUpdate 副作用函数\n\n```\n  useEffect(() => {\n    // 使用浏览器的 API 更新页面标题\n    document.title = `You clicked ${count} times`;\n  }, [count]); // 只在count发生改变的情况下调用\n\n```\n\n### 实现componentWillUnmount 副作用函数\n\n```\n  useEffect(() => {\n    // 使用浏览器的 API 更新页面标题\n    document.title = `You clicked ${count} times`;\n    return () => {\n      // 清除副作用操作\n    }\n  });\n\n```\n- userEffect的执行时机都发生在每次渲染之后，无论首次渲染还是更新渲染\n- userEffect只有在函数组件中执行，不能再非函数组件中执行\n- userEffect可以在函数组件中执行多次，是按调用顺序执行的\n- userEffect传入的函数，return是在组件卸载的时候执行的\n- userEffect的执行，是由他的第二参数来控制的，而且第二的参数必须是一个数组，react会对数组中的每一项与上次的数组进行比较，如果不同，则才会去执行函数\n- userEffect采用的是异步的方案执行，类似于js中的setTimeout，将userEffect进行异步执行\n\n\n**实用之处**\n\n  再实现重复的数据请求中使用\n\n```\n  function getData() {\n    const [data, setdata] = useState(null)\n\n    useEffect(() => {\n      axios('/a/b').then(res => {\n        setdata(res.data)\n      })\n    }, [])\n\n    return data\n  }\n\n  // 在别的函数组件中直接调用即可获取到数据【当然加入第二参数是为了防止数据更新的时候再次触犯请求数据执行】【灵活 的写法有很多种】\n  \n```\n\n\n## 🔐 注意事项\n\n- 不可以在hooks中使用条件语句【会影响hooks的调用规则（顺序）】，会导致调用混乱，产生bug\n- 如果我们想执行一个判断可以将其放在内部来使用\n\n```\n  useEffect(() => {\n    // 将条件语句放置在hooks中\n    if (val != '') {\n      document.title = val\n    }\n  })\n\n```\n\n- 我们可以去自定义hooks，但我们自定义的hooks必须以use开头，这是一种约定，它可以识别我们是否遵循了规范，他是hooks的规范，不是react的\n\n## 💕 useContent\n\n**可以使用useContext进行跨组件传值**\n\n```\n\n  // 父组件\n  import React, {useState} from 'react'\n  export const myContent = React.createContext(null)\n  function Content() {\n    const [val, setval] = useState(myContent)\n    return (\n      <>\n        <input val = {val} onChange((e) => {setval(e.target.value)})/>\n        <myContent.Provider>\n          <Ptemp></Ptemp>\n        <myContent.Provider>\n      </>\n    )\n  }\n  export default Content\n\n  // 子组件\n\n  import React, {useContext} from 'react'\n  import {myContent} from './home'\n  function Ptemp() {\n    const val = useContext(myContent)\n\n    return (\n      <>\n        <p>{val}</p>\n      </>\n    )\n  }\n  \n```\n\n## 🍭 useReducer\n\n**useReducer是useState的另一种替代，他接收(state, action) => newState, 并且返回了一个与当前state成对的dispatch方法\n\n### 例1：最小的简单模式【计数器】\n\n```\n  reducer.ts\n  \n  export const initialState = 0\n  const renducer = (state, action) => {\n    switch(action) {\n      case 'count':\n        console.log(state)\n        return state + 1\n    }\n  }\n\n  export default renducer\n\n  PgReducer.tsx\n\n  import React, {useState, useReducer} from 'react'\n\n  import renducer, {initialState} from '../../renducer/expamel'\n\n  function testRenducer() {\n    const [count, dispatch] = useReducer(renducer, initialState)\n    return (\n      <>\n        <p>{count}</p>\n        <p onClick={() => {dispatch('count')}}>+</p>\n      </>\n    )\n  }\n\n  export default testRenducer\n\n```\n\n## ⚽ useRef\n\n**useRef返回一个可变的ref对象其.current属性被初始化为传入参数，返回的ref对象在组件的整个生命周期内保持不变**\n\n- 常见的就是访问子组件\n- 获取一些dom元素的参数\n\n```\n  import React, { useState, useRef, useEffect } from 'react'\n\n  function PgRef() {\n    const ulRef = useRef(null)\n    useEffect(() => {\n      console.log(ulRef.current.offsetHeight)\n    })\n    return (\n      <>\n        <p className='testP' ref={ulRef}></p>\n      </>\n    )\n  }\n\n  export default PgRef\n\n```\n\n## 🏹 原理实现\n\n### 🔨 useState\n\n**首先我们来看一下useState的调用方式**\n\n```\n  const [count, setCount] = useState(0)\n\n```\n------------------------------------------------------------\n\n> 实现\n\n```\n  let memoizedState = [] // memoizedState存储状态的数组\n  let curson = 0 // 当前memoizedState的下标\n  function useState(ininvalState) {\n    memoizedState[curson] = memoizedState[curson] || ininvalState\n    function setState(newState) {\n      memoizedState[curson] = newState\n      render()\n    }\n    return [memoizedState[curson++], setState] // 每个hooks调用都会递增curson, 从当前组件中取出状态\n  }\n\n```\n> 只是简单 的实现了一下useState【**useState这个hooks这后台使用useReducer，他的返回结果其实已经是Reducer状态**】\n\n### 🔨 useEffect\n\n**首先我们来看一下useEffect的调用方式**\n\n```\n  useEffect(() => {\n    console.log(count)\n  }, [count])\n\n```\n> 实现\n\n**useEffect存在两个参数（callback, dep数组），如果dep数组不存在的话，每次render函数执行后，都会去执行callback函数，如果dep数组存在的时候，当dep发生改变的时候callback才会去执行**\n\n```\n  let memoizedState = []; // hooks 存放在这个数组\n  let cursor = 0; // 当前 memoizedState 下标\n  function useEffect(callback, dep) {\n    const hasDeps = !dep // 是否有dep数组\n    const deps = memoizedState[cursor]\n    const hasChangeDeps = deps ? !dep.every((el, i ) => el === deps[i]) : true\n    if (hasDeps || hasChangeDeps) {\n      callback();\n      memoizedState[cursor] = dep\n    }\n    cursor++;\n  }\n\n```\n> 只是简单 的实现了一下useEffect, 在react调用会有自己的调用机制\n> react中是通过单链表的方式来代替数组的，通过next来串联所有的hooks的\n\n## 🔫 原理链接 https://juejin.im/post/5c99a75af265da60ef635898#comment\n\n## 🛡 Hooks队列\n\n- 在初次渲染的时候，他的初始状态会被创建\n- 他的状态可以在运行的时候进行更改\n- react可以在后续的渲染中记住hooks的状态\n- react可以根据调用的顺序提供给你正确的状态\n- react知道当前的hooks属于哪个部分","source":"_posts/Hooks.md","raw":"---\ntitle: React Hook\ndate: '8/8/2019 11:03:27 AM '\ntag: ['hooks', 'react']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n# Hook \n\n\n\n**有状态的组件没有渲染，有渲染的组件没有状态。在现在回过头来看，这个原则会为我们后续向Hooks的迁移提供非常大的便利。**\n\n\n\n## 🔥 Hook简介\n\n> Hook是react16.8的新增特性，可以在不编写class类的情况下使用state以及react的其他特性\n> React Hooks要解决的问题是状态共享，不会产生jsx嵌套问题\n\n## 🏆 Hooks的运行规则\n\n- 不能再循环中，条件语句和嵌套函数中调用hooks\n- 只在react中函数组件中的hooks\n\n## 🌟 React Hooks的特点\n\n- 多个状态不会产生嵌套\n- Hooks还可以引用其他Hooks\n- 更容易【更清晰】将组件的UI和状态进行分离\n- Hooks函数必须使用‘use’命名开头\n\n## 📌 State Hook\n\n```\n  import React, { useState } from 'react';\n\n  function Example() {\n    // 声明一个叫 “count” 的 state 变量。\n    const [count, setCount] = useState(0); // 使用useState来定义state [参数名字, 改变参数的方法]\n\n    // 也可以多个声明state 【但是必须保证调用的顺序一样】\n\n    const [tods, settods] = useState('this is count')\n\n    return (\n      <div>\n        <p>You clicked {count} times</p>\n        <button onClick={() => setCount(count + 1)}>\n          Click me\n        </button>\n      </div>\n    );\n  }\n\n```\n\n- 函数组件会有特殊的处理方式\n- 在render阶段，再将函数Fiber内容的实例化的时候去处理全局中的Hooks对象的指向\n- 最终userState是调用内部函数mountState去设置state的stringif\n- 在mountState会对传入的参数如果是函数会对其先执行，得出返回值在继续运行\n- 在mountState中会创建一个闭包事件，将当前的Hooks所在的Fiber节点以及Hooks队列对象作为参数绑定在函数，并返回0\n\n## ⚡️ Effect Hook\n\n> useEffect 给函数组件添加副作用，他和class组件中的componentDidMount、componentDidUpdate 和 componentWillUnmount具有相同的用途\n\n### 实现componentDidMount 副作用函数\n\n```\n  useEffect(() => {\n    // 使用浏览器的 API 更新页面标题\n    document.title = `You clicked ${count} times`;\n  });\n\n```\n\n### 实现componentDidUpdate 副作用函数\n\n```\n  useEffect(() => {\n    // 使用浏览器的 API 更新页面标题\n    document.title = `You clicked ${count} times`;\n  }, [count]); // 只在count发生改变的情况下调用\n\n```\n\n### 实现componentWillUnmount 副作用函数\n\n```\n  useEffect(() => {\n    // 使用浏览器的 API 更新页面标题\n    document.title = `You clicked ${count} times`;\n    return () => {\n      // 清除副作用操作\n    }\n  });\n\n```\n- userEffect的执行时机都发生在每次渲染之后，无论首次渲染还是更新渲染\n- userEffect只有在函数组件中执行，不能再非函数组件中执行\n- userEffect可以在函数组件中执行多次，是按调用顺序执行的\n- userEffect传入的函数，return是在组件卸载的时候执行的\n- userEffect的执行，是由他的第二参数来控制的，而且第二的参数必须是一个数组，react会对数组中的每一项与上次的数组进行比较，如果不同，则才会去执行函数\n- userEffect采用的是异步的方案执行，类似于js中的setTimeout，将userEffect进行异步执行\n\n\n**实用之处**\n\n  再实现重复的数据请求中使用\n\n```\n  function getData() {\n    const [data, setdata] = useState(null)\n\n    useEffect(() => {\n      axios('/a/b').then(res => {\n        setdata(res.data)\n      })\n    }, [])\n\n    return data\n  }\n\n  // 在别的函数组件中直接调用即可获取到数据【当然加入第二参数是为了防止数据更新的时候再次触犯请求数据执行】【灵活 的写法有很多种】\n  \n```\n\n\n## 🔐 注意事项\n\n- 不可以在hooks中使用条件语句【会影响hooks的调用规则（顺序）】，会导致调用混乱，产生bug\n- 如果我们想执行一个判断可以将其放在内部来使用\n\n```\n  useEffect(() => {\n    // 将条件语句放置在hooks中\n    if (val != '') {\n      document.title = val\n    }\n  })\n\n```\n\n- 我们可以去自定义hooks，但我们自定义的hooks必须以use开头，这是一种约定，它可以识别我们是否遵循了规范，他是hooks的规范，不是react的\n\n## 💕 useContent\n\n**可以使用useContext进行跨组件传值**\n\n```\n\n  // 父组件\n  import React, {useState} from 'react'\n  export const myContent = React.createContext(null)\n  function Content() {\n    const [val, setval] = useState(myContent)\n    return (\n      <>\n        <input val = {val} onChange((e) => {setval(e.target.value)})/>\n        <myContent.Provider>\n          <Ptemp></Ptemp>\n        <myContent.Provider>\n      </>\n    )\n  }\n  export default Content\n\n  // 子组件\n\n  import React, {useContext} from 'react'\n  import {myContent} from './home'\n  function Ptemp() {\n    const val = useContext(myContent)\n\n    return (\n      <>\n        <p>{val}</p>\n      </>\n    )\n  }\n  \n```\n\n## 🍭 useReducer\n\n**useReducer是useState的另一种替代，他接收(state, action) => newState, 并且返回了一个与当前state成对的dispatch方法\n\n### 例1：最小的简单模式【计数器】\n\n```\n  reducer.ts\n  \n  export const initialState = 0\n  const renducer = (state, action) => {\n    switch(action) {\n      case 'count':\n        console.log(state)\n        return state + 1\n    }\n  }\n\n  export default renducer\n\n  PgReducer.tsx\n\n  import React, {useState, useReducer} from 'react'\n\n  import renducer, {initialState} from '../../renducer/expamel'\n\n  function testRenducer() {\n    const [count, dispatch] = useReducer(renducer, initialState)\n    return (\n      <>\n        <p>{count}</p>\n        <p onClick={() => {dispatch('count')}}>+</p>\n      </>\n    )\n  }\n\n  export default testRenducer\n\n```\n\n## ⚽ useRef\n\n**useRef返回一个可变的ref对象其.current属性被初始化为传入参数，返回的ref对象在组件的整个生命周期内保持不变**\n\n- 常见的就是访问子组件\n- 获取一些dom元素的参数\n\n```\n  import React, { useState, useRef, useEffect } from 'react'\n\n  function PgRef() {\n    const ulRef = useRef(null)\n    useEffect(() => {\n      console.log(ulRef.current.offsetHeight)\n    })\n    return (\n      <>\n        <p className='testP' ref={ulRef}></p>\n      </>\n    )\n  }\n\n  export default PgRef\n\n```\n\n## 🏹 原理实现\n\n### 🔨 useState\n\n**首先我们来看一下useState的调用方式**\n\n```\n  const [count, setCount] = useState(0)\n\n```\n------------------------------------------------------------\n\n> 实现\n\n```\n  let memoizedState = [] // memoizedState存储状态的数组\n  let curson = 0 // 当前memoizedState的下标\n  function useState(ininvalState) {\n    memoizedState[curson] = memoizedState[curson] || ininvalState\n    function setState(newState) {\n      memoizedState[curson] = newState\n      render()\n    }\n    return [memoizedState[curson++], setState] // 每个hooks调用都会递增curson, 从当前组件中取出状态\n  }\n\n```\n> 只是简单 的实现了一下useState【**useState这个hooks这后台使用useReducer，他的返回结果其实已经是Reducer状态**】\n\n### 🔨 useEffect\n\n**首先我们来看一下useEffect的调用方式**\n\n```\n  useEffect(() => {\n    console.log(count)\n  }, [count])\n\n```\n> 实现\n\n**useEffect存在两个参数（callback, dep数组），如果dep数组不存在的话，每次render函数执行后，都会去执行callback函数，如果dep数组存在的时候，当dep发生改变的时候callback才会去执行**\n\n```\n  let memoizedState = []; // hooks 存放在这个数组\n  let cursor = 0; // 当前 memoizedState 下标\n  function useEffect(callback, dep) {\n    const hasDeps = !dep // 是否有dep数组\n    const deps = memoizedState[cursor]\n    const hasChangeDeps = deps ? !dep.every((el, i ) => el === deps[i]) : true\n    if (hasDeps || hasChangeDeps) {\n      callback();\n      memoizedState[cursor] = dep\n    }\n    cursor++;\n  }\n\n```\n> 只是简单 的实现了一下useEffect, 在react调用会有自己的调用机制\n> react中是通过单链表的方式来代替数组的，通过next来串联所有的hooks的\n\n## 🔫 原理链接 https://juejin.im/post/5c99a75af265da60ef635898#comment\n\n## 🛡 Hooks队列\n\n- 在初次渲染的时候，他的初始状态会被创建\n- 他的状态可以在运行的时候进行更改\n- react可以在后续的渲染中记住hooks的状态\n- react可以根据调用的顺序提供给你正确的状态\n- react知道当前的hooks属于哪个部分","slug":"Hooks","published":1,"updated":"2019-08-08T02:31:48.097Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iamdm006on4wdutwebgd1","content":"<h1 id=\"Hook\"><a href=\"#Hook\" class=\"headerlink\" title=\"Hook\"></a>Hook</h1><p><strong>有状态的组件没有渲染，有渲染的组件没有状态。在现在回过头来看，这个原则会为我们后续向Hooks的迁移提供非常大的便利。</strong></p>\n<h2 id=\"🔥-Hook简介\"><a href=\"#🔥-Hook简介\" class=\"headerlink\" title=\"🔥 Hook简介\"></a>🔥 Hook简介</h2><blockquote>\n<p>Hook是react16.8的新增特性，可以在不编写class类的情况下使用state以及react的其他特性<br>React Hooks要解决的问题是状态共享，不会产生jsx嵌套问题</p>\n</blockquote>\n<h2 id=\"🏆-Hooks的运行规则\"><a href=\"#🏆-Hooks的运行规则\" class=\"headerlink\" title=\"🏆 Hooks的运行规则\"></a>🏆 Hooks的运行规则</h2><ul>\n<li>不能再循环中，条件语句和嵌套函数中调用hooks</li>\n<li>只在react中函数组件中的hooks</li>\n</ul>\n<h2 id=\"🌟-React-Hooks的特点\"><a href=\"#🌟-React-Hooks的特点\" class=\"headerlink\" title=\"🌟 React Hooks的特点\"></a>🌟 React Hooks的特点</h2><ul>\n<li>多个状态不会产生嵌套</li>\n<li>Hooks还可以引用其他Hooks</li>\n<li>更容易【更清晰】将组件的UI和状态进行分离</li>\n<li>Hooks函数必须使用‘use’命名开头</li>\n</ul>\n<h2 id=\"📌-State-Hook\"><a href=\"#📌-State-Hook\" class=\"headerlink\" title=\"📌 State Hook\"></a>📌 State Hook</h2><pre><code>  import React, { useState } from &#39;react&#39;;\n\n  function Example() {\n    // 声明一个叫 “count” 的 state 变量。\n    const [count, setCount] = useState(0); // 使用useState来定义state [参数名字, 改变参数的方法]\n\n    // 也可以多个声明state 【但是必须保证调用的顺序一样】\n\n    const [tods, settods] = useState(&#39;this is count&#39;)\n\n    return (\n      &lt;div&gt;\n        &lt;p&gt;You clicked {count} times&lt;/p&gt;\n        &lt;button onClick={() =&gt; setCount(count + 1)}&gt;\n          Click me\n        &lt;/button&gt;\n      &lt;/div&gt;\n    );\n  }\n\n</code></pre><ul>\n<li>函数组件会有特殊的处理方式</li>\n<li>在render阶段，再将函数Fiber内容的实例化的时候去处理全局中的Hooks对象的指向</li>\n<li>最终userState是调用内部函数mountState去设置state的stringif</li>\n<li>在mountState会对传入的参数如果是函数会对其先执行，得出返回值在继续运行</li>\n<li>在mountState中会创建一个闭包事件，将当前的Hooks所在的Fiber节点以及Hooks队列对象作为参数绑定在函数，并返回0</li>\n</ul>\n<h2 id=\"⚡️-Effect-Hook\"><a href=\"#⚡️-Effect-Hook\" class=\"headerlink\" title=\"⚡️ Effect Hook\"></a>⚡️ Effect Hook</h2><blockquote>\n<p>useEffect 给函数组件添加副作用，他和class组件中的componentDidMount、componentDidUpdate 和 componentWillUnmount具有相同的用途</p>\n</blockquote>\n<h3 id=\"实现componentDidMount-副作用函数\"><a href=\"#实现componentDidMount-副作用函数\" class=\"headerlink\" title=\"实现componentDidMount 副作用函数\"></a>实现componentDidMount 副作用函数</h3><pre><code>  useEffect(() =&gt; {\n    // 使用浏览器的 API 更新页面标题\n    document.title = `You clicked ${count} times`;\n  });\n\n</code></pre><h3 id=\"实现componentDidUpdate-副作用函数\"><a href=\"#实现componentDidUpdate-副作用函数\" class=\"headerlink\" title=\"实现componentDidUpdate 副作用函数\"></a>实现componentDidUpdate 副作用函数</h3><pre><code>  useEffect(() =&gt; {\n    // 使用浏览器的 API 更新页面标题\n    document.title = `You clicked ${count} times`;\n  }, [count]); // 只在count发生改变的情况下调用\n\n</code></pre><h3 id=\"实现componentWillUnmount-副作用函数\"><a href=\"#实现componentWillUnmount-副作用函数\" class=\"headerlink\" title=\"实现componentWillUnmount 副作用函数\"></a>实现componentWillUnmount 副作用函数</h3><pre><code>  useEffect(() =&gt; {\n    // 使用浏览器的 API 更新页面标题\n    document.title = `You clicked ${count} times`;\n    return () =&gt; {\n      // 清除副作用操作\n    }\n  });\n\n</code></pre><ul>\n<li>userEffect的执行时机都发生在每次渲染之后，无论首次渲染还是更新渲染</li>\n<li>userEffect只有在函数组件中执行，不能再非函数组件中执行</li>\n<li>userEffect可以在函数组件中执行多次，是按调用顺序执行的</li>\n<li>userEffect传入的函数，return是在组件卸载的时候执行的</li>\n<li>userEffect的执行，是由他的第二参数来控制的，而且第二的参数必须是一个数组，react会对数组中的每一项与上次的数组进行比较，如果不同，则才会去执行函数</li>\n<li>userEffect采用的是异步的方案执行，类似于js中的setTimeout，将userEffect进行异步执行</li>\n</ul>\n<p><strong>实用之处</strong></p>\n<p>  再实现重复的数据请求中使用</p>\n<pre><code>  function getData() {\n    const [data, setdata] = useState(null)\n\n    useEffect(() =&gt; {\n      axios(&#39;/a/b&#39;).then(res =&gt; {\n        setdata(res.data)\n      })\n    }, [])\n\n    return data\n  }\n\n  // 在别的函数组件中直接调用即可获取到数据【当然加入第二参数是为了防止数据更新的时候再次触犯请求数据执行】【灵活 的写法有很多种】\n\n</code></pre><h2 id=\"🔐-注意事项\"><a href=\"#🔐-注意事项\" class=\"headerlink\" title=\"🔐 注意事项\"></a>🔐 注意事项</h2><ul>\n<li>不可以在hooks中使用条件语句【会影响hooks的调用规则（顺序）】，会导致调用混乱，产生bug</li>\n<li>如果我们想执行一个判断可以将其放在内部来使用</li>\n</ul>\n<pre><code>  useEffect(() =&gt; {\n    // 将条件语句放置在hooks中\n    if (val != &#39;&#39;) {\n      document.title = val\n    }\n  })\n\n</code></pre><ul>\n<li>我们可以去自定义hooks，但我们自定义的hooks必须以use开头，这是一种约定，它可以识别我们是否遵循了规范，他是hooks的规范，不是react的</li>\n</ul>\n<h2 id=\"💕-useContent\"><a href=\"#💕-useContent\" class=\"headerlink\" title=\"💕 useContent\"></a>💕 useContent</h2><p><strong>可以使用useContext进行跨组件传值</strong></p>\n<pre><code>\n  // 父组件\n  import React, {useState} from &#39;react&#39;\n  export const myContent = React.createContext(null)\n  function Content() {\n    const [val, setval] = useState(myContent)\n    return (\n      &lt;&gt;\n        &lt;input val = {val} onChange((e) =&gt; {setval(e.target.value)})/&gt;\n        &lt;myContent.Provider&gt;\n          &lt;Ptemp&gt;&lt;/Ptemp&gt;\n        &lt;myContent.Provider&gt;\n      &lt;/&gt;\n    )\n  }\n  export default Content\n\n  // 子组件\n\n  import React, {useContext} from &#39;react&#39;\n  import {myContent} from &#39;./home&#39;\n  function Ptemp() {\n    const val = useContext(myContent)\n\n    return (\n      &lt;&gt;\n        &lt;p&gt;{val}&lt;/p&gt;\n      &lt;/&gt;\n    )\n  }\n\n</code></pre><h2 id=\"🍭-useReducer\"><a href=\"#🍭-useReducer\" class=\"headerlink\" title=\"🍭 useReducer\"></a>🍭 useReducer</h2><p>**useReducer是useState的另一种替代，他接收(state, action) =&gt; newState, 并且返回了一个与当前state成对的dispatch方法</p>\n<h3 id=\"例1：最小的简单模式【计数器】\"><a href=\"#例1：最小的简单模式【计数器】\" class=\"headerlink\" title=\"例1：最小的简单模式【计数器】\"></a>例1：最小的简单模式【计数器】</h3><pre><code>  reducer.ts\n\n  export const initialState = 0\n  const renducer = (state, action) =&gt; {\n    switch(action) {\n      case &#39;count&#39;:\n        console.log(state)\n        return state + 1\n    }\n  }\n\n  export default renducer\n\n  PgReducer.tsx\n\n  import React, {useState, useReducer} from &#39;react&#39;\n\n  import renducer, {initialState} from &#39;../../renducer/expamel&#39;\n\n  function testRenducer() {\n    const [count, dispatch] = useReducer(renducer, initialState)\n    return (\n      &lt;&gt;\n        &lt;p&gt;{count}&lt;/p&gt;\n        &lt;p onClick={() =&gt; {dispatch(&#39;count&#39;)}}&gt;+&lt;/p&gt;\n      &lt;/&gt;\n    )\n  }\n\n  export default testRenducer\n\n</code></pre><h2 id=\"⚽-useRef\"><a href=\"#⚽-useRef\" class=\"headerlink\" title=\"⚽ useRef\"></a>⚽ useRef</h2><p><strong>useRef返回一个可变的ref对象其.current属性被初始化为传入参数，返回的ref对象在组件的整个生命周期内保持不变</strong></p>\n<ul>\n<li>常见的就是访问子组件</li>\n<li>获取一些dom元素的参数</li>\n</ul>\n<pre><code>  import React, { useState, useRef, useEffect } from &#39;react&#39;\n\n  function PgRef() {\n    const ulRef = useRef(null)\n    useEffect(() =&gt; {\n      console.log(ulRef.current.offsetHeight)\n    })\n    return (\n      &lt;&gt;\n        &lt;p className=&#39;testP&#39; ref={ulRef}&gt;&lt;/p&gt;\n      &lt;/&gt;\n    )\n  }\n\n  export default PgRef\n\n</code></pre><h2 id=\"🏹-原理实现\"><a href=\"#🏹-原理实现\" class=\"headerlink\" title=\"🏹 原理实现\"></a>🏹 原理实现</h2><h3 id=\"🔨-useState\"><a href=\"#🔨-useState\" class=\"headerlink\" title=\"🔨 useState\"></a>🔨 useState</h3><p><strong>首先我们来看一下useState的调用方式</strong></p>\n<pre><code>  const [count, setCount] = useState(0)\n\n</code></pre><hr>\n<blockquote>\n<p>实现</p>\n</blockquote>\n<pre><code>  let memoizedState = [] // memoizedState存储状态的数组\n  let curson = 0 // 当前memoizedState的下标\n  function useState(ininvalState) {\n    memoizedState[curson] = memoizedState[curson] || ininvalState\n    function setState(newState) {\n      memoizedState[curson] = newState\n      render()\n    }\n    return [memoizedState[curson++], setState] // 每个hooks调用都会递增curson, 从当前组件中取出状态\n  }\n\n</code></pre><blockquote>\n<p>只是简单 的实现了一下useState【<strong>useState这个hooks这后台使用useReducer，他的返回结果其实已经是Reducer状态</strong>】</p>\n</blockquote>\n<h3 id=\"🔨-useEffect\"><a href=\"#🔨-useEffect\" class=\"headerlink\" title=\"🔨 useEffect\"></a>🔨 useEffect</h3><p><strong>首先我们来看一下useEffect的调用方式</strong></p>\n<pre><code>  useEffect(() =&gt; {\n    console.log(count)\n  }, [count])\n\n</code></pre><blockquote>\n<p>实现</p>\n</blockquote>\n<p><strong>useEffect存在两个参数（callback, dep数组），如果dep数组不存在的话，每次render函数执行后，都会去执行callback函数，如果dep数组存在的时候，当dep发生改变的时候callback才会去执行</strong></p>\n<pre><code>  let memoizedState = []; // hooks 存放在这个数组\n  let cursor = 0; // 当前 memoizedState 下标\n  function useEffect(callback, dep) {\n    const hasDeps = !dep // 是否有dep数组\n    const deps = memoizedState[cursor]\n    const hasChangeDeps = deps ? !dep.every((el, i ) =&gt; el === deps[i]) : true\n    if (hasDeps || hasChangeDeps) {\n      callback();\n      memoizedState[cursor] = dep\n    }\n    cursor++;\n  }\n\n</code></pre><blockquote>\n<p>只是简单 的实现了一下useEffect, 在react调用会有自己的调用机制<br>react中是通过单链表的方式来代替数组的，通过next来串联所有的hooks的</p>\n</blockquote>\n<h2 id=\"🔫-原理链接-https-juejin-im-post-5c99a75af265da60ef635898-comment\"><a href=\"#🔫-原理链接-https-juejin-im-post-5c99a75af265da60ef635898-comment\" class=\"headerlink\" title=\"🔫 原理链接 https://juejin.im/post/5c99a75af265da60ef635898#comment\"></a>🔫 原理链接 <a href=\"https://juejin.im/post/5c99a75af265da60ef635898#comment\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5c99a75af265da60ef635898#comment</a></h2><h2 id=\"🛡-Hooks队列\"><a href=\"#🛡-Hooks队列\" class=\"headerlink\" title=\"🛡 Hooks队列\"></a>🛡 Hooks队列</h2><ul>\n<li>在初次渲染的时候，他的初始状态会被创建</li>\n<li>他的状态可以在运行的时候进行更改</li>\n<li>react可以在后续的渲染中记住hooks的状态</li>\n<li>react可以根据调用的顺序提供给你正确的状态</li>\n<li>react知道当前的hooks属于哪个部分</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Hook\"><a href=\"#Hook\" class=\"headerlink\" title=\"Hook\"></a>Hook</h1><p><strong>有状态的组件没有渲染，有渲染的组件没有状态。在现在回过头来看，这个原则会为我们后续向Hooks的迁移提供非常大的便利。</strong></p>\n<h2 id=\"🔥-Hook简介\"><a href=\"#🔥-Hook简介\" class=\"headerlink\" title=\"🔥 Hook简介\"></a>🔥 Hook简介</h2><blockquote>\n<p>Hook是react16.8的新增特性，可以在不编写class类的情况下使用state以及react的其他特性<br>React Hooks要解决的问题是状态共享，不会产生jsx嵌套问题</p>\n</blockquote>\n<h2 id=\"🏆-Hooks的运行规则\"><a href=\"#🏆-Hooks的运行规则\" class=\"headerlink\" title=\"🏆 Hooks的运行规则\"></a>🏆 Hooks的运行规则</h2><ul>\n<li>不能再循环中，条件语句和嵌套函数中调用hooks</li>\n<li>只在react中函数组件中的hooks</li>\n</ul>\n<h2 id=\"🌟-React-Hooks的特点\"><a href=\"#🌟-React-Hooks的特点\" class=\"headerlink\" title=\"🌟 React Hooks的特点\"></a>🌟 React Hooks的特点</h2><ul>\n<li>多个状态不会产生嵌套</li>\n<li>Hooks还可以引用其他Hooks</li>\n<li>更容易【更清晰】将组件的UI和状态进行分离</li>\n<li>Hooks函数必须使用‘use’命名开头</li>\n</ul>\n<h2 id=\"📌-State-Hook\"><a href=\"#📌-State-Hook\" class=\"headerlink\" title=\"📌 State Hook\"></a>📌 State Hook</h2><pre><code>  import React, { useState } from &#39;react&#39;;\n\n  function Example() {\n    // 声明一个叫 “count” 的 state 变量。\n    const [count, setCount] = useState(0); // 使用useState来定义state [参数名字, 改变参数的方法]\n\n    // 也可以多个声明state 【但是必须保证调用的顺序一样】\n\n    const [tods, settods] = useState(&#39;this is count&#39;)\n\n    return (\n      &lt;div&gt;\n        &lt;p&gt;You clicked {count} times&lt;/p&gt;\n        &lt;button onClick={() =&gt; setCount(count + 1)}&gt;\n          Click me\n        &lt;/button&gt;\n      &lt;/div&gt;\n    );\n  }\n\n</code></pre><ul>\n<li>函数组件会有特殊的处理方式</li>\n<li>在render阶段，再将函数Fiber内容的实例化的时候去处理全局中的Hooks对象的指向</li>\n<li>最终userState是调用内部函数mountState去设置state的stringif</li>\n<li>在mountState会对传入的参数如果是函数会对其先执行，得出返回值在继续运行</li>\n<li>在mountState中会创建一个闭包事件，将当前的Hooks所在的Fiber节点以及Hooks队列对象作为参数绑定在函数，并返回0</li>\n</ul>\n<h2 id=\"⚡️-Effect-Hook\"><a href=\"#⚡️-Effect-Hook\" class=\"headerlink\" title=\"⚡️ Effect Hook\"></a>⚡️ Effect Hook</h2><blockquote>\n<p>useEffect 给函数组件添加副作用，他和class组件中的componentDidMount、componentDidUpdate 和 componentWillUnmount具有相同的用途</p>\n</blockquote>\n<h3 id=\"实现componentDidMount-副作用函数\"><a href=\"#实现componentDidMount-副作用函数\" class=\"headerlink\" title=\"实现componentDidMount 副作用函数\"></a>实现componentDidMount 副作用函数</h3><pre><code>  useEffect(() =&gt; {\n    // 使用浏览器的 API 更新页面标题\n    document.title = `You clicked ${count} times`;\n  });\n\n</code></pre><h3 id=\"实现componentDidUpdate-副作用函数\"><a href=\"#实现componentDidUpdate-副作用函数\" class=\"headerlink\" title=\"实现componentDidUpdate 副作用函数\"></a>实现componentDidUpdate 副作用函数</h3><pre><code>  useEffect(() =&gt; {\n    // 使用浏览器的 API 更新页面标题\n    document.title = `You clicked ${count} times`;\n  }, [count]); // 只在count发生改变的情况下调用\n\n</code></pre><h3 id=\"实现componentWillUnmount-副作用函数\"><a href=\"#实现componentWillUnmount-副作用函数\" class=\"headerlink\" title=\"实现componentWillUnmount 副作用函数\"></a>实现componentWillUnmount 副作用函数</h3><pre><code>  useEffect(() =&gt; {\n    // 使用浏览器的 API 更新页面标题\n    document.title = `You clicked ${count} times`;\n    return () =&gt; {\n      // 清除副作用操作\n    }\n  });\n\n</code></pre><ul>\n<li>userEffect的执行时机都发生在每次渲染之后，无论首次渲染还是更新渲染</li>\n<li>userEffect只有在函数组件中执行，不能再非函数组件中执行</li>\n<li>userEffect可以在函数组件中执行多次，是按调用顺序执行的</li>\n<li>userEffect传入的函数，return是在组件卸载的时候执行的</li>\n<li>userEffect的执行，是由他的第二参数来控制的，而且第二的参数必须是一个数组，react会对数组中的每一项与上次的数组进行比较，如果不同，则才会去执行函数</li>\n<li>userEffect采用的是异步的方案执行，类似于js中的setTimeout，将userEffect进行异步执行</li>\n</ul>\n<p><strong>实用之处</strong></p>\n<p>  再实现重复的数据请求中使用</p>\n<pre><code>  function getData() {\n    const [data, setdata] = useState(null)\n\n    useEffect(() =&gt; {\n      axios(&#39;/a/b&#39;).then(res =&gt; {\n        setdata(res.data)\n      })\n    }, [])\n\n    return data\n  }\n\n  // 在别的函数组件中直接调用即可获取到数据【当然加入第二参数是为了防止数据更新的时候再次触犯请求数据执行】【灵活 的写法有很多种】\n\n</code></pre><h2 id=\"🔐-注意事项\"><a href=\"#🔐-注意事项\" class=\"headerlink\" title=\"🔐 注意事项\"></a>🔐 注意事项</h2><ul>\n<li>不可以在hooks中使用条件语句【会影响hooks的调用规则（顺序）】，会导致调用混乱，产生bug</li>\n<li>如果我们想执行一个判断可以将其放在内部来使用</li>\n</ul>\n<pre><code>  useEffect(() =&gt; {\n    // 将条件语句放置在hooks中\n    if (val != &#39;&#39;) {\n      document.title = val\n    }\n  })\n\n</code></pre><ul>\n<li>我们可以去自定义hooks，但我们自定义的hooks必须以use开头，这是一种约定，它可以识别我们是否遵循了规范，他是hooks的规范，不是react的</li>\n</ul>\n<h2 id=\"💕-useContent\"><a href=\"#💕-useContent\" class=\"headerlink\" title=\"💕 useContent\"></a>💕 useContent</h2><p><strong>可以使用useContext进行跨组件传值</strong></p>\n<pre><code>\n  // 父组件\n  import React, {useState} from &#39;react&#39;\n  export const myContent = React.createContext(null)\n  function Content() {\n    const [val, setval] = useState(myContent)\n    return (\n      &lt;&gt;\n        &lt;input val = {val} onChange((e) =&gt; {setval(e.target.value)})/&gt;\n        &lt;myContent.Provider&gt;\n          &lt;Ptemp&gt;&lt;/Ptemp&gt;\n        &lt;myContent.Provider&gt;\n      &lt;/&gt;\n    )\n  }\n  export default Content\n\n  // 子组件\n\n  import React, {useContext} from &#39;react&#39;\n  import {myContent} from &#39;./home&#39;\n  function Ptemp() {\n    const val = useContext(myContent)\n\n    return (\n      &lt;&gt;\n        &lt;p&gt;{val}&lt;/p&gt;\n      &lt;/&gt;\n    )\n  }\n\n</code></pre><h2 id=\"🍭-useReducer\"><a href=\"#🍭-useReducer\" class=\"headerlink\" title=\"🍭 useReducer\"></a>🍭 useReducer</h2><p>**useReducer是useState的另一种替代，他接收(state, action) =&gt; newState, 并且返回了一个与当前state成对的dispatch方法</p>\n<h3 id=\"例1：最小的简单模式【计数器】\"><a href=\"#例1：最小的简单模式【计数器】\" class=\"headerlink\" title=\"例1：最小的简单模式【计数器】\"></a>例1：最小的简单模式【计数器】</h3><pre><code>  reducer.ts\n\n  export const initialState = 0\n  const renducer = (state, action) =&gt; {\n    switch(action) {\n      case &#39;count&#39;:\n        console.log(state)\n        return state + 1\n    }\n  }\n\n  export default renducer\n\n  PgReducer.tsx\n\n  import React, {useState, useReducer} from &#39;react&#39;\n\n  import renducer, {initialState} from &#39;../../renducer/expamel&#39;\n\n  function testRenducer() {\n    const [count, dispatch] = useReducer(renducer, initialState)\n    return (\n      &lt;&gt;\n        &lt;p&gt;{count}&lt;/p&gt;\n        &lt;p onClick={() =&gt; {dispatch(&#39;count&#39;)}}&gt;+&lt;/p&gt;\n      &lt;/&gt;\n    )\n  }\n\n  export default testRenducer\n\n</code></pre><h2 id=\"⚽-useRef\"><a href=\"#⚽-useRef\" class=\"headerlink\" title=\"⚽ useRef\"></a>⚽ useRef</h2><p><strong>useRef返回一个可变的ref对象其.current属性被初始化为传入参数，返回的ref对象在组件的整个生命周期内保持不变</strong></p>\n<ul>\n<li>常见的就是访问子组件</li>\n<li>获取一些dom元素的参数</li>\n</ul>\n<pre><code>  import React, { useState, useRef, useEffect } from &#39;react&#39;\n\n  function PgRef() {\n    const ulRef = useRef(null)\n    useEffect(() =&gt; {\n      console.log(ulRef.current.offsetHeight)\n    })\n    return (\n      &lt;&gt;\n        &lt;p className=&#39;testP&#39; ref={ulRef}&gt;&lt;/p&gt;\n      &lt;/&gt;\n    )\n  }\n\n  export default PgRef\n\n</code></pre><h2 id=\"🏹-原理实现\"><a href=\"#🏹-原理实现\" class=\"headerlink\" title=\"🏹 原理实现\"></a>🏹 原理实现</h2><h3 id=\"🔨-useState\"><a href=\"#🔨-useState\" class=\"headerlink\" title=\"🔨 useState\"></a>🔨 useState</h3><p><strong>首先我们来看一下useState的调用方式</strong></p>\n<pre><code>  const [count, setCount] = useState(0)\n\n</code></pre><hr>\n<blockquote>\n<p>实现</p>\n</blockquote>\n<pre><code>  let memoizedState = [] // memoizedState存储状态的数组\n  let curson = 0 // 当前memoizedState的下标\n  function useState(ininvalState) {\n    memoizedState[curson] = memoizedState[curson] || ininvalState\n    function setState(newState) {\n      memoizedState[curson] = newState\n      render()\n    }\n    return [memoizedState[curson++], setState] // 每个hooks调用都会递增curson, 从当前组件中取出状态\n  }\n\n</code></pre><blockquote>\n<p>只是简单 的实现了一下useState【<strong>useState这个hooks这后台使用useReducer，他的返回结果其实已经是Reducer状态</strong>】</p>\n</blockquote>\n<h3 id=\"🔨-useEffect\"><a href=\"#🔨-useEffect\" class=\"headerlink\" title=\"🔨 useEffect\"></a>🔨 useEffect</h3><p><strong>首先我们来看一下useEffect的调用方式</strong></p>\n<pre><code>  useEffect(() =&gt; {\n    console.log(count)\n  }, [count])\n\n</code></pre><blockquote>\n<p>实现</p>\n</blockquote>\n<p><strong>useEffect存在两个参数（callback, dep数组），如果dep数组不存在的话，每次render函数执行后，都会去执行callback函数，如果dep数组存在的时候，当dep发生改变的时候callback才会去执行</strong></p>\n<pre><code>  let memoizedState = []; // hooks 存放在这个数组\n  let cursor = 0; // 当前 memoizedState 下标\n  function useEffect(callback, dep) {\n    const hasDeps = !dep // 是否有dep数组\n    const deps = memoizedState[cursor]\n    const hasChangeDeps = deps ? !dep.every((el, i ) =&gt; el === deps[i]) : true\n    if (hasDeps || hasChangeDeps) {\n      callback();\n      memoizedState[cursor] = dep\n    }\n    cursor++;\n  }\n\n</code></pre><blockquote>\n<p>只是简单 的实现了一下useEffect, 在react调用会有自己的调用机制<br>react中是通过单链表的方式来代替数组的，通过next来串联所有的hooks的</p>\n</blockquote>\n<h2 id=\"🔫-原理链接-https-juejin-im-post-5c99a75af265da60ef635898-comment\"><a href=\"#🔫-原理链接-https-juejin-im-post-5c99a75af265da60ef635898-comment\" class=\"headerlink\" title=\"🔫 原理链接 https://juejin.im/post/5c99a75af265da60ef635898#comment\"></a>🔫 原理链接 <a href=\"https://juejin.im/post/5c99a75af265da60ef635898#comment\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5c99a75af265da60ef635898#comment</a></h2><h2 id=\"🛡-Hooks队列\"><a href=\"#🛡-Hooks队列\" class=\"headerlink\" title=\"🛡 Hooks队列\"></a>🛡 Hooks队列</h2><ul>\n<li>在初次渲染的时候，他的初始状态会被创建</li>\n<li>他的状态可以在运行的时候进行更改</li>\n<li>react可以在后续的渲染中记住hooks的状态</li>\n<li>react可以根据调用的顺序提供给你正确的状态</li>\n<li>react知道当前的hooks属于哪个部分</li>\n</ul>\n"},{"title":"对react-router的封装及api","date":"2019-04-03T11:10:00.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"## 对react-router的封装\n\n**直接上代码吧**\n\n> config.js // 该文件是对路由的配置\n\n\t//组件的引入\n\timport Home from '../contentais/home/index'\n\timport Login from \"../contentais/login/index\"\n\timport Business from './../contentais/home/business/index';\n\timport Finance from './../contentais/home/finance/index';\n\timport Tissue from './../contentais/home/tissue/index';\n\timport Statistics from './../contentais/home/statistics/index';\n\timport Order from './../contentais/home/order/index';\n\timport UserHome from './../contentais/home/userHome/index';\n\timport Loans from './../contentais/home/order/loans/index';\n\timport Transfer from './../contentais/home/order/transfer/index';\n\timport Insurance from './../contentais/home/order/insurance/index';\n\t\n\tconst RouteConfig = [\n\t    {\n\t        //title \n\t        title: \"首页\",\n\t        //路由地址\n\t        path: \"/Home\",\n\t        //关键字重定向\n\t        defaultRedirect: true,\n\t        //组件\n\t        component: Home,\n\t        //二级路由\n\t        children: [\n\t            {\n\t                key: \"1\",\n\t                defaultRedirect: true,\n\t\n\t                title: \"首页\",\n\t                path: \"/Home/one\",\n\t                component: UserHome,\n\t            },\n\t            {\n\t                key: \"sub1\",\n\t                title: \"订单管理\",\n\t                path: \"/Home/order\",\n\t                component: Order,\n\t                //三级路由\n\t                children: [\n\t                    {\n\t                        defaultRedirect: true,\n\t\n\t                        key: \"2\",\n\t                        title: \"贷款订单\",\n\t                        path: \"/Home/order/loans\",\n\t                        component: Loans,\n\t                    },\n\t                    {\n\t                        key: \"3\",\n\t                        title: \"转单订单\",\n\t                        path: \"/Home/order/transfer\",\n\t                        component: Transfer,\n\t                    },\n\t                    {\n\t                        key: \"4\",\n\t                        title: \"保险订单\",\n\t                        path: \"/Home/order/insurance\",\n\t                        component: Insurance,\n\t                    },\n\t                    //三级路由的重定向   默认显示的页面\n\t                    {\n\t                        path: \"/Home/order\",\n\t                        redirect: \"/Home/order/loans\"\n\t                    }\n\t                ]\n\t            },\n\t            {\n\t                key: \"5\",\n\t                title: \"财务管理\",\n\t                path: \"/Home/finance\",\n\t                component: Finance,\n\t            }\n\t            ,\n\t            {\n\t                key: \"6\",\n\t                title: \"组织架构\",\n\t                path: \"/Home/tissue\",\n\t                component: Tissue,\n\t            },\n\t            {\n\t                key: \"7\",\n\t                title: \"数据统计\",\n\t                path: \"/Home/statistics\",\n\t                component: Statistics,\n\t            },\n\t            {\n\t                key: \"8\",\n\t                title: \"商务管理\",\n\t                path: \"/Home/business\",\n\t                component: Business,\n\t            },\n\t            //二级路由的重定向   默认显示的页面\n\t            {\n\t                path: \"/Home\",\n\t                redirect: \"/Home/one\"\n\t            }\n\t        ]\n\t    },\n\t    {\n\t        title: \"登陆\",\n\t        path: \"/Login\",\n\t        component: Login,\n\t    }, {\n\t        //一级路由的重定向\n\t        path: \"/\",\n\t        redirect: \"/Home\"\n\t    }\n\t]\n\texport default RouteConfig;\n\n> routerView.js // 路由递归逻辑实现\n\n\timport { Route, Switch, Redirect } from \"react-router-dom\"\n\timport React, { Component } from 'react';\n\tclass RouteView extends Component {\n\t    render() {\n\t\n\t        // props接收配置文件\n\t        // routers 下一级路由的参数\n\t        // defaultConfig默认传参\n\n\t        const { routers, defaultConfig } = this.props\n\n\t\t\t// 这里判断【下一级路由的参数】是否有值 ? 【使用下一级路由的参数】 ： 【默认路由参数】\n\n\t        let routerDate = routers ? routers : defaultConfig;\n\n\t        //数据二次处理\n\t\n\t        //筛除没有重定向的\n\t        let routerDatepath = routerDate.filter((item) => {\n\t            return !item.redirect\n\t        })\n\n\t        //筛选重定向\n\t        let defualtRouter = routerDate.filter((item) => {\n\t            return item.redirect\n\t        })\n\n\t        //重定向\n\t        let defualtRedirect = defualtRouter.map((item, i) => {\n\t            return <Redirect key={i} path={item.path} to={item.redirect}></Redirect>\n\t        })\n\n\t        return (<Switch>\n\t            {\n\t                routerDatepath && routerDatepath.map((item, index) => {\n\t                    const Comp = item.component\n\t                    // 一个大坑 要用render 不然用component会导致页面的回流\n\t                    return <Route path={item.path} render={\n\t                        //api 路由相关参数参数及其它\n\t                        (api) => {\n\t                            //动态的title\n\t                            document.title = item.title || \"路由配置\"\n\t                            //把下一级路由参数存入props中\n\t                            return <Comp routers={item.children} {...api}></Comp>\n\t                        }\n\t                    } key={\"key\" + item.key}></Route>\n\t                    //重定向\n\t                }).concat(defualtRedirect)\n\t            }\n\t        </Switch>)\n\t    }\n\t}\n\texport default RouteView;\n\n> app.js // 路由调用的使用方式\n\n\timport React, { Component } from 'react';\n\timport { BrowserRouter as Router } from \"react-router-dom\"\n\timport RouteConfig from './config.js'; // 引入路由的配置信息\n\timport RouteView from './routeView,js'; // 引入路由的逻辑实现\n\tclass App extends Component {\n\t    render() {\n\t        return <div className=\"wrapper\">\n\t            <Router>\n\t                //传入默认路由配置文件\n\t                <RouteView defaultConfig={RouteConfig}></RouteView>\n\t            </Router>\n\t        </div>\n\t    }\n\t}\n\texport default App;\n\n> 二级路由的调用\n\n\timport React, { Component } from 'react';\n\timport RouteView from './../../router/RouteView';\n\timport SiderMenu from './../../components/SiderMenu/index';\n\timport \"./index.css\"\n\tclass Home extends Component {\n\t    render() {\n\t        //接收路由配置\n\t        const { routers } = this.props\n\t        return <div className=\"home-wrapper\">\n\t            <div className=\"left\">\n\t                <div className=\"user\">\n\t                    <div className=\"user-img\">\n\t                    </div>\n\t                    <p className=\"mt12\">你瞅啥</p>\n\t                    <b className=\"mt12 radius\"></b>\n\t                </div>\n\t                //侧边栏的组件\n\t                <SiderMenu style={{ background:\"#2F3B4C\"}} {...this.props}></SiderMenu>\n\t            <div className=\"ri\n\t            </div>ght\">\n\t                //传入RouteView当中进行处理\n\t                <RouteView routers={routers}></RouteView>\n\t            </div>\n\t        </div>\n\t    }\n\t\n\t}\n\texport default Home;\n\n## 'react-router-dom的api\n\n**react-router-dom提供了BrowserRouter, Route, Link等api,我们可以通过dom的事件控制路由。例如点击一个按钮进行跳转，大多数情况下我们是这种情况，所以在开发过程中，我们更多是使用React-router-dom。安装很简单npm i react-router-dom --save,安装了淘宝镜像的就用cnpm吧。**\n\n### 常用的路由api\n\n----------\n\n\n- HashRouter和BrowserRouter\n\n**它们两个是路由的基本，就像盖房子必须有地基一样，我们需要将它们包裹在最外层，我们只要选择其一就可以了。现在讲它们的不同：**\n\n> HashRouter\n\n**如果你使用过react-router2或3或者vue-router，你经常会发现一个现象就是url中会有个#，例如localhost:3000/#，HashRouter就会出现这种情况，它是通过hash值来对路由进行控制。如果你使用HashRouter，你的路由就会默认有这个#。**\n\n> BrowserRouter\n\n**很多情况下我们则不是这种情况，我们不需要这个#，因为它看起来很怪，这时我们就需要用到BrowserRouter。**\n\n----------\n\n- Route\n\n**Route是路由的一个原材料，它是控制路径对应显示的组件。我们经常用的是exact、path以及component属性。**\n\n\t<Route path='/' component='' exact></Route>\n\n> exact控制匹配到/路径时不会再继续向下匹配，\n> \n> path标识路由的路径\n> \n> component表示路径对应显示的组件\n\n----------\n\n\n- Link和NavLink的选择\n\n**两者都是可以控制路由跳转的，不同点是NavLink的api更多，更加满足你的需求。**\n\n> Link\n\n**主要api是to，to可以接受string或者一个object，来控制url。使用方法如下**\n\n<Link to='/api'>\n\n> NavLink\n\n**它可以为当前选中的路由设置类名、样式以及回调函数等。使用如下**\n\n\t<Navlink to='' activeClassName='actived'>\n\n**activeClassName是选中状态的类名，我们可以为其添加样式**\n\n----------\n\n- Switch\n\n**Switch常常会用来包裹Route，它里面不能放其他元素，用来只显示一个路由。**\n\n----------\n\n","source":"_posts/react-router.md","raw":"---\ntitle: 对react-router的封装及api\ndate: '4/3/2019 7:10:00 PM  '\ntag: ['js', 'react']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n## 对react-router的封装\n\n**直接上代码吧**\n\n> config.js // 该文件是对路由的配置\n\n\t//组件的引入\n\timport Home from '../contentais/home/index'\n\timport Login from \"../contentais/login/index\"\n\timport Business from './../contentais/home/business/index';\n\timport Finance from './../contentais/home/finance/index';\n\timport Tissue from './../contentais/home/tissue/index';\n\timport Statistics from './../contentais/home/statistics/index';\n\timport Order from './../contentais/home/order/index';\n\timport UserHome from './../contentais/home/userHome/index';\n\timport Loans from './../contentais/home/order/loans/index';\n\timport Transfer from './../contentais/home/order/transfer/index';\n\timport Insurance from './../contentais/home/order/insurance/index';\n\t\n\tconst RouteConfig = [\n\t    {\n\t        //title \n\t        title: \"首页\",\n\t        //路由地址\n\t        path: \"/Home\",\n\t        //关键字重定向\n\t        defaultRedirect: true,\n\t        //组件\n\t        component: Home,\n\t        //二级路由\n\t        children: [\n\t            {\n\t                key: \"1\",\n\t                defaultRedirect: true,\n\t\n\t                title: \"首页\",\n\t                path: \"/Home/one\",\n\t                component: UserHome,\n\t            },\n\t            {\n\t                key: \"sub1\",\n\t                title: \"订单管理\",\n\t                path: \"/Home/order\",\n\t                component: Order,\n\t                //三级路由\n\t                children: [\n\t                    {\n\t                        defaultRedirect: true,\n\t\n\t                        key: \"2\",\n\t                        title: \"贷款订单\",\n\t                        path: \"/Home/order/loans\",\n\t                        component: Loans,\n\t                    },\n\t                    {\n\t                        key: \"3\",\n\t                        title: \"转单订单\",\n\t                        path: \"/Home/order/transfer\",\n\t                        component: Transfer,\n\t                    },\n\t                    {\n\t                        key: \"4\",\n\t                        title: \"保险订单\",\n\t                        path: \"/Home/order/insurance\",\n\t                        component: Insurance,\n\t                    },\n\t                    //三级路由的重定向   默认显示的页面\n\t                    {\n\t                        path: \"/Home/order\",\n\t                        redirect: \"/Home/order/loans\"\n\t                    }\n\t                ]\n\t            },\n\t            {\n\t                key: \"5\",\n\t                title: \"财务管理\",\n\t                path: \"/Home/finance\",\n\t                component: Finance,\n\t            }\n\t            ,\n\t            {\n\t                key: \"6\",\n\t                title: \"组织架构\",\n\t                path: \"/Home/tissue\",\n\t                component: Tissue,\n\t            },\n\t            {\n\t                key: \"7\",\n\t                title: \"数据统计\",\n\t                path: \"/Home/statistics\",\n\t                component: Statistics,\n\t            },\n\t            {\n\t                key: \"8\",\n\t                title: \"商务管理\",\n\t                path: \"/Home/business\",\n\t                component: Business,\n\t            },\n\t            //二级路由的重定向   默认显示的页面\n\t            {\n\t                path: \"/Home\",\n\t                redirect: \"/Home/one\"\n\t            }\n\t        ]\n\t    },\n\t    {\n\t        title: \"登陆\",\n\t        path: \"/Login\",\n\t        component: Login,\n\t    }, {\n\t        //一级路由的重定向\n\t        path: \"/\",\n\t        redirect: \"/Home\"\n\t    }\n\t]\n\texport default RouteConfig;\n\n> routerView.js // 路由递归逻辑实现\n\n\timport { Route, Switch, Redirect } from \"react-router-dom\"\n\timport React, { Component } from 'react';\n\tclass RouteView extends Component {\n\t    render() {\n\t\n\t        // props接收配置文件\n\t        // routers 下一级路由的参数\n\t        // defaultConfig默认传参\n\n\t        const { routers, defaultConfig } = this.props\n\n\t\t\t// 这里判断【下一级路由的参数】是否有值 ? 【使用下一级路由的参数】 ： 【默认路由参数】\n\n\t        let routerDate = routers ? routers : defaultConfig;\n\n\t        //数据二次处理\n\t\n\t        //筛除没有重定向的\n\t        let routerDatepath = routerDate.filter((item) => {\n\t            return !item.redirect\n\t        })\n\n\t        //筛选重定向\n\t        let defualtRouter = routerDate.filter((item) => {\n\t            return item.redirect\n\t        })\n\n\t        //重定向\n\t        let defualtRedirect = defualtRouter.map((item, i) => {\n\t            return <Redirect key={i} path={item.path} to={item.redirect}></Redirect>\n\t        })\n\n\t        return (<Switch>\n\t            {\n\t                routerDatepath && routerDatepath.map((item, index) => {\n\t                    const Comp = item.component\n\t                    // 一个大坑 要用render 不然用component会导致页面的回流\n\t                    return <Route path={item.path} render={\n\t                        //api 路由相关参数参数及其它\n\t                        (api) => {\n\t                            //动态的title\n\t                            document.title = item.title || \"路由配置\"\n\t                            //把下一级路由参数存入props中\n\t                            return <Comp routers={item.children} {...api}></Comp>\n\t                        }\n\t                    } key={\"key\" + item.key}></Route>\n\t                    //重定向\n\t                }).concat(defualtRedirect)\n\t            }\n\t        </Switch>)\n\t    }\n\t}\n\texport default RouteView;\n\n> app.js // 路由调用的使用方式\n\n\timport React, { Component } from 'react';\n\timport { BrowserRouter as Router } from \"react-router-dom\"\n\timport RouteConfig from './config.js'; // 引入路由的配置信息\n\timport RouteView from './routeView,js'; // 引入路由的逻辑实现\n\tclass App extends Component {\n\t    render() {\n\t        return <div className=\"wrapper\">\n\t            <Router>\n\t                //传入默认路由配置文件\n\t                <RouteView defaultConfig={RouteConfig}></RouteView>\n\t            </Router>\n\t        </div>\n\t    }\n\t}\n\texport default App;\n\n> 二级路由的调用\n\n\timport React, { Component } from 'react';\n\timport RouteView from './../../router/RouteView';\n\timport SiderMenu from './../../components/SiderMenu/index';\n\timport \"./index.css\"\n\tclass Home extends Component {\n\t    render() {\n\t        //接收路由配置\n\t        const { routers } = this.props\n\t        return <div className=\"home-wrapper\">\n\t            <div className=\"left\">\n\t                <div className=\"user\">\n\t                    <div className=\"user-img\">\n\t                    </div>\n\t                    <p className=\"mt12\">你瞅啥</p>\n\t                    <b className=\"mt12 radius\"></b>\n\t                </div>\n\t                //侧边栏的组件\n\t                <SiderMenu style={{ background:\"#2F3B4C\"}} {...this.props}></SiderMenu>\n\t            <div className=\"ri\n\t            </div>ght\">\n\t                //传入RouteView当中进行处理\n\t                <RouteView routers={routers}></RouteView>\n\t            </div>\n\t        </div>\n\t    }\n\t\n\t}\n\texport default Home;\n\n## 'react-router-dom的api\n\n**react-router-dom提供了BrowserRouter, Route, Link等api,我们可以通过dom的事件控制路由。例如点击一个按钮进行跳转，大多数情况下我们是这种情况，所以在开发过程中，我们更多是使用React-router-dom。安装很简单npm i react-router-dom --save,安装了淘宝镜像的就用cnpm吧。**\n\n### 常用的路由api\n\n----------\n\n\n- HashRouter和BrowserRouter\n\n**它们两个是路由的基本，就像盖房子必须有地基一样，我们需要将它们包裹在最外层，我们只要选择其一就可以了。现在讲它们的不同：**\n\n> HashRouter\n\n**如果你使用过react-router2或3或者vue-router，你经常会发现一个现象就是url中会有个#，例如localhost:3000/#，HashRouter就会出现这种情况，它是通过hash值来对路由进行控制。如果你使用HashRouter，你的路由就会默认有这个#。**\n\n> BrowserRouter\n\n**很多情况下我们则不是这种情况，我们不需要这个#，因为它看起来很怪，这时我们就需要用到BrowserRouter。**\n\n----------\n\n- Route\n\n**Route是路由的一个原材料，它是控制路径对应显示的组件。我们经常用的是exact、path以及component属性。**\n\n\t<Route path='/' component='' exact></Route>\n\n> exact控制匹配到/路径时不会再继续向下匹配，\n> \n> path标识路由的路径\n> \n> component表示路径对应显示的组件\n\n----------\n\n\n- Link和NavLink的选择\n\n**两者都是可以控制路由跳转的，不同点是NavLink的api更多，更加满足你的需求。**\n\n> Link\n\n**主要api是to，to可以接受string或者一个object，来控制url。使用方法如下**\n\n<Link to='/api'>\n\n> NavLink\n\n**它可以为当前选中的路由设置类名、样式以及回调函数等。使用如下**\n\n\t<Navlink to='' activeClassName='actived'>\n\n**activeClassName是选中状态的类名，我们可以为其添加样式**\n\n----------\n\n- Switch\n\n**Switch常常会用来包裹Route，它里面不能放其他元素，用来只显示一个路由。**\n\n----------\n\n","slug":"react-router","published":1,"updated":"2019-04-03T11:10:01.553Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iamdp006pn4wd5asa8nkx","content":"<h2 id=\"对react-router的封装\"><a href=\"#对react-router的封装\" class=\"headerlink\" title=\"对react-router的封装\"></a>对react-router的封装</h2><p><strong>直接上代码吧</strong></p>\n<blockquote>\n<p>config.js // 该文件是对路由的配置</p>\n</blockquote>\n<pre><code>//组件的引入\nimport Home from &#39;../contentais/home/index&#39;\nimport Login from &quot;../contentais/login/index&quot;\nimport Business from &#39;./../contentais/home/business/index&#39;;\nimport Finance from &#39;./../contentais/home/finance/index&#39;;\nimport Tissue from &#39;./../contentais/home/tissue/index&#39;;\nimport Statistics from &#39;./../contentais/home/statistics/index&#39;;\nimport Order from &#39;./../contentais/home/order/index&#39;;\nimport UserHome from &#39;./../contentais/home/userHome/index&#39;;\nimport Loans from &#39;./../contentais/home/order/loans/index&#39;;\nimport Transfer from &#39;./../contentais/home/order/transfer/index&#39;;\nimport Insurance from &#39;./../contentais/home/order/insurance/index&#39;;\n\nconst RouteConfig = [\n    {\n        //title \n        title: &quot;首页&quot;,\n        //路由地址\n        path: &quot;/Home&quot;,\n        //关键字重定向\n        defaultRedirect: true,\n        //组件\n        component: Home,\n        //二级路由\n        children: [\n            {\n                key: &quot;1&quot;,\n                defaultRedirect: true,\n\n                title: &quot;首页&quot;,\n                path: &quot;/Home/one&quot;,\n                component: UserHome,\n            },\n            {\n                key: &quot;sub1&quot;,\n                title: &quot;订单管理&quot;,\n                path: &quot;/Home/order&quot;,\n                component: Order,\n                //三级路由\n                children: [\n                    {\n                        defaultRedirect: true,\n\n                        key: &quot;2&quot;,\n                        title: &quot;贷款订单&quot;,\n                        path: &quot;/Home/order/loans&quot;,\n                        component: Loans,\n                    },\n                    {\n                        key: &quot;3&quot;,\n                        title: &quot;转单订单&quot;,\n                        path: &quot;/Home/order/transfer&quot;,\n                        component: Transfer,\n                    },\n                    {\n                        key: &quot;4&quot;,\n                        title: &quot;保险订单&quot;,\n                        path: &quot;/Home/order/insurance&quot;,\n                        component: Insurance,\n                    },\n                    //三级路由的重定向   默认显示的页面\n                    {\n                        path: &quot;/Home/order&quot;,\n                        redirect: &quot;/Home/order/loans&quot;\n                    }\n                ]\n            },\n            {\n                key: &quot;5&quot;,\n                title: &quot;财务管理&quot;,\n                path: &quot;/Home/finance&quot;,\n                component: Finance,\n            }\n            ,\n            {\n                key: &quot;6&quot;,\n                title: &quot;组织架构&quot;,\n                path: &quot;/Home/tissue&quot;,\n                component: Tissue,\n            },\n            {\n                key: &quot;7&quot;,\n                title: &quot;数据统计&quot;,\n                path: &quot;/Home/statistics&quot;,\n                component: Statistics,\n            },\n            {\n                key: &quot;8&quot;,\n                title: &quot;商务管理&quot;,\n                path: &quot;/Home/business&quot;,\n                component: Business,\n            },\n            //二级路由的重定向   默认显示的页面\n            {\n                path: &quot;/Home&quot;,\n                redirect: &quot;/Home/one&quot;\n            }\n        ]\n    },\n    {\n        title: &quot;登陆&quot;,\n        path: &quot;/Login&quot;,\n        component: Login,\n    }, {\n        //一级路由的重定向\n        path: &quot;/&quot;,\n        redirect: &quot;/Home&quot;\n    }\n]\nexport default RouteConfig;\n</code></pre><blockquote>\n<p>routerView.js // 路由递归逻辑实现</p>\n</blockquote>\n<pre><code>import { Route, Switch, Redirect } from &quot;react-router-dom&quot;\nimport React, { Component } from &#39;react&#39;;\nclass RouteView extends Component {\n    render() {\n\n        // props接收配置文件\n        // routers 下一级路由的参数\n        // defaultConfig默认传参\n\n        const { routers, defaultConfig } = this.props\n\n        // 这里判断【下一级路由的参数】是否有值 ? 【使用下一级路由的参数】 ： 【默认路由参数】\n\n        let routerDate = routers ? routers : defaultConfig;\n\n        //数据二次处理\n\n        //筛除没有重定向的\n        let routerDatepath = routerDate.filter((item) =&gt; {\n            return !item.redirect\n        })\n\n        //筛选重定向\n        let defualtRouter = routerDate.filter((item) =&gt; {\n            return item.redirect\n        })\n\n        //重定向\n        let defualtRedirect = defualtRouter.map((item, i) =&gt; {\n            return &lt;Redirect key={i} path={item.path} to={item.redirect}&gt;&lt;/Redirect&gt;\n        })\n\n        return (&lt;Switch&gt;\n            {\n                routerDatepath &amp;&amp; routerDatepath.map((item, index) =&gt; {\n                    const Comp = item.component\n                    // 一个大坑 要用render 不然用component会导致页面的回流\n                    return &lt;Route path={item.path} render={\n                        //api 路由相关参数参数及其它\n                        (api) =&gt; {\n                            //动态的title\n                            document.title = item.title || &quot;路由配置&quot;\n                            //把下一级路由参数存入props中\n                            return &lt;Comp routers={item.children} {...api}&gt;&lt;/Comp&gt;\n                        }\n                    } key={&quot;key&quot; + item.key}&gt;&lt;/Route&gt;\n                    //重定向\n                }).concat(defualtRedirect)\n            }\n        &lt;/Switch&gt;)\n    }\n}\nexport default RouteView;\n</code></pre><blockquote>\n<p>app.js // 路由调用的使用方式</p>\n</blockquote>\n<pre><code>import React, { Component } from &#39;react&#39;;\nimport { BrowserRouter as Router } from &quot;react-router-dom&quot;\nimport RouteConfig from &#39;./config.js&#39;; // 引入路由的配置信息\nimport RouteView from &#39;./routeView,js&#39;; // 引入路由的逻辑实现\nclass App extends Component {\n    render() {\n        return &lt;div className=&quot;wrapper&quot;&gt;\n            &lt;Router&gt;\n                //传入默认路由配置文件\n                &lt;RouteView defaultConfig={RouteConfig}&gt;&lt;/RouteView&gt;\n            &lt;/Router&gt;\n        &lt;/div&gt;\n    }\n}\nexport default App;\n</code></pre><blockquote>\n<p>二级路由的调用</p>\n</blockquote>\n<pre><code>import React, { Component } from &#39;react&#39;;\nimport RouteView from &#39;./../../router/RouteView&#39;;\nimport SiderMenu from &#39;./../../components/SiderMenu/index&#39;;\nimport &quot;./index.css&quot;\nclass Home extends Component {\n    render() {\n        //接收路由配置\n        const { routers } = this.props\n        return &lt;div className=&quot;home-wrapper&quot;&gt;\n            &lt;div className=&quot;left&quot;&gt;\n                &lt;div className=&quot;user&quot;&gt;\n                    &lt;div className=&quot;user-img&quot;&gt;\n                    &lt;/div&gt;\n                    &lt;p className=&quot;mt12&quot;&gt;你瞅啥&lt;/p&gt;\n                    &lt;b className=&quot;mt12 radius&quot;&gt;&lt;/b&gt;\n                &lt;/div&gt;\n                //侧边栏的组件\n                &lt;SiderMenu style={{ background:\"#2F3B4C\"}} {...this.props}&gt;&lt;/SiderMenu&gt;\n            &lt;div className=&quot;ri\n            &lt;/div&gt;ght&quot;&gt;\n                //传入RouteView当中进行处理\n                &lt;RouteView routers={routers}&gt;&lt;/RouteView&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    }\n\n}\nexport default Home;\n</code></pre><h2 id=\"‘react-router-dom的api\"><a href=\"#‘react-router-dom的api\" class=\"headerlink\" title=\"‘react-router-dom的api\"></a>‘react-router-dom的api</h2><p><strong>react-router-dom提供了BrowserRouter, Route, Link等api,我们可以通过dom的事件控制路由。例如点击一个按钮进行跳转，大多数情况下我们是这种情况，所以在开发过程中，我们更多是使用React-router-dom。安装很简单npm i react-router-dom –save,安装了淘宝镜像的就用cnpm吧。</strong></p>\n<h3 id=\"常用的路由api\"><a href=\"#常用的路由api\" class=\"headerlink\" title=\"常用的路由api\"></a>常用的路由api</h3><hr>\n<ul>\n<li>HashRouter和BrowserRouter</li>\n</ul>\n<p><strong>它们两个是路由的基本，就像盖房子必须有地基一样，我们需要将它们包裹在最外层，我们只要选择其一就可以了。现在讲它们的不同：</strong></p>\n<blockquote>\n<p>HashRouter</p>\n</blockquote>\n<p><strong>如果你使用过react-router2或3或者vue-router，你经常会发现一个现象就是url中会有个#，例如localhost:3000/#，HashRouter就会出现这种情况，它是通过hash值来对路由进行控制。如果你使用HashRouter，你的路由就会默认有这个#。</strong></p>\n<blockquote>\n<p>BrowserRouter</p>\n</blockquote>\n<p><strong>很多情况下我们则不是这种情况，我们不需要这个#，因为它看起来很怪，这时我们就需要用到BrowserRouter。</strong></p>\n<hr>\n<ul>\n<li>Route</li>\n</ul>\n<p><strong>Route是路由的一个原材料，它是控制路径对应显示的组件。我们经常用的是exact、path以及component属性。</strong></p>\n<pre><code>&lt;Route path=&#39;/&#39; component=&#39;&#39; exact&gt;&lt;/Route&gt;\n</code></pre><blockquote>\n<p>exact控制匹配到/路径时不会再继续向下匹配，</p>\n<p>path标识路由的路径</p>\n<p>component表示路径对应显示的组件</p>\n</blockquote>\n<hr>\n<ul>\n<li>Link和NavLink的选择</li>\n</ul>\n<p><strong>两者都是可以控制路由跳转的，不同点是NavLink的api更多，更加满足你的需求。</strong></p>\n<blockquote>\n<p>Link</p>\n</blockquote>\n<p><strong>主要api是to，to可以接受string或者一个object，来控制url。使用方法如下</strong></p>\n<link to=\"/api\">\n\n<blockquote>\n<p>NavLink</p>\n</blockquote>\n<p><strong>它可以为当前选中的路由设置类名、样式以及回调函数等。使用如下</strong></p>\n<pre><code>&lt;Navlink to=&#39;&#39; activeClassName=&#39;actived&#39;&gt;\n</code></pre><p><strong>activeClassName是选中状态的类名，我们可以为其添加样式</strong></p>\n<hr>\n<ul>\n<li>Switch</li>\n</ul>\n<p><strong>Switch常常会用来包裹Route，它里面不能放其他元素，用来只显示一个路由。</strong></p>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"对react-router的封装\"><a href=\"#对react-router的封装\" class=\"headerlink\" title=\"对react-router的封装\"></a>对react-router的封装</h2><p><strong>直接上代码吧</strong></p>\n<blockquote>\n<p>config.js // 该文件是对路由的配置</p>\n</blockquote>\n<pre><code>//组件的引入\nimport Home from &#39;../contentais/home/index&#39;\nimport Login from &quot;../contentais/login/index&quot;\nimport Business from &#39;./../contentais/home/business/index&#39;;\nimport Finance from &#39;./../contentais/home/finance/index&#39;;\nimport Tissue from &#39;./../contentais/home/tissue/index&#39;;\nimport Statistics from &#39;./../contentais/home/statistics/index&#39;;\nimport Order from &#39;./../contentais/home/order/index&#39;;\nimport UserHome from &#39;./../contentais/home/userHome/index&#39;;\nimport Loans from &#39;./../contentais/home/order/loans/index&#39;;\nimport Transfer from &#39;./../contentais/home/order/transfer/index&#39;;\nimport Insurance from &#39;./../contentais/home/order/insurance/index&#39;;\n\nconst RouteConfig = [\n    {\n        //title \n        title: &quot;首页&quot;,\n        //路由地址\n        path: &quot;/Home&quot;,\n        //关键字重定向\n        defaultRedirect: true,\n        //组件\n        component: Home,\n        //二级路由\n        children: [\n            {\n                key: &quot;1&quot;,\n                defaultRedirect: true,\n\n                title: &quot;首页&quot;,\n                path: &quot;/Home/one&quot;,\n                component: UserHome,\n            },\n            {\n                key: &quot;sub1&quot;,\n                title: &quot;订单管理&quot;,\n                path: &quot;/Home/order&quot;,\n                component: Order,\n                //三级路由\n                children: [\n                    {\n                        defaultRedirect: true,\n\n                        key: &quot;2&quot;,\n                        title: &quot;贷款订单&quot;,\n                        path: &quot;/Home/order/loans&quot;,\n                        component: Loans,\n                    },\n                    {\n                        key: &quot;3&quot;,\n                        title: &quot;转单订单&quot;,\n                        path: &quot;/Home/order/transfer&quot;,\n                        component: Transfer,\n                    },\n                    {\n                        key: &quot;4&quot;,\n                        title: &quot;保险订单&quot;,\n                        path: &quot;/Home/order/insurance&quot;,\n                        component: Insurance,\n                    },\n                    //三级路由的重定向   默认显示的页面\n                    {\n                        path: &quot;/Home/order&quot;,\n                        redirect: &quot;/Home/order/loans&quot;\n                    }\n                ]\n            },\n            {\n                key: &quot;5&quot;,\n                title: &quot;财务管理&quot;,\n                path: &quot;/Home/finance&quot;,\n                component: Finance,\n            }\n            ,\n            {\n                key: &quot;6&quot;,\n                title: &quot;组织架构&quot;,\n                path: &quot;/Home/tissue&quot;,\n                component: Tissue,\n            },\n            {\n                key: &quot;7&quot;,\n                title: &quot;数据统计&quot;,\n                path: &quot;/Home/statistics&quot;,\n                component: Statistics,\n            },\n            {\n                key: &quot;8&quot;,\n                title: &quot;商务管理&quot;,\n                path: &quot;/Home/business&quot;,\n                component: Business,\n            },\n            //二级路由的重定向   默认显示的页面\n            {\n                path: &quot;/Home&quot;,\n                redirect: &quot;/Home/one&quot;\n            }\n        ]\n    },\n    {\n        title: &quot;登陆&quot;,\n        path: &quot;/Login&quot;,\n        component: Login,\n    }, {\n        //一级路由的重定向\n        path: &quot;/&quot;,\n        redirect: &quot;/Home&quot;\n    }\n]\nexport default RouteConfig;\n</code></pre><blockquote>\n<p>routerView.js // 路由递归逻辑实现</p>\n</blockquote>\n<pre><code>import { Route, Switch, Redirect } from &quot;react-router-dom&quot;\nimport React, { Component } from &#39;react&#39;;\nclass RouteView extends Component {\n    render() {\n\n        // props接收配置文件\n        // routers 下一级路由的参数\n        // defaultConfig默认传参\n\n        const { routers, defaultConfig } = this.props\n\n        // 这里判断【下一级路由的参数】是否有值 ? 【使用下一级路由的参数】 ： 【默认路由参数】\n\n        let routerDate = routers ? routers : defaultConfig;\n\n        //数据二次处理\n\n        //筛除没有重定向的\n        let routerDatepath = routerDate.filter((item) =&gt; {\n            return !item.redirect\n        })\n\n        //筛选重定向\n        let defualtRouter = routerDate.filter((item) =&gt; {\n            return item.redirect\n        })\n\n        //重定向\n        let defualtRedirect = defualtRouter.map((item, i) =&gt; {\n            return &lt;Redirect key={i} path={item.path} to={item.redirect}&gt;&lt;/Redirect&gt;\n        })\n\n        return (&lt;Switch&gt;\n            {\n                routerDatepath &amp;&amp; routerDatepath.map((item, index) =&gt; {\n                    const Comp = item.component\n                    // 一个大坑 要用render 不然用component会导致页面的回流\n                    return &lt;Route path={item.path} render={\n                        //api 路由相关参数参数及其它\n                        (api) =&gt; {\n                            //动态的title\n                            document.title = item.title || &quot;路由配置&quot;\n                            //把下一级路由参数存入props中\n                            return &lt;Comp routers={item.children} {...api}&gt;&lt;/Comp&gt;\n                        }\n                    } key={&quot;key&quot; + item.key}&gt;&lt;/Route&gt;\n                    //重定向\n                }).concat(defualtRedirect)\n            }\n        &lt;/Switch&gt;)\n    }\n}\nexport default RouteView;\n</code></pre><blockquote>\n<p>app.js // 路由调用的使用方式</p>\n</blockquote>\n<pre><code>import React, { Component } from &#39;react&#39;;\nimport { BrowserRouter as Router } from &quot;react-router-dom&quot;\nimport RouteConfig from &#39;./config.js&#39;; // 引入路由的配置信息\nimport RouteView from &#39;./routeView,js&#39;; // 引入路由的逻辑实现\nclass App extends Component {\n    render() {\n        return &lt;div className=&quot;wrapper&quot;&gt;\n            &lt;Router&gt;\n                //传入默认路由配置文件\n                &lt;RouteView defaultConfig={RouteConfig}&gt;&lt;/RouteView&gt;\n            &lt;/Router&gt;\n        &lt;/div&gt;\n    }\n}\nexport default App;\n</code></pre><blockquote>\n<p>二级路由的调用</p>\n</blockquote>\n<pre><code>import React, { Component } from &#39;react&#39;;\nimport RouteView from &#39;./../../router/RouteView&#39;;\nimport SiderMenu from &#39;./../../components/SiderMenu/index&#39;;\nimport &quot;./index.css&quot;\nclass Home extends Component {\n    render() {\n        //接收路由配置\n        const { routers } = this.props\n        return &lt;div className=&quot;home-wrapper&quot;&gt;\n            &lt;div className=&quot;left&quot;&gt;\n                &lt;div className=&quot;user&quot;&gt;\n                    &lt;div className=&quot;user-img&quot;&gt;\n                    &lt;/div&gt;\n                    &lt;p className=&quot;mt12&quot;&gt;你瞅啥&lt;/p&gt;\n                    &lt;b className=&quot;mt12 radius&quot;&gt;&lt;/b&gt;\n                &lt;/div&gt;\n                //侧边栏的组件\n                &lt;SiderMenu style={{ background:\"#2F3B4C\"}} {...this.props}&gt;&lt;/SiderMenu&gt;\n            &lt;div className=&quot;ri\n            &lt;/div&gt;ght&quot;&gt;\n                //传入RouteView当中进行处理\n                &lt;RouteView routers={routers}&gt;&lt;/RouteView&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    }\n\n}\nexport default Home;\n</code></pre><h2 id=\"‘react-router-dom的api\"><a href=\"#‘react-router-dom的api\" class=\"headerlink\" title=\"‘react-router-dom的api\"></a>‘react-router-dom的api</h2><p><strong>react-router-dom提供了BrowserRouter, Route, Link等api,我们可以通过dom的事件控制路由。例如点击一个按钮进行跳转，大多数情况下我们是这种情况，所以在开发过程中，我们更多是使用React-router-dom。安装很简单npm i react-router-dom –save,安装了淘宝镜像的就用cnpm吧。</strong></p>\n<h3 id=\"常用的路由api\"><a href=\"#常用的路由api\" class=\"headerlink\" title=\"常用的路由api\"></a>常用的路由api</h3><hr>\n<ul>\n<li>HashRouter和BrowserRouter</li>\n</ul>\n<p><strong>它们两个是路由的基本，就像盖房子必须有地基一样，我们需要将它们包裹在最外层，我们只要选择其一就可以了。现在讲它们的不同：</strong></p>\n<blockquote>\n<p>HashRouter</p>\n</blockquote>\n<p><strong>如果你使用过react-router2或3或者vue-router，你经常会发现一个现象就是url中会有个#，例如localhost:3000/#，HashRouter就会出现这种情况，它是通过hash值来对路由进行控制。如果你使用HashRouter，你的路由就会默认有这个#。</strong></p>\n<blockquote>\n<p>BrowserRouter</p>\n</blockquote>\n<p><strong>很多情况下我们则不是这种情况，我们不需要这个#，因为它看起来很怪，这时我们就需要用到BrowserRouter。</strong></p>\n<hr>\n<ul>\n<li>Route</li>\n</ul>\n<p><strong>Route是路由的一个原材料，它是控制路径对应显示的组件。我们经常用的是exact、path以及component属性。</strong></p>\n<pre><code>&lt;Route path=&#39;/&#39; component=&#39;&#39; exact&gt;&lt;/Route&gt;\n</code></pre><blockquote>\n<p>exact控制匹配到/路径时不会再继续向下匹配，</p>\n<p>path标识路由的路径</p>\n<p>component表示路径对应显示的组件</p>\n</blockquote>\n<hr>\n<ul>\n<li>Link和NavLink的选择</li>\n</ul>\n<p><strong>两者都是可以控制路由跳转的，不同点是NavLink的api更多，更加满足你的需求。</strong></p>\n<blockquote>\n<p>Link</p>\n</blockquote>\n<p><strong>主要api是to，to可以接受string或者一个object，来控制url。使用方法如下</strong></p>\n<link to=\"/api\">\n\n<blockquote>\n<p>NavLink</p>\n</blockquote>\n<p><strong>它可以为当前选中的路由设置类名、样式以及回调函数等。使用如下</strong></p>\n<pre><code>&lt;Navlink to=&#39;&#39; activeClassName=&#39;actived&#39;&gt;\n</code></pre><p><strong>activeClassName是选中状态的类名，我们可以为其添加样式</strong></p>\n<hr>\n<ul>\n<li>Switch</li>\n</ul>\n<p><strong>Switch常常会用来包裹Route，它里面不能放其他元素，用来只显示一个路由。</strong></p>\n<hr>\n"},{"title":"react的概述","date":"2019-04-03T11:28:59.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"## react的概述\n\n### 什么是react\n\n> react是一个前端的js库，用于构建用户界面，尤其是单页面应用程序\n\n### react的特点：\n\n> 单向数据流，组件化开发，虚拟dom，jsx，只关注mv*中的m这一层，渲染性能好\n\n### react组件的划分\n\n- 业务组件\n\n**每个功能对应的业务逻辑划分**\n\n- 展示组件\n\n**列表，按钮表单。。。ui组件**\n\n- 容器组件\n\n**包装的盒子，页面组件**\n\n- 木偶组件\n\n**展示组件，功能组件【一些效果】**\n\n> components[业务组件]（展示组件，木偶组件，容器组件）\n> views[页面组件]\n\n### 创建组件方式\n\n> **class组件创建：业务组件，页面组件**\n> \n> **函数式创建：展示组件，包装类型组件**\n\n### render用法\n\n- 在react中有两个render，一个是组件内部的render，一个是reactdom的render\n- 组建的render用来返回一个虚拟dom，在里面不能修改state，只能读取\n- 虚拟dom是通过编译器，将jsx转化为react.createElement()的方法调用，这个方法的返回结果就是一个jsx对象【虚拟dom】\n- 每一个组件都必须有render这个方法\n- reactdom的render只是将虚拟dom渲染到页面中\n\n### react中的state\n\n**state只能定义在construct中的this.state中，函数式的组件没有state**\n\n**修改state只能通过setState方法，只能修改一级属性，不能修改索引数组，不能通过属性修改对象**\n\n**读取使用this.state.xxx，this.props.xxx**\n\n**定义props默认值使用static defaultProps**\n\n### react的生明周期\n\n> **组件初始化阶段**\n\n\timport React, { Component } from 'react';\n\n\tclass Test extends Component {\n\t  constructor(props) {\n\t    super(props);\n\t  }\n\t}\n\t\n> **组件挂载阶段**\n\n\tcomponentWillMount:\n\n**在组件挂载到DOM前调用，且只会被调用一次，在这边调用this.setState不会引起组件重新渲染，也可以把写在这边的内容提前到constructor()中，所以项目中很少用。**\n\n\trender:\n\n**根据组件的props和state（无两者的重传递和重赋值，论值是否有变化，都可以引起组件重新render） ，return 一个React元素（描述组件，即UI），不负责组件实际渲染工作，之后由React自身根据此元素去渲染出页面DOM。render是纯函数（Pure function：函数的返回结果只依赖于它的参数；函数执行过程里面没有副作用），不能在里面执行this.setState，会有改变组件状态的副作用。**\n\n\tcomponentDidMount:\n\n**组件挂载到DOM后调用，且只会被调用一次**\n\n> **组件更新阶段**\n\n**setState引起的state更新或父组件重新render引起的props更新，更新后的state和props相对之前无论是否有变化，都将引起子组件的重新render。**\n\n#### 造成组件更新有两类（三种）情况：\n\n- 父组件重新render\n\n**每当父组件重新render的导致的重传props，子组件将直接跟着重新渲染，可以通过shouldComponentUpdate方法进行优化**\n\n\tclass Child extends Component {\n\t   shouldComponentUpdate(nextProps){ // 应该使用这个方法，否则无论props是否有变化都将会导致组件跟着重新渲染\n\t        if(nextProps.someThings === this.props.someThings){\n\t          return false\n\t        }\n\t    }\n\t    render() {\n\t        return <div>{this.props.someThings}</div>\n\t    }\n\t}\n\n**在componentWillReceiveProps方法中，将props转换成自己的state**\n\n\tclass Child extends Component {\n\t    constructor(props) {\n\t        super(props);\n\t        this.state = {\n\t            someThings: props.someThings\n\t        };\n\t    }\n\t    componentWillReceiveProps(nextProps) { // 父组件重传props时就会调用这个方法\n\t        this.setState({someThings: nextProps.someThings});\n\t    }\n\t    render() {\n\t        return <div>{this.state.someThings}</div>\n\t    }\n\t}\n\n\n\n- . 组件本身调用setState，无论state有没有变化。可通过shouldComponentUpdate方法优化。\n\n----------\n\n\tclass Child extends Component {\n\t   constructor(props) {\n\t        super(props);\n\t        this.state = {\n\t          someThings:1\n\t        }\n\t   }\n\t   shouldComponentUpdate(nextStates){ // 应该使用这个方法，否则无论state是否有变化都将会导致组件重新渲染\n\t        if(nextStates.someThings === this.state.someThings){\n\t          return false\n\t        }\n\t    }\n\t\n\t   handleClick = () => { // 虽然调用了setState ，但state并无变化\n\t        const preSomeThings = this.state.someThings\n\t         this.setState({\n\t            someThings: preSomeThings\n\t         })\n\t   }\n\t\n\t    render() {\n\t        return <div onClick = {this.handleClick}>{this.state.someThings}</div>\n\t    }\n\t}\n\n\n----------\n**执行顺序：**\n----------\n\n\tcomponentWillReceiveProps\n\n\tshouldComponentUpdate\n\n\tcomponentWillUpdate\n\n\trender\n\n\tcomponentDidUpdate\n\n\n----------\n\tcomponentWillReceiveProps(nextProps)\n\n**此方法只调用于props引起的组件更新过程中，参数nextProps是父组件传给当前组件的新props。但父组件render方法的调用不能保证重传给当前组件的props是有变化的，所以在此方法中根据nextProps和this.props来查明重传的props是否改变，以及如果改变了要执行啥，比如根据新的props调用this.setState出发当前组件的重新render**\n\n\tshouldComponentUpdate(nextProps, nextState)\n\n**此方法通过比较nextProps，nextState及当前组件的this.props，this.state，返回true时当前组件将继续执行更新过程，返回false则当前组件更新停止，以此可用来减少组件的不必要渲染，优化组件性能。**\n\n\tcomponentWillUpdate(nextProps, nextState)\n\n**此方法在调用render方法前执行，在这边可执行一些组件更新发生前的工作，一般较少用。**\n\n\trender\n\n**只是重新调用。**\n\n\tcomponentDidUpdate(prevProps, prevState)\n\n**此方法在组件更新后被调用，可以操作组件更新的DOM，prevProps和prevState这两个参数指的是组件更新前的props和state**\n\n> **卸载阶段**\n\n\tcomponentWillUnmount\n\n**此方法在组件被卸载前调用，可以在这里执行一些清理工作，比如清楚组件中使用的定时器，清楚componentDidMount中手动创建的DOM元素等，以避免引起内存泄漏。**\n\n## React v16.4 的生命周期\n\n### 变更缘由\n\n**原来（React v16.0前）的生命周期在React v16推出的Fiber之后就不合适了，因为如果要开启async rendering，在render函数之前的所有函数，都有可能被执行多次。**\n\n**原来（React v16.0前）的生命周期有哪些是在render前执行的呢？**\n\n- componentWillMount\n- componentWillReceiveProps\n- shouldComponentUpdate\n- componentWillUpdate\n\n**如果开发者开了async rendering，而且又在以上这些render前执行的生命周期方法做AJAX请求的话，那AJAX将被无谓地多次调用。。。明显不是我们期望的结果。而且在componentWillMount里发起AJAX，不管多快得到结果也赶不上首次render，而且componentWillMount在服务器端渲染也会被调用到（当然，也许这是预期的结果），这样的IO操作放在componentDidMount里更合适。**\n\n**因此引入两个新增的生命周期函数**\n\n\tgetDerivedStateFromProps\n\n\tgetSnapshotBeforeUpdate\n\n**随着getDerivedStateFromProps的推出，同时deprecate了一组生命周期API，包括：**\n\n- componentWillReceiveProps\n- componentWillMount\n- componentWillUpdate\n\n----------\n\n\n**按照官方说法，以前需要利用被deprecate的所有生命周期函数才能实现的功能，都可以通过getDerivedStateFromProps的帮助来实现。**\n\n**这个getDerivedStateFromProps是一个静态函数，所以函数体内不能访问this，简单说，就是应该一个纯函数，纯函数是一个好东西啊，输出完全由输入决定。**\n\n\tstatic getDerivedStateFromProps(nextProps, prevState) {\n\t  //根据nextProps和prevState计算出预期的状态改变，返回结果会被送给setState\n\t}\n\n**所有被deprecate的生命周期函数，目前还凑合着用，但是只要用了，开发模式下会有红色警告，在下一个大版本（也就是React v17)更新时会彻底废弃。**\n\n----------\n\n**getSnapshotBeforeUpdate，这函数会在render之后执行，而执行之时DOM元素还没有被更新，给了一个机会去获取DOM信息，计算得到一个snapshot，这个snapshot会作为componentDidUpdate的第三个参数传入。**\n\n\tgetSnapshotBeforeUpdate(prevProps, prevState) {\n\t   console.log('#enter getSnapshotBeforeUpdate');\n\t   return 'foo';\n\t}\n\t\n\t componentDidUpdate(prevProps, prevState, snapshot) {\n\t   console.log('#enter componentDidUpdate snapshot = ', snapshot);\n\t }.\n\n\n**getDerivedStateFromProps无论是Mounting还是Updating，也无论是因为什么引起的Updating，全部都会被调用。**\n\n### 总结：\n\n> **用一个静态函数getDerivedStateFromProps来取代被deprecate的几个生命周期函数，就是强制开发者在render之前只做无副作用的操作，而且能做的操作局限在根据props和state决定新的state，而已。**\n\n> **引用**\n\n[程墨Morgan老师的React v16.3之后的组件生命周期函数](https://zhuanlan.zhihu.com/p/38030418)\n","source":"_posts/react-task.md","raw":"---\ntitle: react的概述\ndate: '4/3/2019 7:28:59 PM '\ntag: ['js', 'react']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n## react的概述\n\n### 什么是react\n\n> react是一个前端的js库，用于构建用户界面，尤其是单页面应用程序\n\n### react的特点：\n\n> 单向数据流，组件化开发，虚拟dom，jsx，只关注mv*中的m这一层，渲染性能好\n\n### react组件的划分\n\n- 业务组件\n\n**每个功能对应的业务逻辑划分**\n\n- 展示组件\n\n**列表，按钮表单。。。ui组件**\n\n- 容器组件\n\n**包装的盒子，页面组件**\n\n- 木偶组件\n\n**展示组件，功能组件【一些效果】**\n\n> components[业务组件]（展示组件，木偶组件，容器组件）\n> views[页面组件]\n\n### 创建组件方式\n\n> **class组件创建：业务组件，页面组件**\n> \n> **函数式创建：展示组件，包装类型组件**\n\n### render用法\n\n- 在react中有两个render，一个是组件内部的render，一个是reactdom的render\n- 组建的render用来返回一个虚拟dom，在里面不能修改state，只能读取\n- 虚拟dom是通过编译器，将jsx转化为react.createElement()的方法调用，这个方法的返回结果就是一个jsx对象【虚拟dom】\n- 每一个组件都必须有render这个方法\n- reactdom的render只是将虚拟dom渲染到页面中\n\n### react中的state\n\n**state只能定义在construct中的this.state中，函数式的组件没有state**\n\n**修改state只能通过setState方法，只能修改一级属性，不能修改索引数组，不能通过属性修改对象**\n\n**读取使用this.state.xxx，this.props.xxx**\n\n**定义props默认值使用static defaultProps**\n\n### react的生明周期\n\n> **组件初始化阶段**\n\n\timport React, { Component } from 'react';\n\n\tclass Test extends Component {\n\t  constructor(props) {\n\t    super(props);\n\t  }\n\t}\n\t\n> **组件挂载阶段**\n\n\tcomponentWillMount:\n\n**在组件挂载到DOM前调用，且只会被调用一次，在这边调用this.setState不会引起组件重新渲染，也可以把写在这边的内容提前到constructor()中，所以项目中很少用。**\n\n\trender:\n\n**根据组件的props和state（无两者的重传递和重赋值，论值是否有变化，都可以引起组件重新render） ，return 一个React元素（描述组件，即UI），不负责组件实际渲染工作，之后由React自身根据此元素去渲染出页面DOM。render是纯函数（Pure function：函数的返回结果只依赖于它的参数；函数执行过程里面没有副作用），不能在里面执行this.setState，会有改变组件状态的副作用。**\n\n\tcomponentDidMount:\n\n**组件挂载到DOM后调用，且只会被调用一次**\n\n> **组件更新阶段**\n\n**setState引起的state更新或父组件重新render引起的props更新，更新后的state和props相对之前无论是否有变化，都将引起子组件的重新render。**\n\n#### 造成组件更新有两类（三种）情况：\n\n- 父组件重新render\n\n**每当父组件重新render的导致的重传props，子组件将直接跟着重新渲染，可以通过shouldComponentUpdate方法进行优化**\n\n\tclass Child extends Component {\n\t   shouldComponentUpdate(nextProps){ // 应该使用这个方法，否则无论props是否有变化都将会导致组件跟着重新渲染\n\t        if(nextProps.someThings === this.props.someThings){\n\t          return false\n\t        }\n\t    }\n\t    render() {\n\t        return <div>{this.props.someThings}</div>\n\t    }\n\t}\n\n**在componentWillReceiveProps方法中，将props转换成自己的state**\n\n\tclass Child extends Component {\n\t    constructor(props) {\n\t        super(props);\n\t        this.state = {\n\t            someThings: props.someThings\n\t        };\n\t    }\n\t    componentWillReceiveProps(nextProps) { // 父组件重传props时就会调用这个方法\n\t        this.setState({someThings: nextProps.someThings});\n\t    }\n\t    render() {\n\t        return <div>{this.state.someThings}</div>\n\t    }\n\t}\n\n\n\n- . 组件本身调用setState，无论state有没有变化。可通过shouldComponentUpdate方法优化。\n\n----------\n\n\tclass Child extends Component {\n\t   constructor(props) {\n\t        super(props);\n\t        this.state = {\n\t          someThings:1\n\t        }\n\t   }\n\t   shouldComponentUpdate(nextStates){ // 应该使用这个方法，否则无论state是否有变化都将会导致组件重新渲染\n\t        if(nextStates.someThings === this.state.someThings){\n\t          return false\n\t        }\n\t    }\n\t\n\t   handleClick = () => { // 虽然调用了setState ，但state并无变化\n\t        const preSomeThings = this.state.someThings\n\t         this.setState({\n\t            someThings: preSomeThings\n\t         })\n\t   }\n\t\n\t    render() {\n\t        return <div onClick = {this.handleClick}>{this.state.someThings}</div>\n\t    }\n\t}\n\n\n----------\n**执行顺序：**\n----------\n\n\tcomponentWillReceiveProps\n\n\tshouldComponentUpdate\n\n\tcomponentWillUpdate\n\n\trender\n\n\tcomponentDidUpdate\n\n\n----------\n\tcomponentWillReceiveProps(nextProps)\n\n**此方法只调用于props引起的组件更新过程中，参数nextProps是父组件传给当前组件的新props。但父组件render方法的调用不能保证重传给当前组件的props是有变化的，所以在此方法中根据nextProps和this.props来查明重传的props是否改变，以及如果改变了要执行啥，比如根据新的props调用this.setState出发当前组件的重新render**\n\n\tshouldComponentUpdate(nextProps, nextState)\n\n**此方法通过比较nextProps，nextState及当前组件的this.props，this.state，返回true时当前组件将继续执行更新过程，返回false则当前组件更新停止，以此可用来减少组件的不必要渲染，优化组件性能。**\n\n\tcomponentWillUpdate(nextProps, nextState)\n\n**此方法在调用render方法前执行，在这边可执行一些组件更新发生前的工作，一般较少用。**\n\n\trender\n\n**只是重新调用。**\n\n\tcomponentDidUpdate(prevProps, prevState)\n\n**此方法在组件更新后被调用，可以操作组件更新的DOM，prevProps和prevState这两个参数指的是组件更新前的props和state**\n\n> **卸载阶段**\n\n\tcomponentWillUnmount\n\n**此方法在组件被卸载前调用，可以在这里执行一些清理工作，比如清楚组件中使用的定时器，清楚componentDidMount中手动创建的DOM元素等，以避免引起内存泄漏。**\n\n## React v16.4 的生命周期\n\n### 变更缘由\n\n**原来（React v16.0前）的生命周期在React v16推出的Fiber之后就不合适了，因为如果要开启async rendering，在render函数之前的所有函数，都有可能被执行多次。**\n\n**原来（React v16.0前）的生命周期有哪些是在render前执行的呢？**\n\n- componentWillMount\n- componentWillReceiveProps\n- shouldComponentUpdate\n- componentWillUpdate\n\n**如果开发者开了async rendering，而且又在以上这些render前执行的生命周期方法做AJAX请求的话，那AJAX将被无谓地多次调用。。。明显不是我们期望的结果。而且在componentWillMount里发起AJAX，不管多快得到结果也赶不上首次render，而且componentWillMount在服务器端渲染也会被调用到（当然，也许这是预期的结果），这样的IO操作放在componentDidMount里更合适。**\n\n**因此引入两个新增的生命周期函数**\n\n\tgetDerivedStateFromProps\n\n\tgetSnapshotBeforeUpdate\n\n**随着getDerivedStateFromProps的推出，同时deprecate了一组生命周期API，包括：**\n\n- componentWillReceiveProps\n- componentWillMount\n- componentWillUpdate\n\n----------\n\n\n**按照官方说法，以前需要利用被deprecate的所有生命周期函数才能实现的功能，都可以通过getDerivedStateFromProps的帮助来实现。**\n\n**这个getDerivedStateFromProps是一个静态函数，所以函数体内不能访问this，简单说，就是应该一个纯函数，纯函数是一个好东西啊，输出完全由输入决定。**\n\n\tstatic getDerivedStateFromProps(nextProps, prevState) {\n\t  //根据nextProps和prevState计算出预期的状态改变，返回结果会被送给setState\n\t}\n\n**所有被deprecate的生命周期函数，目前还凑合着用，但是只要用了，开发模式下会有红色警告，在下一个大版本（也就是React v17)更新时会彻底废弃。**\n\n----------\n\n**getSnapshotBeforeUpdate，这函数会在render之后执行，而执行之时DOM元素还没有被更新，给了一个机会去获取DOM信息，计算得到一个snapshot，这个snapshot会作为componentDidUpdate的第三个参数传入。**\n\n\tgetSnapshotBeforeUpdate(prevProps, prevState) {\n\t   console.log('#enter getSnapshotBeforeUpdate');\n\t   return 'foo';\n\t}\n\t\n\t componentDidUpdate(prevProps, prevState, snapshot) {\n\t   console.log('#enter componentDidUpdate snapshot = ', snapshot);\n\t }.\n\n\n**getDerivedStateFromProps无论是Mounting还是Updating，也无论是因为什么引起的Updating，全部都会被调用。**\n\n### 总结：\n\n> **用一个静态函数getDerivedStateFromProps来取代被deprecate的几个生命周期函数，就是强制开发者在render之前只做无副作用的操作，而且能做的操作局限在根据props和state决定新的state，而已。**\n\n> **引用**\n\n[程墨Morgan老师的React v16.3之后的组件生命周期函数](https://zhuanlan.zhihu.com/p/38030418)\n","slug":"react-task","published":1,"updated":"2019-04-03T01:15:15.195Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iamdt006rn4wdgm6emj6l","content":"<h2 id=\"react的概述\"><a href=\"#react的概述\" class=\"headerlink\" title=\"react的概述\"></a>react的概述</h2><h3 id=\"什么是react\"><a href=\"#什么是react\" class=\"headerlink\" title=\"什么是react\"></a>什么是react</h3><blockquote>\n<p>react是一个前端的js库，用于构建用户界面，尤其是单页面应用程序</p>\n</blockquote>\n<h3 id=\"react的特点：\"><a href=\"#react的特点：\" class=\"headerlink\" title=\"react的特点：\"></a>react的特点：</h3><blockquote>\n<p>单向数据流，组件化开发，虚拟dom，jsx，只关注mv*中的m这一层，渲染性能好</p>\n</blockquote>\n<h3 id=\"react组件的划分\"><a href=\"#react组件的划分\" class=\"headerlink\" title=\"react组件的划分\"></a>react组件的划分</h3><ul>\n<li>业务组件</li>\n</ul>\n<p><strong>每个功能对应的业务逻辑划分</strong></p>\n<ul>\n<li>展示组件</li>\n</ul>\n<p><strong>列表，按钮表单。。。ui组件</strong></p>\n<ul>\n<li>容器组件</li>\n</ul>\n<p><strong>包装的盒子，页面组件</strong></p>\n<ul>\n<li>木偶组件</li>\n</ul>\n<p><strong>展示组件，功能组件【一些效果】</strong></p>\n<blockquote>\n<p>components[业务组件]（展示组件，木偶组件，容器组件）<br>views[页面组件]</p>\n</blockquote>\n<h3 id=\"创建组件方式\"><a href=\"#创建组件方式\" class=\"headerlink\" title=\"创建组件方式\"></a>创建组件方式</h3><blockquote>\n<p><strong>class组件创建：业务组件，页面组件</strong></p>\n<p><strong>函数式创建：展示组件，包装类型组件</strong></p>\n</blockquote>\n<h3 id=\"render用法\"><a href=\"#render用法\" class=\"headerlink\" title=\"render用法\"></a>render用法</h3><ul>\n<li>在react中有两个render，一个是组件内部的render，一个是reactdom的render</li>\n<li>组建的render用来返回一个虚拟dom，在里面不能修改state，只能读取</li>\n<li>虚拟dom是通过编译器，将jsx转化为react.createElement()的方法调用，这个方法的返回结果就是一个jsx对象【虚拟dom】</li>\n<li>每一个组件都必须有render这个方法</li>\n<li>reactdom的render只是将虚拟dom渲染到页面中</li>\n</ul>\n<h3 id=\"react中的state\"><a href=\"#react中的state\" class=\"headerlink\" title=\"react中的state\"></a>react中的state</h3><p><strong>state只能定义在construct中的this.state中，函数式的组件没有state</strong></p>\n<p><strong>修改state只能通过setState方法，只能修改一级属性，不能修改索引数组，不能通过属性修改对象</strong></p>\n<p><strong>读取使用this.state.xxx，this.props.xxx</strong></p>\n<p><strong>定义props默认值使用static defaultProps</strong></p>\n<h3 id=\"react的生明周期\"><a href=\"#react的生明周期\" class=\"headerlink\" title=\"react的生明周期\"></a>react的生明周期</h3><blockquote>\n<p><strong>组件初始化阶段</strong></p>\n</blockquote>\n<pre><code>import React, { Component } from &#39;react&#39;;\n\nclass Test extends Component {\n  constructor(props) {\n    super(props);\n  }\n}\n</code></pre><blockquote>\n<p><strong>组件挂载阶段</strong></p>\n</blockquote>\n<pre><code>componentWillMount:\n</code></pre><p><strong>在组件挂载到DOM前调用，且只会被调用一次，在这边调用this.setState不会引起组件重新渲染，也可以把写在这边的内容提前到constructor()中，所以项目中很少用。</strong></p>\n<pre><code>render:\n</code></pre><p><strong>根据组件的props和state（无两者的重传递和重赋值，论值是否有变化，都可以引起组件重新render） ，return 一个React元素（描述组件，即UI），不负责组件实际渲染工作，之后由React自身根据此元素去渲染出页面DOM。render是纯函数（Pure function：函数的返回结果只依赖于它的参数；函数执行过程里面没有副作用），不能在里面执行this.setState，会有改变组件状态的副作用。</strong></p>\n<pre><code>componentDidMount:\n</code></pre><p><strong>组件挂载到DOM后调用，且只会被调用一次</strong></p>\n<blockquote>\n<p><strong>组件更新阶段</strong></p>\n</blockquote>\n<p><strong>setState引起的state更新或父组件重新render引起的props更新，更新后的state和props相对之前无论是否有变化，都将引起子组件的重新render。</strong></p>\n<h4 id=\"造成组件更新有两类（三种）情况：\"><a href=\"#造成组件更新有两类（三种）情况：\" class=\"headerlink\" title=\"造成组件更新有两类（三种）情况：\"></a>造成组件更新有两类（三种）情况：</h4><ul>\n<li>父组件重新render</li>\n</ul>\n<p><strong>每当父组件重新render的导致的重传props，子组件将直接跟着重新渲染，可以通过shouldComponentUpdate方法进行优化</strong></p>\n<pre><code>class Child extends Component {\n   shouldComponentUpdate(nextProps){ // 应该使用这个方法，否则无论props是否有变化都将会导致组件跟着重新渲染\n        if(nextProps.someThings === this.props.someThings){\n          return false\n        }\n    }\n    render() {\n        return &lt;div&gt;{this.props.someThings}&lt;/div&gt;\n    }\n}\n</code></pre><p><strong>在componentWillReceiveProps方法中，将props转换成自己的state</strong></p>\n<pre><code>class Child extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            someThings: props.someThings\n        };\n    }\n    componentWillReceiveProps(nextProps) { // 父组件重传props时就会调用这个方法\n        this.setState({someThings: nextProps.someThings});\n    }\n    render() {\n        return &lt;div&gt;{this.state.someThings}&lt;/div&gt;\n    }\n}\n</code></pre><ul>\n<li>. 组件本身调用setState，无论state有没有变化。可通过shouldComponentUpdate方法优化。</li>\n</ul>\n<hr>\n<pre><code>class Child extends Component {\n   constructor(props) {\n        super(props);\n        this.state = {\n          someThings:1\n        }\n   }\n   shouldComponentUpdate(nextStates){ // 应该使用这个方法，否则无论state是否有变化都将会导致组件重新渲染\n        if(nextStates.someThings === this.state.someThings){\n          return false\n        }\n    }\n\n   handleClick = () =&gt; { // 虽然调用了setState ，但state并无变化\n        const preSomeThings = this.state.someThings\n         this.setState({\n            someThings: preSomeThings\n         })\n   }\n\n    render() {\n        return &lt;div onClick = {this.handleClick}&gt;{this.state.someThings}&lt;/div&gt;\n    }\n}\n</code></pre><hr>\n<h2 id=\"执行顺序：\"><a href=\"#执行顺序：\" class=\"headerlink\" title=\"执行顺序：\"></a><strong>执行顺序：</strong></h2><pre><code>componentWillReceiveProps\n\nshouldComponentUpdate\n\ncomponentWillUpdate\n\nrender\n\ncomponentDidUpdate\n</code></pre><hr>\n<pre><code>componentWillReceiveProps(nextProps)\n</code></pre><p><strong>此方法只调用于props引起的组件更新过程中，参数nextProps是父组件传给当前组件的新props。但父组件render方法的调用不能保证重传给当前组件的props是有变化的，所以在此方法中根据nextProps和this.props来查明重传的props是否改变，以及如果改变了要执行啥，比如根据新的props调用this.setState出发当前组件的重新render</strong></p>\n<pre><code>shouldComponentUpdate(nextProps, nextState)\n</code></pre><p><strong>此方法通过比较nextProps，nextState及当前组件的this.props，this.state，返回true时当前组件将继续执行更新过程，返回false则当前组件更新停止，以此可用来减少组件的不必要渲染，优化组件性能。</strong></p>\n<pre><code>componentWillUpdate(nextProps, nextState)\n</code></pre><p><strong>此方法在调用render方法前执行，在这边可执行一些组件更新发生前的工作，一般较少用。</strong></p>\n<pre><code>render\n</code></pre><p><strong>只是重新调用。</strong></p>\n<pre><code>componentDidUpdate(prevProps, prevState)\n</code></pre><p><strong>此方法在组件更新后被调用，可以操作组件更新的DOM，prevProps和prevState这两个参数指的是组件更新前的props和state</strong></p>\n<blockquote>\n<p><strong>卸载阶段</strong></p>\n</blockquote>\n<pre><code>componentWillUnmount\n</code></pre><p><strong>此方法在组件被卸载前调用，可以在这里执行一些清理工作，比如清楚组件中使用的定时器，清楚componentDidMount中手动创建的DOM元素等，以避免引起内存泄漏。</strong></p>\n<h2 id=\"React-v16-4-的生命周期\"><a href=\"#React-v16-4-的生命周期\" class=\"headerlink\" title=\"React v16.4 的生命周期\"></a>React v16.4 的生命周期</h2><h3 id=\"变更缘由\"><a href=\"#变更缘由\" class=\"headerlink\" title=\"变更缘由\"></a>变更缘由</h3><p><strong>原来（React v16.0前）的生命周期在React v16推出的Fiber之后就不合适了，因为如果要开启async rendering，在render函数之前的所有函数，都有可能被执行多次。</strong></p>\n<p><strong>原来（React v16.0前）的生命周期有哪些是在render前执行的呢？</strong></p>\n<ul>\n<li>componentWillMount</li>\n<li>componentWillReceiveProps</li>\n<li>shouldComponentUpdate</li>\n<li>componentWillUpdate</li>\n</ul>\n<p><strong>如果开发者开了async rendering，而且又在以上这些render前执行的生命周期方法做AJAX请求的话，那AJAX将被无谓地多次调用。。。明显不是我们期望的结果。而且在componentWillMount里发起AJAX，不管多快得到结果也赶不上首次render，而且componentWillMount在服务器端渲染也会被调用到（当然，也许这是预期的结果），这样的IO操作放在componentDidMount里更合适。</strong></p>\n<p><strong>因此引入两个新增的生命周期函数</strong></p>\n<pre><code>getDerivedStateFromProps\n\ngetSnapshotBeforeUpdate\n</code></pre><p><strong>随着getDerivedStateFromProps的推出，同时deprecate了一组生命周期API，包括：</strong></p>\n<ul>\n<li>componentWillReceiveProps</li>\n<li>componentWillMount</li>\n<li>componentWillUpdate</li>\n</ul>\n<hr>\n<p><strong>按照官方说法，以前需要利用被deprecate的所有生命周期函数才能实现的功能，都可以通过getDerivedStateFromProps的帮助来实现。</strong></p>\n<p><strong>这个getDerivedStateFromProps是一个静态函数，所以函数体内不能访问this，简单说，就是应该一个纯函数，纯函数是一个好东西啊，输出完全由输入决定。</strong></p>\n<pre><code>static getDerivedStateFromProps(nextProps, prevState) {\n  //根据nextProps和prevState计算出预期的状态改变，返回结果会被送给setState\n}\n</code></pre><p><strong>所有被deprecate的生命周期函数，目前还凑合着用，但是只要用了，开发模式下会有红色警告，在下一个大版本（也就是React v17)更新时会彻底废弃。</strong></p>\n<hr>\n<p><strong>getSnapshotBeforeUpdate，这函数会在render之后执行，而执行之时DOM元素还没有被更新，给了一个机会去获取DOM信息，计算得到一个snapshot，这个snapshot会作为componentDidUpdate的第三个参数传入。</strong></p>\n<pre><code>getSnapshotBeforeUpdate(prevProps, prevState) {\n   console.log(&#39;#enter getSnapshotBeforeUpdate&#39;);\n   return &#39;foo&#39;;\n}\n\n componentDidUpdate(prevProps, prevState, snapshot) {\n   console.log(&#39;#enter componentDidUpdate snapshot = &#39;, snapshot);\n }.\n</code></pre><p><strong>getDerivedStateFromProps无论是Mounting还是Updating，也无论是因为什么引起的Updating，全部都会被调用。</strong></p>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><blockquote>\n<p><strong>用一个静态函数getDerivedStateFromProps来取代被deprecate的几个生命周期函数，就是强制开发者在render之前只做无副作用的操作，而且能做的操作局限在根据props和state决定新的state，而已。</strong></p>\n</blockquote>\n<blockquote>\n<p><strong>引用</strong></p>\n</blockquote>\n<p><a href=\"https://zhuanlan.zhihu.com/p/38030418\" target=\"_blank\" rel=\"noopener\">程墨Morgan老师的React v16.3之后的组件生命周期函数</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"react的概述\"><a href=\"#react的概述\" class=\"headerlink\" title=\"react的概述\"></a>react的概述</h2><h3 id=\"什么是react\"><a href=\"#什么是react\" class=\"headerlink\" title=\"什么是react\"></a>什么是react</h3><blockquote>\n<p>react是一个前端的js库，用于构建用户界面，尤其是单页面应用程序</p>\n</blockquote>\n<h3 id=\"react的特点：\"><a href=\"#react的特点：\" class=\"headerlink\" title=\"react的特点：\"></a>react的特点：</h3><blockquote>\n<p>单向数据流，组件化开发，虚拟dom，jsx，只关注mv*中的m这一层，渲染性能好</p>\n</blockquote>\n<h3 id=\"react组件的划分\"><a href=\"#react组件的划分\" class=\"headerlink\" title=\"react组件的划分\"></a>react组件的划分</h3><ul>\n<li>业务组件</li>\n</ul>\n<p><strong>每个功能对应的业务逻辑划分</strong></p>\n<ul>\n<li>展示组件</li>\n</ul>\n<p><strong>列表，按钮表单。。。ui组件</strong></p>\n<ul>\n<li>容器组件</li>\n</ul>\n<p><strong>包装的盒子，页面组件</strong></p>\n<ul>\n<li>木偶组件</li>\n</ul>\n<p><strong>展示组件，功能组件【一些效果】</strong></p>\n<blockquote>\n<p>components[业务组件]（展示组件，木偶组件，容器组件）<br>views[页面组件]</p>\n</blockquote>\n<h3 id=\"创建组件方式\"><a href=\"#创建组件方式\" class=\"headerlink\" title=\"创建组件方式\"></a>创建组件方式</h3><blockquote>\n<p><strong>class组件创建：业务组件，页面组件</strong></p>\n<p><strong>函数式创建：展示组件，包装类型组件</strong></p>\n</blockquote>\n<h3 id=\"render用法\"><a href=\"#render用法\" class=\"headerlink\" title=\"render用法\"></a>render用法</h3><ul>\n<li>在react中有两个render，一个是组件内部的render，一个是reactdom的render</li>\n<li>组建的render用来返回一个虚拟dom，在里面不能修改state，只能读取</li>\n<li>虚拟dom是通过编译器，将jsx转化为react.createElement()的方法调用，这个方法的返回结果就是一个jsx对象【虚拟dom】</li>\n<li>每一个组件都必须有render这个方法</li>\n<li>reactdom的render只是将虚拟dom渲染到页面中</li>\n</ul>\n<h3 id=\"react中的state\"><a href=\"#react中的state\" class=\"headerlink\" title=\"react中的state\"></a>react中的state</h3><p><strong>state只能定义在construct中的this.state中，函数式的组件没有state</strong></p>\n<p><strong>修改state只能通过setState方法，只能修改一级属性，不能修改索引数组，不能通过属性修改对象</strong></p>\n<p><strong>读取使用this.state.xxx，this.props.xxx</strong></p>\n<p><strong>定义props默认值使用static defaultProps</strong></p>\n<h3 id=\"react的生明周期\"><a href=\"#react的生明周期\" class=\"headerlink\" title=\"react的生明周期\"></a>react的生明周期</h3><blockquote>\n<p><strong>组件初始化阶段</strong></p>\n</blockquote>\n<pre><code>import React, { Component } from &#39;react&#39;;\n\nclass Test extends Component {\n  constructor(props) {\n    super(props);\n  }\n}\n</code></pre><blockquote>\n<p><strong>组件挂载阶段</strong></p>\n</blockquote>\n<pre><code>componentWillMount:\n</code></pre><p><strong>在组件挂载到DOM前调用，且只会被调用一次，在这边调用this.setState不会引起组件重新渲染，也可以把写在这边的内容提前到constructor()中，所以项目中很少用。</strong></p>\n<pre><code>render:\n</code></pre><p><strong>根据组件的props和state（无两者的重传递和重赋值，论值是否有变化，都可以引起组件重新render） ，return 一个React元素（描述组件，即UI），不负责组件实际渲染工作，之后由React自身根据此元素去渲染出页面DOM。render是纯函数（Pure function：函数的返回结果只依赖于它的参数；函数执行过程里面没有副作用），不能在里面执行this.setState，会有改变组件状态的副作用。</strong></p>\n<pre><code>componentDidMount:\n</code></pre><p><strong>组件挂载到DOM后调用，且只会被调用一次</strong></p>\n<blockquote>\n<p><strong>组件更新阶段</strong></p>\n</blockquote>\n<p><strong>setState引起的state更新或父组件重新render引起的props更新，更新后的state和props相对之前无论是否有变化，都将引起子组件的重新render。</strong></p>\n<h4 id=\"造成组件更新有两类（三种）情况：\"><a href=\"#造成组件更新有两类（三种）情况：\" class=\"headerlink\" title=\"造成组件更新有两类（三种）情况：\"></a>造成组件更新有两类（三种）情况：</h4><ul>\n<li>父组件重新render</li>\n</ul>\n<p><strong>每当父组件重新render的导致的重传props，子组件将直接跟着重新渲染，可以通过shouldComponentUpdate方法进行优化</strong></p>\n<pre><code>class Child extends Component {\n   shouldComponentUpdate(nextProps){ // 应该使用这个方法，否则无论props是否有变化都将会导致组件跟着重新渲染\n        if(nextProps.someThings === this.props.someThings){\n          return false\n        }\n    }\n    render() {\n        return &lt;div&gt;{this.props.someThings}&lt;/div&gt;\n    }\n}\n</code></pre><p><strong>在componentWillReceiveProps方法中，将props转换成自己的state</strong></p>\n<pre><code>class Child extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            someThings: props.someThings\n        };\n    }\n    componentWillReceiveProps(nextProps) { // 父组件重传props时就会调用这个方法\n        this.setState({someThings: nextProps.someThings});\n    }\n    render() {\n        return &lt;div&gt;{this.state.someThings}&lt;/div&gt;\n    }\n}\n</code></pre><ul>\n<li>. 组件本身调用setState，无论state有没有变化。可通过shouldComponentUpdate方法优化。</li>\n</ul>\n<hr>\n<pre><code>class Child extends Component {\n   constructor(props) {\n        super(props);\n        this.state = {\n          someThings:1\n        }\n   }\n   shouldComponentUpdate(nextStates){ // 应该使用这个方法，否则无论state是否有变化都将会导致组件重新渲染\n        if(nextStates.someThings === this.state.someThings){\n          return false\n        }\n    }\n\n   handleClick = () =&gt; { // 虽然调用了setState ，但state并无变化\n        const preSomeThings = this.state.someThings\n         this.setState({\n            someThings: preSomeThings\n         })\n   }\n\n    render() {\n        return &lt;div onClick = {this.handleClick}&gt;{this.state.someThings}&lt;/div&gt;\n    }\n}\n</code></pre><hr>\n<h2 id=\"执行顺序：\"><a href=\"#执行顺序：\" class=\"headerlink\" title=\"执行顺序：\"></a><strong>执行顺序：</strong></h2><pre><code>componentWillReceiveProps\n\nshouldComponentUpdate\n\ncomponentWillUpdate\n\nrender\n\ncomponentDidUpdate\n</code></pre><hr>\n<pre><code>componentWillReceiveProps(nextProps)\n</code></pre><p><strong>此方法只调用于props引起的组件更新过程中，参数nextProps是父组件传给当前组件的新props。但父组件render方法的调用不能保证重传给当前组件的props是有变化的，所以在此方法中根据nextProps和this.props来查明重传的props是否改变，以及如果改变了要执行啥，比如根据新的props调用this.setState出发当前组件的重新render</strong></p>\n<pre><code>shouldComponentUpdate(nextProps, nextState)\n</code></pre><p><strong>此方法通过比较nextProps，nextState及当前组件的this.props，this.state，返回true时当前组件将继续执行更新过程，返回false则当前组件更新停止，以此可用来减少组件的不必要渲染，优化组件性能。</strong></p>\n<pre><code>componentWillUpdate(nextProps, nextState)\n</code></pre><p><strong>此方法在调用render方法前执行，在这边可执行一些组件更新发生前的工作，一般较少用。</strong></p>\n<pre><code>render\n</code></pre><p><strong>只是重新调用。</strong></p>\n<pre><code>componentDidUpdate(prevProps, prevState)\n</code></pre><p><strong>此方法在组件更新后被调用，可以操作组件更新的DOM，prevProps和prevState这两个参数指的是组件更新前的props和state</strong></p>\n<blockquote>\n<p><strong>卸载阶段</strong></p>\n</blockquote>\n<pre><code>componentWillUnmount\n</code></pre><p><strong>此方法在组件被卸载前调用，可以在这里执行一些清理工作，比如清楚组件中使用的定时器，清楚componentDidMount中手动创建的DOM元素等，以避免引起内存泄漏。</strong></p>\n<h2 id=\"React-v16-4-的生命周期\"><a href=\"#React-v16-4-的生命周期\" class=\"headerlink\" title=\"React v16.4 的生命周期\"></a>React v16.4 的生命周期</h2><h3 id=\"变更缘由\"><a href=\"#变更缘由\" class=\"headerlink\" title=\"变更缘由\"></a>变更缘由</h3><p><strong>原来（React v16.0前）的生命周期在React v16推出的Fiber之后就不合适了，因为如果要开启async rendering，在render函数之前的所有函数，都有可能被执行多次。</strong></p>\n<p><strong>原来（React v16.0前）的生命周期有哪些是在render前执行的呢？</strong></p>\n<ul>\n<li>componentWillMount</li>\n<li>componentWillReceiveProps</li>\n<li>shouldComponentUpdate</li>\n<li>componentWillUpdate</li>\n</ul>\n<p><strong>如果开发者开了async rendering，而且又在以上这些render前执行的生命周期方法做AJAX请求的话，那AJAX将被无谓地多次调用。。。明显不是我们期望的结果。而且在componentWillMount里发起AJAX，不管多快得到结果也赶不上首次render，而且componentWillMount在服务器端渲染也会被调用到（当然，也许这是预期的结果），这样的IO操作放在componentDidMount里更合适。</strong></p>\n<p><strong>因此引入两个新增的生命周期函数</strong></p>\n<pre><code>getDerivedStateFromProps\n\ngetSnapshotBeforeUpdate\n</code></pre><p><strong>随着getDerivedStateFromProps的推出，同时deprecate了一组生命周期API，包括：</strong></p>\n<ul>\n<li>componentWillReceiveProps</li>\n<li>componentWillMount</li>\n<li>componentWillUpdate</li>\n</ul>\n<hr>\n<p><strong>按照官方说法，以前需要利用被deprecate的所有生命周期函数才能实现的功能，都可以通过getDerivedStateFromProps的帮助来实现。</strong></p>\n<p><strong>这个getDerivedStateFromProps是一个静态函数，所以函数体内不能访问this，简单说，就是应该一个纯函数，纯函数是一个好东西啊，输出完全由输入决定。</strong></p>\n<pre><code>static getDerivedStateFromProps(nextProps, prevState) {\n  //根据nextProps和prevState计算出预期的状态改变，返回结果会被送给setState\n}\n</code></pre><p><strong>所有被deprecate的生命周期函数，目前还凑合着用，但是只要用了，开发模式下会有红色警告，在下一个大版本（也就是React v17)更新时会彻底废弃。</strong></p>\n<hr>\n<p><strong>getSnapshotBeforeUpdate，这函数会在render之后执行，而执行之时DOM元素还没有被更新，给了一个机会去获取DOM信息，计算得到一个snapshot，这个snapshot会作为componentDidUpdate的第三个参数传入。</strong></p>\n<pre><code>getSnapshotBeforeUpdate(prevProps, prevState) {\n   console.log(&#39;#enter getSnapshotBeforeUpdate&#39;);\n   return &#39;foo&#39;;\n}\n\n componentDidUpdate(prevProps, prevState, snapshot) {\n   console.log(&#39;#enter componentDidUpdate snapshot = &#39;, snapshot);\n }.\n</code></pre><p><strong>getDerivedStateFromProps无论是Mounting还是Updating，也无论是因为什么引起的Updating，全部都会被调用。</strong></p>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><blockquote>\n<p><strong>用一个静态函数getDerivedStateFromProps来取代被deprecate的几个生命周期函数，就是强制开发者在render之前只做无副作用的操作，而且能做的操作局限在根据props和state决定新的state，而已。</strong></p>\n</blockquote>\n<blockquote>\n<p><strong>引用</strong></p>\n</blockquote>\n<p><a href=\"https://zhuanlan.zhihu.com/p/38030418\" target=\"_blank\" rel=\"noopener\">程墨Morgan老师的React v16.3之后的组件生命周期函数</a></p>\n"},{"title":"react-redux","date":"2019-04-05T12:03:01.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"## react-redux\n\n### 为什么需要redux\n\n**学过react的都知道，react用state和props控制组件的渲染情况，而对于JavaScript单页面日趋复杂的今天，JavaScript需要管理越来越多的state，而这些state包括着各种乱七八糟途径来的数据。甚至有的应用的state会关系到另一个组件的状态。所以为了方便对这些state的管理以及对state变化的可控性。这个时候Redux这个东西就出来了，它可以让state的变化变得可预测。**\n\n### Redux的基本概念\n\n**什么是redux？这里非权威的解释：就是一个应用的state管理库，甚至可以说是前端数据库。更包括的是管理数据。**\n\n#### state\n\n**state是整个应用的数据，本质上是一个普通对象。**\n\n#### action\n\n**数据state已经有了，那么我们是如何实现管理这些state中的数据的呢？那就是action，什么是action？按字面意思解释就是动作，也可以理解成，一个可能！改变state的动作包装。就这么简单。。。。**\n\n**比如有一个counter数量加减应用，我们就有两个action，一个decrement，一个increment。 所以这里的action creator写成如下：**\n\n\texport function decrement() {\n\t    return{\n\t        type:DECREMENT_COUNTER\n\t    }\n\t}\n\t\n\texport function increment(){\n\t    return{\n\t        type:INCREMENT_COUNTER\n\t    }\n\t}\n\n\n**那么，当action创建完成了之后呢，我们怎么触发这些action呢，这时我们是要利用dispatch，比如我们执行count增减减少动作。**\n\n\texport function incrementIfOdd(){\n\t    return(dispatch,getState)=>{\n\t        const {counter} = getState();\n\t        if(counter%2==0) {\n\t            return;\n\t        }\n\t        dispatch(increment());\n\t    }\n\t}\n\t\n\texport function incrementAsync() {\n\t    return dispatch => {\n\t        setTimeout(() => {\n\t            dispatch(increment());\n\t        }, 1000);\n\t    };\n\t}\n\n**为了减少样板代码，我们使用单独的模块或文件来定义 action type 常量**\n\n\texport const INCREMENT_COUNTER = 'INCREMENT_COUNTER';\n\texport const DECREMENT_COUNTER = 'DECREMENT_COUNTER';\n\n**这么做不是必须的，在大型应用中把它们显式地定义成常量还是利大于弊的。**\n\n#### reducer\n\n**既然这个可能改变state的动作已经包装好了，那么我们怎么去判断并且对state做相应的改变呢？对，这就是reducer干的事情了。**\n\n**reducer是state最终格式的确定。它是一个纯函数，也就是说，只要传入参数相同，返回计算得到的下一个 state 就一定相同。没有特殊情况、没有副作用，没有 API 请求、没有变量修改，单纯执行计算。**\n\n**reducer对传入的action进行判断，然后返回一个通过判断后的state，这就是reducer的全部职责。如我们的counter应用：**\n\n\timport {INCREMENT_COUNTER,DECREMENT_COUNTER} from '../actions';\n\n\texport default function counter(state = 0, action) {\n\t    switch (action.type){\n\t        case INCREMENT_COUNTER:\n\t            return state+1;\n\t        case DECREMENT_COUNTER:\n\t            return state-1;\n\t        default:\n\t            return state;\n\t    }\n\t}\n\n**对于一个比较大一点的应用来说，我们是需要将reducer拆分的，最后通过redux提供的combineReducers方法组合到一起。 如此项目上的：**\n\n\tconst rootReducer = combineReducers({\n\t    counter\n\t});\n\texport default rootReducer;\n\n**每个reducer只负责管理全局state中它负责的一部分。每个reducer的state参数都不同，分别对应它管理的那部分state数据。combineReducers()所做的只是生成一个函数，这个函数来调用你的一系列reducer，每个reducer根据它们的key来筛选出state中的一部分数据并处理， 然后这个生成的函数再将所有reducer的结果合并成一个大的对象。**\n\n#### store\n\n**store是对之前说到一个联系和管理。具有如下职责**\n\n\n> - 维持应用的state；\n> - 提供getState()方法获取 state\n> - 提供dispatch(action)方法更新 state；\n> - 通过subscribe(listener)注册监听器;\n> - 通过subscribe(listener)返回的函数注销监听器。\n\n**强调一下 Redux 应用只有一个单一的store。当需要拆分数据处理逻辑时，你应该使用reducer组合,而不是创建多个store。store的创建通过redux的createStore方法创建，这个方法还需要传入reducer，很容易理解：毕竟我需要dispatch一个action来改变state嘛。 应用一般会有一个初始化的state，所以可选为第二个参数，这个参数通常是有服务端提供的，传说中的Universal渲染。 第三个参数一般是需要使用的中间件，通过applyMiddleware传入。**\n\n### redux-thunk\n\n**一个比较流行的redux的action中间件，它可以让actionCreator暂时不返回action对象，而是返回一个函数，函数传递两个参数(dispatch, getState)，在函数体内进行业务逻辑的封装，比如异步操作，我们至少需要触发两个action，这时候我们可以通过redux-thunk将这两个action封装在一起，如下：**\n\n> store.js\n\n\timport { createStore, applyMiddleware } from \"redux\";\n\timport RankReducer from \"./reducers/reducer\"\n\timport thunk from \"redux-thunk\";\n\tconst store = createStore(RankReducer, applyMiddleware(thunk));\n\texport default store\n\n> reducer.jsx\n\n\tconst defaultState = {\n\t    rankList: []\n\t}\n\tconst RankReducer = (state = defaultState, action) => {\n\t    const { type, layload } = action;\n\t    switch (type) {\n\t        case \"UPDATE\":\n\t            return { ...state, rankList: layload }\n\t        default:\n\t            return state;\n\t    }\n\t}\n\texport default RankReducer;\n\n> rank.js\n\n\timport axios from \"axios\"\n\n\texport function updata(layload){\n\t    return function(dispatch){\n\t        return axios.get(\"/getrankList\").then(result=>{\n\t            return dispatch({\n\t                type:\"UPDATA\",\n\t                layload:result.data.data\n\t            })\n\t        })\n\t    }\n\t}\n\n> index.jsx\n\n\timport {updata} from \"../../store/action/rank\"\n\tconst mapdispatchToprops=(dispatch)=>{\n\t    return {\n\t        updata(){\n\t            dispatch(updata())\n\t        },\n\t        add(layload){\n\t            dispatch({\n\t                type:\"ADD\",\n\t                layload:layload\n\t            })\n\t        }\n\t    }\n\t}\n\n### react-redux\n\n**redux和react的桥梁工具。**\n\n> index.js\n\n\timport React from 'react';\n\timport ReactDOM from 'react-dom';\n\timport \"./common/css/index.css\"\n\timport App from '../src/containers/app';\n\timport {Provider} from \"react-redux\"\n\timport {store} from \"./store/store\"\n\t\n\tReactDOM.render(\n\t        <Provider store={store}>\n\t          \n\t                <App />\n\t            \n\t        </Provider>\n\t     ,document.getElementById('root')\n\t);\n\n\n> home.js\n\n\timport React from \"react\"\n\timport {connect} from \"react-redux\"\n\tclass Home extends React.Component{\n\n\n\t}\n\n\tconst mapstateToprops=(state)=>{\n\t    return state\n\t}\n\tconst mapdispatchToprops=(dispatch)=>{\n\t    return {\n\t        updata(){\n\t            dispatch(updata())\n\t        },\n\t        add(layload){\n\t            dispatch({\n\t                type:\"ADD\",\n\t                layload:layload\n\t            })\n\t        }\n\t    }\n\t}\n\texport default connect(mapstateToprops,mapdispatchToprops)(Home) \n\n### redux-saga\n\n**上面介绍了redux-thunk是异步操作的方法，我们可以看出，他的函数内部比较复杂，如果需要每个异步操作都定义一个action的话，显然是不易维护的**\n\n### redux-saga的API\n\n**redux-saga是通过ES6中的generator实现的（babel的基础版本不包含generator语法，因此需要在使用saga的地方import ‘babel-polyfill’）。redux-saga本质是一个可以自执行的generator。**\n\n#### redux-saga中的Effect\n\n**redux-saga中定义了Effect，Effect是什么呢，本质就是一个特定的函数，返回的是纯文本对象。简单理解，通过Effect函数，会返回一个字符串，saga-middleware根据这个字符串来执行真正的异步操作，可以具体表现成如下形式：**\n\n> 异步操作——>Effect函数——>纯文本对象——>saga-middleware——>执行异步操作\n\n**因为Effect的存在，方便saga测试异步操作。**\n\n#### Effect具体函数\n\n**Effect函数有很多个，在redux-saga/effects提供，主要包括call，fork，put，take，select等，它们都与middleware中的操作一一对应。**\n\n- call 和 fork\n\n> call和fork表示异步调用，其中call表示的是阻塞调用，fork表示的是非阻塞调用。\n\n- put和select\n\n> put对应的是middleware中的dispatch方法，参数是一个plain object，一般在异步调用返回结果后，接着执行put。select相当于getState，用于获取store中的相应部分的state。\n\n- take、takeEvery、takeLatest\n\n> redux-saga中如果在非阻塞调用下（fork）,那么遵循的是worker/watcher模式，通过take可以监听某个action是否被发起，此外通过take结合fork，可以实现takeEvery和takeLatest的效果。\n\n> 如果一个异步操作的action被发起多次，takeEvery会执行多次action，而takeLatest只会执行最近的一次。\n\n###  redux-saga的优缺点\n\n> 优点：\n\n（1）集中处理了所有的异步操作，异步接口部分一目了然\n\n（2）action是普通对象，这跟redux同步的action一模一样\n\n（3）通过Effect，方便异步接口的测试\n\n（4）通过worker 和watcher可以实现非阻塞异步调用，并且同时可以实现非阻塞调用下的事件监听\n\n（5） 异步操作的流程是可以控制的，可以随时取消相应的异步操作。\n\n> 缺点：\n\n 太复杂，学习成本较高\n\n\n### 使用方式\n\n> sagas.js\n\n\timport { takeEvery, takeLatest } from 'redux-saga';\n\timport { call, put } from 'redux-saga/effects';\n\timport axios from 'axios';\n\timport { BEGIN_GET_POSTS, GET_POSTS, GET_POSTS_ERROR } from '../reducers';\n\t\n\t// worker saga\n\tfunction* showPostsAsync(action) {\n\t    try {\n\t        const response = yield call(axios.get, 'https://jsonplaceholder.typicode.com/posts');\n\t        yield put(GET_POSTS(response.data));\n\t    } catch(e) {\n\t        yield put(GET_ERROR(e));\n\t    }\n\t}\n\n> reducers.js\n\n\timport { combineReducers } from 'redux'\n\n\t// actions\n\texport const RECEIVE_USERS = 'RECEIVE_USERS';\n\texport const FETCH_USERS_ERROR = 'FETCH_USERS_ERROR';\n\texport const RECEIVE_POSTS = 'RECEIVE_POPTS';\n\texport const FETCH_POSTS_ERROR = 'FETCH_USERS_ERROR';\n\texport const BEGIN_GET_POSTS = 'BEGIN_GET_POSTS';\n\t\n\t// action creators\n\texport function GET_USERS(users) {\n\t\treturn { type: RECEIVE_USERS, users }\n\t}\n\t\n\texport function GET_ERROR(error) {\n\t\treturn { type: FETCH_USERS_ERROR, error }\n\t}\n\t\n\texport function GET_POSTS(posts) {\n\t    return { type: RECEIVE_POSTS, posts }\n\t}\n\t\n\texport function Begin_GET_POSTS() {\n\t    return { type: BEGIN_GET_POSTS }\n\t}\n\t\n\texport function GET_POSTS_ERROR(error) {\n\t\treturn { type: FETCH_POSTS_ERROR, error }\n\t}\n\t\n\t// reducer\n\tconst initialState = { \n\t\tfetched: false, \n\t\tusers: [{\n\t\t\tkey: '1',\n\t\t\tname: '张三',\n\t\t\temail: 'zhangsan@126.com'\n\t    }],\n\t    posts: [{\n\t        key: '1',\n\t        id: '1',\n\t        title: 'test'\n\t    }],\n\t\terror: null\n\t};\n\t\n\tconst appReducer = (state = initialState, action) => {\n\t    switch(action.type) {\n\t        case FETCH_USERS_ERROR: {\n\t            return {...state, error: action.error} \n\t            break;\n\t        }\n\t        case RECEIVE_USERS: {\n\t            return {...state, fetched: true, users: action.users} \n\t            break;\n\t        }\n\t        case FETCH_POSTS_ERROR: {\n\t            return {...state, error: action.error} \n\t            break;\n\t        }\n\t        case RECEIVE_POSTS: {\n\t            return {...state, fetched: true, posts: action.posts} \n\t            break;\n\t        }\n\t    }\n\t    return state;\n\t}\n\t\n\texport default appReducer\n\n\n> app.js\n\n\t'use strict';\n\t\n\timport '../asset/css/style.scss';\n\timport 'antd/dist/antd.min.css';\n\timport React from 'react';\n\timport { render } from 'react-dom';\n\timport { Provider } from 'react-redux';\n\timport { createStore, applyMiddleware, combineReducers } from 'redux';\n\timport logger from 'redux-logger';\n\timport thunk from 'redux-thunk';\n\timport createSagaMiddleware from 'redux-saga';\n\timport axios from 'axios';\n\t\n\timport appReducer from './reducers';\n\timport AppRouter from './router';\n\timport rootSaga from './sagas';\n\t\n\tconst sagaMiddleware = createSagaMiddleware();\n\tconst middlewares = [thunk, sagaMiddleware, logger];\n\t\n\tconst store = createStore(appReducer, applyMiddleware(...middlewares));\n\tsagaMiddleware.run(rootSaga);\n\t\n\trender(\n\t    <Provider store={store}>\n\t        <AppRouter />\n\t    </Provider>,\n\t    document.getElementById('app')\n\t);\n\n\n## 总结\n\n### 本文介绍了react-redux基本使用方法：\n\n**首先需要创建仓库，使用redux创建仓库，创建reducer，页面中使用dispatch执行action，将改变的值传递到renducer中，然而链接页面与仓库需要react-redux中的{provider,connect},在根目录进行链接，将组件使用provider包裹起来，将创建的仓库，传入到provider中，视图中使用connect链接仓库。**\n\n### redux-thunk\n\n**使用applymiddle引入插件thunk，创建一个函数，他返回一个函数，这个函数可以接收dispatch，他可以在异步任务执行完以后在，dispatch**\n\n### redux-saga\n\n**redux-sage中的effect中有put，call，select...几个属性，call使用来提交一个异步操作，有两个参数，第一个要执行的异步函数，第二个是要传递的参数，put是用来执行reducer，使用时需要创建一个sage**\n\n\n","source":"_posts/redux.md","raw":"---\ntitle: react-redux\ndate: '4/5/2019 8:03:01 PM '\ntag: ['js', 'react']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n## react-redux\n\n### 为什么需要redux\n\n**学过react的都知道，react用state和props控制组件的渲染情况，而对于JavaScript单页面日趋复杂的今天，JavaScript需要管理越来越多的state，而这些state包括着各种乱七八糟途径来的数据。甚至有的应用的state会关系到另一个组件的状态。所以为了方便对这些state的管理以及对state变化的可控性。这个时候Redux这个东西就出来了，它可以让state的变化变得可预测。**\n\n### Redux的基本概念\n\n**什么是redux？这里非权威的解释：就是一个应用的state管理库，甚至可以说是前端数据库。更包括的是管理数据。**\n\n#### state\n\n**state是整个应用的数据，本质上是一个普通对象。**\n\n#### action\n\n**数据state已经有了，那么我们是如何实现管理这些state中的数据的呢？那就是action，什么是action？按字面意思解释就是动作，也可以理解成，一个可能！改变state的动作包装。就这么简单。。。。**\n\n**比如有一个counter数量加减应用，我们就有两个action，一个decrement，一个increment。 所以这里的action creator写成如下：**\n\n\texport function decrement() {\n\t    return{\n\t        type:DECREMENT_COUNTER\n\t    }\n\t}\n\t\n\texport function increment(){\n\t    return{\n\t        type:INCREMENT_COUNTER\n\t    }\n\t}\n\n\n**那么，当action创建完成了之后呢，我们怎么触发这些action呢，这时我们是要利用dispatch，比如我们执行count增减减少动作。**\n\n\texport function incrementIfOdd(){\n\t    return(dispatch,getState)=>{\n\t        const {counter} = getState();\n\t        if(counter%2==0) {\n\t            return;\n\t        }\n\t        dispatch(increment());\n\t    }\n\t}\n\t\n\texport function incrementAsync() {\n\t    return dispatch => {\n\t        setTimeout(() => {\n\t            dispatch(increment());\n\t        }, 1000);\n\t    };\n\t}\n\n**为了减少样板代码，我们使用单独的模块或文件来定义 action type 常量**\n\n\texport const INCREMENT_COUNTER = 'INCREMENT_COUNTER';\n\texport const DECREMENT_COUNTER = 'DECREMENT_COUNTER';\n\n**这么做不是必须的，在大型应用中把它们显式地定义成常量还是利大于弊的。**\n\n#### reducer\n\n**既然这个可能改变state的动作已经包装好了，那么我们怎么去判断并且对state做相应的改变呢？对，这就是reducer干的事情了。**\n\n**reducer是state最终格式的确定。它是一个纯函数，也就是说，只要传入参数相同，返回计算得到的下一个 state 就一定相同。没有特殊情况、没有副作用，没有 API 请求、没有变量修改，单纯执行计算。**\n\n**reducer对传入的action进行判断，然后返回一个通过判断后的state，这就是reducer的全部职责。如我们的counter应用：**\n\n\timport {INCREMENT_COUNTER,DECREMENT_COUNTER} from '../actions';\n\n\texport default function counter(state = 0, action) {\n\t    switch (action.type){\n\t        case INCREMENT_COUNTER:\n\t            return state+1;\n\t        case DECREMENT_COUNTER:\n\t            return state-1;\n\t        default:\n\t            return state;\n\t    }\n\t}\n\n**对于一个比较大一点的应用来说，我们是需要将reducer拆分的，最后通过redux提供的combineReducers方法组合到一起。 如此项目上的：**\n\n\tconst rootReducer = combineReducers({\n\t    counter\n\t});\n\texport default rootReducer;\n\n**每个reducer只负责管理全局state中它负责的一部分。每个reducer的state参数都不同，分别对应它管理的那部分state数据。combineReducers()所做的只是生成一个函数，这个函数来调用你的一系列reducer，每个reducer根据它们的key来筛选出state中的一部分数据并处理， 然后这个生成的函数再将所有reducer的结果合并成一个大的对象。**\n\n#### store\n\n**store是对之前说到一个联系和管理。具有如下职责**\n\n\n> - 维持应用的state；\n> - 提供getState()方法获取 state\n> - 提供dispatch(action)方法更新 state；\n> - 通过subscribe(listener)注册监听器;\n> - 通过subscribe(listener)返回的函数注销监听器。\n\n**强调一下 Redux 应用只有一个单一的store。当需要拆分数据处理逻辑时，你应该使用reducer组合,而不是创建多个store。store的创建通过redux的createStore方法创建，这个方法还需要传入reducer，很容易理解：毕竟我需要dispatch一个action来改变state嘛。 应用一般会有一个初始化的state，所以可选为第二个参数，这个参数通常是有服务端提供的，传说中的Universal渲染。 第三个参数一般是需要使用的中间件，通过applyMiddleware传入。**\n\n### redux-thunk\n\n**一个比较流行的redux的action中间件，它可以让actionCreator暂时不返回action对象，而是返回一个函数，函数传递两个参数(dispatch, getState)，在函数体内进行业务逻辑的封装，比如异步操作，我们至少需要触发两个action，这时候我们可以通过redux-thunk将这两个action封装在一起，如下：**\n\n> store.js\n\n\timport { createStore, applyMiddleware } from \"redux\";\n\timport RankReducer from \"./reducers/reducer\"\n\timport thunk from \"redux-thunk\";\n\tconst store = createStore(RankReducer, applyMiddleware(thunk));\n\texport default store\n\n> reducer.jsx\n\n\tconst defaultState = {\n\t    rankList: []\n\t}\n\tconst RankReducer = (state = defaultState, action) => {\n\t    const { type, layload } = action;\n\t    switch (type) {\n\t        case \"UPDATE\":\n\t            return { ...state, rankList: layload }\n\t        default:\n\t            return state;\n\t    }\n\t}\n\texport default RankReducer;\n\n> rank.js\n\n\timport axios from \"axios\"\n\n\texport function updata(layload){\n\t    return function(dispatch){\n\t        return axios.get(\"/getrankList\").then(result=>{\n\t            return dispatch({\n\t                type:\"UPDATA\",\n\t                layload:result.data.data\n\t            })\n\t        })\n\t    }\n\t}\n\n> index.jsx\n\n\timport {updata} from \"../../store/action/rank\"\n\tconst mapdispatchToprops=(dispatch)=>{\n\t    return {\n\t        updata(){\n\t            dispatch(updata())\n\t        },\n\t        add(layload){\n\t            dispatch({\n\t                type:\"ADD\",\n\t                layload:layload\n\t            })\n\t        }\n\t    }\n\t}\n\n### react-redux\n\n**redux和react的桥梁工具。**\n\n> index.js\n\n\timport React from 'react';\n\timport ReactDOM from 'react-dom';\n\timport \"./common/css/index.css\"\n\timport App from '../src/containers/app';\n\timport {Provider} from \"react-redux\"\n\timport {store} from \"./store/store\"\n\t\n\tReactDOM.render(\n\t        <Provider store={store}>\n\t          \n\t                <App />\n\t            \n\t        </Provider>\n\t     ,document.getElementById('root')\n\t);\n\n\n> home.js\n\n\timport React from \"react\"\n\timport {connect} from \"react-redux\"\n\tclass Home extends React.Component{\n\n\n\t}\n\n\tconst mapstateToprops=(state)=>{\n\t    return state\n\t}\n\tconst mapdispatchToprops=(dispatch)=>{\n\t    return {\n\t        updata(){\n\t            dispatch(updata())\n\t        },\n\t        add(layload){\n\t            dispatch({\n\t                type:\"ADD\",\n\t                layload:layload\n\t            })\n\t        }\n\t    }\n\t}\n\texport default connect(mapstateToprops,mapdispatchToprops)(Home) \n\n### redux-saga\n\n**上面介绍了redux-thunk是异步操作的方法，我们可以看出，他的函数内部比较复杂，如果需要每个异步操作都定义一个action的话，显然是不易维护的**\n\n### redux-saga的API\n\n**redux-saga是通过ES6中的generator实现的（babel的基础版本不包含generator语法，因此需要在使用saga的地方import ‘babel-polyfill’）。redux-saga本质是一个可以自执行的generator。**\n\n#### redux-saga中的Effect\n\n**redux-saga中定义了Effect，Effect是什么呢，本质就是一个特定的函数，返回的是纯文本对象。简单理解，通过Effect函数，会返回一个字符串，saga-middleware根据这个字符串来执行真正的异步操作，可以具体表现成如下形式：**\n\n> 异步操作——>Effect函数——>纯文本对象——>saga-middleware——>执行异步操作\n\n**因为Effect的存在，方便saga测试异步操作。**\n\n#### Effect具体函数\n\n**Effect函数有很多个，在redux-saga/effects提供，主要包括call，fork，put，take，select等，它们都与middleware中的操作一一对应。**\n\n- call 和 fork\n\n> call和fork表示异步调用，其中call表示的是阻塞调用，fork表示的是非阻塞调用。\n\n- put和select\n\n> put对应的是middleware中的dispatch方法，参数是一个plain object，一般在异步调用返回结果后，接着执行put。select相当于getState，用于获取store中的相应部分的state。\n\n- take、takeEvery、takeLatest\n\n> redux-saga中如果在非阻塞调用下（fork）,那么遵循的是worker/watcher模式，通过take可以监听某个action是否被发起，此外通过take结合fork，可以实现takeEvery和takeLatest的效果。\n\n> 如果一个异步操作的action被发起多次，takeEvery会执行多次action，而takeLatest只会执行最近的一次。\n\n###  redux-saga的优缺点\n\n> 优点：\n\n（1）集中处理了所有的异步操作，异步接口部分一目了然\n\n（2）action是普通对象，这跟redux同步的action一模一样\n\n（3）通过Effect，方便异步接口的测试\n\n（4）通过worker 和watcher可以实现非阻塞异步调用，并且同时可以实现非阻塞调用下的事件监听\n\n（5） 异步操作的流程是可以控制的，可以随时取消相应的异步操作。\n\n> 缺点：\n\n 太复杂，学习成本较高\n\n\n### 使用方式\n\n> sagas.js\n\n\timport { takeEvery, takeLatest } from 'redux-saga';\n\timport { call, put } from 'redux-saga/effects';\n\timport axios from 'axios';\n\timport { BEGIN_GET_POSTS, GET_POSTS, GET_POSTS_ERROR } from '../reducers';\n\t\n\t// worker saga\n\tfunction* showPostsAsync(action) {\n\t    try {\n\t        const response = yield call(axios.get, 'https://jsonplaceholder.typicode.com/posts');\n\t        yield put(GET_POSTS(response.data));\n\t    } catch(e) {\n\t        yield put(GET_ERROR(e));\n\t    }\n\t}\n\n> reducers.js\n\n\timport { combineReducers } from 'redux'\n\n\t// actions\n\texport const RECEIVE_USERS = 'RECEIVE_USERS';\n\texport const FETCH_USERS_ERROR = 'FETCH_USERS_ERROR';\n\texport const RECEIVE_POSTS = 'RECEIVE_POPTS';\n\texport const FETCH_POSTS_ERROR = 'FETCH_USERS_ERROR';\n\texport const BEGIN_GET_POSTS = 'BEGIN_GET_POSTS';\n\t\n\t// action creators\n\texport function GET_USERS(users) {\n\t\treturn { type: RECEIVE_USERS, users }\n\t}\n\t\n\texport function GET_ERROR(error) {\n\t\treturn { type: FETCH_USERS_ERROR, error }\n\t}\n\t\n\texport function GET_POSTS(posts) {\n\t    return { type: RECEIVE_POSTS, posts }\n\t}\n\t\n\texport function Begin_GET_POSTS() {\n\t    return { type: BEGIN_GET_POSTS }\n\t}\n\t\n\texport function GET_POSTS_ERROR(error) {\n\t\treturn { type: FETCH_POSTS_ERROR, error }\n\t}\n\t\n\t// reducer\n\tconst initialState = { \n\t\tfetched: false, \n\t\tusers: [{\n\t\t\tkey: '1',\n\t\t\tname: '张三',\n\t\t\temail: 'zhangsan@126.com'\n\t    }],\n\t    posts: [{\n\t        key: '1',\n\t        id: '1',\n\t        title: 'test'\n\t    }],\n\t\terror: null\n\t};\n\t\n\tconst appReducer = (state = initialState, action) => {\n\t    switch(action.type) {\n\t        case FETCH_USERS_ERROR: {\n\t            return {...state, error: action.error} \n\t            break;\n\t        }\n\t        case RECEIVE_USERS: {\n\t            return {...state, fetched: true, users: action.users} \n\t            break;\n\t        }\n\t        case FETCH_POSTS_ERROR: {\n\t            return {...state, error: action.error} \n\t            break;\n\t        }\n\t        case RECEIVE_POSTS: {\n\t            return {...state, fetched: true, posts: action.posts} \n\t            break;\n\t        }\n\t    }\n\t    return state;\n\t}\n\t\n\texport default appReducer\n\n\n> app.js\n\n\t'use strict';\n\t\n\timport '../asset/css/style.scss';\n\timport 'antd/dist/antd.min.css';\n\timport React from 'react';\n\timport { render } from 'react-dom';\n\timport { Provider } from 'react-redux';\n\timport { createStore, applyMiddleware, combineReducers } from 'redux';\n\timport logger from 'redux-logger';\n\timport thunk from 'redux-thunk';\n\timport createSagaMiddleware from 'redux-saga';\n\timport axios from 'axios';\n\t\n\timport appReducer from './reducers';\n\timport AppRouter from './router';\n\timport rootSaga from './sagas';\n\t\n\tconst sagaMiddleware = createSagaMiddleware();\n\tconst middlewares = [thunk, sagaMiddleware, logger];\n\t\n\tconst store = createStore(appReducer, applyMiddleware(...middlewares));\n\tsagaMiddleware.run(rootSaga);\n\t\n\trender(\n\t    <Provider store={store}>\n\t        <AppRouter />\n\t    </Provider>,\n\t    document.getElementById('app')\n\t);\n\n\n## 总结\n\n### 本文介绍了react-redux基本使用方法：\n\n**首先需要创建仓库，使用redux创建仓库，创建reducer，页面中使用dispatch执行action，将改变的值传递到renducer中，然而链接页面与仓库需要react-redux中的{provider,connect},在根目录进行链接，将组件使用provider包裹起来，将创建的仓库，传入到provider中，视图中使用connect链接仓库。**\n\n### redux-thunk\n\n**使用applymiddle引入插件thunk，创建一个函数，他返回一个函数，这个函数可以接收dispatch，他可以在异步任务执行完以后在，dispatch**\n\n### redux-saga\n\n**redux-sage中的effect中有put，call，select...几个属性，call使用来提交一个异步操作，有两个参数，第一个要执行的异步函数，第二个是要传递的参数，put是用来执行reducer，使用时需要创建一个sage**\n\n\n","slug":"redux","published":1,"updated":"2019-04-05T12:23:43.906Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iamdu006tn4wdcleo365j","content":"<h2 id=\"react-redux\"><a href=\"#react-redux\" class=\"headerlink\" title=\"react-redux\"></a>react-redux</h2><h3 id=\"为什么需要redux\"><a href=\"#为什么需要redux\" class=\"headerlink\" title=\"为什么需要redux\"></a>为什么需要redux</h3><p><strong>学过react的都知道，react用state和props控制组件的渲染情况，而对于JavaScript单页面日趋复杂的今天，JavaScript需要管理越来越多的state，而这些state包括着各种乱七八糟途径来的数据。甚至有的应用的state会关系到另一个组件的状态。所以为了方便对这些state的管理以及对state变化的可控性。这个时候Redux这个东西就出来了，它可以让state的变化变得可预测。</strong></p>\n<h3 id=\"Redux的基本概念\"><a href=\"#Redux的基本概念\" class=\"headerlink\" title=\"Redux的基本概念\"></a>Redux的基本概念</h3><p><strong>什么是redux？这里非权威的解释：就是一个应用的state管理库，甚至可以说是前端数据库。更包括的是管理数据。</strong></p>\n<h4 id=\"state\"><a href=\"#state\" class=\"headerlink\" title=\"state\"></a>state</h4><p><strong>state是整个应用的数据，本质上是一个普通对象。</strong></p>\n<h4 id=\"action\"><a href=\"#action\" class=\"headerlink\" title=\"action\"></a>action</h4><p><strong>数据state已经有了，那么我们是如何实现管理这些state中的数据的呢？那就是action，什么是action？按字面意思解释就是动作，也可以理解成，一个可能！改变state的动作包装。就这么简单。。。。</strong></p>\n<p><strong>比如有一个counter数量加减应用，我们就有两个action，一个decrement，一个increment。 所以这里的action creator写成如下：</strong></p>\n<pre><code>export function decrement() {\n    return{\n        type:DECREMENT_COUNTER\n    }\n}\n\nexport function increment(){\n    return{\n        type:INCREMENT_COUNTER\n    }\n}\n</code></pre><p><strong>那么，当action创建完成了之后呢，我们怎么触发这些action呢，这时我们是要利用dispatch，比如我们执行count增减减少动作。</strong></p>\n<pre><code>export function incrementIfOdd(){\n    return(dispatch,getState)=&gt;{\n        const {counter} = getState();\n        if(counter%2==0) {\n            return;\n        }\n        dispatch(increment());\n    }\n}\n\nexport function incrementAsync() {\n    return dispatch =&gt; {\n        setTimeout(() =&gt; {\n            dispatch(increment());\n        }, 1000);\n    };\n}\n</code></pre><p><strong>为了减少样板代码，我们使用单独的模块或文件来定义 action type 常量</strong></p>\n<pre><code>export const INCREMENT_COUNTER = &#39;INCREMENT_COUNTER&#39;;\nexport const DECREMENT_COUNTER = &#39;DECREMENT_COUNTER&#39;;\n</code></pre><p><strong>这么做不是必须的，在大型应用中把它们显式地定义成常量还是利大于弊的。</strong></p>\n<h4 id=\"reducer\"><a href=\"#reducer\" class=\"headerlink\" title=\"reducer\"></a>reducer</h4><p><strong>既然这个可能改变state的动作已经包装好了，那么我们怎么去判断并且对state做相应的改变呢？对，这就是reducer干的事情了。</strong></p>\n<p><strong>reducer是state最终格式的确定。它是一个纯函数，也就是说，只要传入参数相同，返回计算得到的下一个 state 就一定相同。没有特殊情况、没有副作用，没有 API 请求、没有变量修改，单纯执行计算。</strong></p>\n<p><strong>reducer对传入的action进行判断，然后返回一个通过判断后的state，这就是reducer的全部职责。如我们的counter应用：</strong></p>\n<pre><code>import {INCREMENT_COUNTER,DECREMENT_COUNTER} from &#39;../actions&#39;;\n\nexport default function counter(state = 0, action) {\n    switch (action.type){\n        case INCREMENT_COUNTER:\n            return state+1;\n        case DECREMENT_COUNTER:\n            return state-1;\n        default:\n            return state;\n    }\n}\n</code></pre><p><strong>对于一个比较大一点的应用来说，我们是需要将reducer拆分的，最后通过redux提供的combineReducers方法组合到一起。 如此项目上的：</strong></p>\n<pre><code>const rootReducer = combineReducers({\n    counter\n});\nexport default rootReducer;\n</code></pre><p><strong>每个reducer只负责管理全局state中它负责的一部分。每个reducer的state参数都不同，分别对应它管理的那部分state数据。combineReducers()所做的只是生成一个函数，这个函数来调用你的一系列reducer，每个reducer根据它们的key来筛选出state中的一部分数据并处理， 然后这个生成的函数再将所有reducer的结果合并成一个大的对象。</strong></p>\n<h4 id=\"store\"><a href=\"#store\" class=\"headerlink\" title=\"store\"></a>store</h4><p><strong>store是对之前说到一个联系和管理。具有如下职责</strong></p>\n<blockquote>\n<ul>\n<li>维持应用的state；</li>\n<li>提供getState()方法获取 state</li>\n<li>提供dispatch(action)方法更新 state；</li>\n<li>通过subscribe(listener)注册监听器;</li>\n<li>通过subscribe(listener)返回的函数注销监听器。</li>\n</ul>\n</blockquote>\n<p><strong>强调一下 Redux 应用只有一个单一的store。当需要拆分数据处理逻辑时，你应该使用reducer组合,而不是创建多个store。store的创建通过redux的createStore方法创建，这个方法还需要传入reducer，很容易理解：毕竟我需要dispatch一个action来改变state嘛。 应用一般会有一个初始化的state，所以可选为第二个参数，这个参数通常是有服务端提供的，传说中的Universal渲染。 第三个参数一般是需要使用的中间件，通过applyMiddleware传入。</strong></p>\n<h3 id=\"redux-thunk\"><a href=\"#redux-thunk\" class=\"headerlink\" title=\"redux-thunk\"></a>redux-thunk</h3><p><strong>一个比较流行的redux的action中间件，它可以让actionCreator暂时不返回action对象，而是返回一个函数，函数传递两个参数(dispatch, getState)，在函数体内进行业务逻辑的封装，比如异步操作，我们至少需要触发两个action，这时候我们可以通过redux-thunk将这两个action封装在一起，如下：</strong></p>\n<blockquote>\n<p>store.js</p>\n</blockquote>\n<pre><code>import { createStore, applyMiddleware } from &quot;redux&quot;;\nimport RankReducer from &quot;./reducers/reducer&quot;\nimport thunk from &quot;redux-thunk&quot;;\nconst store = createStore(RankReducer, applyMiddleware(thunk));\nexport default store\n</code></pre><blockquote>\n<p>reducer.jsx</p>\n</blockquote>\n<pre><code>const defaultState = {\n    rankList: []\n}\nconst RankReducer = (state = defaultState, action) =&gt; {\n    const { type, layload } = action;\n    switch (type) {\n        case &quot;UPDATE&quot;:\n            return { ...state, rankList: layload }\n        default:\n            return state;\n    }\n}\nexport default RankReducer;\n</code></pre><blockquote>\n<p>rank.js</p>\n</blockquote>\n<pre><code>import axios from &quot;axios&quot;\n\nexport function updata(layload){\n    return function(dispatch){\n        return axios.get(&quot;/getrankList&quot;).then(result=&gt;{\n            return dispatch({\n                type:&quot;UPDATA&quot;,\n                layload:result.data.data\n            })\n        })\n    }\n}\n</code></pre><blockquote>\n<p>index.jsx</p>\n</blockquote>\n<pre><code>import {updata} from &quot;../../store/action/rank&quot;\nconst mapdispatchToprops=(dispatch)=&gt;{\n    return {\n        updata(){\n            dispatch(updata())\n        },\n        add(layload){\n            dispatch({\n                type:&quot;ADD&quot;,\n                layload:layload\n            })\n        }\n    }\n}\n</code></pre><h3 id=\"react-redux-1\"><a href=\"#react-redux-1\" class=\"headerlink\" title=\"react-redux\"></a>react-redux</h3><p><strong>redux和react的桥梁工具。</strong></p>\n<blockquote>\n<p>index.js</p>\n</blockquote>\n<pre><code>import React from &#39;react&#39;;\nimport ReactDOM from &#39;react-dom&#39;;\nimport &quot;./common/css/index.css&quot;\nimport App from &#39;../src/containers/app&#39;;\nimport {Provider} from &quot;react-redux&quot;\nimport {store} from &quot;./store/store&quot;\n\nReactDOM.render(\n        &lt;Provider store={store}&gt;\n\n                &lt;App /&gt;\n\n        &lt;/Provider&gt;\n     ,document.getElementById(&#39;root&#39;)\n);\n</code></pre><blockquote>\n<p>home.js</p>\n</blockquote>\n<pre><code>import React from &quot;react&quot;\nimport {connect} from &quot;react-redux&quot;\nclass Home extends React.Component{\n\n\n}\n\nconst mapstateToprops=(state)=&gt;{\n    return state\n}\nconst mapdispatchToprops=(dispatch)=&gt;{\n    return {\n        updata(){\n            dispatch(updata())\n        },\n        add(layload){\n            dispatch({\n                type:&quot;ADD&quot;,\n                layload:layload\n            })\n        }\n    }\n}\nexport default connect(mapstateToprops,mapdispatchToprops)(Home) \n</code></pre><h3 id=\"redux-saga\"><a href=\"#redux-saga\" class=\"headerlink\" title=\"redux-saga\"></a>redux-saga</h3><p><strong>上面介绍了redux-thunk是异步操作的方法，我们可以看出，他的函数内部比较复杂，如果需要每个异步操作都定义一个action的话，显然是不易维护的</strong></p>\n<h3 id=\"redux-saga的API\"><a href=\"#redux-saga的API\" class=\"headerlink\" title=\"redux-saga的API\"></a>redux-saga的API</h3><p><strong>redux-saga是通过ES6中的generator实现的（babel的基础版本不包含generator语法，因此需要在使用saga的地方import ‘babel-polyfill’）。redux-saga本质是一个可以自执行的generator。</strong></p>\n<h4 id=\"redux-saga中的Effect\"><a href=\"#redux-saga中的Effect\" class=\"headerlink\" title=\"redux-saga中的Effect\"></a>redux-saga中的Effect</h4><p><strong>redux-saga中定义了Effect，Effect是什么呢，本质就是一个特定的函数，返回的是纯文本对象。简单理解，通过Effect函数，会返回一个字符串，saga-middleware根据这个字符串来执行真正的异步操作，可以具体表现成如下形式：</strong></p>\n<blockquote>\n<p>异步操作——&gt;Effect函数——&gt;纯文本对象——&gt;saga-middleware——&gt;执行异步操作</p>\n</blockquote>\n<p><strong>因为Effect的存在，方便saga测试异步操作。</strong></p>\n<h4 id=\"Effect具体函数\"><a href=\"#Effect具体函数\" class=\"headerlink\" title=\"Effect具体函数\"></a>Effect具体函数</h4><p><strong>Effect函数有很多个，在redux-saga/effects提供，主要包括call，fork，put，take，select等，它们都与middleware中的操作一一对应。</strong></p>\n<ul>\n<li>call 和 fork</li>\n</ul>\n<blockquote>\n<p>call和fork表示异步调用，其中call表示的是阻塞调用，fork表示的是非阻塞调用。</p>\n</blockquote>\n<ul>\n<li>put和select</li>\n</ul>\n<blockquote>\n<p>put对应的是middleware中的dispatch方法，参数是一个plain object，一般在异步调用返回结果后，接着执行put。select相当于getState，用于获取store中的相应部分的state。</p>\n</blockquote>\n<ul>\n<li>take、takeEvery、takeLatest</li>\n</ul>\n<blockquote>\n<p>redux-saga中如果在非阻塞调用下（fork）,那么遵循的是worker/watcher模式，通过take可以监听某个action是否被发起，此外通过take结合fork，可以实现takeEvery和takeLatest的效果。</p>\n</blockquote>\n<blockquote>\n<p>如果一个异步操作的action被发起多次，takeEvery会执行多次action，而takeLatest只会执行最近的一次。</p>\n</blockquote>\n<h3 id=\"redux-saga的优缺点\"><a href=\"#redux-saga的优缺点\" class=\"headerlink\" title=\"redux-saga的优缺点\"></a>redux-saga的优缺点</h3><blockquote>\n<p>优点：</p>\n</blockquote>\n<p>（1）集中处理了所有的异步操作，异步接口部分一目了然</p>\n<p>（2）action是普通对象，这跟redux同步的action一模一样</p>\n<p>（3）通过Effect，方便异步接口的测试</p>\n<p>（4）通过worker 和watcher可以实现非阻塞异步调用，并且同时可以实现非阻塞调用下的事件监听</p>\n<p>（5） 异步操作的流程是可以控制的，可以随时取消相应的异步操作。</p>\n<blockquote>\n<p>缺点：</p>\n</blockquote>\n<p> 太复杂，学习成本较高</p>\n<h3 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h3><blockquote>\n<p>sagas.js</p>\n</blockquote>\n<pre><code>import { takeEvery, takeLatest } from &#39;redux-saga&#39;;\nimport { call, put } from &#39;redux-saga/effects&#39;;\nimport axios from &#39;axios&#39;;\nimport { BEGIN_GET_POSTS, GET_POSTS, GET_POSTS_ERROR } from &#39;../reducers&#39;;\n\n// worker saga\nfunction* showPostsAsync(action) {\n    try {\n        const response = yield call(axios.get, &#39;https://jsonplaceholder.typicode.com/posts&#39;);\n        yield put(GET_POSTS(response.data));\n    } catch(e) {\n        yield put(GET_ERROR(e));\n    }\n}\n</code></pre><blockquote>\n<p>reducers.js</p>\n</blockquote>\n<pre><code>import { combineReducers } from &#39;redux&#39;\n\n// actions\nexport const RECEIVE_USERS = &#39;RECEIVE_USERS&#39;;\nexport const FETCH_USERS_ERROR = &#39;FETCH_USERS_ERROR&#39;;\nexport const RECEIVE_POSTS = &#39;RECEIVE_POPTS&#39;;\nexport const FETCH_POSTS_ERROR = &#39;FETCH_USERS_ERROR&#39;;\nexport const BEGIN_GET_POSTS = &#39;BEGIN_GET_POSTS&#39;;\n\n// action creators\nexport function GET_USERS(users) {\n    return { type: RECEIVE_USERS, users }\n}\n\nexport function GET_ERROR(error) {\n    return { type: FETCH_USERS_ERROR, error }\n}\n\nexport function GET_POSTS(posts) {\n    return { type: RECEIVE_POSTS, posts }\n}\n\nexport function Begin_GET_POSTS() {\n    return { type: BEGIN_GET_POSTS }\n}\n\nexport function GET_POSTS_ERROR(error) {\n    return { type: FETCH_POSTS_ERROR, error }\n}\n\n// reducer\nconst initialState = { \n    fetched: false, \n    users: [{\n        key: &#39;1&#39;,\n        name: &#39;张三&#39;,\n        email: &#39;zhangsan@126.com&#39;\n    }],\n    posts: [{\n        key: &#39;1&#39;,\n        id: &#39;1&#39;,\n        title: &#39;test&#39;\n    }],\n    error: null\n};\n\nconst appReducer = (state = initialState, action) =&gt; {\n    switch(action.type) {\n        case FETCH_USERS_ERROR: {\n            return {...state, error: action.error} \n            break;\n        }\n        case RECEIVE_USERS: {\n            return {...state, fetched: true, users: action.users} \n            break;\n        }\n        case FETCH_POSTS_ERROR: {\n            return {...state, error: action.error} \n            break;\n        }\n        case RECEIVE_POSTS: {\n            return {...state, fetched: true, posts: action.posts} \n            break;\n        }\n    }\n    return state;\n}\n\nexport default appReducer\n</code></pre><blockquote>\n<p>app.js</p>\n</blockquote>\n<pre><code>&#39;use strict&#39;;\n\nimport &#39;../asset/css/style.scss&#39;;\nimport &#39;antd/dist/antd.min.css&#39;;\nimport React from &#39;react&#39;;\nimport { render } from &#39;react-dom&#39;;\nimport { Provider } from &#39;react-redux&#39;;\nimport { createStore, applyMiddleware, combineReducers } from &#39;redux&#39;;\nimport logger from &#39;redux-logger&#39;;\nimport thunk from &#39;redux-thunk&#39;;\nimport createSagaMiddleware from &#39;redux-saga&#39;;\nimport axios from &#39;axios&#39;;\n\nimport appReducer from &#39;./reducers&#39;;\nimport AppRouter from &#39;./router&#39;;\nimport rootSaga from &#39;./sagas&#39;;\n\nconst sagaMiddleware = createSagaMiddleware();\nconst middlewares = [thunk, sagaMiddleware, logger];\n\nconst store = createStore(appReducer, applyMiddleware(...middlewares));\nsagaMiddleware.run(rootSaga);\n\nrender(\n    &lt;Provider store={store}&gt;\n        &lt;AppRouter /&gt;\n    &lt;/Provider&gt;,\n    document.getElementById(&#39;app&#39;)\n);\n</code></pre><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h3 id=\"本文介绍了react-redux基本使用方法：\"><a href=\"#本文介绍了react-redux基本使用方法：\" class=\"headerlink\" title=\"本文介绍了react-redux基本使用方法：\"></a>本文介绍了react-redux基本使用方法：</h3><p><strong>首先需要创建仓库，使用redux创建仓库，创建reducer，页面中使用dispatch执行action，将改变的值传递到renducer中，然而链接页面与仓库需要react-redux中的{provider,connect},在根目录进行链接，将组件使用provider包裹起来，将创建的仓库，传入到provider中，视图中使用connect链接仓库。</strong></p>\n<h3 id=\"redux-thunk-1\"><a href=\"#redux-thunk-1\" class=\"headerlink\" title=\"redux-thunk\"></a>redux-thunk</h3><p><strong>使用applymiddle引入插件thunk，创建一个函数，他返回一个函数，这个函数可以接收dispatch，他可以在异步任务执行完以后在，dispatch</strong></p>\n<h3 id=\"redux-saga-1\"><a href=\"#redux-saga-1\" class=\"headerlink\" title=\"redux-saga\"></a>redux-saga</h3><p><strong>redux-sage中的effect中有put，call，select…几个属性，call使用来提交一个异步操作，有两个参数，第一个要执行的异步函数，第二个是要传递的参数，put是用来执行reducer，使用时需要创建一个sage</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"react-redux\"><a href=\"#react-redux\" class=\"headerlink\" title=\"react-redux\"></a>react-redux</h2><h3 id=\"为什么需要redux\"><a href=\"#为什么需要redux\" class=\"headerlink\" title=\"为什么需要redux\"></a>为什么需要redux</h3><p><strong>学过react的都知道，react用state和props控制组件的渲染情况，而对于JavaScript单页面日趋复杂的今天，JavaScript需要管理越来越多的state，而这些state包括着各种乱七八糟途径来的数据。甚至有的应用的state会关系到另一个组件的状态。所以为了方便对这些state的管理以及对state变化的可控性。这个时候Redux这个东西就出来了，它可以让state的变化变得可预测。</strong></p>\n<h3 id=\"Redux的基本概念\"><a href=\"#Redux的基本概念\" class=\"headerlink\" title=\"Redux的基本概念\"></a>Redux的基本概念</h3><p><strong>什么是redux？这里非权威的解释：就是一个应用的state管理库，甚至可以说是前端数据库。更包括的是管理数据。</strong></p>\n<h4 id=\"state\"><a href=\"#state\" class=\"headerlink\" title=\"state\"></a>state</h4><p><strong>state是整个应用的数据，本质上是一个普通对象。</strong></p>\n<h4 id=\"action\"><a href=\"#action\" class=\"headerlink\" title=\"action\"></a>action</h4><p><strong>数据state已经有了，那么我们是如何实现管理这些state中的数据的呢？那就是action，什么是action？按字面意思解释就是动作，也可以理解成，一个可能！改变state的动作包装。就这么简单。。。。</strong></p>\n<p><strong>比如有一个counter数量加减应用，我们就有两个action，一个decrement，一个increment。 所以这里的action creator写成如下：</strong></p>\n<pre><code>export function decrement() {\n    return{\n        type:DECREMENT_COUNTER\n    }\n}\n\nexport function increment(){\n    return{\n        type:INCREMENT_COUNTER\n    }\n}\n</code></pre><p><strong>那么，当action创建完成了之后呢，我们怎么触发这些action呢，这时我们是要利用dispatch，比如我们执行count增减减少动作。</strong></p>\n<pre><code>export function incrementIfOdd(){\n    return(dispatch,getState)=&gt;{\n        const {counter} = getState();\n        if(counter%2==0) {\n            return;\n        }\n        dispatch(increment());\n    }\n}\n\nexport function incrementAsync() {\n    return dispatch =&gt; {\n        setTimeout(() =&gt; {\n            dispatch(increment());\n        }, 1000);\n    };\n}\n</code></pre><p><strong>为了减少样板代码，我们使用单独的模块或文件来定义 action type 常量</strong></p>\n<pre><code>export const INCREMENT_COUNTER = &#39;INCREMENT_COUNTER&#39;;\nexport const DECREMENT_COUNTER = &#39;DECREMENT_COUNTER&#39;;\n</code></pre><p><strong>这么做不是必须的，在大型应用中把它们显式地定义成常量还是利大于弊的。</strong></p>\n<h4 id=\"reducer\"><a href=\"#reducer\" class=\"headerlink\" title=\"reducer\"></a>reducer</h4><p><strong>既然这个可能改变state的动作已经包装好了，那么我们怎么去判断并且对state做相应的改变呢？对，这就是reducer干的事情了。</strong></p>\n<p><strong>reducer是state最终格式的确定。它是一个纯函数，也就是说，只要传入参数相同，返回计算得到的下一个 state 就一定相同。没有特殊情况、没有副作用，没有 API 请求、没有变量修改，单纯执行计算。</strong></p>\n<p><strong>reducer对传入的action进行判断，然后返回一个通过判断后的state，这就是reducer的全部职责。如我们的counter应用：</strong></p>\n<pre><code>import {INCREMENT_COUNTER,DECREMENT_COUNTER} from &#39;../actions&#39;;\n\nexport default function counter(state = 0, action) {\n    switch (action.type){\n        case INCREMENT_COUNTER:\n            return state+1;\n        case DECREMENT_COUNTER:\n            return state-1;\n        default:\n            return state;\n    }\n}\n</code></pre><p><strong>对于一个比较大一点的应用来说，我们是需要将reducer拆分的，最后通过redux提供的combineReducers方法组合到一起。 如此项目上的：</strong></p>\n<pre><code>const rootReducer = combineReducers({\n    counter\n});\nexport default rootReducer;\n</code></pre><p><strong>每个reducer只负责管理全局state中它负责的一部分。每个reducer的state参数都不同，分别对应它管理的那部分state数据。combineReducers()所做的只是生成一个函数，这个函数来调用你的一系列reducer，每个reducer根据它们的key来筛选出state中的一部分数据并处理， 然后这个生成的函数再将所有reducer的结果合并成一个大的对象。</strong></p>\n<h4 id=\"store\"><a href=\"#store\" class=\"headerlink\" title=\"store\"></a>store</h4><p><strong>store是对之前说到一个联系和管理。具有如下职责</strong></p>\n<blockquote>\n<ul>\n<li>维持应用的state；</li>\n<li>提供getState()方法获取 state</li>\n<li>提供dispatch(action)方法更新 state；</li>\n<li>通过subscribe(listener)注册监听器;</li>\n<li>通过subscribe(listener)返回的函数注销监听器。</li>\n</ul>\n</blockquote>\n<p><strong>强调一下 Redux 应用只有一个单一的store。当需要拆分数据处理逻辑时，你应该使用reducer组合,而不是创建多个store。store的创建通过redux的createStore方法创建，这个方法还需要传入reducer，很容易理解：毕竟我需要dispatch一个action来改变state嘛。 应用一般会有一个初始化的state，所以可选为第二个参数，这个参数通常是有服务端提供的，传说中的Universal渲染。 第三个参数一般是需要使用的中间件，通过applyMiddleware传入。</strong></p>\n<h3 id=\"redux-thunk\"><a href=\"#redux-thunk\" class=\"headerlink\" title=\"redux-thunk\"></a>redux-thunk</h3><p><strong>一个比较流行的redux的action中间件，它可以让actionCreator暂时不返回action对象，而是返回一个函数，函数传递两个参数(dispatch, getState)，在函数体内进行业务逻辑的封装，比如异步操作，我们至少需要触发两个action，这时候我们可以通过redux-thunk将这两个action封装在一起，如下：</strong></p>\n<blockquote>\n<p>store.js</p>\n</blockquote>\n<pre><code>import { createStore, applyMiddleware } from &quot;redux&quot;;\nimport RankReducer from &quot;./reducers/reducer&quot;\nimport thunk from &quot;redux-thunk&quot;;\nconst store = createStore(RankReducer, applyMiddleware(thunk));\nexport default store\n</code></pre><blockquote>\n<p>reducer.jsx</p>\n</blockquote>\n<pre><code>const defaultState = {\n    rankList: []\n}\nconst RankReducer = (state = defaultState, action) =&gt; {\n    const { type, layload } = action;\n    switch (type) {\n        case &quot;UPDATE&quot;:\n            return { ...state, rankList: layload }\n        default:\n            return state;\n    }\n}\nexport default RankReducer;\n</code></pre><blockquote>\n<p>rank.js</p>\n</blockquote>\n<pre><code>import axios from &quot;axios&quot;\n\nexport function updata(layload){\n    return function(dispatch){\n        return axios.get(&quot;/getrankList&quot;).then(result=&gt;{\n            return dispatch({\n                type:&quot;UPDATA&quot;,\n                layload:result.data.data\n            })\n        })\n    }\n}\n</code></pre><blockquote>\n<p>index.jsx</p>\n</blockquote>\n<pre><code>import {updata} from &quot;../../store/action/rank&quot;\nconst mapdispatchToprops=(dispatch)=&gt;{\n    return {\n        updata(){\n            dispatch(updata())\n        },\n        add(layload){\n            dispatch({\n                type:&quot;ADD&quot;,\n                layload:layload\n            })\n        }\n    }\n}\n</code></pre><h3 id=\"react-redux-1\"><a href=\"#react-redux-1\" class=\"headerlink\" title=\"react-redux\"></a>react-redux</h3><p><strong>redux和react的桥梁工具。</strong></p>\n<blockquote>\n<p>index.js</p>\n</blockquote>\n<pre><code>import React from &#39;react&#39;;\nimport ReactDOM from &#39;react-dom&#39;;\nimport &quot;./common/css/index.css&quot;\nimport App from &#39;../src/containers/app&#39;;\nimport {Provider} from &quot;react-redux&quot;\nimport {store} from &quot;./store/store&quot;\n\nReactDOM.render(\n        &lt;Provider store={store}&gt;\n\n                &lt;App /&gt;\n\n        &lt;/Provider&gt;\n     ,document.getElementById(&#39;root&#39;)\n);\n</code></pre><blockquote>\n<p>home.js</p>\n</blockquote>\n<pre><code>import React from &quot;react&quot;\nimport {connect} from &quot;react-redux&quot;\nclass Home extends React.Component{\n\n\n}\n\nconst mapstateToprops=(state)=&gt;{\n    return state\n}\nconst mapdispatchToprops=(dispatch)=&gt;{\n    return {\n        updata(){\n            dispatch(updata())\n        },\n        add(layload){\n            dispatch({\n                type:&quot;ADD&quot;,\n                layload:layload\n            })\n        }\n    }\n}\nexport default connect(mapstateToprops,mapdispatchToprops)(Home) \n</code></pre><h3 id=\"redux-saga\"><a href=\"#redux-saga\" class=\"headerlink\" title=\"redux-saga\"></a>redux-saga</h3><p><strong>上面介绍了redux-thunk是异步操作的方法，我们可以看出，他的函数内部比较复杂，如果需要每个异步操作都定义一个action的话，显然是不易维护的</strong></p>\n<h3 id=\"redux-saga的API\"><a href=\"#redux-saga的API\" class=\"headerlink\" title=\"redux-saga的API\"></a>redux-saga的API</h3><p><strong>redux-saga是通过ES6中的generator实现的（babel的基础版本不包含generator语法，因此需要在使用saga的地方import ‘babel-polyfill’）。redux-saga本质是一个可以自执行的generator。</strong></p>\n<h4 id=\"redux-saga中的Effect\"><a href=\"#redux-saga中的Effect\" class=\"headerlink\" title=\"redux-saga中的Effect\"></a>redux-saga中的Effect</h4><p><strong>redux-saga中定义了Effect，Effect是什么呢，本质就是一个特定的函数，返回的是纯文本对象。简单理解，通过Effect函数，会返回一个字符串，saga-middleware根据这个字符串来执行真正的异步操作，可以具体表现成如下形式：</strong></p>\n<blockquote>\n<p>异步操作——&gt;Effect函数——&gt;纯文本对象——&gt;saga-middleware——&gt;执行异步操作</p>\n</blockquote>\n<p><strong>因为Effect的存在，方便saga测试异步操作。</strong></p>\n<h4 id=\"Effect具体函数\"><a href=\"#Effect具体函数\" class=\"headerlink\" title=\"Effect具体函数\"></a>Effect具体函数</h4><p><strong>Effect函数有很多个，在redux-saga/effects提供，主要包括call，fork，put，take，select等，它们都与middleware中的操作一一对应。</strong></p>\n<ul>\n<li>call 和 fork</li>\n</ul>\n<blockquote>\n<p>call和fork表示异步调用，其中call表示的是阻塞调用，fork表示的是非阻塞调用。</p>\n</blockquote>\n<ul>\n<li>put和select</li>\n</ul>\n<blockquote>\n<p>put对应的是middleware中的dispatch方法，参数是一个plain object，一般在异步调用返回结果后，接着执行put。select相当于getState，用于获取store中的相应部分的state。</p>\n</blockquote>\n<ul>\n<li>take、takeEvery、takeLatest</li>\n</ul>\n<blockquote>\n<p>redux-saga中如果在非阻塞调用下（fork）,那么遵循的是worker/watcher模式，通过take可以监听某个action是否被发起，此外通过take结合fork，可以实现takeEvery和takeLatest的效果。</p>\n</blockquote>\n<blockquote>\n<p>如果一个异步操作的action被发起多次，takeEvery会执行多次action，而takeLatest只会执行最近的一次。</p>\n</blockquote>\n<h3 id=\"redux-saga的优缺点\"><a href=\"#redux-saga的优缺点\" class=\"headerlink\" title=\"redux-saga的优缺点\"></a>redux-saga的优缺点</h3><blockquote>\n<p>优点：</p>\n</blockquote>\n<p>（1）集中处理了所有的异步操作，异步接口部分一目了然</p>\n<p>（2）action是普通对象，这跟redux同步的action一模一样</p>\n<p>（3）通过Effect，方便异步接口的测试</p>\n<p>（4）通过worker 和watcher可以实现非阻塞异步调用，并且同时可以实现非阻塞调用下的事件监听</p>\n<p>（5） 异步操作的流程是可以控制的，可以随时取消相应的异步操作。</p>\n<blockquote>\n<p>缺点：</p>\n</blockquote>\n<p> 太复杂，学习成本较高</p>\n<h3 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h3><blockquote>\n<p>sagas.js</p>\n</blockquote>\n<pre><code>import { takeEvery, takeLatest } from &#39;redux-saga&#39;;\nimport { call, put } from &#39;redux-saga/effects&#39;;\nimport axios from &#39;axios&#39;;\nimport { BEGIN_GET_POSTS, GET_POSTS, GET_POSTS_ERROR } from &#39;../reducers&#39;;\n\n// worker saga\nfunction* showPostsAsync(action) {\n    try {\n        const response = yield call(axios.get, &#39;https://jsonplaceholder.typicode.com/posts&#39;);\n        yield put(GET_POSTS(response.data));\n    } catch(e) {\n        yield put(GET_ERROR(e));\n    }\n}\n</code></pre><blockquote>\n<p>reducers.js</p>\n</blockquote>\n<pre><code>import { combineReducers } from &#39;redux&#39;\n\n// actions\nexport const RECEIVE_USERS = &#39;RECEIVE_USERS&#39;;\nexport const FETCH_USERS_ERROR = &#39;FETCH_USERS_ERROR&#39;;\nexport const RECEIVE_POSTS = &#39;RECEIVE_POPTS&#39;;\nexport const FETCH_POSTS_ERROR = &#39;FETCH_USERS_ERROR&#39;;\nexport const BEGIN_GET_POSTS = &#39;BEGIN_GET_POSTS&#39;;\n\n// action creators\nexport function GET_USERS(users) {\n    return { type: RECEIVE_USERS, users }\n}\n\nexport function GET_ERROR(error) {\n    return { type: FETCH_USERS_ERROR, error }\n}\n\nexport function GET_POSTS(posts) {\n    return { type: RECEIVE_POSTS, posts }\n}\n\nexport function Begin_GET_POSTS() {\n    return { type: BEGIN_GET_POSTS }\n}\n\nexport function GET_POSTS_ERROR(error) {\n    return { type: FETCH_POSTS_ERROR, error }\n}\n\n// reducer\nconst initialState = { \n    fetched: false, \n    users: [{\n        key: &#39;1&#39;,\n        name: &#39;张三&#39;,\n        email: &#39;zhangsan@126.com&#39;\n    }],\n    posts: [{\n        key: &#39;1&#39;,\n        id: &#39;1&#39;,\n        title: &#39;test&#39;\n    }],\n    error: null\n};\n\nconst appReducer = (state = initialState, action) =&gt; {\n    switch(action.type) {\n        case FETCH_USERS_ERROR: {\n            return {...state, error: action.error} \n            break;\n        }\n        case RECEIVE_USERS: {\n            return {...state, fetched: true, users: action.users} \n            break;\n        }\n        case FETCH_POSTS_ERROR: {\n            return {...state, error: action.error} \n            break;\n        }\n        case RECEIVE_POSTS: {\n            return {...state, fetched: true, posts: action.posts} \n            break;\n        }\n    }\n    return state;\n}\n\nexport default appReducer\n</code></pre><blockquote>\n<p>app.js</p>\n</blockquote>\n<pre><code>&#39;use strict&#39;;\n\nimport &#39;../asset/css/style.scss&#39;;\nimport &#39;antd/dist/antd.min.css&#39;;\nimport React from &#39;react&#39;;\nimport { render } from &#39;react-dom&#39;;\nimport { Provider } from &#39;react-redux&#39;;\nimport { createStore, applyMiddleware, combineReducers } from &#39;redux&#39;;\nimport logger from &#39;redux-logger&#39;;\nimport thunk from &#39;redux-thunk&#39;;\nimport createSagaMiddleware from &#39;redux-saga&#39;;\nimport axios from &#39;axios&#39;;\n\nimport appReducer from &#39;./reducers&#39;;\nimport AppRouter from &#39;./router&#39;;\nimport rootSaga from &#39;./sagas&#39;;\n\nconst sagaMiddleware = createSagaMiddleware();\nconst middlewares = [thunk, sagaMiddleware, logger];\n\nconst store = createStore(appReducer, applyMiddleware(...middlewares));\nsagaMiddleware.run(rootSaga);\n\nrender(\n    &lt;Provider store={store}&gt;\n        &lt;AppRouter /&gt;\n    &lt;/Provider&gt;,\n    document.getElementById(&#39;app&#39;)\n);\n</code></pre><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h3 id=\"本文介绍了react-redux基本使用方法：\"><a href=\"#本文介绍了react-redux基本使用方法：\" class=\"headerlink\" title=\"本文介绍了react-redux基本使用方法：\"></a>本文介绍了react-redux基本使用方法：</h3><p><strong>首先需要创建仓库，使用redux创建仓库，创建reducer，页面中使用dispatch执行action，将改变的值传递到renducer中，然而链接页面与仓库需要react-redux中的{provider,connect},在根目录进行链接，将组件使用provider包裹起来，将创建的仓库，传入到provider中，视图中使用connect链接仓库。</strong></p>\n<h3 id=\"redux-thunk-1\"><a href=\"#redux-thunk-1\" class=\"headerlink\" title=\"redux-thunk\"></a>redux-thunk</h3><p><strong>使用applymiddle引入插件thunk，创建一个函数，他返回一个函数，这个函数可以接收dispatch，他可以在异步任务执行完以后在，dispatch</strong></p>\n<h3 id=\"redux-saga-1\"><a href=\"#redux-saga-1\" class=\"headerlink\" title=\"redux-saga\"></a>redux-saga</h3><p><strong>redux-sage中的effect中有put，call，select…几个属性，call使用来提交一个异步操作，有两个参数，第一个要执行的异步函数，第二个是要传递的参数，put是用来执行reducer，使用时需要创建一个sage</strong></p>\n"},{"title":"浅谈React的最大亮点——虚拟DOM","date":"2019-04-03T07:09:41.000Z","meta":[{"name":"description","content":null},{"name":"keywords","content":null}],"_content":"## 浅谈React的最大亮点——虚拟DOM\n\n**React非常快速是因为它从不直接操作DOM。**\n\n**虚拟DOM是在DOM的基础上建立了一个抽象层，对数据和状态所做的任何改动，都会被自动且高效的同步到虚拟DOM，最后再批量同步到DOM中。**\n\n**在React中，render执行的结果得到的并不是真正的DOM节点，而仅仅是JavaScript对象，称之为虚拟DOM。**\n\n**虚拟DOM具有批处理和高效的Diff算法，可以无需担心性能问题而随时“刷新”整个页面，因为虚拟DOM可以确保只对界面上真正变化的部分进行实际的DOM操作。**\n\n## 虚拟DOM的原理：\n\n**React会在内存中维护一个虚拟DOM树，对这个树进行读或写，实际上是对虚拟DOM进行。当数据变化时，React会自动更新虚拟DOM，然后将新的虚拟DOM和旧的虚拟DOM进行对比，找到变更的部分，得出一个diff，然后将diff放到一个队列里，最终批量更新这些diff到DOM中。**\n\n## 虚拟DOM的优点：\n\n**最终表现在DOM上的修改只是变更的部分，可以保证非常高效的渲染。**\n\n## 虚拟DOM的缺点：\n\n**首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。**\n\n## 虚拟DOM的理解误区\n\n**对虚拟DOM的理解往往停留在：通过JavaScript对象模拟原生DOM，加上DOM Diff 极大提升了DOM操作的性能。然而，虚拟DOM最大的意义不在于性能的提升（JavaScript对象比DOM对象性能高），而在于抽象了DOM的具体实现（对DOM进行了一层抽象），这在浏览器中使用 React时不是特别明显，因为写的DOM标签跟原生的没有区别，并且最终都被渲染成了DOM，在React Native中将会有很好的说明。**\n\n## 模拟方法和渲染方法\n\n> 调用\n\n\tlet virtualDom1 = createElement('ul', {class: 'list'}, [\n\t    createElement('li', {class: 'item'}, ['a']),\n\t    createElement('li', {class: 'item'}, ['b']),\n\t    createElement('li', {class: 'item'}, ['c']),\n\t])\n\tlet virtualDom2 = createElement('ul', {class: 'list'}, [\n\t    createElement('li', {class: 'item'}, ['1']),\n\t    createElement('li', {class: 'item'}, ['2']),\n\t    createElement('li', {class: 'item'}, ['3']),\n\t])\n\tlet el = render(virtualDom);\n\trenderDom(el, window.root);\n\tlet patchs = diff(virtualDom1, virtualDom2);\n\n> 生成虚拟对象的方法createElement\n\n\tfunction createElement(type, props, children) {\n\t    return new Element(type, props, children)\n\t}\n\tclass Element{\n\t    constructor(type, props, children){\n\t        this.type = type;\n\t        this.props = props;\n\t        this.children = children\n\t    }\n\t}\n\n> 将虚拟对象渲染成真实DOM的render方法\n\n\t//render方法将vNode转化成真实DOM\n\tfunction render(eleObj){\n\t    //创建元素\n\t    let el = document.createElement(eleObj.type);\n\t    //设置属性\n\t    for(let key in eleObj.props) {\n\t        setAttr(el, key, eleObj.props[key]);\n\t    }\n\t    //递归渲染子元素\n\t    eleObj.children.foEach(child => {\n\t        child = child instanceof Element ? render(child) : document.createTextNode(child);\n\t        el.appendChild(child);\n\t    })\n\t}\n\tsetAttr(node, key, value) {\n\t    switch(key) {\n\t        case 'value':\n\t            if (node.tagName.toUpperCase() === 'INPUT' || node.tagName.toUpperCase() === 'TEXTAREA') {\n\t                node.value = value;          \n\t            }else {\n\t                node.setAttribute(key, value);\n\t            }\n\t            break;\n\t        case 'style':\n\t            node.style.cssText = value;\n\t            break;\n\t        default:\n\t            node.setAttribute(key, value);\n\t            break;\n\t    }\n\t}\n\n> 渲染节点到页面的方法renderDom\n\n\t//将真实DOM渲染到页面\n\tfunction renderDom(el, target) {\n\t    target.appendChild(el);\n\t}\n\n## DOM DIFF 算法\n\n**DOM DIFF 就是比较两个虚拟DOM的区别，实际上就是比较两个对象的区别。根据两个虚拟对象创建出补丁，描述改变的内容。将这个补丁用来更新DOM。**\n\n> 【注意】不会更改所有节点，只更改有改变的部分\n\n\n### 算法实现\n\n> 差异计算：先序深度优先遍历\n\n#### 规则：\n\n1. 若节点类型不相同，直接采用替换模式，{type:'REPLACE',newNode:newNode}\n2. 当节点类型相同时，去看一下属性是否相同，产生一个属性的补丁包，比如{type:'ATTRS',attrs:{class: 'list-group'}\n3. 新的DOM节点不存在，也返回一个不存在的补丁包{type:'REMOVE',index:XXX}\n4. 文本的变化{type:'TEXT', text:1}\n\n----------\n\n\n\t//diff 算法\n\tlet Index = 0;\n\tfunction diff(oldTree, newTree) {\n\t    let patches = {};\n\t    let index = 0;\n\t    //递归数比较后的结果放到补丁包中\n\t    walk(oldTree, newTree, index, patches);\n\t    return patches;\n\t}\n\tfunction walk(oldTree, newTree, index, patches){\n\t    let currentPatch = [];//每个元素都有一个补丁对象\n\t    if (!newTree) {\n\t        currentPatch.push({type:'REMOVE', index})\n\t    } \n\t    if (isString(oldTree) && isString(newTree)) {\n\t        // 判断文本是否一致\n\t        if (oldTree !== newTree) {\n\t            currentPatch.push({type:'TEXT',text:newTree}); \n\t        }\n\t    }else if(oldTree.type === newTree.type) {\n\t        //比较属性是否有更改\n\t        let attrs = diffAttr(oldTree.props, newTree.props);\n\t        if(Object.keys(attrs).length) {\n\t            currentPatch.push({type:'ATTRS', attrs});\n\t        }\n\t        // 如果有儿子节点，遍历子节点\n\t          diffChildren(oldTree.children, newTree.children, index, patches);\n\t    } else {\n\t        // 节点类型不同的时候，直接替换\n\t        currentPatch.push({type:'REPLACE', newTree});\n\t    }\n\t    // 当前元素有补丁的情况下，将元素和补丁对应起来，放到大补丁包中\n\t    if(currentPatch.length) {\n\t        patches[index] = currentPatch; \n\t    }\n\t}\n\tfunction diffAttr(oldAttrs, newAttrs) {\n\t    let patch = {};\n\t    for(let key in oldAttrs) {\n\t        if(oldAttrs[key] !== newAttrs[key]) {\n\t            patch[key] = newAttrs[key];//有可能是undefined，新节点没有旧节点的属性      \n\t        }\n\t    }\n\t    for(let key in newAttrs) {\n\t        //老节点没有新节点的属性\n\t        if(! oldAttrs.hasOwnProperty(key)) {\n\t            patch[key] = newAttrs[key]\n\t        }\n\t    }\n\t    return patch;\n\t}\n\t\n\tfunction diffChildren(oldChildren, newChildren, index, patches){\n\t    // 比较老的第一个和新的第一个\n\t    oldChildren.forEach((child, idx) => {\n\t        // 记得索引得改\n\t        // Index 每次传递给walk时，index是递增的，所有节点都基于一个序号实现，因此需要维护一个全局Index\n\t        walk(child, newChildren[idx], ++Index, patches);\n\t    }) \n\t}\n\t\n\t\n\tfunction isString(node) {\n\t    return Object.prototype.toString.call(node) === '[object string]';\n\t}\n\t\n\t\n\tfunction patch(node, patches) {\n\t // 给某个元素打补丁\n\t \n\t}\n\n## 总结\n\n- dom结构发生改变： 直接卸载并重新create\n- dom结构一样： 不会卸载，但是会更新\n- 在同一层级的子节点，他们都可以通过key开区分【同时遵循上面两点】\n\n## 衍生：\n\n### 加了key的好处:\n\n> 加了key值可以具体确定哪些元素被修改，便于对比新旧dom树，加快虚拟dom的渲染速度\n\n### 我们该不该把map的index作为key\n\n> 最好将数据本身的id最为key值，如果使用index作为key值，如果前后两次两次arr分别为[1,2,3,4]和[5,6,7,8]和前后两次arr分别为[1,2,3,4]和[4,3,2,1]的情况,很明显前者可以认为是DOM改变了,后者可以认为是DOM节点的位移操作,那么对于第一种情况来说index作为key和没有key值无区别,但是第二种情况用index作为key值效果没有比用数据本身作为key值好\n\n### key值必须唯一且不重复么\n\n> 前提条件是是否为同一父节点\n\n----------\n> [参考文章：飞飞廉的简书](https://www.jianshu.com/p/8c1505ebcf0e)\n","source":"_posts/virtualDom1 .md","raw":"---\ntitle: 浅谈React的最大亮点——虚拟DOM\ndate: '4/3/2019 3:09:41 PM '\ntag: ['js', 'react']\nmeta:\n  -\n    name: description\n    content: null\n  -\n    name: keywords\n    content: null\n---\n## 浅谈React的最大亮点——虚拟DOM\n\n**React非常快速是因为它从不直接操作DOM。**\n\n**虚拟DOM是在DOM的基础上建立了一个抽象层，对数据和状态所做的任何改动，都会被自动且高效的同步到虚拟DOM，最后再批量同步到DOM中。**\n\n**在React中，render执行的结果得到的并不是真正的DOM节点，而仅仅是JavaScript对象，称之为虚拟DOM。**\n\n**虚拟DOM具有批处理和高效的Diff算法，可以无需担心性能问题而随时“刷新”整个页面，因为虚拟DOM可以确保只对界面上真正变化的部分进行实际的DOM操作。**\n\n## 虚拟DOM的原理：\n\n**React会在内存中维护一个虚拟DOM树，对这个树进行读或写，实际上是对虚拟DOM进行。当数据变化时，React会自动更新虚拟DOM，然后将新的虚拟DOM和旧的虚拟DOM进行对比，找到变更的部分，得出一个diff，然后将diff放到一个队列里，最终批量更新这些diff到DOM中。**\n\n## 虚拟DOM的优点：\n\n**最终表现在DOM上的修改只是变更的部分，可以保证非常高效的渲染。**\n\n## 虚拟DOM的缺点：\n\n**首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。**\n\n## 虚拟DOM的理解误区\n\n**对虚拟DOM的理解往往停留在：通过JavaScript对象模拟原生DOM，加上DOM Diff 极大提升了DOM操作的性能。然而，虚拟DOM最大的意义不在于性能的提升（JavaScript对象比DOM对象性能高），而在于抽象了DOM的具体实现（对DOM进行了一层抽象），这在浏览器中使用 React时不是特别明显，因为写的DOM标签跟原生的没有区别，并且最终都被渲染成了DOM，在React Native中将会有很好的说明。**\n\n## 模拟方法和渲染方法\n\n> 调用\n\n\tlet virtualDom1 = createElement('ul', {class: 'list'}, [\n\t    createElement('li', {class: 'item'}, ['a']),\n\t    createElement('li', {class: 'item'}, ['b']),\n\t    createElement('li', {class: 'item'}, ['c']),\n\t])\n\tlet virtualDom2 = createElement('ul', {class: 'list'}, [\n\t    createElement('li', {class: 'item'}, ['1']),\n\t    createElement('li', {class: 'item'}, ['2']),\n\t    createElement('li', {class: 'item'}, ['3']),\n\t])\n\tlet el = render(virtualDom);\n\trenderDom(el, window.root);\n\tlet patchs = diff(virtualDom1, virtualDom2);\n\n> 生成虚拟对象的方法createElement\n\n\tfunction createElement(type, props, children) {\n\t    return new Element(type, props, children)\n\t}\n\tclass Element{\n\t    constructor(type, props, children){\n\t        this.type = type;\n\t        this.props = props;\n\t        this.children = children\n\t    }\n\t}\n\n> 将虚拟对象渲染成真实DOM的render方法\n\n\t//render方法将vNode转化成真实DOM\n\tfunction render(eleObj){\n\t    //创建元素\n\t    let el = document.createElement(eleObj.type);\n\t    //设置属性\n\t    for(let key in eleObj.props) {\n\t        setAttr(el, key, eleObj.props[key]);\n\t    }\n\t    //递归渲染子元素\n\t    eleObj.children.foEach(child => {\n\t        child = child instanceof Element ? render(child) : document.createTextNode(child);\n\t        el.appendChild(child);\n\t    })\n\t}\n\tsetAttr(node, key, value) {\n\t    switch(key) {\n\t        case 'value':\n\t            if (node.tagName.toUpperCase() === 'INPUT' || node.tagName.toUpperCase() === 'TEXTAREA') {\n\t                node.value = value;          \n\t            }else {\n\t                node.setAttribute(key, value);\n\t            }\n\t            break;\n\t        case 'style':\n\t            node.style.cssText = value;\n\t            break;\n\t        default:\n\t            node.setAttribute(key, value);\n\t            break;\n\t    }\n\t}\n\n> 渲染节点到页面的方法renderDom\n\n\t//将真实DOM渲染到页面\n\tfunction renderDom(el, target) {\n\t    target.appendChild(el);\n\t}\n\n## DOM DIFF 算法\n\n**DOM DIFF 就是比较两个虚拟DOM的区别，实际上就是比较两个对象的区别。根据两个虚拟对象创建出补丁，描述改变的内容。将这个补丁用来更新DOM。**\n\n> 【注意】不会更改所有节点，只更改有改变的部分\n\n\n### 算法实现\n\n> 差异计算：先序深度优先遍历\n\n#### 规则：\n\n1. 若节点类型不相同，直接采用替换模式，{type:'REPLACE',newNode:newNode}\n2. 当节点类型相同时，去看一下属性是否相同，产生一个属性的补丁包，比如{type:'ATTRS',attrs:{class: 'list-group'}\n3. 新的DOM节点不存在，也返回一个不存在的补丁包{type:'REMOVE',index:XXX}\n4. 文本的变化{type:'TEXT', text:1}\n\n----------\n\n\n\t//diff 算法\n\tlet Index = 0;\n\tfunction diff(oldTree, newTree) {\n\t    let patches = {};\n\t    let index = 0;\n\t    //递归数比较后的结果放到补丁包中\n\t    walk(oldTree, newTree, index, patches);\n\t    return patches;\n\t}\n\tfunction walk(oldTree, newTree, index, patches){\n\t    let currentPatch = [];//每个元素都有一个补丁对象\n\t    if (!newTree) {\n\t        currentPatch.push({type:'REMOVE', index})\n\t    } \n\t    if (isString(oldTree) && isString(newTree)) {\n\t        // 判断文本是否一致\n\t        if (oldTree !== newTree) {\n\t            currentPatch.push({type:'TEXT',text:newTree}); \n\t        }\n\t    }else if(oldTree.type === newTree.type) {\n\t        //比较属性是否有更改\n\t        let attrs = diffAttr(oldTree.props, newTree.props);\n\t        if(Object.keys(attrs).length) {\n\t            currentPatch.push({type:'ATTRS', attrs});\n\t        }\n\t        // 如果有儿子节点，遍历子节点\n\t          diffChildren(oldTree.children, newTree.children, index, patches);\n\t    } else {\n\t        // 节点类型不同的时候，直接替换\n\t        currentPatch.push({type:'REPLACE', newTree});\n\t    }\n\t    // 当前元素有补丁的情况下，将元素和补丁对应起来，放到大补丁包中\n\t    if(currentPatch.length) {\n\t        patches[index] = currentPatch; \n\t    }\n\t}\n\tfunction diffAttr(oldAttrs, newAttrs) {\n\t    let patch = {};\n\t    for(let key in oldAttrs) {\n\t        if(oldAttrs[key] !== newAttrs[key]) {\n\t            patch[key] = newAttrs[key];//有可能是undefined，新节点没有旧节点的属性      \n\t        }\n\t    }\n\t    for(let key in newAttrs) {\n\t        //老节点没有新节点的属性\n\t        if(! oldAttrs.hasOwnProperty(key)) {\n\t            patch[key] = newAttrs[key]\n\t        }\n\t    }\n\t    return patch;\n\t}\n\t\n\tfunction diffChildren(oldChildren, newChildren, index, patches){\n\t    // 比较老的第一个和新的第一个\n\t    oldChildren.forEach((child, idx) => {\n\t        // 记得索引得改\n\t        // Index 每次传递给walk时，index是递增的，所有节点都基于一个序号实现，因此需要维护一个全局Index\n\t        walk(child, newChildren[idx], ++Index, patches);\n\t    }) \n\t}\n\t\n\t\n\tfunction isString(node) {\n\t    return Object.prototype.toString.call(node) === '[object string]';\n\t}\n\t\n\t\n\tfunction patch(node, patches) {\n\t // 给某个元素打补丁\n\t \n\t}\n\n## 总结\n\n- dom结构发生改变： 直接卸载并重新create\n- dom结构一样： 不会卸载，但是会更新\n- 在同一层级的子节点，他们都可以通过key开区分【同时遵循上面两点】\n\n## 衍生：\n\n### 加了key的好处:\n\n> 加了key值可以具体确定哪些元素被修改，便于对比新旧dom树，加快虚拟dom的渲染速度\n\n### 我们该不该把map的index作为key\n\n> 最好将数据本身的id最为key值，如果使用index作为key值，如果前后两次两次arr分别为[1,2,3,4]和[5,6,7,8]和前后两次arr分别为[1,2,3,4]和[4,3,2,1]的情况,很明显前者可以认为是DOM改变了,后者可以认为是DOM节点的位移操作,那么对于第一种情况来说index作为key和没有key值无区别,但是第二种情况用index作为key值效果没有比用数据本身作为key值好\n\n### key值必须唯一且不重复么\n\n> 前提条件是是否为同一父节点\n\n----------\n> [参考文章：飞飞廉的简书](https://www.jianshu.com/p/8c1505ebcf0e)\n","slug":"virtualDom1 ","published":1,"updated":"2019-04-03T07:09:42.574Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck11iamdv006vn4wdpoqwr4gv","content":"<h2 id=\"浅谈React的最大亮点——虚拟DOM\"><a href=\"#浅谈React的最大亮点——虚拟DOM\" class=\"headerlink\" title=\"浅谈React的最大亮点——虚拟DOM\"></a>浅谈React的最大亮点——虚拟DOM</h2><p><strong>React非常快速是因为它从不直接操作DOM。</strong></p>\n<p><strong>虚拟DOM是在DOM的基础上建立了一个抽象层，对数据和状态所做的任何改动，都会被自动且高效的同步到虚拟DOM，最后再批量同步到DOM中。</strong></p>\n<p><strong>在React中，render执行的结果得到的并不是真正的DOM节点，而仅仅是JavaScript对象，称之为虚拟DOM。</strong></p>\n<p><strong>虚拟DOM具有批处理和高效的Diff算法，可以无需担心性能问题而随时“刷新”整个页面，因为虚拟DOM可以确保只对界面上真正变化的部分进行实际的DOM操作。</strong></p>\n<h2 id=\"虚拟DOM的原理：\"><a href=\"#虚拟DOM的原理：\" class=\"headerlink\" title=\"虚拟DOM的原理：\"></a>虚拟DOM的原理：</h2><p><strong>React会在内存中维护一个虚拟DOM树，对这个树进行读或写，实际上是对虚拟DOM进行。当数据变化时，React会自动更新虚拟DOM，然后将新的虚拟DOM和旧的虚拟DOM进行对比，找到变更的部分，得出一个diff，然后将diff放到一个队列里，最终批量更新这些diff到DOM中。</strong></p>\n<h2 id=\"虚拟DOM的优点：\"><a href=\"#虚拟DOM的优点：\" class=\"headerlink\" title=\"虚拟DOM的优点：\"></a>虚拟DOM的优点：</h2><p><strong>最终表现在DOM上的修改只是变更的部分，可以保证非常高效的渲染。</strong></p>\n<h2 id=\"虚拟DOM的缺点：\"><a href=\"#虚拟DOM的缺点：\" class=\"headerlink\" title=\"虚拟DOM的缺点：\"></a>虚拟DOM的缺点：</h2><p><strong>首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。</strong></p>\n<h2 id=\"虚拟DOM的理解误区\"><a href=\"#虚拟DOM的理解误区\" class=\"headerlink\" title=\"虚拟DOM的理解误区\"></a>虚拟DOM的理解误区</h2><p><strong>对虚拟DOM的理解往往停留在：通过JavaScript对象模拟原生DOM，加上DOM Diff 极大提升了DOM操作的性能。然而，虚拟DOM最大的意义不在于性能的提升（JavaScript对象比DOM对象性能高），而在于抽象了DOM的具体实现（对DOM进行了一层抽象），这在浏览器中使用 React时不是特别明显，因为写的DOM标签跟原生的没有区别，并且最终都被渲染成了DOM，在React Native中将会有很好的说明。</strong></p>\n<h2 id=\"模拟方法和渲染方法\"><a href=\"#模拟方法和渲染方法\" class=\"headerlink\" title=\"模拟方法和渲染方法\"></a>模拟方法和渲染方法</h2><blockquote>\n<p>调用</p>\n</blockquote>\n<pre><code>let virtualDom1 = createElement(&#39;ul&#39;, {class: &#39;list&#39;}, [\n    createElement(&#39;li&#39;, {class: &#39;item&#39;}, [&#39;a&#39;]),\n    createElement(&#39;li&#39;, {class: &#39;item&#39;}, [&#39;b&#39;]),\n    createElement(&#39;li&#39;, {class: &#39;item&#39;}, [&#39;c&#39;]),\n])\nlet virtualDom2 = createElement(&#39;ul&#39;, {class: &#39;list&#39;}, [\n    createElement(&#39;li&#39;, {class: &#39;item&#39;}, [&#39;1&#39;]),\n    createElement(&#39;li&#39;, {class: &#39;item&#39;}, [&#39;2&#39;]),\n    createElement(&#39;li&#39;, {class: &#39;item&#39;}, [&#39;3&#39;]),\n])\nlet el = render(virtualDom);\nrenderDom(el, window.root);\nlet patchs = diff(virtualDom1, virtualDom2);\n</code></pre><blockquote>\n<p>生成虚拟对象的方法createElement</p>\n</blockquote>\n<pre><code>function createElement(type, props, children) {\n    return new Element(type, props, children)\n}\nclass Element{\n    constructor(type, props, children){\n        this.type = type;\n        this.props = props;\n        this.children = children\n    }\n}\n</code></pre><blockquote>\n<p>将虚拟对象渲染成真实DOM的render方法</p>\n</blockquote>\n<pre><code>//render方法将vNode转化成真实DOM\nfunction render(eleObj){\n    //创建元素\n    let el = document.createElement(eleObj.type);\n    //设置属性\n    for(let key in eleObj.props) {\n        setAttr(el, key, eleObj.props[key]);\n    }\n    //递归渲染子元素\n    eleObj.children.foEach(child =&gt; {\n        child = child instanceof Element ? render(child) : document.createTextNode(child);\n        el.appendChild(child);\n    })\n}\nsetAttr(node, key, value) {\n    switch(key) {\n        case &#39;value&#39;:\n            if (node.tagName.toUpperCase() === &#39;INPUT&#39; || node.tagName.toUpperCase() === &#39;TEXTAREA&#39;) {\n                node.value = value;          \n            }else {\n                node.setAttribute(key, value);\n            }\n            break;\n        case &#39;style&#39;:\n            node.style.cssText = value;\n            break;\n        default:\n            node.setAttribute(key, value);\n            break;\n    }\n}\n</code></pre><blockquote>\n<p>渲染节点到页面的方法renderDom</p>\n</blockquote>\n<pre><code>//将真实DOM渲染到页面\nfunction renderDom(el, target) {\n    target.appendChild(el);\n}\n</code></pre><h2 id=\"DOM-DIFF-算法\"><a href=\"#DOM-DIFF-算法\" class=\"headerlink\" title=\"DOM DIFF 算法\"></a>DOM DIFF 算法</h2><p><strong>DOM DIFF 就是比较两个虚拟DOM的区别，实际上就是比较两个对象的区别。根据两个虚拟对象创建出补丁，描述改变的内容。将这个补丁用来更新DOM。</strong></p>\n<blockquote>\n<p>【注意】不会更改所有节点，只更改有改变的部分</p>\n</blockquote>\n<h3 id=\"算法实现\"><a href=\"#算法实现\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h3><blockquote>\n<p>差异计算：先序深度优先遍历</p>\n</blockquote>\n<h4 id=\"规则：\"><a href=\"#规则：\" class=\"headerlink\" title=\"规则：\"></a>规则：</h4><ol>\n<li>若节点类型不相同，直接采用替换模式，{type:’REPLACE’,newNode:newNode}</li>\n<li>当节点类型相同时，去看一下属性是否相同，产生一个属性的补丁包，比如{type:’ATTRS’,attrs:{class: ‘list-group’}</li>\n<li>新的DOM节点不存在，也返回一个不存在的补丁包{type:’REMOVE’,index:XXX}</li>\n<li>文本的变化{type:’TEXT’, text:1}</li>\n</ol>\n<hr>\n<pre><code>//diff 算法\nlet Index = 0;\nfunction diff(oldTree, newTree) {\n    let patches = {};\n    let index = 0;\n    //递归数比较后的结果放到补丁包中\n    walk(oldTree, newTree, index, patches);\n    return patches;\n}\nfunction walk(oldTree, newTree, index, patches){\n    let currentPatch = [];//每个元素都有一个补丁对象\n    if (!newTree) {\n        currentPatch.push({type:&#39;REMOVE&#39;, index})\n    } \n    if (isString(oldTree) &amp;&amp; isString(newTree)) {\n        // 判断文本是否一致\n        if (oldTree !== newTree) {\n            currentPatch.push({type:&#39;TEXT&#39;,text:newTree}); \n        }\n    }else if(oldTree.type === newTree.type) {\n        //比较属性是否有更改\n        let attrs = diffAttr(oldTree.props, newTree.props);\n        if(Object.keys(attrs).length) {\n            currentPatch.push({type:&#39;ATTRS&#39;, attrs});\n        }\n        // 如果有儿子节点，遍历子节点\n          diffChildren(oldTree.children, newTree.children, index, patches);\n    } else {\n        // 节点类型不同的时候，直接替换\n        currentPatch.push({type:&#39;REPLACE&#39;, newTree});\n    }\n    // 当前元素有补丁的情况下，将元素和补丁对应起来，放到大补丁包中\n    if(currentPatch.length) {\n        patches[index] = currentPatch; \n    }\n}\nfunction diffAttr(oldAttrs, newAttrs) {\n    let patch = {};\n    for(let key in oldAttrs) {\n        if(oldAttrs[key] !== newAttrs[key]) {\n            patch[key] = newAttrs[key];//有可能是undefined，新节点没有旧节点的属性      \n        }\n    }\n    for(let key in newAttrs) {\n        //老节点没有新节点的属性\n        if(! oldAttrs.hasOwnProperty(key)) {\n            patch[key] = newAttrs[key]\n        }\n    }\n    return patch;\n}\n\nfunction diffChildren(oldChildren, newChildren, index, patches){\n    // 比较老的第一个和新的第一个\n    oldChildren.forEach((child, idx) =&gt; {\n        // 记得索引得改\n        // Index 每次传递给walk时，index是递增的，所有节点都基于一个序号实现，因此需要维护一个全局Index\n        walk(child, newChildren[idx], ++Index, patches);\n    }) \n}\n\n\nfunction isString(node) {\n    return Object.prototype.toString.call(node) === &#39;[object string]&#39;;\n}\n\n\nfunction patch(node, patches) {\n // 给某个元素打补丁\n\n}\n</code></pre><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>dom结构发生改变： 直接卸载并重新create</li>\n<li>dom结构一样： 不会卸载，但是会更新</li>\n<li>在同一层级的子节点，他们都可以通过key开区分【同时遵循上面两点】</li>\n</ul>\n<h2 id=\"衍生：\"><a href=\"#衍生：\" class=\"headerlink\" title=\"衍生：\"></a>衍生：</h2><h3 id=\"加了key的好处\"><a href=\"#加了key的好处\" class=\"headerlink\" title=\"加了key的好处:\"></a>加了key的好处:</h3><blockquote>\n<p>加了key值可以具体确定哪些元素被修改，便于对比新旧dom树，加快虚拟dom的渲染速度</p>\n</blockquote>\n<h3 id=\"我们该不该把map的index作为key\"><a href=\"#我们该不该把map的index作为key\" class=\"headerlink\" title=\"我们该不该把map的index作为key\"></a>我们该不该把map的index作为key</h3><blockquote>\n<p>最好将数据本身的id最为key值，如果使用index作为key值，如果前后两次两次arr分别为[1,2,3,4]和[5,6,7,8]和前后两次arr分别为[1,2,3,4]和[4,3,2,1]的情况,很明显前者可以认为是DOM改变了,后者可以认为是DOM节点的位移操作,那么对于第一种情况来说index作为key和没有key值无区别,但是第二种情况用index作为key值效果没有比用数据本身作为key值好</p>\n</blockquote>\n<h3 id=\"key值必须唯一且不重复么\"><a href=\"#key值必须唯一且不重复么\" class=\"headerlink\" title=\"key值必须唯一且不重复么\"></a>key值必须唯一且不重复么</h3><blockquote>\n<p>前提条件是是否为同一父节点</p>\n</blockquote>\n<hr>\n<blockquote>\n<p><a href=\"https://www.jianshu.com/p/8c1505ebcf0e\" target=\"_blank\" rel=\"noopener\">参考文章：飞飞廉的简书</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"浅谈React的最大亮点——虚拟DOM\"><a href=\"#浅谈React的最大亮点——虚拟DOM\" class=\"headerlink\" title=\"浅谈React的最大亮点——虚拟DOM\"></a>浅谈React的最大亮点——虚拟DOM</h2><p><strong>React非常快速是因为它从不直接操作DOM。</strong></p>\n<p><strong>虚拟DOM是在DOM的基础上建立了一个抽象层，对数据和状态所做的任何改动，都会被自动且高效的同步到虚拟DOM，最后再批量同步到DOM中。</strong></p>\n<p><strong>在React中，render执行的结果得到的并不是真正的DOM节点，而仅仅是JavaScript对象，称之为虚拟DOM。</strong></p>\n<p><strong>虚拟DOM具有批处理和高效的Diff算法，可以无需担心性能问题而随时“刷新”整个页面，因为虚拟DOM可以确保只对界面上真正变化的部分进行实际的DOM操作。</strong></p>\n<h2 id=\"虚拟DOM的原理：\"><a href=\"#虚拟DOM的原理：\" class=\"headerlink\" title=\"虚拟DOM的原理：\"></a>虚拟DOM的原理：</h2><p><strong>React会在内存中维护一个虚拟DOM树，对这个树进行读或写，实际上是对虚拟DOM进行。当数据变化时，React会自动更新虚拟DOM，然后将新的虚拟DOM和旧的虚拟DOM进行对比，找到变更的部分，得出一个diff，然后将diff放到一个队列里，最终批量更新这些diff到DOM中。</strong></p>\n<h2 id=\"虚拟DOM的优点：\"><a href=\"#虚拟DOM的优点：\" class=\"headerlink\" title=\"虚拟DOM的优点：\"></a>虚拟DOM的优点：</h2><p><strong>最终表现在DOM上的修改只是变更的部分，可以保证非常高效的渲染。</strong></p>\n<h2 id=\"虚拟DOM的缺点：\"><a href=\"#虚拟DOM的缺点：\" class=\"headerlink\" title=\"虚拟DOM的缺点：\"></a>虚拟DOM的缺点：</h2><p><strong>首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。</strong></p>\n<h2 id=\"虚拟DOM的理解误区\"><a href=\"#虚拟DOM的理解误区\" class=\"headerlink\" title=\"虚拟DOM的理解误区\"></a>虚拟DOM的理解误区</h2><p><strong>对虚拟DOM的理解往往停留在：通过JavaScript对象模拟原生DOM，加上DOM Diff 极大提升了DOM操作的性能。然而，虚拟DOM最大的意义不在于性能的提升（JavaScript对象比DOM对象性能高），而在于抽象了DOM的具体实现（对DOM进行了一层抽象），这在浏览器中使用 React时不是特别明显，因为写的DOM标签跟原生的没有区别，并且最终都被渲染成了DOM，在React Native中将会有很好的说明。</strong></p>\n<h2 id=\"模拟方法和渲染方法\"><a href=\"#模拟方法和渲染方法\" class=\"headerlink\" title=\"模拟方法和渲染方法\"></a>模拟方法和渲染方法</h2><blockquote>\n<p>调用</p>\n</blockquote>\n<pre><code>let virtualDom1 = createElement(&#39;ul&#39;, {class: &#39;list&#39;}, [\n    createElement(&#39;li&#39;, {class: &#39;item&#39;}, [&#39;a&#39;]),\n    createElement(&#39;li&#39;, {class: &#39;item&#39;}, [&#39;b&#39;]),\n    createElement(&#39;li&#39;, {class: &#39;item&#39;}, [&#39;c&#39;]),\n])\nlet virtualDom2 = createElement(&#39;ul&#39;, {class: &#39;list&#39;}, [\n    createElement(&#39;li&#39;, {class: &#39;item&#39;}, [&#39;1&#39;]),\n    createElement(&#39;li&#39;, {class: &#39;item&#39;}, [&#39;2&#39;]),\n    createElement(&#39;li&#39;, {class: &#39;item&#39;}, [&#39;3&#39;]),\n])\nlet el = render(virtualDom);\nrenderDom(el, window.root);\nlet patchs = diff(virtualDom1, virtualDom2);\n</code></pre><blockquote>\n<p>生成虚拟对象的方法createElement</p>\n</blockquote>\n<pre><code>function createElement(type, props, children) {\n    return new Element(type, props, children)\n}\nclass Element{\n    constructor(type, props, children){\n        this.type = type;\n        this.props = props;\n        this.children = children\n    }\n}\n</code></pre><blockquote>\n<p>将虚拟对象渲染成真实DOM的render方法</p>\n</blockquote>\n<pre><code>//render方法将vNode转化成真实DOM\nfunction render(eleObj){\n    //创建元素\n    let el = document.createElement(eleObj.type);\n    //设置属性\n    for(let key in eleObj.props) {\n        setAttr(el, key, eleObj.props[key]);\n    }\n    //递归渲染子元素\n    eleObj.children.foEach(child =&gt; {\n        child = child instanceof Element ? render(child) : document.createTextNode(child);\n        el.appendChild(child);\n    })\n}\nsetAttr(node, key, value) {\n    switch(key) {\n        case &#39;value&#39;:\n            if (node.tagName.toUpperCase() === &#39;INPUT&#39; || node.tagName.toUpperCase() === &#39;TEXTAREA&#39;) {\n                node.value = value;          \n            }else {\n                node.setAttribute(key, value);\n            }\n            break;\n        case &#39;style&#39;:\n            node.style.cssText = value;\n            break;\n        default:\n            node.setAttribute(key, value);\n            break;\n    }\n}\n</code></pre><blockquote>\n<p>渲染节点到页面的方法renderDom</p>\n</blockquote>\n<pre><code>//将真实DOM渲染到页面\nfunction renderDom(el, target) {\n    target.appendChild(el);\n}\n</code></pre><h2 id=\"DOM-DIFF-算法\"><a href=\"#DOM-DIFF-算法\" class=\"headerlink\" title=\"DOM DIFF 算法\"></a>DOM DIFF 算法</h2><p><strong>DOM DIFF 就是比较两个虚拟DOM的区别，实际上就是比较两个对象的区别。根据两个虚拟对象创建出补丁，描述改变的内容。将这个补丁用来更新DOM。</strong></p>\n<blockquote>\n<p>【注意】不会更改所有节点，只更改有改变的部分</p>\n</blockquote>\n<h3 id=\"算法实现\"><a href=\"#算法实现\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h3><blockquote>\n<p>差异计算：先序深度优先遍历</p>\n</blockquote>\n<h4 id=\"规则：\"><a href=\"#规则：\" class=\"headerlink\" title=\"规则：\"></a>规则：</h4><ol>\n<li>若节点类型不相同，直接采用替换模式，{type:’REPLACE’,newNode:newNode}</li>\n<li>当节点类型相同时，去看一下属性是否相同，产生一个属性的补丁包，比如{type:’ATTRS’,attrs:{class: ‘list-group’}</li>\n<li>新的DOM节点不存在，也返回一个不存在的补丁包{type:’REMOVE’,index:XXX}</li>\n<li>文本的变化{type:’TEXT’, text:1}</li>\n</ol>\n<hr>\n<pre><code>//diff 算法\nlet Index = 0;\nfunction diff(oldTree, newTree) {\n    let patches = {};\n    let index = 0;\n    //递归数比较后的结果放到补丁包中\n    walk(oldTree, newTree, index, patches);\n    return patches;\n}\nfunction walk(oldTree, newTree, index, patches){\n    let currentPatch = [];//每个元素都有一个补丁对象\n    if (!newTree) {\n        currentPatch.push({type:&#39;REMOVE&#39;, index})\n    } \n    if (isString(oldTree) &amp;&amp; isString(newTree)) {\n        // 判断文本是否一致\n        if (oldTree !== newTree) {\n            currentPatch.push({type:&#39;TEXT&#39;,text:newTree}); \n        }\n    }else if(oldTree.type === newTree.type) {\n        //比较属性是否有更改\n        let attrs = diffAttr(oldTree.props, newTree.props);\n        if(Object.keys(attrs).length) {\n            currentPatch.push({type:&#39;ATTRS&#39;, attrs});\n        }\n        // 如果有儿子节点，遍历子节点\n          diffChildren(oldTree.children, newTree.children, index, patches);\n    } else {\n        // 节点类型不同的时候，直接替换\n        currentPatch.push({type:&#39;REPLACE&#39;, newTree});\n    }\n    // 当前元素有补丁的情况下，将元素和补丁对应起来，放到大补丁包中\n    if(currentPatch.length) {\n        patches[index] = currentPatch; \n    }\n}\nfunction diffAttr(oldAttrs, newAttrs) {\n    let patch = {};\n    for(let key in oldAttrs) {\n        if(oldAttrs[key] !== newAttrs[key]) {\n            patch[key] = newAttrs[key];//有可能是undefined，新节点没有旧节点的属性      \n        }\n    }\n    for(let key in newAttrs) {\n        //老节点没有新节点的属性\n        if(! oldAttrs.hasOwnProperty(key)) {\n            patch[key] = newAttrs[key]\n        }\n    }\n    return patch;\n}\n\nfunction diffChildren(oldChildren, newChildren, index, patches){\n    // 比较老的第一个和新的第一个\n    oldChildren.forEach((child, idx) =&gt; {\n        // 记得索引得改\n        // Index 每次传递给walk时，index是递增的，所有节点都基于一个序号实现，因此需要维护一个全局Index\n        walk(child, newChildren[idx], ++Index, patches);\n    }) \n}\n\n\nfunction isString(node) {\n    return Object.prototype.toString.call(node) === &#39;[object string]&#39;;\n}\n\n\nfunction patch(node, patches) {\n // 给某个元素打补丁\n\n}\n</code></pre><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>dom结构发生改变： 直接卸载并重新create</li>\n<li>dom结构一样： 不会卸载，但是会更新</li>\n<li>在同一层级的子节点，他们都可以通过key开区分【同时遵循上面两点】</li>\n</ul>\n<h2 id=\"衍生：\"><a href=\"#衍生：\" class=\"headerlink\" title=\"衍生：\"></a>衍生：</h2><h3 id=\"加了key的好处\"><a href=\"#加了key的好处\" class=\"headerlink\" title=\"加了key的好处:\"></a>加了key的好处:</h3><blockquote>\n<p>加了key值可以具体确定哪些元素被修改，便于对比新旧dom树，加快虚拟dom的渲染速度</p>\n</blockquote>\n<h3 id=\"我们该不该把map的index作为key\"><a href=\"#我们该不该把map的index作为key\" class=\"headerlink\" title=\"我们该不该把map的index作为key\"></a>我们该不该把map的index作为key</h3><blockquote>\n<p>最好将数据本身的id最为key值，如果使用index作为key值，如果前后两次两次arr分别为[1,2,3,4]和[5,6,7,8]和前后两次arr分别为[1,2,3,4]和[4,3,2,1]的情况,很明显前者可以认为是DOM改变了,后者可以认为是DOM节点的位移操作,那么对于第一种情况来说index作为key和没有key值无区别,但是第二种情况用index作为key值效果没有比用数据本身作为key值好</p>\n</blockquote>\n<h3 id=\"key值必须唯一且不重复么\"><a href=\"#key值必须唯一且不重复么\" class=\"headerlink\" title=\"key值必须唯一且不重复么\"></a>key值必须唯一且不重复么</h3><blockquote>\n<p>前提条件是是否为同一父节点</p>\n</blockquote>\n<hr>\n<blockquote>\n<p><a href=\"https://www.jianshu.com/p/8c1505ebcf0e\" target=\"_blank\" rel=\"noopener\">参考文章：飞飞廉的简书</a></p>\n</blockquote>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ck11iam5v0000n4wd8olrrnji","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam6k000gn4wdyeeey5do"},{"post_id":"ck11iam5v0000n4wd8olrrnji","tag_id":"ck11iam6c000an4wdms0h6bh0","_id":"ck11iam6l000in4wdbwh04nzn"},{"post_id":"ck11iam610002n4wdb0vf89x0","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam6q000on4wdi67mzzw3"},{"post_id":"ck11iam610002n4wdb0vf89x0","tag_id":"ck11iam6m000jn4wdk6qbbwo8","_id":"ck11iam6r000qn4wd452zsbg5"},{"post_id":"ck11iam660005n4wdcqebd1xp","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam6v000wn4wdgjtorceh"},{"post_id":"ck11iam660005n4wdcqebd1xp","tag_id":"ck11iam6s000rn4wdql9y066q","_id":"ck11iam6w000yn4wd959zpw5e"},{"post_id":"ck11iam680007n4wdp6vwyyrj","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam6x0011n4wdyw4n4x1r"},{"post_id":"ck11iam680007n4wdp6vwyyrj","tag_id":"ck11iam6u000un4wd4drs7co0","_id":"ck11iam6y0013n4wdihtnibho"},{"post_id":"ck11iam6b0009n4wd81zym9nj","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam720017n4wdxanp8fq7"},{"post_id":"ck11iam6b0009n4wd81zym9nj","tag_id":"ck11iam6x0010n4wdk7zs3my9","_id":"ck11iam740019n4wdhmsibxu4"},{"post_id":"ck11iam6f000cn4wdjfruu02l","tag_id":"ck11iam700015n4wdzdkhpgoz","_id":"ck11iam78001fn4wdtwwj3rpc"},{"post_id":"ck11iam6f000cn4wdjfruu02l","tag_id":"ck11iam75001an4wde9l8kfbh","_id":"ck11iam79001hn4wd8h4ppf57"},{"post_id":"ck11iam76001cn4wdc3mhf1z7","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam7a001kn4wdskuftqb2"},{"post_id":"ck11iam76001cn4wdc3mhf1z7","tag_id":"ck11iam75001an4wde9l8kfbh","_id":"ck11iam7b001mn4wd7546uonz"},{"post_id":"ck11iam7a001ln4wdhemv9ooh","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam7c001pn4wdesjjzek8"},{"post_id":"ck11iam7a001ln4wdhemv9ooh","tag_id":"ck11iam6m000jn4wdk6qbbwo8","_id":"ck11iam7d001rn4wdbolbzuiu"},{"post_id":"ck11iam6g000dn4wd5i8ku2on","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam7e001un4wdbnh9o5m9"},{"post_id":"ck11iam6g000dn4wd5i8ku2on","tag_id":"ck11iam76001dn4wd1npvxeil","_id":"ck11iam7g001wn4wd595zkikj"},{"post_id":"ck11iam6g000dn4wd5i8ku2on","tag_id":"ck11iam79001jn4wd2quubl6h","_id":"ck11iam7h001yn4wdytuwnc6f"},{"post_id":"ck11iam6j000fn4wdmhok7la8","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam7i0021n4wdt3b2sijq"},{"post_id":"ck11iam6j000fn4wdmhok7la8","tag_id":"ck11iam7c001on4wd6crizedf","_id":"ck11iam7k0023n4wd6wns4dwx"},{"post_id":"ck11iam7d001sn4wdib69s8bp","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam7m0026n4wdn321n1t3"},{"post_id":"ck11iam7d001sn4wdib69s8bp","tag_id":"ck11iam7c001on4wd6crizedf","_id":"ck11iam7n0028n4wdu9laojee"},{"post_id":"ck11iam7f001vn4wdobvpgkgy","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam7p002bn4wduixn4xqe"},{"post_id":"ck11iam7f001vn4wdobvpgkgy","tag_id":"ck11iam7c001on4wd6crizedf","_id":"ck11iam7q002dn4wdp5ka1gin"},{"post_id":"ck11iam6l000hn4wdgsnfj805","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam7r002gn4wdgih30ovy"},{"post_id":"ck11iam6l000hn4wdgsnfj805","tag_id":"ck11iam7e001tn4wdrrms7o8a","_id":"ck11iam7t002in4wdhjczbwib"},{"post_id":"ck11iam6n000kn4wdm10vua2b","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam7u002ln4wd6rp9igph"},{"post_id":"ck11iam6n000kn4wdm10vua2b","tag_id":"ck11iam7h001zn4wdyb4wxdu9","_id":"ck11iam7v002nn4wdspfwh0ak"},{"post_id":"ck11iam7k0024n4wd9ekrjp1r","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam7x002qn4wd95q9a7sk"},{"post_id":"ck11iam7k0024n4wd9ekrjp1r","tag_id":"ck11iam7c001on4wd6crizedf","_id":"ck11iam7y002sn4wdi107aztg"},{"post_id":"ck11iam6p000nn4wdu9ho4wfc","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam7z002un4wdiak1tm3t"},{"post_id":"ck11iam6p000nn4wdu9ho4wfc","tag_id":"ck11iam75001an4wde9l8kfbh","_id":"ck11iam81002xn4wdtin6zgb2"},{"post_id":"ck11iam6p000nn4wdu9ho4wfc","tag_id":"ck11iam7o002an4wdlq09d1fm","_id":"ck11iam83002zn4wdvacn0seo"},{"post_id":"ck11iam7v002on4wdnva3m3er","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam840032n4wdgrt2pt29"},{"post_id":"ck11iam7v002on4wdnva3m3er","tag_id":"ck11iam75001an4wde9l8kfbh","_id":"ck11iam850034n4wd399r8soj"},{"post_id":"ck11iam7x002rn4wd3jw98hum","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam870037n4wd2htwno48"},{"post_id":"ck11iam7x002rn4wd3jw98hum","tag_id":"ck11iam75001an4wde9l8kfbh","_id":"ck11iam8a0039n4wd1i41hngu"},{"post_id":"ck11iam6r000pn4wdsof7463u","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam8a003bn4wdhrynfanr"},{"post_id":"ck11iam6r000pn4wdsof7463u","tag_id":"ck11iam75001an4wde9l8kfbh","_id":"ck11iam8b003cn4wdhej4cn4t"},{"post_id":"ck11iam6r000pn4wdsof7463u","tag_id":"ck11iam7u002kn4wde0uz89bs","_id":"ck11iam8b003en4wdmicue9e7"},{"post_id":"ck11iam6r000pn4wdsof7463u","tag_id":"ck11iam7w002pn4wdro1wk803","_id":"ck11iam8c003fn4wdlrwfe82j"},{"post_id":"ck11iam7y002tn4wdh92jqgk5","tag_id":"ck11iam7c001on4wd6crizedf","_id":"ck11iam8c003gn4wd8lfxqmu1"},{"post_id":"ck11iam7y002tn4wdh92jqgk5","tag_id":"ck11iam75001an4wde9l8kfbh","_id":"ck11iam8c003in4wdpdjgwam3"},{"post_id":"ck11iam82002yn4wdxsqkkaic","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam8d003jn4wdgmvz3326"},{"post_id":"ck11iam82002yn4wdxsqkkaic","tag_id":"ck11iam75001an4wde9l8kfbh","_id":"ck11iam8d003ln4wdiqahwqz8"},{"post_id":"ck11iam850035n4wdnnxv9mrz","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam8d003mn4wdb7s0fkom"},{"post_id":"ck11iam850035n4wdnnxv9mrz","tag_id":"ck11iam700015n4wdzdkhpgoz","_id":"ck11iam8e003on4wd9pgehbsk"},{"post_id":"ck11iam850035n4wdnnxv9mrz","tag_id":"ck11iam75001an4wde9l8kfbh","_id":"ck11iam8e003pn4wdgzkr6l0q"},{"post_id":"ck11iam6s000sn4wd2uk6t1vh","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam8f003rn4wdy5o3qfvv"},{"post_id":"ck11iam6s000sn4wd2uk6t1vh","tag_id":"ck11iam80002vn4wdv35i56dk","_id":"ck11iam8f003sn4wd4r29b1nh"},{"post_id":"ck11iam6s000sn4wd2uk6t1vh","tag_id":"ck11iam830031n4wdsiq5ya41","_id":"ck11iam8f003tn4wde92kflrg"},{"post_id":"ck11iam6s000sn4wd2uk6t1vh","tag_id":"ck11iam870036n4wdx9hwp3g3","_id":"ck11iam8g003vn4wd0uuwc8y2"},{"post_id":"ck11iam6t000tn4wdqprras0v","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam8g003wn4wdydgy5gbl"},{"post_id":"ck11iam6t000tn4wdqprras0v","tag_id":"ck11iam75001an4wde9l8kfbh","_id":"ck11iam8g003yn4wd36jw0iuw"},{"post_id":"ck11iam6t000tn4wdqprras0v","tag_id":"ck11iam8b003dn4wdhkrx87nd","_id":"ck11iam8h003zn4wd6v3hwuh2"},{"post_id":"ck11iam6u000vn4wdwdqw1fq5","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam8h0041n4wdi15bfndf"},{"post_id":"ck11iam6u000vn4wdwdqw1fq5","tag_id":"ck11iam8c003hn4wdwy59cu50","_id":"ck11iam8i0042n4wdmsytivlb"},{"post_id":"ck11iam6w000zn4wdpo5tgn8c","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam8i0044n4wdj00i7yzx"},{"post_id":"ck11iam6w000zn4wdpo5tgn8c","tag_id":"ck11iam8d003kn4wd9xojh0m4","_id":"ck11iam8i0045n4wdqjfhtcpd"},{"post_id":"ck11iam6x0012n4wdbpd48shf","tag_id":"ck11iam8e003nn4wdcwvqcdnw","_id":"ck11iam8j0047n4wdi4q10cs3"},{"post_id":"ck11iam6x0012n4wdbpd48shf","tag_id":"ck11iam8e003qn4wdld5dc2zh","_id":"ck11iam8j0048n4wdakmrrndv"},{"post_id":"ck11iam6z0014n4wd3r9q8cwo","tag_id":"ck11iam8f003un4wd0hrgb47a","_id":"ck11iam8j0049n4wdqj7lq5e5"},{"post_id":"ck11iam6z0014n4wd3r9q8cwo","tag_id":"ck11iam8g003xn4wd7x1pt9f2","_id":"ck11iam8k004bn4wd8elhfkny"},{"post_id":"ck11iam710016n4wdqxj7739a","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam8k004cn4wdian4b3uu"},{"post_id":"ck11iam710016n4wdqxj7739a","tag_id":"ck11iam75001an4wde9l8kfbh","_id":"ck11iam8l004en4wdavdoe5fe"},{"post_id":"ck11iam710016n4wdqxj7739a","tag_id":"ck11iam8i0043n4wd65tibaxs","_id":"ck11iam8l004fn4wdvea887w9"},{"post_id":"ck11iam730018n4wdz7yu9pw4","tag_id":"ck11iam8j0046n4wd1gjhp8g3","_id":"ck11iam8m004hn4wd08ezugvi"},{"post_id":"ck11iam730018n4wdz7yu9pw4","tag_id":"ck11iam8k004an4wd72b87o3o","_id":"ck11iam8m004in4wdms696d9f"},{"post_id":"ck11iam75001bn4wdcy6678s5","tag_id":"ck11iam8e003nn4wdcwvqcdnw","_id":"ck11iam8n004kn4wd7kuhb43m"},{"post_id":"ck11iam75001bn4wdcy6678s5","tag_id":"ck11iam8k004an4wd72b87o3o","_id":"ck11iam8n004ln4wdfxsfk1yt"},{"post_id":"ck11iam77001en4wdvdk3fjfo","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam8n004nn4wd3pbqm0ie"},{"post_id":"ck11iam77001en4wdvdk3fjfo","tag_id":"ck11iam8f003un4wd0hrgb47a","_id":"ck11iam8o004on4wdnnlgoi4k"},{"post_id":"ck11iam78001gn4wdxb4knzga","tag_id":"ck11iam8f003un4wd0hrgb47a","_id":"ck11iam8p004rn4wdxhgs62yh"},{"post_id":"ck11iam78001gn4wdxb4knzga","tag_id":"ck11iam8k004an4wd72b87o3o","_id":"ck11iam8p004sn4wdlfoo9t44"},{"post_id":"ck11iam79001in4wda7frtoql","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam8q004un4wdz9v5kqhw"},{"post_id":"ck11iam79001in4wda7frtoql","tag_id":"ck11iam8o004qn4wdrp564dp0","_id":"ck11iam8q004vn4wdpg5enjqk"},{"post_id":"ck11iam7b001nn4wddcal5dyi","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam8r004yn4wdd19j4phv"},{"post_id":"ck11iam7b001nn4wddcal5dyi","tag_id":"ck11iam75001an4wde9l8kfbh","_id":"ck11iam8r004zn4wdgg3rlouc"},{"post_id":"ck11iam7b001nn4wddcal5dyi","tag_id":"ck11iam8p004tn4wdhlu6d8w0","_id":"ck11iam8s0051n4wd1kwqwqbu"},{"post_id":"ck11iam7b001nn4wddcal5dyi","tag_id":"ck11iam8q004wn4wd4r6uy738","_id":"ck11iam8t0052n4wdy41t2bao"},{"post_id":"ck11iam7c001qn4wd803ilnbi","tag_id":"ck11iam8q004xn4wd5t6a9kri","_id":"ck11iam8t0054n4wdrt8w2tfj"},{"post_id":"ck11iam7g001xn4wdd2kfapp5","tag_id":"ck11iam8q004xn4wd5t6a9kri","_id":"ck11iam8t0055n4wdg6dcna6q"},{"post_id":"ck11iam7h0020n4wdabj9bkcl","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam940058n4wddepxj6yj"},{"post_id":"ck11iam7h0020n4wdabj9bkcl","tag_id":"ck11iam8t0053n4wdy3quc7ue","_id":"ck11iam940059n4wd6relauec"},{"post_id":"ck11iam7h0020n4wdabj9bkcl","tag_id":"ck11iam8u0056n4wd6ggp8iay","_id":"ck11iam95005bn4wdkh9vpc69"},{"post_id":"ck11iam7i0022n4wdptfs3c6a","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam95005cn4wdqteml8ad"},{"post_id":"ck11iam7i0022n4wdptfs3c6a","tag_id":"ck11iam940057n4wdu8gc0eoz","_id":"ck11iam96005en4wdbzqcgduo"},{"post_id":"ck11iam7m0027n4wdcv1lcj6x","tag_id":"ck11iam95005an4wd1ffr8f5k","_id":"ck11iam96005fn4wdkifivlza"},{"post_id":"ck11iam7m0027n4wdcv1lcj6x","tag_id":"ck11iam75001an4wde9l8kfbh","_id":"ck11iam97005hn4wdnlzyzc6k"},{"post_id":"ck11iam7n0029n4wdstwbgr1s","tag_id":"ck11iam96005dn4wds7pi0jh3","_id":"ck11iam98005kn4wdtbr7t26f"},{"post_id":"ck11iam7n0029n4wdstwbgr1s","tag_id":"ck11iam96005gn4wd0linxaiq","_id":"ck11iam98005ln4wd2kvrqokz"},{"post_id":"ck11iam7n0029n4wdstwbgr1s","tag_id":"ck11iam97005in4wdv8gcabbt","_id":"ck11iam99005nn4wd20tolzye"},{"post_id":"ck11iam7p002cn4wdaapl0zux","tag_id":"ck11iam97005jn4wdo71bv04a","_id":"ck11iam99005on4wd7xpyw2h3"},{"post_id":"ck11iam7q002en4wdfvc7runm","tag_id":"ck11iam97005jn4wdo71bv04a","_id":"ck11iam99005qn4wddhfebxh6"},{"post_id":"ck11iam7s002hn4wdc2yatsv6","tag_id":"ck11iam99005pn4wde7202wmk","_id":"ck11iam9b005vn4wdougey9ji"},{"post_id":"ck11iam7s002hn4wdc2yatsv6","tag_id":"ck11iam75001an4wde9l8kfbh","_id":"ck11iam9b005wn4wdx42zcnq0"},{"post_id":"ck11iam7s002hn4wdc2yatsv6","tag_id":"ck11iam9a005rn4wd7zhcvnwv","_id":"ck11iam9c005yn4wdavb1dy5l"},{"post_id":"ck11iam7s002hn4wdc2yatsv6","tag_id":"ck11iam9a005sn4wd46irii2p","_id":"ck11iam9c005zn4wdhd34zy48"},{"post_id":"ck11iam7s002hn4wdc2yatsv6","tag_id":"ck11iam9a005tn4wdj8vf1a4i","_id":"ck11iam9c0061n4wdvj0qkh60"},{"post_id":"ck11iam7t002jn4wdnszez2dt","tag_id":"ck11iam9b005un4wdy45wq90o","_id":"ck11iam9d0062n4wdijqoymsn"},{"post_id":"ck11iam7t002jn4wdnszez2dt","tag_id":"ck11iam75001an4wde9l8kfbh","_id":"ck11iam9d0064n4wdg9n3r724"},{"post_id":"ck11iam7t002jn4wdnszez2dt","tag_id":"ck11iam9b005xn4wducmamc3f","_id":"ck11iam9d0065n4wdmko81r9z"},{"post_id":"ck11iam7u002mn4wd0qxnl7mr","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam9e0066n4wdiua7i575"},{"post_id":"ck11iam7u002mn4wd0qxnl7mr","tag_id":"ck11iam75001an4wde9l8kfbh","_id":"ck11iam9e0068n4wdk4r2xe0m"},{"post_id":"ck11iam7u002mn4wd0qxnl7mr","tag_id":"ck11iam9c0060n4wdeo39ttzc","_id":"ck11iam9f0069n4wdiruf9p1v"},{"post_id":"ck11iam80002wn4wdxwep66ju","tag_id":"ck11iam9d0063n4wd81dmfhei","_id":"ck11iam9f006bn4wdrgyx9d3t"},{"post_id":"ck11iam80002wn4wdxwep66ju","tag_id":"ck11iam75001an4wde9l8kfbh","_id":"ck11iam9g006cn4wdq3ejy3q5"},{"post_id":"ck11iam830030n4wd7komr8gx","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam9g006en4wdz54h7yof"},{"post_id":"ck11iam830030n4wd7komr8gx","tag_id":"ck11iam9e0067n4wdflkugq83","_id":"ck11iam9h006fn4wduiesg4te"},{"post_id":"ck11iam830030n4wd7komr8gx","tag_id":"ck11iam9f006an4wdrtgj8g12","_id":"ck11iam9h006hn4wdu95mgo9h"},{"post_id":"ck11iam840033n4wdf2fcmjbr","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iam9i006in4wdzl7uc2za"},{"post_id":"ck11iam840033n4wdf2fcmjbr","tag_id":"ck11iam9g006dn4wdr8sqnjf3","_id":"ck11iam9i006kn4wd5d6pg99s"},{"post_id":"ck11iam840033n4wdf2fcmjbr","tag_id":"ck11iam75001an4wde9l8kfbh","_id":"ck11iam9i006ln4wdw5i2pv1b"},{"post_id":"ck11iam870038n4wddjah2lgf","tag_id":"ck11iam9h006gn4wd05fk9ghe","_id":"ck11iam9j006mn4wd55yqd27h"},{"post_id":"ck11iam870038n4wddjah2lgf","tag_id":"ck11iam9i006jn4wdjmnwi09k","_id":"ck11iam9j006nn4wdd9xhu5ve"},{"post_id":"ck11iamdp006pn4wd5asa8nkx","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iamdu006sn4wdiu21gg7f"},{"post_id":"ck11iamdp006pn4wd5asa8nkx","tag_id":"ck11iam7c001on4wd6crizedf","_id":"ck11iamdv006un4wdniv4p53r"},{"post_id":"ck11iamdt006rn4wdgm6emj6l","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iamdx006wn4wd828k1xis"},{"post_id":"ck11iamdt006rn4wdgm6emj6l","tag_id":"ck11iam7c001on4wd6crizedf","_id":"ck11iamdy006xn4wd6fsutrlb"},{"post_id":"ck11iamdu006tn4wdcleo365j","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iamdy006yn4wd1gz0fp58"},{"post_id":"ck11iamdu006tn4wdcleo365j","tag_id":"ck11iam7c001on4wd6crizedf","_id":"ck11iamdy006zn4wdreivkseg"},{"post_id":"ck11iamdm006on4wdutwebgd1","tag_id":"ck11iamds006qn4wdkz6qmxgo","_id":"ck11iamdz0070n4wdsn3bm1qc"},{"post_id":"ck11iamdm006on4wdutwebgd1","tag_id":"ck11iam7c001on4wd6crizedf","_id":"ck11iamdz0071n4wdj3c9evg7"},{"post_id":"ck11iamdv006vn4wdpoqwr4gv","tag_id":"ck11iam640004n4wdgtd63sdg","_id":"ck11iamdz0072n4wd3cskzjno"},{"post_id":"ck11iamdv006vn4wdpoqwr4gv","tag_id":"ck11iam7c001on4wd6crizedf","_id":"ck11iame00073n4wdta3ptlgi"}],"Tag":[{"name":"js","_id":"ck11iam640004n4wdgtd63sdg"},{"name":"object","_id":"ck11iam6c000an4wdms0h6bh0"},{"name":"兼容与优化","_id":"ck11iam6m000jn4wdk6qbbwo8"},{"name":"Event","_id":"ck11iam6s000rn4wdql9y066q"},{"name":"mvvm","_id":"ck11iam6u000un4wd4drs7co0"},{"name":"Linux","_id":"ck11iam6x0010n4wdk7zs3my9"},{"name":"vue-router","_id":"ck11iam700015n4wdzdkhpgoz"},{"name":"vue","_id":"ck11iam75001an4wde9l8kfbh"},{"name":"sort","_id":"ck11iam76001dn4wd1npvxeil"},{"name":"排序","_id":"ck11iam79001jn4wd2quubl6h"},{"name":"react","_id":"ck11iam7c001on4wd6crizedf"},{"name":"ajax","_id":"ck11iam7e001tn4wdrrms7o8a"},{"name":"拷贝","_id":"ck11iam7h001zn4wdyb4wxdu9"},{"name":"axios","_id":"ck11iam7o002an4wdlq09d1fm"},{"name":"debouce","_id":"ck11iam7u002kn4wde0uz89bs"},{"name":"throttle","_id":"ck11iam7w002pn4wdro1wk803"},{"name":"cors","_id":"ck11iam80002vn4wdv35i56dk"},{"name":"跨域","_id":"ck11iam830031n4wdsiq5ya41"},{"name":"jsonp","_id":"ck11iam870036n4wdx9hwp3g3"},{"name":"定位","_id":"ck11iam8b003dn4wdhkrx87nd"},{"name":"fetch","_id":"ck11iam8c003hn4wdwy59cu50"},{"name":"extend","_id":"ck11iam8d003kn4wd9xojh0m4"},{"name":"nginx","_id":"ck11iam8e003nn4wdcwvqcdnw"},{"name":"gzip","_id":"ck11iam8e003qn4wdld5dc2zh"},{"name":"node","_id":"ck11iam8f003un4wd0hrgb47a"},{"name":"koa","_id":"ck11iam8g003xn4wd7x1pt9f2"},{"name":"json web token","_id":"ck11iam8i0043n4wd65tibaxs"},{"name":"mysql","_id":"ck11iam8j0046n4wd1gjhp8g3"},{"name":"linux服务器配置","_id":"ck11iam8k004an4wd72b87o3o"},{"name":"mvc","_id":"ck11iam8o004qn4wdrp564dp0"},{"name":"vue-cli","_id":"ck11iam8p004tn4wdhlu6d8w0"},{"name":"px2rem","_id":"ck11iam8q004wn4wd4r6uy738"},{"name":"react-native","_id":"ck11iam8q004xn4wd5t6a9kri"},{"name":"session","_id":"ck11iam8t0053n4wdy3quc7ue"},{"name":"cookie","_id":"ck11iam8u0056n4wd6ggp8iay"},{"name":"堆&栈","_id":"ck11iam940057n4wdu8gc0eoz"},{"name":"transfrom","_id":"ck11iam95005an4wd1ffr8f5k"},{"name":"css","_id":"ck11iam96005dn4wds7pi0jh3"},{"name":"scss","_id":"ck11iam96005gn4wd0linxaiq"},{"name":"sass","_id":"ck11iam97005in4wdv8gcabbt"},{"name":"ts","_id":"ck11iam97005jn4wdo71bv04a"},{"name":"vue全局组件","_id":"ck11iam99005pn4wde7202wmk"},{"name":"vue指令","_id":"ck11iam9a005rn4wd7zhcvnwv"},{"name":"vue过滤器","_id":"ck11iam9a005sn4wd46irii2p"},{"name":"directive","_id":"ck11iam9a005tn4wdj8vf1a4i"},{"name":"vue构造器","_id":"ck11iam9b005un4wdy45wq90o"},{"name":"vue extend","_id":"ck11iam9b005xn4wducmamc3f"},{"name":"slot","_id":"ck11iam9c0060n4wdeo39ttzc"},{"name":"dom","_id":"ck11iam9d0063n4wd81dmfhei"},{"name":"前后端交互","_id":"ck11iam9e0067n4wdflkugq83"},{"name":"Restful","_id":"ck11iam9f006an4wdrtgj8g12"},{"name":"vuex","_id":"ck11iam9g006dn4wdr8sqnjf3"},{"name":"wx","_id":"ck11iam9h006gn4wd05fk9ghe"},{"name":"瀑布流","_id":"ck11iam9i006jn4wdjmnwi09k"},{"name":"hooks","_id":"ck11iamds006qn4wdkz6qmxgo"}]}}