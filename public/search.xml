<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[🌑Flutter 页面导航及打包🌑]]></title>
    <url>%2F2019%2F10%2F12%2FFlutter_navigation%2F</url>
    <content type="text"><![CDATA[🌑Flutter 页面导航及打包🌑🌓一般页面导航和返回RaisedButton按钮组件 child： 可以放入容器，图标，文字 onPressed：点击的相应事件，一般会调用Navigator组件 Navigator.push和Navigator.pop Navigator.push: 是跳转到下一个页面，他要接受两个参数一个是上下文的context，另一个是要跳转的函数 Navigator.pop: 是返回到上一个页面，使用时传递一个context（上下文参数），使用的时候要注意是，你必须有上级页面，也就是说上级页面使用了Navgitor.push import &#39;package:flutter/material.dart&#39;; void main() =&gt; runApp(MaterialApp( title:&#39;导航演示1&#39;, home:Home() )); class Home extends StatelessWidget{ @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: Text(&#39;首页&#39;),), body: Center( child: RaisedButton( onPressed: (){ Navigator.push(context,MaterialPageRoute(builder: (context) =&gt; new Detail())); }, child: Text(&#39;跳转到商品详情页&#39;), ), ), ); } } class Detail extends StatelessWidget{ @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: Text(&#39;商品详情页&#39;),), body: Center( child: RaisedButton( onPressed: (){ Navigator.pop(context); }, child: Text(&#39;该回去了，老弟&#39;), ), ), ); } } 🌔导航参数的传递和接受import &#39;package:flutter/material.dart&#39;; void main() =&gt; runApp(MaterialApp( title:&#39;导航演示1&#39;, home:TextWidget() )); // 创建一个列表 class MyList extends StatelessWidget{ final List&lt;String&gt; items = new List&lt;String&gt;.generate(1000, (i)=&gt; &quot;Item $i&quot;); @override Widget build(BuildContext context) { return ListView.builder( itemCount:items.length, itemBuilder:(context,index){ return new ListTile( title:new Text(&#39;${items[index]}&#39;), onTap: () { Navigator.push( context, MaterialPageRoute( builder: (context) =&gt; Detail(value: items[index]) // 传递参数 ) ); }, ); } ); } } class TextWidget extends StatelessWidget { @override Widget build(BuildContext context) { return MaterialApp( title: &quot;Flutter Demo&quot;, theme: ThemeData( primaryColor: Colors.blue, ), home: Scaffold( appBar: AppBar(title: Text(&quot;首页1&quot;)), body: Center( child: Container( child: MyList() // 调用列表组件 ), ), ), ); } } class Detail extends StatelessWidget{ final String value; Detail({Key key,@required this.value}):super(key:key); // 接受参数 @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: Text(&#39;商品详情页&#39;),), body: Center( child: RaisedButton( onPressed: (){ Navigator.pop(context); }, child: Text(&#39;来了，老弟 $value&#39;), ), ), ); } } 🌙页面跳转并返回数据 实际开发我们可能遇到这种需求，列表页跳转到详情页，详情页在跳转到列表页，需要把详情页的某些数据传递到列表页 先贴出代码 import &#39;package:flutter/material.dart&#39;; void main() =&gt; runApp(MaterialApp( title:&#39;导航演示1&#39;, home:TextWidget() )); class MyList extends StatelessWidget{ final List&lt;String&gt; items = new List&lt;String&gt;.generate(1000, (i)=&gt; &quot;Item $i&quot;); @override Widget build(BuildContext context) { return ListView.builder( itemCount:items.length, itemBuilder:(context,index){ return new ListTile( title:new Text(&#39;${items[index]}&#39;), onTap: () { _navigatoreto(context, items, index); }, ); } ); } _navigatoreto(BuildContext context, List&lt;String&gt; items, index) async{ final result = await Navigator.push( context, MaterialPageRoute( builder: (context) =&gt; Detail(value: items[index],) ) ); Scaffold.of(context).showSnackBar(SnackBar(content: Text(&#39;$result&#39;),)); } } class TextWidget extends StatelessWidget { @override Widget build(BuildContext context) { return MaterialApp( title: &quot;Flutter Demo&quot;, theme: ThemeData( primaryColor: Colors.blue, ), home: Scaffold( appBar: AppBar(title: Text(&quot;首页1&quot;)), body: Center( child: Container( child: MyList() // 调用列表组件 ), ), ), ); } } class Detail extends StatelessWidget{ final String value; Detail({Key key,@required this.value}):super(key:key); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: Text(&#39;商品详情页&#39;),), body: Center( child: RaisedButton( onPressed: (){ Navigator.pop(context, &#39;恭喜你选中了$value&#39;); }, child: Text(&#39;来了，老弟 $value&#39;), ), ), ); } } 异步请求和等待 Dart中的异步请求和ES6中的方法很像，可以直接使用async await就可以实现 _navigatoreto(BuildContext context, List&lt;String&gt; items, index) async{ final result = await Navigator.push( // 这是一个异步的方法，我们等这个方法执行完毕以后，【等待结果回来】 context, MaterialPageRoute( builder: (context) =&gt; Detail(value: items[index],) ) ); Scaffold.of(context).showSnackBar(SnackBar(content: Text(&#39;$result&#39;),)); // 我们在显示具体内容 } SnackBar的使用 SnackBar使用户操作以后，显示提示信息的一个控件，类似Toast，会自动隐藏，SnackBar是以Scaffold的showSnackBar的方法来进行显示的 Scaffold.of(context).showSnackBar(SnackBar(content: Text(&#39;$result&#39;),)); // 我们在显示具体内容 返回数据的方式 返回数据其实特别容易，只要在返回的时候带上第二个参数就可以了 Navigator.pop(context,&#39;xxxx&#39;); //xxx就是返回的参数 🌛Flutter 客户端打包【Android】配置app的图标 找到目录 /android/app/src/main/res/ 进入之后你会看到很多mipomap-为前缀命名的文件夹，后面是像素密度，可以看出图标的分辨率 mdpi（中） ~ 160dpi hdpi （高） ~240dip xhdpi （超高） ~320dip xxhdpi （超超高） ~480dip xxxhdpi （超超超高） ~640dip 将对应的像素密度的图片放入对应的文件夹中，图片记得使用png格式，记得名字要统一，才能一次性进行配置 AndroidManifest.xml 文件这个文件主要用来配置APP的名称、图标和系统权限，所在的目录在: /android/app/src/main/AndroidManifest.xml android:label=&quot;flutter_app&quot; //配置APP的名称，支持中文 android:icon=&quot;@mipmap/ic_launcher&quot; //APP图标的文件名称 生成 keystorekeytool -genkey -v -keystore ~/key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias key 这里会有报错： 如下 很容易知道，没有环境变量，这里我们就不去配值，直接拿到他的根目录进行执行 通过下面的命令进行查找他的根目录 flutter doctor -v 这时候你直接拷贝命令并进行输入，但这里也有个坑，就是如果文件夹中间带有空空，你需要用带引号扩上。 ！！！有可能还会报错 这个错误的主要问题是目录不存在和没有写权限，所以我们要更换一个有写权限的目录。我们把命令改成了下面的形式。 D:\Program\Android\&#39;Android Studio&#39;\jre\bin\keytool -genkey -v -keystore D:\key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias key 有了这个key.jks文件后，可以到项目目录下的android文件夹下，创建一个名为key.properties的文件，并打开粘贴下面的代码。 storePassword=&lt;password from previous step&gt; //输入上一步创建KEY时输入的 密钥库 密码 keyPassword=&lt;password from previous step&gt; //输入上一步创建KEY时输入的 密钥 密码 keyAlias=key storeFile=&lt;E:/key.jks&gt; //key.jks的存放路径 我的文件最后是这样的： storePassword=123123 keyPassword=123123 keyAlias=key storeFile=D:/key.jks 配置key注册key生成好后，需要在build.gradle文件中进行配置。这个过程其实很简单，就是粘贴复制一些东西，你是不需要知道这些文件的具体用处的。 第一项： 进入项目目录的/android/app/build.gradle文件，在android{这一行前面,加入如下代码: def keystorePropertiesFile = rootProject.file(&quot;key.properties&quot;) def keystoreProperties = new Properties() keystoreProperties.load(new FileInputStream(keystorePropertiesFile)) 把如下代码进行替换 buildTypes { release { signingConfig signingConfigs.debug } } 替换成的代码： signingConfigs { release { keyAlias keystoreProperties[&#39;keyAlias&#39;] keyPassword keystoreProperties[&#39;keyPassword&#39;] storeFile file(keystoreProperties[&#39;storeFile&#39;]) storePassword keystoreProperties[&#39;storePassword&#39;] } } buildTypes { release { signingConfig signingConfigs.release } } 生成apk 直接在终端中输入： flutter build apk 打包成功 打包成功的apk文件在根目录下的 /build/app/outputs/apk/app.apk]]></content>
      <tags>
        <tag>Dart</tag>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[😈Flutter 布局😈]]></title>
    <url>%2F2019%2F10%2F11%2FFlutter_layout%2F</url>
    <content type="text"><![CDATA[😈Flutter 布局😈👿水平布局Row的使用 Flutter的row控件就是水平控件，它可以让Row的里面的子元素进行水平排列 不灵活水平布局import &#39;package:flutter/material.dart&#39;; void main () =&gt; runApp(MyApp()); class MyApp extends StatelessWidget{ @override Widget build(BuildContext context ){ return MaterialApp( title:&#39;ListView widget&#39;, home:Scaffold( appBar:new AppBar(title:new Text(&#39;水平方向布局&#39;)), body:new Row( children: &lt;Widget&gt;[ new RaisedButton( onPressed: (){ }, color:Colors.redAccent, child:new Text(&#39;红色按钮&#39;) ), new RaisedButton( onPressed: (){ }, color:Colors.orangeAccent, child: new Text(&#39;黄色按钮&#39;), ), new RaisedButton( onPressed: (){ }, color:Colors.pinkAccent, child:new Text(&#39;粉色按钮&#39;) ) ], ) ), ); } } 运行我们可以发现，按钮在一行没有平均分布，右侧还有空隙，如果想要他平均分布，我们就要使用灵活水平布局 灵活水平布局 需要解决上面的问题，我们可以通过Expanded来进行解决，将按钮包在Expanded中 body: Row( children: &lt;Widget&gt;[ Expanded( child:RaisedButton( onPressed: (){ }, color: Colors.red, child: Text(&#39;红褐色按钮&#39;) ), ), Expanded( child: RaisedButton( onPressed: (){ }, color: Colors.yellow, child: Text(&#39;黄褐色按钮&#39;) ), ) ], ), 👹垂直布局Column组件 Column组件是垂直布局控件，可以将子组件垂直排列 import &#39;package:flutter/material.dart&#39;; void main () =&gt; runApp(MyApp()); class MyApp extends StatelessWidget{ @override Widget build(BuildContext context ){ return MaterialApp( title:&#39;ListView widget&#39;, home:Scaffold( appBar:new AppBar( title:new Text(&#39;垂直方向布局&#39;), ), body: Column( children: &lt;Widget&gt;[ Text(&#39;data&#39;), Text(&#39;wwwwwwwwwwwwwwwwwwwwwwwwww&#39;), Text(&#39;data&#39;) ], ), ), ); } } 这样你会发现中间一段字母很长，并且整个布局是居中对齐的，如果我们希望他是靠左对齐的，需要加一个对齐属性 CrossAxisAlignment.star: 居左对齐 CrossAxisAlignment.end: 居右对齐 CrossAxisAlignment.center: 居中对齐 主轴和副轴的辨识【mainAxisAlignment】 main轴：如果你用cloumn组件，那垂直就是主轴，如果用的是Row组件，那么水平就是主轴 cross轴：Cross轴称为副轴，是和主轴垂直的方向，例：Row组件，垂直就是副轴，Column的副轴就是水平方向 现在将上面布局改为垂直居中 body: Column( crossAxisAlignment: CrossAxisAlignment.start, mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text(&#39;data&#39;), Text(&#39;wwwwwwwwwwwwwwwwwwwwwwwwww&#39;), Text(&#39;data&#39;) ], ), Expanded属性的使用 如果我们想要让中间部分变大，上下根据文字大小在底部显示， body: Column( // crossAxisAlignment: CrossAxisAlignment.center, mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Center(child: Text(&#39;data&#39;),), Expanded( child: Container( color: Colors.red, ) ), Center(child: Text(&#39;data&#39;),) ], ), 👺Stack层叠布局 层叠布局就是就是放入一张图片，然后在图片上面加入文字，或者放入容器 import &#39;package:flutter/material.dart&#39;; void main () =&gt; runApp(MyApp()); class MyApp extends StatelessWidget{ @override Widget build(BuildContext context ){ var stack = new Stack( alignment: const FractionalOffset(0.5, 0.8), children: &lt;Widget&gt;[ new CircleAvatar( backgroundImage: new NetworkImage(&#39;http://jspang.com/static//myimg/blogtouxiang.jpg&#39;), radius: 100.0, ), new Container( decoration: new BoxDecoration( color: Colors.lightBlue, ), padding: EdgeInsets.all(5.0), child: new Text(&quot;sssssssssssss&quot;), ) ], ); return MaterialApp( title:&#39;ListView widget&#39;, home:Scaffold( appBar:new AppBar( title:new Text(&#39;垂直方向布局&#39;), ), body:Center(child:stack), ), ); } } 运行以上代码，就可以得到我们想要的布局效果 alignment属性 层叠布局alignment属性是控制层叠的位置的, 建议两个元素进行层叠时使用，他有两个值X轴距离和Y轴的距离，值是0到1，都是从上层容器的左上角开始算起的 CircleAvatar组件的使用 CircleAvatar这个组件是经常是用来制作头像的，组件里面有一个radius的值可以设置图片的弧度 new CircleAvatar( backgroundImage: new NetworkImage(&#39;http://jspang.com/static//myimg/blogtouxiang.jpg&#39;), // 放入一张背景图片 radius: 100.0, ), 👽Stack的Positioned属性 上述只是两个容器之间的嵌套，如果超过了两个容器之间的层叠嵌套，我们就要使用Positioned组件 bottom：距离层叠组件下面的距离 left：距离层叠组件左面的距离 top: 距离层叠组件上面的距离 right: 距离层叠组件右边的距离 width：层叠定位组件的宽度 height： 层叠定位组件的高度 import &#39;package:flutter/material.dart&#39;; void main () =&gt; runApp(MyApp()); class MyApp extends StatelessWidget{ @override Widget build(BuildContext context ){ var stack = Stack( alignment: const FractionalOffset(0.5, 0.8), children: &lt;Widget&gt;[ CircleAvatar( backgroundImage: new NetworkImage(&#39;http://img5.mtime.cn/mt/2018/10/22/104316.77318635_180X260X4.jpg&#39;), radius: 100.0, ), Positioned( top:10.0, left:10.0, child: Container( decoration: BoxDecoration( color: Colors.blue ), padding: EdgeInsets.all(10.0), child: Text(&#39;ssssssss&#39;) ), ), Positioned( bottom:10.0, right: 10.0, child: Container( decoration: BoxDecoration( color: Colors.red ), padding: EdgeInsets.fromLTRB(10.0, 20.0, 30.0, 40.0), child: Text(&#39;data&#39;), ), ) ], ); return MaterialApp( title:&#39;ListView widget&#39;, home:Scaffold( appBar:new AppBar( title:new Text(&#39;层叠布局&#39;), ), body:Center(child:stack), ), ); } } 运行即可实现我们想要的效果 💣卡片组件布局 卡片布局是撑满整个外部容器的，如果你想设置卡片的宽高，需要在外部容器进行制定 import &#39;package:flutter/material.dart&#39;; void main () =&gt; runApp(MyApp()); class MyApp extends StatelessWidget{ @override Widget build(BuildContext context ){ var card = Card( child: Column( children: &lt;Widget&gt;[ ListTile( title: Text(&#39;data&#39;,style: TextStyle(fontWeight: FontWeight.w800),), subtitle: Text(&#39;data&#39;), leading: Icon(Icons.access_alarms, color: Colors.blue), ), Divider(), // 分割线 ListTile( title: Text(&#39;data&#39;,style: TextStyle(fontWeight: FontWeight.w800),), subtitle: Text(&#39;data&#39;), leading: Icon(Icons.access_alarms, color: Colors.blue), ), Divider(), ListTile( title: Text(&#39;data&#39;,style: TextStyle(fontWeight: FontWeight.w800),), subtitle: Text(&#39;data&#39;), leading: Icon(Icons.access_alarms, color: Colors.blue), ), Divider(), ], ), ); return MaterialApp( title:&#39;ListView widget&#39;, home:Scaffold( appBar:new AppBar( title:new Text(&#39;卡片布局&#39;), ), body:Center(child: card), ), ); } }]]></content>
      <tags>
        <tag>Dart</tag>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🥰Flutter 常用组件🥰]]></title>
    <url>%2F2019%2F10%2F10%2FFlutter_view%2F</url>
    <content type="text"><![CDATA[Flutter 常用组件 🥰Flutter 常用组件🥰 🌟Text Widget文本组件的使用import &#39;package:flutter/material.dart&#39;; void main () =&gt; runApp(MyApp()); class MyApp extends StatelessWidget{ @override Widget build(BuildContext context ){ return MaterialApp( title:&#39;Text widget&#39;, home:Scaffold( body:Center( child:Text(&#39;hello Flutter， i like&#39;) ), ), ); } } TextAlign属性 TextAlign属性就是文本的对齐方式 center ———- 文本以居中的形式对齐 left————– 文本以左对齐的方式对齐 right————- 文本以右对齐的方式对齐 start————- 文本以开始的位置对齐，类似left end ————– 文本以结尾处对齐，类似于right child:Text( &#39;hello Flutter， i like&#39;, textAlign: TextAlign.left, ) maxLines属性 设置最多显示行数 child:Text( &#39;hello Flutter， i like&#39;, textAlign: TextAlign.left, maxLines: 1 // 最多显示一行 ) overflow属性 overflow属性是设置文本溢出的 clip：直接切断，相当于css中hidden ellipsis：在后面显示省略号 fade：溢出部分采用渐变消失的状态(是上线渐变消失)) child:Text( &#39;hello Flutter， i like&#39;, textAlign: TextAlign.left, maxLines: 1, // 最多显示一行 overflow: TextOverflow.ellipsis // 超出部分以省略号的形式出现 ) style属性 style的属性比较多，这里只演示部分【下面制作一个字体大小为25.0，颜色为蓝色，有下划线的,下划线颜色为黄色】 child:Text( &#39;hello Flutter， i like&#39;, textAlign: TextAlign.left, maxLines: 1, // 最多显示一行 overflow: TextOverflow.ellipsis, // 超出部分以省略号的形式出现 style: TextStyle( fontSize: 25.0, color: Colors.blue, // color:Color.fromARGB(255, 255, 150, 150), // 颜色也可以用这种方式表示 decoration: TextDecoration.underline, decorationStyle: TextDecorationStyle.solid, decorationColor: Colors.yellow ), ) 更多属性资料 Flutter中文网 - 文本 Widget ⚡Container容器组件的使用 Container（容器组件）是经常使用的组件，相当于HTML的div标签 class MyApp extends StatelessWidget{ @override Widget build(BuildContext context ){ return MaterialApp( title:&#39;Text widget&#39;, home:Scaffold( body:Center( child:Container( child:new Text(&#39;hello Flutter， i like&#39;), ), ), ), ); } } Alignment属性 这个属性是争对Container内child的对齐方式，也就是容器子内容的对齐方式 bottomCenter ————– 下部居中对齐 bottomLeft —————- 下部左对齐 bottomRight ————— 下部右对齐 center ——————– 纵横双向居中对齐 centerLeft —————- 纵向居中横向居左对齐。 centerRight ————— 纵向居中横向居右对齐。 topLeft ——————- 顶部左侧对齐。 topCenter —————– 顶部居中对齐。 topRight —————— 顶部居左对齐。 home:Scaffold( body:Center( child:Container( child:new Text(&#39;hello Flutter， i like&#39;), alignment: Alignment.center, ), ), ), 设置宽、高和颜色属性 设置宽高相对容易，只要在属性名称后面加入浮点数字就可以 home:Scaffold( body:Center( child:Container( child:new Text(&#39;hello Flutter， i like&#39;), alignment: Alignment.center, width:500.0, height:400.0, color: Colors.lightBlue, ), ), ), padding属性 padding指的的是Container和child内容器的距离 home:Scaffold( body:Center( child:Container( child:new Text(&#39;hello Flutter， i like&#39;), alignment: Alignment.center, width:500.0, height:400.0, color: Colors.lightBlue, padding: const EdgeInsets.all(10.0), // 代表上下左右的padding距离都是10 ), ), ), 上面主要说明了padding的一个统一的值，如果我们想分别设置呢 padding: const EdgeInsets.fromLTRB(10.0, 50.0, 0.0, 0.0) 这样我们就可以分别设置各个方向的padding值 margin属性 用法同上 margin: const EdgeInsets.all(10.0), // 代表上下左右的margin距离都是10 ||或 margin: const EdgeInsets.fromLTRB(10.0, 50.0, 0.0, 0.0) decoration属性 decoration是container的修饰器，主要功能设置背景和边框 如果你想要给一个背景加一个渐变，这时候需要这个BoxDecoation home:Scaffold( body:Center( child:Container( child:new Text(&#39;hello Flutter， i like&#39;), alignment: Alignment.center, width:500.0, height:400.0, // color: Colors.lightBlue, padding: const EdgeInsets.all(10.0), // 代表上下左右的padding距离都是10 decoration: new BoxDecoration( gradient: const LinearGradient( colors: [Colors.blue, Colors.red, Colors.white] // 设置渐变色 ), border: Border.all(width: 2.0, color: Colors.red) // 设置边框线的样式 ), ), ), ), 注意color和decoration不能共存,会有冲突 🔥Image图片的使用 Image.asset: 加载资源图片,就是加载项目资源的目录中的图片,加入图片会增加打包的体积,以相对路径引入 Image.network: 网络资源图片,意思就是引入网络图片路径 Image.file: 加载本地图片,就是加载本地文件中的图片,不会增加打包体积,以绝对路径引入 Image.memory: 加载Uint8List资源图片 home:Scaffold( body:Center( child:Container( child: Image.network( &#39;http://my.ignorantscholar.cn/images/headers.png&#39;, width: 300.0, height: 300.0, ), alignment: Alignment.center, width:500.0, height:400.0, // color: Colors.lightBlue, padding: const EdgeInsets.all(10.0), // 代表上下左右的padding距离都是10 decoration: new BoxDecoration( gradient: const LinearGradient( colors: [Colors.blue, Colors.red, Colors.white] // 设置渐变色 ), border: Border.all(width: 2.0, color: Colors.red) // 设置边框线的样式 ), ), ), ), fit属性 fit属性可以控制图片的拉伸和挤压,这些都是根据图片的父级容器来的 BoxFit.fill: 全图显示,图片会被拉伸,并且充满父容器 BoxFit.contain: 全图显示,显示原比例,可能会有空隙 BoxFit.cover: 显示可能拉伸,可能裁剪,充满(图片要充满整个容器,还不变形) BoxFit.fitWidth: 宽度充满,(横向充满) BoxFit.fitHeight: 高度充满 (属相充满) BoxFit.scaleDown: 效果和contain差不多,但是此属性不能超过图片大小,可小不可大 child: Image.network( &#39;http://my.ignorantscholar.cn/images/headers.png&#39;, width: 300.0, height: 300.0, fit: BoxFit.cover, // 不变形,充满整个容器 ), 图片混合模式 图片混合模式(colorBlendMode) 和 color 属性一起使用,可以让图片改变颜色 ！！！！！！colorBlendMode和color需要同时使用,单独使用一个达不到预期效果 child: Image.network( &#39;http://my.ignorantscholar.cn/images/headers.png&#39;, width: 300.0, height: 300.0, color: Colors.yellow, colorBlendMode: BlendMode.modulate, fit: BoxFit.cover, ), 使用项目资源图片pubspec.yaml文件 如果想配置项目资源文件，就需要使用pubspec.yaml文件，需要把资源文件在这里声明 比如在项目根目录下建立了一个文件images用来存放图片，文件夹下面有一个图片，pic.png，那我们在pubspec.yaml文件中进行声明 assets: - images/pic.png child: Image.asset(&#39;images/pic.png&#39;), 💧ListView列表组件ListView的声明import &#39;package:flutter/material.dart&#39;; void main () =&gt; runApp(MyApp()); class MyApp extends StatelessWidget{ @override Widget build(BuildContext context ){ return MaterialApp( title:&#39;Text widget&#39;, home:Scaffold( body:ListView( child: &lt;Widget&gt;[ ListTile( leading: Icon(Icons.assess_time), title: new Text(&#39;assess_time&#39;) ), ListTile( leading: Icon(Icons.assess_time), title: new Text(&#39;assess_time&#39;) ) ] ), ), ); } } 我们使用了ListView，然后在他的内部children中，使用了widget数组，因为是一个列表，所以他接受一个数组，然后使用了ListTile组件【列表瓦片】，具体效果可以在项目中查看 图片列表的使用 我们使用网络的方式，插入两张图片 body: new ListView( children:&lt;Widget&gt;[ new Image.network(&#39;http://jspang.com/static/upload/20181111/G-wj-ZQuocWlYOHM6MT2Hbh5.jpg&#39;), new Image.network(&#39;http://jspang.com/static/upload/20181109/1bHNoNGpZjyriCNcvqdKo3s6.jpg&#39;), ] ), 横向列表的使用 使用横向列表需要加一个属性scrollDirection Axis.horizontal: 横向滚动 Axis.vertical: 纵向滚动 【默认纵向滚动】 home:Scaffold( body:Center( child:Container( height:200.0, child:new ListView( scrollDirection: Axis.horizontal, children: &lt;Widget&gt;[ new Container( width:180.0, color: Colors.lightBlue, ), new Container( width:180.0, color: Colors.amber, ), new Container( width:180.0, color: Colors.deepOrange, ), new Container( width:180.0, color: Colors.deepPurpleAccent, ), ], ) ), ), 从上面代码我们可以看出，代码嵌套比较深，进行优化，提取 class MyList extends StatelessWidget{ @override Widget build(BuildContext context) { return ListView( scrollDirection: Axis.horizontal, children: &lt;Widget&gt;[ Container( width: 180.0, color: Colors.red, ), Container( width: 180.0, color: Colors.yellow, ), Container( width: 180.0, color: Colors.red, ), Container( width: 180.0, color: Colors.yellow, ) ] ); } } home:Scaffold( body:Center( child:Container( height:200.0, child: MyList() ), ), 这样看就简洁许多 动态列表的使用 上面的列表是写死的，我们在实际开发中，大多数是不会死的 class MyList extends StatelessWidget{ final List&lt;String&gt; items = new List&lt;String&gt;.generate(1000, (i)=&gt; &quot;Item $i&quot;); // 使用list中的属性generate方法产生List里面的元素 @override Widget build(BuildContext context) { return ListView.builder( // 调用动态列表生成 itemCount:items.length, itemBuilder:(context,index){ return new ListTile( title:new Text(&#39;${items[index]}&#39;), ); } ); } } 🌊GridView网格列表布局组件import &#39;package:flutter/material.dart&#39;; void main () =&gt; runApp(MyApp()); class MyApp extends StatelessWidget{ @override Widget build(BuildContext context ){ return MaterialApp( title:&#39;ListView widget&#39;, home:Scaffold( body:GridView.count( padding:const EdgeInsets.all(20.0), crossAxisSpacing: 10.0, crossAxisCount: 3, children: &lt;Widget&gt;[ Container( color: Colors.red, ), Container( color: Colors.red, ), Container( color: Colors.red, ), Container( color: Colors.red, ), Container( color: Colors.red, ) ], ) ), ); } } crossAxisSpacing: 网格之间 的空隙 crossAxisSpacing：网格列数，相当于一行放置的网格数量 现在做一个图片的网格布局 body: GridView.count( padding: const EdgeInsets.all(10.0), crossAxisSpacing: 2.0, crossAxisCount: 3, mainAxisSpacing: 2, childAspectRatio: 0.7, children: &lt;Widget&gt;[ new Image.network(&#39;http://img5.mtime.cn/mt/2018/10/22/104316.77318635_180X260X4.jpg&#39;,fit: BoxFit.cover), new Image.network(&#39;http://img5.mtime.cn/mt/2018/10/10/112514.30587089_180X260X4.jpg&#39;,fit: BoxFit.cover), new Image.network(&#39;http://img5.mtime.cn/mt/2018/11/13/093605.61422332_180X260X4.jpg&#39;,fit: BoxFit.cover), new Image.network(&#39;http://img5.mtime.cn/mt/2018/11/07/092515.55805319_180X260X4.jpg&#39;,fit: BoxFit.cover), new Image.network(&#39;http://img5.mtime.cn/mt/2018/11/21/090246.16772408_135X190X4.jpg&#39;,fit: BoxFit.cover), new Image.network(&#39;http://img5.mtime.cn/mt/2018/11/17/162028.94879602_135X190X4.jpg&#39;,fit: BoxFit.cover), new Image.network(&#39;http://img5.mtime.cn/mt/2018/11/19/165350.52237320_135X190X4.jpg&#39;,fit: BoxFit.cover), new Image.network(&#39;http://img5.mtime.cn/mt/2018/11/16/115256.24365160_180X260X4.jpg&#39;,fit: BoxFit.cover), new Image.network(&#39;http://img5.mtime.cn/mt/2018/11/20/141608.71613590_135X190X4.jpg&#39;,fit: BoxFit.cover), ], ), childAspectRatio： 宽高比， 这个值的意思是宽是高的多少倍]]></content>
      <tags>
        <tag>Dart</tag>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🍉Dart学习【基础】🍉]]></title>
    <url>%2F2019%2F10%2F09%2FFlutter_Dart%2F</url>
    <content type="text"><![CDATA[🍉Dart学习【基础】🍉🍌Dart简介 在Dart中，一切都是对象，一切对象都是class实例，哪怕是数字类型，方法甚至是null都是对象，所有对象继承于Object Dart是强语言类型，但是Dart可以自动推变变量类型，所以也可以支持动态类型 Dart具有强大的异步编程能力 🍍Dart用法 import 导入库 import &#39;package:flutter/material.dart&#39;; 注释【和js一样】 //单行注释 /****/多行注释 =&gt; [Dart的箭头函数，即Lambda表达式] void main() =&gt; runApp(MyApp()); extends 继承 class MyApp extends StatelessWidget { var content = &#39;Dart&#39;; // 声明并初始化变量 String _name = &quot;Flutter&quot;; @override Widget build(BuildContext context) { print(&#39;display $content&#39;); // 打印【对应js的console】 // return a Widget return MaterialApp( title: &quot;Flutter Demo&quot;, theme: ThemeData( primaryColor: Colors.blue, ), home: Scaffold( appBar: AppBar(title: Text(&quot;Flutter Dart 语法&quot;)), body: Text(content+_name) ), ); } } var 变量申明并且不指定其类型的方法 var content = &#39;Dart 语法&#39;; // 声明并初始化变量 _ 以下划线 _ 开头的类或成员变量是私有的 Dart 没有 Public、Protected、Private 的关键字，在 Dart 里，类或成员变量默认都是 Public 的，以下划线 _ 开头的就是私有的，例如成员变量 _name 就是私有的。 String _name = &quot;Flutter&quot;; String 在声明变量时也可以指定具体类型，String 是字符串，还有其他的数据类型：int、double等。 String _name = &quot;Flutter&quot;; $variableName 或 ${expression} 字符串插值：将变量的值直接插入字符串中。 print(&#39;display $content&#39;); 🍑变量声明（一共有四种方式） var var content = &#39;Dart 语法&#39; var switchOn = false var current = 0 使用var来申明变量，不需要指定变量的数据类型，因为Dart会自动推断其数据类型，所以可以使用var来定义任何变量 var不是直接储存值，而是存储的对象的引用，例如：var content = ‘Dart’,是名字为content的var的变量存储了值为Dart的String对象的引用，因此var可以定义定义任何变量 明确数据类型 String name = &#39;Flutter&#39; int count = 0 就是在声明变量的时候，使用明确的数据类型 dynamic dynamic example = &#39;example&#39; 意思是数据类型是动态可变的，也可以定义任何变量，但是和var不同，var一旦赋值以后，就不能改变数据类型了 Object Object index = 100 Dart里面的所有东西都是对象，因为Dart的所有东西都是对象，都继承于Object，因此可以定义任意类型，而且赋值以后也可以更改 Object index = 100 index = &#39;string&#39; √ 因为&#39;string&#39;也是object ！！！注意： 请不要滥用dynamic，一般情况下都可以使用Object来代替 dynamic 使用场景 在与native对接时，对传入的参数类型不确定时，进行使用 常量：final 和 constfinal content = &#39;Dart static const bool switch = false 使用的时候需要注意一下几点 使用final和const时候可以把var省略 final和const变量只能赋值一次，并且他在声明的时候就已经赋值 const是隐式的const 在使用const的时候，如果是在全局声明的话，不需要加static属性，如果是在类里面声明，则需要加上 final与const的区别 const是编译时常量，在编译的时候就已经初始化了，而final变量是当类创建的时候才初始化 🍓Dart支持的数据类型 int 整数，范围带-2^63到2^63-1 int x = 1; // 没有小数点就是int double 浮点数，64位，双精度- 浮点数 double y = 1.1; // 有小数的就是浮点数 num num是数字类型，既可以表示整数，也可以表示浮点数，具体看赋值 num x = 1; num y = 2; String 字符串【Dart字符串采用UTF-8编码，可以采用单引号或双引号】 var s1 = &#39;string&#39; String s1 = &#39;string&#39; bool 布尔值 var isShow = true bool isShow = true List List[E] E表示List里面的数据类型 List&lt;int&gt; = [1, 2, 3] Set Set&lt;\E&gt; E表示Set的数据类型，使用大括号进行赋值 Set&lt;String&gt; halong = {&#39;hellow&#39;, &#39;world&#39;, &#39;koal&#39;} Map Map&lt;\k, v&gt;k是Key的数据类型，V是Value的数据类型 Map&lt;String, String&gt; gits = { &#39;first&#39;: &#39;partridge&#39;, &#39;second&#39;: &#39;turtledoves&#39;, } Runes 表示采用UTF-32字符串，用于显示Unicode，因为Dart字符串是UTF-16，因此在Dart中表示32位的Unicode需要Runes这个特殊的语法 Runes input = new Runes(&#39;\u{1f600}&#39;); print(new String.fromCharCodes(input)); 打印出来的是笑脸emoji：😆 🍄函数 在Dart中函数也是对象,函数的类型是Function 函数的写作格式bool say(String msg , String from, int clock){ print(msg+&quot; from &quot; + from + &quot; at &quot; + clock?.toString()); return true; } 返回类型 函数名(函数参数){ } 函数的类型print(say is Function) // 判断say是否为函数 函数的参数： 必选参数 ===== 可选参数 首先必选参数必须在前面，和普通函数一样，后面跟可选参数，可选参数需要用{}或者[]包起来，用不同的括号，可选参数的意义也不一样 必选参数和普通函数一样，这里不多阐述，主要说明可选参数 可选参数 可选命名参数：：使用{}包起来的参数是可选命名参数 可选位置参数：：使用[]包起来的参数是可选位置参数 可选命名参数：{} 用{}包起来的参数，前面说的数据类型，使用{}来赋值的数据类型是Map，所以可选参数的的类型也是Map，因此调用函数时，可选参数的赋值必须是key: value这种格式的，如下： bool say(String msg , {String from, int clock}){ print(msg+&quot; from &quot; + from + &quot; at &quot; + clock.toString()); return true; } // 调用 say(&#39;Hello Flutter&#39;);//✅ 因为 from 和 clock 是可选参数，所以可以不填 say(&#39;Hello Flutter&#39;, from: &#39;XiaoMing&#39;);//对 用命名参数格式 paramName: value 为 from 赋值 say(&#39;Hello Flutter&#39;, clock: 11);//✅ say(&#39;Hello Flutter&#39;, from: &#39;XiaoMing&#39;, clock: 11);//✅ 同时也可以给命名参数加@required，意思是这个也是必选参数，如下： bool say(String msg , {@required String from, int clock}){ print(msg+&quot; from &quot; + from + &quot; at &quot; + clock.toString()); return true; } // 调用 say(&#39;Hello Flutter&#39;);//❌ 错误调用方式，因为 from 是必选参数，不填的话会报错 say(&#39;Hello Flutter&#39;, from: &#39;XiaoMing&#39;);//✅ 正确调用方式 say(&#39;Hello Flutter&#39;, from: &#39;XiaoMing&#39;, clock: 11);//✅ 这个调用方式也是正确的 可选位置参数：[] 用[ ]包起来的参数是可选位置参数，前面说的数据类型的时候，使用[ ]来赋值的数据类型是List，所以可选参数的命名参数也是List，所以赋值和参数是一一对应的，如下： bool say(String msg , [String from , int clock]){ print(msg+&quot; from &quot; + from + &quot; at &quot; + clock.toString()); return true; } // 调用 say(&#39;Hello Flutter&#39;);//✅ 因为 from 和 clock 是可选参数，所以可以不填 say(&#39;Hello Flutter&#39;, &#39;XiaoMing&#39;,1);//✅ 为可选位置参数赋值，只能一个参数一个参数对应的赋值，所以要全部赋值 say(&#39;Hello Flutter&#39;, &#39;XiaoMing&#39;)//✅ say(&#39;Hello Flutter&#39;, 1)//❌ 因为 1 赋值给了 from,但是 from 是String，所以会报错 可选参数的默认值： = 因为参数是可选的，那么参数的值很可能没有赋值，也就是null，我们如果需要用到该参数，可以赋值给他一个默认值 bool say(String msg , {String from = &#39;empty&#39;, int clock = 0}){ print(msg+&quot; from &quot; + from + &quot; at &quot; + clock.toString()); return true; } 🍒=&gt; 箭头语法 =&gt; 语句后面的只能加一行代码，而且这一行代码只能一个表达式，而且不能跟语句，表达式可以使函数或值 void main() =&gt; runApp(MyApp()); 等价于： void main(){ return runApp(MyApp());//runApp() 返回的是 void } 🍭操作符 类型判断操作符 as 类型转换 (emp as Person).firstName = &#39;Bob&#39;; is 判断是否为某个类型，如果是的话，就返回true if (emp is Person) { // 如果 emp 是 Person 类型 emp.firstName =&#39;Bob&#39;; } is! 判断是否不是某个类型，如果不是的话就返回true if (emp is! Person) { // 如果 emp 不是 Person 类型 } 🍬条件运算符condition ? expr1 : expr2 如果condition为true的时候，返回expr1，否则返回expr2 var visibility = isPublic ? &#39;public&#39; : &#39;private&#39;; expr1 ?? expr2 如果 expr1 为 null，就返回 expr2 的值，否则返回 expr1 的值。 如果需要根据一个 boolean 表达式是否为 null 来作为条件，可以使用 ??，例如： String playerName(String name) =&gt; name ?? &#39;Guest&#39;;]]></content>
      <tags>
        <tag>Dart</tag>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[😎flutter环境搭建（window）🤔]]></title>
    <url>%2F2019%2F10%2F08%2Fflutter-windows%2F</url>
    <content type="text"><![CDATA[😎flutter环境搭建（window）🤔🤣搭建 Android 开发环境 具体环境搭建参考使用react-native基础环境搭建 😁配置flutter环境变量 打开高级系统设置 =&gt; 配置环境变量 用户变量下，选择新建环境变量 FLUTTER_STORAGE_BASE_URL https://storage.flutter-io.cn PUB_HOSTED_URL https://pub.flutter-io.cn Flutter SDK Flutter 开发需要安装 Flutter SDK，这里只介绍 Flutter SDK 在 Windows 这个平台上的安装过程。 下载 Flutter SDK 你可以在 Flutter SDK 的下载页面，选择你想要的版本，一般选择稳定版的，目前最新的稳定版是 v1.9.1+hotfix.2。 将 Flutter SDK 的 zip 包解压到一个目录下，例如 E:\src\flutter（目录随意，但是不要放在需要权限的目录下，例如 C:\Program Files\ ） 设置 Flutter SDK 的环境变量 计算机 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量，打开环境变量设置框。 在用户变量下, 将 Flutter SDK 的完整路径 E:\src\flutter\bin 添加到[Path]变量上。 运行 flutter doctor 为了验证 Flutter 是否安装成功，在 cmd 运行： flutter doctor C:\Users\Administrator&gt;flutter doctor Doctor summary (to see all details, run flutter doctor -v): [✓] Flutter (Channel stable, v1.9.1-hotfix.2, on Microsoft Windows [Version 6.1.7601], locale zh-CN) [✓] Android toolchain - develop for Android devices (Android SDK 27.0.3) [✓] Android Studio (version 3.1) [!] Connected device ! No devices available ! Doctor found issues in 1 categories. 可能会遇到的报错Some Android licenses not accepted（Android证书的问题） 运行 flutter doctor –android-licenses 修护 得到X:\xxxxsdk\tool\bin\sdkmanager –update 复制运行[会出现的报错]] Exception in thread “main” java.lang.UnsupportedClassVersionError 查看Java版本 [如果Java版本大于8,去下载8版本的Java包,下载完成后,将Java的环境变量进行替换,并且Java的环境变量要优先于flutter],修复完成后继续运行X:\xxxxsdk\tool\bin\sdkmanager –update Warning: An error occured during installation: Failed to move away or delete existing target file: X盘:\androidSDK\sdk\tools 把sdk下面的tools文件夹，重命名一下tool或者随意，然后打开cmd，前往其目录下的bin\sdkmanager 执行–update，也就是你的X:\xxxxsdk\tool\bin\sdkmanager –update，执行 这里会有警告，也就是你刚刚重命名了，给你提醒一下，直接忽略警告等待完成，过程有点久，逛逛小网站，该干嘛干嘛 最终会在刚刚的sdk目录下生成新的tools文件夹，然后覆盖刚刚重命名的tool文件夹里的内容，删掉tools 就是把刚刚更新下来的tools里面的东西copy到tool里去，然后抛弃它 最后再次执行flutter doctor –android-licenses 并且在指令里跳出来的y/N那里，全部选y 最后提示所有的都接受了, 问题应该解决了。 🤑如何鏈接模擬器進行debug開發 這裏我下載的是逍遙模擬器【👄进入D:\Microvirt\MEmu文件夹下，打开cmd输入以下代码】 adb connect 127.0.0.1:21503 可能遇到的问题 拒绝连接 ‼ ‼ ‼ 确定全局的adb版本是否与逍遥模拟器的adb版本一致 如果不一致, 将全局变量代表的adb.exe文件复制到逍遥模拟器中的adb.exe进行替换 版本一致后, 继续执行adb connect 127.0.0.1:21503 出现successfully, 表示连接成功 😍使用vscode启动项目创建 Flutter 项目 在 VS Code 中，点击 View &gt; Command Palette…，或者快捷键 Shift+cmd+P(MacOS) /Ctrl+Shift+P(Windows、Linux)，打开命令面板,输入 Flutter 选择 Flutter: New Project,会弹出出入框 然你输入 Flutter 工程的名字，你可以自己起一个，例如： hello_world。输入 Flutter 工程的名字后，回车，会弹出保存文件的目录地址,选择好等待即可 (大约1-2分钟) ： 运行Flutter APP VS Code 有两种方式运行 Flutter APP： Start Debugging Start Without Debugging 😱报错( 1 ) Error running Gradle:ProcessException: Process “C:\Users\asus\Desktop\myflutter\android\gradlew.bat” exited abnormally:Starting a Gradle Daemon, 1 incompatible Daemon could not be reused, use –status for details 修改 android目录下的build.gradle文件，将google()和jcenter()注释掉，新加如下代码； buildscript { ext.kotlin_version = &#39;1.2.71&#39; repositories { // google() // jcenter() maven { url &#39;https://maven.aliyun.com/repository/google&#39; } maven { url &#39;https://maven.aliyun.com/repository/jcenter&#39; } maven { url &#39;http://maven.aliyun.com/nexus/content/groups/public&#39; } } dependencies { classpath &#39;com.android.tools.build:gradle:3.2.1&#39; classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; } } allprojects { repositories { // google() // jcenter() maven { url &#39;https://maven.aliyun.com/repository/google&#39; } maven { url &#39;https://maven.aliyun.com/repository/jcenter&#39; } maven { url &#39;http://maven.aliyun.com/nexus/content/groups/public&#39; } } } 修改Flutter SDK包下的 flutter.gradle 文件 buildscript { repositories { // google() // jcenter() maven { url &#39;https://maven.aliyun.com/repository/google&#39; } maven { url &#39;https://maven.aliyun.com/repository/jcenter&#39; } maven { url &#39;http://maven.aliyun.com/nexus/content/groups/public&#39; } } dependencies { classpath &#39;com.android.tools.build:gradle:3.2.1&#39; } } 😇VSCode 开发 Flutter 必用插件 Flutter Widget Snippets //提供 Widget 代码片段， Awesome Flutter Snippets //插件提供常用函数的代码片段。 Bracket Pair Colorizer // 高亮]]></content>
      <tags>
        <tag>Dart</tag>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node + koa2基础]]></title>
    <url>%2F2019%2F09%2F26%2Fkoa%2F</url>
    <content type="text"><![CDATA[node + koa2基础 使用koa2，必须保持你的node版本在7.6以上，最好实在10以上，如低于7.6版本请更新您的node版本 搭建http服务+ 使用koa2搭建服务，只需要三步 /index.js const Koa = require(&#39;koa&#39;) const app = new Koa() app.listen(3000) 使用node命令运行即可 node index.js 打开浏览器输入http://loaclhost:3000访问，页面中会显示Not Found，这是因为我们没有去指定koa该返回什么内容，这一点与express不同，koa内部会自动判断，是否有返回内容 Context对象koa内部提供了一个Context对象，表示一次对话的上下文【包括http的请求对象和响应对象】，通过操控这个对象我们可以控制返回给用户的内容 /index.js const Koa = require(&#39;koa&#39;) const app = new Koa() app.use(async (ctx, next) =&gt; { ctx.response.body = &#39;hello&#39; await next() }) app.listen(3000) 路由【koa-router】的使用const router = require(&#39;koa-router&#39;)() const Koa = require(&#39;koa&#39;) const app = new Koa() router.get(&#39;/list&#39;, ctx =&gt; { ctx.response.body = &#39;hellow, list&#39; }) router.get(&#39;/home&#39;, ctx =&gt; { ctx.response.body = &#39;hellow, home&#39; }) app.use(router.routes()).use(router.allowedMethods()) // 启动路由 中间件应用级别中间件 任何路由都会经过应用级别中间件,当执行玩成后next()去匹配相应的路由 app.use(async (ctx, next) =&gt; { await next() }) 错误处理中间件app.use(async (ctx, next) =&gt; { await next() if (ctx.status == 404) { ctx.body = &#39;404&#39; } }) 路由中间件 在匹配路由的过程中匹配到的路由会依次执行中间件,知道最后一个没有next参数 router.get(&#39;/&#39;, async (ctx, next) =&gt; { ctx.response.body = &#39;hellow&#39; ctx.response.status = 200 await next() }) router.get(&#39;/home&#39;, ctx =&gt; { ctx.body = &#39;hellow, world&#39; }) 中间件的合成 koa-compose 模块可以将多个中间件合成为一个 const Koa = require(&#39;koa&#39;) const app = new Koa() const compose = require(&#39;koa-compose&#39;) const logger = (ctx,next) =&gt; { console.log(new Date()) next() } const main = (ctx,next) =&gt; { ctx.response.body = &#39;hello world&#39; } const middleWares = compose([logger,main]) app.use(middleWares) app.listen(3000) xtemplate模板渲染【koa-xtpl】app.use(xtpl({ root: path.join(__dirname, &#39;template&#39;), // 获取到模板所在的文件夹 extname: &#39;xtpl&#39;, // 模板后缀 commands: {} })) 新建template/login/index.xtpl（模板必须以xtpl后缀结尾） &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;后台管理系统&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container-fluid&quot;&gt; hellow, world &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 打开index.js router.get(&#39;/&#39;, async (ctx, next) =&gt; { await ctx.render(&#39;login/index&#39;, { title: new Date() }) await next() }) 运行就可以看到页面中出现 hellow, world 静态资源 如果网站提供了静态资源（图片，字体，样式，脚本），为他们一个个写路由就很麻烦，也没必要 koa-static 模块封装了这部分的请求 const Koa = require(&#39;koa&#39;) const app = new Koa() const serve = require(&#39;koa-static&#39;) const path = require(&#39;path&#39;) const main = serve(path.join(__dirname)) app.use(main) app.listen(3000) 设置之后可以直接在URL地址中输入静态资源文件名进行访问]]></content>
      <tags>
        <tag>node</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node简单的压缩/解压缩]]></title>
    <url>%2F2019%2F08%2F10%2Fnode_zip%2F</url>
    <content type="text"><![CDATA[node简单的压缩/解压缩 为了减少网络传输数据量，http传输过程中会采用通用的压缩算法来压缩数据，gzip属于最常用的压缩算法。 压缩文件//压缩文件 let zlib=require(&quot;zlib&quot;) let fs=require(&quot;fs&quot;) var gzip=zlib.createGzip() let rs=fs.createReadStream(&#39;./copy.js&#39;) let ws=fs.createWriteStream(&#39;./copy.js.gz&#39;) re.pipe(gzip).pipe.(ws) 解压文件//解压文件 let zlib=require(&quot;zlib&quot;) let fs=require(&quot;fs&quot;) var gzip=zlib.createGzip() let rs=fs.createReadStream(&#39;./copy.js.gz&#39;) let ws=fs.createWriteStream(&#39;./copy.js&#39;) re.pipe(gzip).pipe.(ws) 服务端的gzip压缩//服务端的gzip压缩 //先起一个服务，判断req.headers[&#39;accept-encoding&#39;]是否包含gzip let server=http.createServer(function(req,res){ console.log(req) var zp=req.headers[[&#39;accept-encoding&#39;]] console.log(zp) if(zp.indexOf(&#39;gzip&#39;)!=-1){//判断是否需要gzip压缩 var gzip = zlib.createGzip(); res.writeHead(200, {//记得响应 Content-Encoding，告诉浏览器：文件被 gzip 压缩过 &#39;Content-Encoding&#39;: &#39;gzip&#39; }); let ws=fs.createWriteStream(&quot;./cop.js.gz&quot;) fs.createReadStream(&quot;./cop.js&quot;).pipe(gzip).pipe(ws); }else{ fs.createReadStream(&quot;./cop.js&quot;).pipe(res); } res.end() }).listen(3000)]]></content>
      <tags>
        <tag>js</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Hook]]></title>
    <url>%2F2019%2F08%2F08%2FHooks%2F</url>
    <content type="text"><![CDATA[Hook有状态的组件没有渲染，有渲染的组件没有状态。在现在回过头来看，这个原则会为我们后续向Hooks的迁移提供非常大的便利。 🔥 Hook简介 Hook是react16.8的新增特性，可以在不编写class类的情况下使用state以及react的其他特性React Hooks要解决的问题是状态共享，不会产生jsx嵌套问题 🏆 Hooks的运行规则 不能再循环中，条件语句和嵌套函数中调用hooks 只在react中函数组件中的hooks 🌟 React Hooks的特点 多个状态不会产生嵌套 Hooks还可以引用其他Hooks 更容易【更清晰】将组件的UI和状态进行分离 Hooks函数必须使用‘use’命名开头 📌 State Hook import React, { useState } from &#39;react&#39;; function Example() { // 声明一个叫 “count” 的 state 变量。 const [count, setCount] = useState(0); // 使用useState来定义state [参数名字, 改变参数的方法] // 也可以多个声明state 【但是必须保证调用的顺序一样】 const [tods, settods] = useState(&#39;this is count&#39;) return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt; &lt;/div&gt; ); } 函数组件会有特殊的处理方式 在render阶段，再将函数Fiber内容的实例化的时候去处理全局中的Hooks对象的指向 最终userState是调用内部函数mountState去设置state的stringif 在mountState会对传入的参数如果是函数会对其先执行，得出返回值在继续运行 在mountState中会创建一个闭包事件，将当前的Hooks所在的Fiber节点以及Hooks队列对象作为参数绑定在函数，并返回0 ⚡️ Effect Hook useEffect 给函数组件添加副作用，他和class组件中的componentDidMount、componentDidUpdate 和 componentWillUnmount具有相同的用途 实现componentDidMount 副作用函数 useEffect(() =&gt; { // 使用浏览器的 API 更新页面标题 document.title = `You clicked ${count} times`; }); 实现componentDidUpdate 副作用函数 useEffect(() =&gt; { // 使用浏览器的 API 更新页面标题 document.title = `You clicked ${count} times`; }, [count]); // 只在count发生改变的情况下调用 实现componentWillUnmount 副作用函数 useEffect(() =&gt; { // 使用浏览器的 API 更新页面标题 document.title = `You clicked ${count} times`; return () =&gt; { // 清除副作用操作 } }); userEffect的执行时机都发生在每次渲染之后，无论首次渲染还是更新渲染 userEffect只有在函数组件中执行，不能再非函数组件中执行 userEffect可以在函数组件中执行多次，是按调用顺序执行的 userEffect传入的函数，return是在组件卸载的时候执行的 userEffect的执行，是由他的第二参数来控制的，而且第二的参数必须是一个数组，react会对数组中的每一项与上次的数组进行比较，如果不同，则才会去执行函数 userEffect采用的是异步的方案执行，类似于js中的setTimeout，将userEffect进行异步执行 实用之处 再实现重复的数据请求中使用 function getData() { const [data, setdata] = useState(null) useEffect(() =&gt; { axios(&#39;/a/b&#39;).then(res =&gt; { setdata(res.data) }) }, []) return data } // 在别的函数组件中直接调用即可获取到数据【当然加入第二参数是为了防止数据更新的时候再次触犯请求数据执行】【灵活 的写法有很多种】 🔐 注意事项 不可以在hooks中使用条件语句【会影响hooks的调用规则（顺序）】，会导致调用混乱，产生bug 如果我们想执行一个判断可以将其放在内部来使用 useEffect(() =&gt; { // 将条件语句放置在hooks中 if (val != &#39;&#39;) { document.title = val } }) 我们可以去自定义hooks，但我们自定义的hooks必须以use开头，这是一种约定，它可以识别我们是否遵循了规范，他是hooks的规范，不是react的 💕 useContent可以使用useContext进行跨组件传值 // 父组件 import React, {useState} from &#39;react&#39; export const myContent = React.createContext(null) function Content() { const [val, setval] = useState(myContent) return ( &lt;&gt; &lt;input val = {val} onChange((e) =&gt; {setval(e.target.value)})/&gt; &lt;myContent.Provider&gt; &lt;Ptemp&gt;&lt;/Ptemp&gt; &lt;myContent.Provider&gt; &lt;/&gt; ) } export default Content // 子组件 import React, {useContext} from &#39;react&#39; import {myContent} from &#39;./home&#39; function Ptemp() { const val = useContext(myContent) return ( &lt;&gt; &lt;p&gt;{val}&lt;/p&gt; &lt;/&gt; ) } 🍭 useReducer**useReducer是useState的另一种替代，他接收(state, action) =&gt; newState, 并且返回了一个与当前state成对的dispatch方法 例1：最小的简单模式【计数器】 reducer.ts export const initialState = 0 const renducer = (state, action) =&gt; { switch(action) { case &#39;count&#39;: console.log(state) return state + 1 } } export default renducer PgReducer.tsx import React, {useState, useReducer} from &#39;react&#39; import renducer, {initialState} from &#39;../../renducer/expamel&#39; function testRenducer() { const [count, dispatch] = useReducer(renducer, initialState) return ( &lt;&gt; &lt;p&gt;{count}&lt;/p&gt; &lt;p onClick={() =&gt; {dispatch(&#39;count&#39;)}}&gt;+&lt;/p&gt; &lt;/&gt; ) } export default testRenducer ⚽ useRefuseRef返回一个可变的ref对象其.current属性被初始化为传入参数，返回的ref对象在组件的整个生命周期内保持不变 常见的就是访问子组件 获取一些dom元素的参数 import React, { useState, useRef, useEffect } from &#39;react&#39; function PgRef() { const ulRef = useRef(null) useEffect(() =&gt; { console.log(ulRef.current.offsetHeight) }) return ( &lt;&gt; &lt;p className=&#39;testP&#39; ref={ulRef}&gt;&lt;/p&gt; &lt;/&gt; ) } export default PgRef 🏹 原理实现🔨 useState首先我们来看一下useState的调用方式 const [count, setCount] = useState(0) 实现 let memoizedState = [] // memoizedState存储状态的数组 let curson = 0 // 当前memoizedState的下标 function useState(ininvalState) { memoizedState[curson] = memoizedState[curson] || ininvalState function setState(newState) { memoizedState[curson] = newState render() } return [memoizedState[curson++], setState] // 每个hooks调用都会递增curson, 从当前组件中取出状态 } 只是简单 的实现了一下useState【useState这个hooks这后台使用useReducer，他的返回结果其实已经是Reducer状态】 🔨 useEffect首先我们来看一下useEffect的调用方式 useEffect(() =&gt; { console.log(count) }, [count]) 实现 useEffect存在两个参数（callback, dep数组），如果dep数组不存在的话，每次render函数执行后，都会去执行callback函数，如果dep数组存在的时候，当dep发生改变的时候callback才会去执行 let memoizedState = []; // hooks 存放在这个数组 let cursor = 0; // 当前 memoizedState 下标 function useEffect(callback, dep) { const hasDeps = !dep // 是否有dep数组 const deps = memoizedState[cursor] const hasChangeDeps = deps ? !dep.every((el, i ) =&gt; el === deps[i]) : true if (hasDeps || hasChangeDeps) { callback(); memoizedState[cursor] = dep } cursor++; } 只是简单 的实现了一下useEffect, 在react调用会有自己的调用机制react中是通过单链表的方式来代替数组的，通过next来串联所有的hooks的 🔫 原理链接 https://juejin.im/post/5c99a75af265da60ef635898#comment🛡 Hooks队列 在初次渲染的时候，他的初始状态会被创建 他的状态可以在运行的时候进行更改 react可以在后续的渲染中记住hooks的状态 react可以根据调用的顺序提供给你正确的状态 react知道当前的hooks属于哪个部分]]></content>
      <tags>
        <tag>react</tag>
        <tag>hooks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Native填坑之删除第三方开源组件的依赖包]]></title>
    <url>%2F2019%2F05%2F24%2Freact-native%20unlink%2F</url>
    <content type="text"><![CDATA[React-Native填坑之删除第三方开源组件的依赖包今天遇到了一个问题：下载了react-native-webview的开源组件，可是在Android中遇到了问题，编译不通过，我想删除这个组件，然后写其他的功能，以后再添加这个地图功能，可是发现无法删除干净，android和ios原生都编译失败。就这个问题研究了下，现将方法卸载下面： npm uninstall -s -D -O react-native-webview 进入Android目录，找到setting.gradle文件 删除所有有关该包的依赖 然后进入android/app目录下，打开build.gradle 删除所有有关该包的依赖 打开android/app/src/main/java/com/包名/MainApplication.java, 删除所有有关该包的依赖 然后终端运行 npm install react-native run-android 成功！！！]]></content>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用react-native基础环境搭建]]></title>
    <url>%2F2019%2F05%2F22%2Freact-native-windows%2F</url>
    <content type="text"><![CDATA[使用react-native基础环境搭建Android Studio开发window环境搭建Android 开发环境搭建下载jdk 在这里你可以点击链接去下载 操作步骤按照下图进行操作 点进去以后是这么个页面 傻瓜式操作 接下来是配置环境变量 小娜搜索 变量名：JAVA_HOME变量值：当然是你安装的jdk目录了 编辑Path变量值 在Path值的前头加上 %JAVA_HOME%\bin; CLASSPATH变量 看一下如果你的系统变量中没有CLASSPATH变量，就新建一个输入变量值 .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; 测试 好了，现在我们来测试一下我们的环境变量是否配置成功 “开始”–“cmd”打开我们的dos命了窗口输入 javac 安装Android Studio地址： http://www.android-studio.org/ 现在的安装包一般没有sdk安装，直接下一步，不要慌 成功安装后， Android Studio配置加载本地配置信息提示 刚开始打开的时候会问我们是否加载本地的配置信息，其实就是android studio的配置环境信息等，如果你以前没有用过，忽略掉就好了。直接按默认的点ok启动android studio 接下来如果还有，直接Cancel 这时候我们需要sdk 附上链接https://www.androiddevtools.cn/ 安装完以后是这个样子 设置sdk的环境变量 设置adb环境变量【用来链接手机，这里不过多阐述】 验证 基础环境以搭建完成 这里需要着重强调必须node版本为10以上 如何安装node就不都在过多阐述 安装 react-native-cli npm install -g react-native-cli 安装完成后，通过 react-native-cli -v 查看版本，确定是否安装成功 初始化项目到指定目录下，通过命令行初始化一个项目： react-native init NewProject 随后开始初始化项目，下载资源： 运行项目 来到项目根目录下，通过输入如下命令来运行项目： react-native run-android 输入命令后，项目开始初始化运行，运行过程中会打开一个 node 服务窗口，如下所示： 然后重新输入命令 react-native run-android 来初始化运行项目，程序首先会解压 gradle 压缩文件，第一次初始化可能需要一点时间： 初始化完成后，项目运行成功，可以在手机上看到如下界面： 到现在为止，一个环境就搭建完成了，中还有少许挫折，但是还是成功了。。。。。。。。。]]></content>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ts的学习历程 -- 02]]></title>
    <url>%2F2019%2F05%2F16%2Fts-02%2F</url>
    <content type="text"><![CDATA[ts的学习历程 – 02ts接口ts的核心原则之一是对该值所对应的数据类型进行一个检测 作用：为你规定的这些类型命名，【签订契约】 /** * 通过ts对函数的参数进行检测 */ function lable(lable: {lable: string}){ console.log(lable) } let lables = { lable: &#39;storing&#39;, mine: 1 } lable(lables) 对参数lable进行检测，必须包括一个lable属性，并且值为string类型 使用接口进行描述 interface lableV { lable: string; } function lable(lable: lableV){ console.log(lable) } let lables = { lable: &#39;storing&#39;, mine: 1 } lable(lables) lableV此接口就相当于一个名字，用来描述参数的要求【它代表了有一个label属性且类型为string的对象】 可选属性 接口里面的属性不全是必须的，根据页面需求，有些参数可传可不传： interface lableV { lable?: string; mine?: number } function lable(lable: lableV){ console.log(lable) } let lables = { lable: &#39;storing&#39;, mine: 1 } lable(lables) 只读属性一些对象属性只能在对象创建的时候进行创建的时候修改他的值，你可以使用readonly指定只读属性 interface lableV { readonly a?: string; readonly b?: number } let str: lableV = { a: &#39;1&#39;, b: 1 } str.a = 1 // 报错 。 Cannot assign to &#39;a&#39; because it is a read-only property.ts(2540) 确保创建完以后不能再修改 typeScript具有ReadonlyArray类型，它与Array相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改： let a: number[] = [1, 2, 3, 4]; let ro: ReadonlyArray&lt;number&gt; = a; ro[0] = 12; // error! 类型“readonly number[]”中的索引签名仅允许读取。ts(2542) ro.push(5); // error! 类型“readonly number[]”上不存在属性“push”。ts(2339) ro.length = 100; // error! Cannot assign to &#39;length&#39; because it is a read-only property.ts(2540) a = ro; // error! Type &#39;readonly number[]&#39; is missing the following properties from type &#39;number[]&#39;: pop, push, reverse, shift, and 6 more.ts(2740) || //使用类型断言重写 a = ro as number[]; 最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用const，若做为属性则使用readonly。 额外的属性检测当我们在传参的过程中，对于某个属性，写错的时候，如下 interface lableV { lable?: string; mine?: number; maxs: number; } function lable(lable: lableV){ console.log(lable) } let lables = { lable: &#39;storing&#39;, mine: 1, max: 20, min: 10, array: [1,2,3,5] } lable(lables) //类型“{ lable: string; mine: number; max: number; min: number; array: number[]; }”的参数不能赋给类型“lableV”的参数。 //Property &#39;maxs&#39; is missing in type &#39;{ lable: string; mine: number; max: number; min: number; array: number[]; }&#39; but required in type &#39;lableV&#39;.ts(2345) //type.ts(50, 5): &#39;maxs&#39; is declared here 在js中没什么问题，如果传递的参数在函数中没有使用到，则可以正确执行，但是在ts中会认为这段代码存在bug，最佳的解决方法如下 interface SquareConfig { color?: string; width?: number; [propName: string]: any; } 函数类型接口也可以用来描述函数类型 interface SearchFunc { (source: string, subString: string): boolean; } let mySearch: SearchFunc; mySearch = function(source: string, subString: string) { let result = source.search(subString); return result &gt; -1; } //不能将类型“(source: string, subString: string) =&gt; string”分配给类型“SearchFunc”。 //不能将类型“string”分配给类型“boolean”。ts(2322) SearchFunc 该接口规定了函数的参数类型，以及该函数的返回值，如果与接口中定义的不匹配，则会出错 可索引类型接口可以描述那些能够通过索引得到的类型，可索引类型具有一个索引签名，它描述了对象索引的类型，还有相应的索引值类型，索引签名支持两种类型：number 和 string，但是由于 number 实际上会被转化为 string 类型（根据对象 key 的性质），所以需要遵守：number 索引的返回值类型是 string 索引的返回值类型的子类型。 interface IPerson { [index: string]: string; } let me: IPerson = {love: &#39;TS&#39;} me.name = &#39;funlee&#39;; me.age = 18; // error 不能将类型“18”分配给类型“string”。ts(2322) 如果 interface 里还声明了一个和索引签名索引返回值类型不匹配的属性，会报错 interface ITest { [index: string]: string; name: string; age: 18; // 报错，因为返回值类型是number，不符合string类型 [类型“18”的属性“age”不能赋给字符串索引类型“string”。ts(2411)] } 还可以声明一个 readonly 的索引签名 interface IPerson { readonly [index: string]: string; } let p: IPerson = {name: &#39;funlee&#39;}; p.love = &#39;TS&#39;; // error 类型“IPerson”中的索引签名仅允许读取。ts(2542) 类类型typeScript也可以使用class来实现一个接口，只不过他描述得是类的公共部分，因此不会检查类是否具有某些私有成员 interface ISome { prop: string // 描述一个属性 method(paramA: string, paramB: number) // 描述一个方法 } class A implements ISome { prop: &#39;propValue&#39; method(a: string, b: number) { // ... } constructor(paramA: number){ // ... } } 继承接口和类一样，接口也可以互相继承 interface Shape { color: string; } interface Square extends Shape { sideLength: number; } const square = &lt;Square&gt;{}; square.color = &#39;blue&#39;; square.sideLength = 10; 同时，一个接口也可以继承多个接口，创建出多个接口的合成接口，如： interface Shape { color: string; } interface PenStroke { penWidth: number; } interface Square extends Shape, PenStroke { sideLength } const square = &lt;Square&gt;{}; square.color = &#39;blue&#39;; square.sideLength = 10; square.penWidth = 5.0;]]></content>
      <tags>
        <tag>ts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ts的学习历程 -- 01]]></title>
    <url>%2F2019%2F05%2F10%2Fts-01%2F</url>
    <content type="text"><![CDATA[ts的学习历程 – 01ts是什么？ TypeScript 是 JavaScript 的一个超集，支持 ECMAScript 6 标准。 TypeScript 由微软开发的自由和开源的编程语言。 TypeScript 设计目标是开发大型应用，它可以编译成纯 JavaScript，编译出来的 JavaScript 可以运行在任何浏览器上。 语言特性ts是一种给js添加特性的扩展性语言，扩展功能如下： 基础类型 接口 类 函数 泛型 类型兼容性 高级类型 模块 命名空间 混入 基础类型js是弱语言类型，而ts类似c++这种强语言，可以对变量进行处理，规定变量的类型，让程序变得可维护性强，有价值。布尔值我们可以在ts中进行如下声明： let isDone: boolean = false 数字和js一样，ts中的数字都是浮点数，类型为number. let num: number = 6 字符串let str: string = &quot;26&quot; 数组有两种可以定义数组的方式 let list: number[] = [1, 2, 3] // 表示由此类型元素组成的一个数组 let list: Array&lt;number&gt; = [1, 2, 3] // 使用数组泛型Array&lt;元素类型&gt; 元组 Tuple元组类型表示允许一个已知元素数量和类型的数组，各元素的类型不必相同 let x: [string, number]; x = [&#39;hello&#39;, 10]; 枚举 enum类型是对JavaScript标准数据类型的一个补充 enum Color {Red, Green, Blue} let c: Color = Color.Green; 默认情况下，从0开始为元素编号。你也可以手动的指定成员的数值 enum Color {Red = 1, Green, Blue} let c: Color = Color.Green; 或者，全部都采用手动赋值： enum Color {Red = 1, Green = 2, Blue = 4} let c: Color = Color.Green; 枚举类型提供的一个便利是你可以由枚举的值得到它的名字 enum Color {Red = 1, Green, Blue} let colorName: string = Color[2]; // Green 任意值 any有的时候我们或许还不知到该变量到底该赋什么类型的值，比如对象 let notSure: any = 4; 当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据： let list: any[] = [1, true, &quot;free&quot;]; list[1] = 100; 空值 void你可以理解为和any相反的类型，他表示没有任何类型 function warnUser(): void { alert(&quot;This is my warning message&quot;); } 在声明变量的时候，你只能赋予它undefined和null let unusable: void = undefined; ||或 let unusable: void = null; Null 和 Undefinedundefined和null两者各自有自己的类型分别叫做undefined和null。 和void相似 let u: undefined = undefined; let n: null = null; Nevernever类型表示的是那些永不存在的值的类型。 返回never的函数必须存在无法达到的终点 function infiniteLoop(): never { while (true) { } } 类型断言有的时候会或许更了解你的一些变量【两种写法】 尖括号 let someValue: any = &quot;this is a string&quot;; let strLength: number = (&lt;string&gt;someValue).length; as语法 let someValue: any = &quot;this is a string&quot;; let strLength: number = (someValue as string).length; ！表示非null的意思 有时候获取的节点有可能为null，但是我们可以明确的使用ts表达自己的意向，明确自己想要的值 const a = document.getElementById(&#39;id&#39;)!]]></content>
      <tags>
        <tag>ts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax]]></title>
    <url>%2F2019%2F04%2F05%2Fajax-task%2F</url>
    <content type="text"><![CDATA[ajax什么是ajax?AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。Ajax 是一种用于创建快速动态网页的技术。Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。 原生js ajax请求有几个步骤？分别是什么//创建 XMLHttpRequest 对象 var ajax = new XMLHttpRequest(); //规定请求的类型、URL 以及是否异步处理请求。 ajax.open(&#39;GET&#39;,url,true); //发送信息至服务器时内容编码类型 ajax.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); //发送请求 ajax.send(null); //接受服务器响应数据 ajax.onreadystatechange = function () { if (ajax.readyState == 4 &amp;&amp; (ajax.status == 200 || ajax.status == 304)) { } }; ajax几种请求方式？他们的优缺点？常用的post,get,delete。 // 代码上的区别 1: get通过url传递参数 2: post设置请求头 规定请求数据类型 // 使用上的区别 1: post比get安全(因为post参数在请求体中。get参数在url上面) 2: get传输速度比post快 根据传参决定的。 (post通过请求体传参，后台通过数据流接收。速度稍微慢一些。而get通过url传参可以直接获取) 3: post传输文件大理论没有限制 get传输文件小大概7-8k ie4k左右 4: get获取数据 post上传数据(上传的数据比较多 而且上传数据都是重要数据。所以不论在安全性还是数据量级 post是最好的选择) 优点： 1.减轻服务器的负担,按需取数据,最大程度的减少冗余请求 2.局部刷新页面,减少用户心理和实际的等待时间,带来更好的用户体验 3.基于xml标准化,并被广泛支持,不需安装插件等,进一步促进页面和数据的分离 缺点： 1.AJAX大量的使用了javascript和ajax引擎,这些取决于浏览器的支持.在编写的时候考虑对浏览器的兼容性. 2.AJAX只是局部刷新,所以页面的后退按钮是没有用的. 3.对流媒体还有移动设备的支持不是太好等 请求头：header(&#39;Access-Control-Allow-Origin:*&#39;); //支持全域名访问，不安全，部署后需要固定限制为客户端网址 header(&#39;Access-Control-Allow-Methods:POST,GET,OPTIONS,DELETE&#39;); //支持的http 动作 header(&#39;Access-Control-Allow-Headers:x-requested-with,content-type&#39;); //响应头 请按照自己需求添加。]]></content>
      <tags>
        <tag>js</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-redux]]></title>
    <url>%2F2019%2F04%2F05%2Fredux%2F</url>
    <content type="text"><![CDATA[react-redux为什么需要redux学过react的都知道，react用state和props控制组件的渲染情况，而对于JavaScript单页面日趋复杂的今天，JavaScript需要管理越来越多的state，而这些state包括着各种乱七八糟途径来的数据。甚至有的应用的state会关系到另一个组件的状态。所以为了方便对这些state的管理以及对state变化的可控性。这个时候Redux这个东西就出来了，它可以让state的变化变得可预测。 Redux的基本概念什么是redux？这里非权威的解释：就是一个应用的state管理库，甚至可以说是前端数据库。更包括的是管理数据。 statestate是整个应用的数据，本质上是一个普通对象。 action数据state已经有了，那么我们是如何实现管理这些state中的数据的呢？那就是action，什么是action？按字面意思解释就是动作，也可以理解成，一个可能！改变state的动作包装。就这么简单。。。。 比如有一个counter数量加减应用，我们就有两个action，一个decrement，一个increment。 所以这里的action creator写成如下： export function decrement() { return{ type:DECREMENT_COUNTER } } export function increment(){ return{ type:INCREMENT_COUNTER } } 那么，当action创建完成了之后呢，我们怎么触发这些action呢，这时我们是要利用dispatch，比如我们执行count增减减少动作。 export function incrementIfOdd(){ return(dispatch,getState)=&gt;{ const {counter} = getState(); if(counter%2==0) { return; } dispatch(increment()); } } export function incrementAsync() { return dispatch =&gt; { setTimeout(() =&gt; { dispatch(increment()); }, 1000); }; } 为了减少样板代码，我们使用单独的模块或文件来定义 action type 常量 export const INCREMENT_COUNTER = &#39;INCREMENT_COUNTER&#39;; export const DECREMENT_COUNTER = &#39;DECREMENT_COUNTER&#39;; 这么做不是必须的，在大型应用中把它们显式地定义成常量还是利大于弊的。 reducer既然这个可能改变state的动作已经包装好了，那么我们怎么去判断并且对state做相应的改变呢？对，这就是reducer干的事情了。 reducer是state最终格式的确定。它是一个纯函数，也就是说，只要传入参数相同，返回计算得到的下一个 state 就一定相同。没有特殊情况、没有副作用，没有 API 请求、没有变量修改，单纯执行计算。 reducer对传入的action进行判断，然后返回一个通过判断后的state，这就是reducer的全部职责。如我们的counter应用： import {INCREMENT_COUNTER,DECREMENT_COUNTER} from &#39;../actions&#39;; export default function counter(state = 0, action) { switch (action.type){ case INCREMENT_COUNTER: return state+1; case DECREMENT_COUNTER: return state-1; default: return state; } } 对于一个比较大一点的应用来说，我们是需要将reducer拆分的，最后通过redux提供的combineReducers方法组合到一起。 如此项目上的： const rootReducer = combineReducers({ counter }); export default rootReducer; 每个reducer只负责管理全局state中它负责的一部分。每个reducer的state参数都不同，分别对应它管理的那部分state数据。combineReducers()所做的只是生成一个函数，这个函数来调用你的一系列reducer，每个reducer根据它们的key来筛选出state中的一部分数据并处理， 然后这个生成的函数再将所有reducer的结果合并成一个大的对象。 storestore是对之前说到一个联系和管理。具有如下职责 维持应用的state； 提供getState()方法获取 state 提供dispatch(action)方法更新 state； 通过subscribe(listener)注册监听器; 通过subscribe(listener)返回的函数注销监听器。 强调一下 Redux 应用只有一个单一的store。当需要拆分数据处理逻辑时，你应该使用reducer组合,而不是创建多个store。store的创建通过redux的createStore方法创建，这个方法还需要传入reducer，很容易理解：毕竟我需要dispatch一个action来改变state嘛。 应用一般会有一个初始化的state，所以可选为第二个参数，这个参数通常是有服务端提供的，传说中的Universal渲染。 第三个参数一般是需要使用的中间件，通过applyMiddleware传入。 redux-thunk一个比较流行的redux的action中间件，它可以让actionCreator暂时不返回action对象，而是返回一个函数，函数传递两个参数(dispatch, getState)，在函数体内进行业务逻辑的封装，比如异步操作，我们至少需要触发两个action，这时候我们可以通过redux-thunk将这两个action封装在一起，如下： store.js import { createStore, applyMiddleware } from &quot;redux&quot;; import RankReducer from &quot;./reducers/reducer&quot; import thunk from &quot;redux-thunk&quot;; const store = createStore(RankReducer, applyMiddleware(thunk)); export default store reducer.jsx const defaultState = { rankList: [] } const RankReducer = (state = defaultState, action) =&gt; { const { type, layload } = action; switch (type) { case &quot;UPDATE&quot;: return { ...state, rankList: layload } default: return state; } } export default RankReducer; rank.js import axios from &quot;axios&quot; export function updata(layload){ return function(dispatch){ return axios.get(&quot;/getrankList&quot;).then(result=&gt;{ return dispatch({ type:&quot;UPDATA&quot;, layload:result.data.data }) }) } } index.jsx import {updata} from &quot;../../store/action/rank&quot; const mapdispatchToprops=(dispatch)=&gt;{ return { updata(){ dispatch(updata()) }, add(layload){ dispatch({ type:&quot;ADD&quot;, layload:layload }) } } } react-reduxredux和react的桥梁工具。 index.js import React from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; import &quot;./common/css/index.css&quot; import App from &#39;../src/containers/app&#39;; import {Provider} from &quot;react-redux&quot; import {store} from &quot;./store/store&quot; ReactDOM.render( &lt;Provider store={store}&gt; &lt;App /&gt; &lt;/Provider&gt; ,document.getElementById(&#39;root&#39;) ); home.js import React from &quot;react&quot; import {connect} from &quot;react-redux&quot; class Home extends React.Component{ } const mapstateToprops=(state)=&gt;{ return state } const mapdispatchToprops=(dispatch)=&gt;{ return { updata(){ dispatch(updata()) }, add(layload){ dispatch({ type:&quot;ADD&quot;, layload:layload }) } } } export default connect(mapstateToprops,mapdispatchToprops)(Home) redux-saga上面介绍了redux-thunk是异步操作的方法，我们可以看出，他的函数内部比较复杂，如果需要每个异步操作都定义一个action的话，显然是不易维护的 redux-saga的APIredux-saga是通过ES6中的generator实现的（babel的基础版本不包含generator语法，因此需要在使用saga的地方import ‘babel-polyfill’）。redux-saga本质是一个可以自执行的generator。 redux-saga中的Effectredux-saga中定义了Effect，Effect是什么呢，本质就是一个特定的函数，返回的是纯文本对象。简单理解，通过Effect函数，会返回一个字符串，saga-middleware根据这个字符串来执行真正的异步操作，可以具体表现成如下形式： 异步操作——&gt;Effect函数——&gt;纯文本对象——&gt;saga-middleware——&gt;执行异步操作 因为Effect的存在，方便saga测试异步操作。 Effect具体函数Effect函数有很多个，在redux-saga/effects提供，主要包括call，fork，put，take，select等，它们都与middleware中的操作一一对应。 call 和 fork call和fork表示异步调用，其中call表示的是阻塞调用，fork表示的是非阻塞调用。 put和select put对应的是middleware中的dispatch方法，参数是一个plain object，一般在异步调用返回结果后，接着执行put。select相当于getState，用于获取store中的相应部分的state。 take、takeEvery、takeLatest redux-saga中如果在非阻塞调用下（fork）,那么遵循的是worker/watcher模式，通过take可以监听某个action是否被发起，此外通过take结合fork，可以实现takeEvery和takeLatest的效果。 如果一个异步操作的action被发起多次，takeEvery会执行多次action，而takeLatest只会执行最近的一次。 redux-saga的优缺点 优点： （1）集中处理了所有的异步操作，异步接口部分一目了然 （2）action是普通对象，这跟redux同步的action一模一样 （3）通过Effect，方便异步接口的测试 （4）通过worker 和watcher可以实现非阻塞异步调用，并且同时可以实现非阻塞调用下的事件监听 （5） 异步操作的流程是可以控制的，可以随时取消相应的异步操作。 缺点： 太复杂，学习成本较高 使用方式 sagas.js import { takeEvery, takeLatest } from &#39;redux-saga&#39;; import { call, put } from &#39;redux-saga/effects&#39;; import axios from &#39;axios&#39;; import { BEGIN_GET_POSTS, GET_POSTS, GET_POSTS_ERROR } from &#39;../reducers&#39;; // worker saga function* showPostsAsync(action) { try { const response = yield call(axios.get, &#39;https://jsonplaceholder.typicode.com/posts&#39;); yield put(GET_POSTS(response.data)); } catch(e) { yield put(GET_ERROR(e)); } } reducers.js import { combineReducers } from &#39;redux&#39; // actions export const RECEIVE_USERS = &#39;RECEIVE_USERS&#39;; export const FETCH_USERS_ERROR = &#39;FETCH_USERS_ERROR&#39;; export const RECEIVE_POSTS = &#39;RECEIVE_POPTS&#39;; export const FETCH_POSTS_ERROR = &#39;FETCH_USERS_ERROR&#39;; export const BEGIN_GET_POSTS = &#39;BEGIN_GET_POSTS&#39;; // action creators export function GET_USERS(users) { return { type: RECEIVE_USERS, users } } export function GET_ERROR(error) { return { type: FETCH_USERS_ERROR, error } } export function GET_POSTS(posts) { return { type: RECEIVE_POSTS, posts } } export function Begin_GET_POSTS() { return { type: BEGIN_GET_POSTS } } export function GET_POSTS_ERROR(error) { return { type: FETCH_POSTS_ERROR, error } } // reducer const initialState = { fetched: false, users: [{ key: &#39;1&#39;, name: &#39;张三&#39;, email: &#39;zhangsan@126.com&#39; }], posts: [{ key: &#39;1&#39;, id: &#39;1&#39;, title: &#39;test&#39; }], error: null }; const appReducer = (state = initialState, action) =&gt; { switch(action.type) { case FETCH_USERS_ERROR: { return {...state, error: action.error} break; } case RECEIVE_USERS: { return {...state, fetched: true, users: action.users} break; } case FETCH_POSTS_ERROR: { return {...state, error: action.error} break; } case RECEIVE_POSTS: { return {...state, fetched: true, posts: action.posts} break; } } return state; } export default appReducer app.js &#39;use strict&#39;; import &#39;../asset/css/style.scss&#39;; import &#39;antd/dist/antd.min.css&#39;; import React from &#39;react&#39;; import { render } from &#39;react-dom&#39;; import { Provider } from &#39;react-redux&#39;; import { createStore, applyMiddleware, combineReducers } from &#39;redux&#39;; import logger from &#39;redux-logger&#39;; import thunk from &#39;redux-thunk&#39;; import createSagaMiddleware from &#39;redux-saga&#39;; import axios from &#39;axios&#39;; import appReducer from &#39;./reducers&#39;; import AppRouter from &#39;./router&#39;; import rootSaga from &#39;./sagas&#39;; const sagaMiddleware = createSagaMiddleware(); const middlewares = [thunk, sagaMiddleware, logger]; const store = createStore(appReducer, applyMiddleware(...middlewares)); sagaMiddleware.run(rootSaga); render( &lt;Provider store={store}&gt; &lt;AppRouter /&gt; &lt;/Provider&gt;, document.getElementById(&#39;app&#39;) ); 总结本文介绍了react-redux基本使用方法：首先需要创建仓库，使用redux创建仓库，创建reducer，页面中使用dispatch执行action，将改变的值传递到renducer中，然而链接页面与仓库需要react-redux中的{provider,connect},在根目录进行链接，将组件使用provider包裹起来，将创建的仓库，传入到provider中，视图中使用connect链接仓库。 redux-thunk使用applymiddle引入插件thunk，创建一个函数，他返回一个函数，这个函数可以接收dispatch，他可以在异步任务执行完以后在，dispatch redux-sagaredux-sage中的effect中有put，call，select…几个属性，call使用来提交一个异步操作，有两个参数，第一个要执行的异步函数，第二个是要传递的参数，put是用来执行reducer，使用时需要创建一个sage]]></content>
      <tags>
        <tag>js</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react的概述]]></title>
    <url>%2F2019%2F04%2F03%2Freact-task%2F</url>
    <content type="text"><![CDATA[react的概述什么是react react是一个前端的js库，用于构建用户界面，尤其是单页面应用程序 react的特点： 单向数据流，组件化开发，虚拟dom，jsx，只关注mv*中的m这一层，渲染性能好 react组件的划分 业务组件 每个功能对应的业务逻辑划分 展示组件 列表，按钮表单。。。ui组件 容器组件 包装的盒子，页面组件 木偶组件 展示组件，功能组件【一些效果】 components[业务组件]（展示组件，木偶组件，容器组件）views[页面组件] 创建组件方式 class组件创建：业务组件，页面组件 函数式创建：展示组件，包装类型组件 render用法 在react中有两个render，一个是组件内部的render，一个是reactdom的render 组建的render用来返回一个虚拟dom，在里面不能修改state，只能读取 虚拟dom是通过编译器，将jsx转化为react.createElement()的方法调用，这个方法的返回结果就是一个jsx对象【虚拟dom】 每一个组件都必须有render这个方法 reactdom的render只是将虚拟dom渲染到页面中 react中的statestate只能定义在construct中的this.state中，函数式的组件没有state 修改state只能通过setState方法，只能修改一级属性，不能修改索引数组，不能通过属性修改对象 读取使用this.state.xxx，this.props.xxx 定义props默认值使用static defaultProps react的生明周期 组件初始化阶段 import React, { Component } from &#39;react&#39;; class Test extends Component { constructor(props) { super(props); } } 组件挂载阶段 componentWillMount: 在组件挂载到DOM前调用，且只会被调用一次，在这边调用this.setState不会引起组件重新渲染，也可以把写在这边的内容提前到constructor()中，所以项目中很少用。 render: 根据组件的props和state（无两者的重传递和重赋值，论值是否有变化，都可以引起组件重新render） ，return 一个React元素（描述组件，即UI），不负责组件实际渲染工作，之后由React自身根据此元素去渲染出页面DOM。render是纯函数（Pure function：函数的返回结果只依赖于它的参数；函数执行过程里面没有副作用），不能在里面执行this.setState，会有改变组件状态的副作用。 componentDidMount: 组件挂载到DOM后调用，且只会被调用一次 组件更新阶段 setState引起的state更新或父组件重新render引起的props更新，更新后的state和props相对之前无论是否有变化，都将引起子组件的重新render。 造成组件更新有两类（三种）情况： 父组件重新render 每当父组件重新render的导致的重传props，子组件将直接跟着重新渲染，可以通过shouldComponentUpdate方法进行优化 class Child extends Component { shouldComponentUpdate(nextProps){ // 应该使用这个方法，否则无论props是否有变化都将会导致组件跟着重新渲染 if(nextProps.someThings === this.props.someThings){ return false } } render() { return &lt;div&gt;{this.props.someThings}&lt;/div&gt; } } 在componentWillReceiveProps方法中，将props转换成自己的state class Child extends Component { constructor(props) { super(props); this.state = { someThings: props.someThings }; } componentWillReceiveProps(nextProps) { // 父组件重传props时就会调用这个方法 this.setState({someThings: nextProps.someThings}); } render() { return &lt;div&gt;{this.state.someThings}&lt;/div&gt; } } . 组件本身调用setState，无论state有没有变化。可通过shouldComponentUpdate方法优化。 class Child extends Component { constructor(props) { super(props); this.state = { someThings:1 } } shouldComponentUpdate(nextStates){ // 应该使用这个方法，否则无论state是否有变化都将会导致组件重新渲染 if(nextStates.someThings === this.state.someThings){ return false } } handleClick = () =&gt; { // 虽然调用了setState ，但state并无变化 const preSomeThings = this.state.someThings this.setState({ someThings: preSomeThings }) } render() { return &lt;div onClick = {this.handleClick}&gt;{this.state.someThings}&lt;/div&gt; } } 执行顺序：componentWillReceiveProps shouldComponentUpdate componentWillUpdate render componentDidUpdate componentWillReceiveProps(nextProps) 此方法只调用于props引起的组件更新过程中，参数nextProps是父组件传给当前组件的新props。但父组件render方法的调用不能保证重传给当前组件的props是有变化的，所以在此方法中根据nextProps和this.props来查明重传的props是否改变，以及如果改变了要执行啥，比如根据新的props调用this.setState出发当前组件的重新render shouldComponentUpdate(nextProps, nextState) 此方法通过比较nextProps，nextState及当前组件的this.props，this.state，返回true时当前组件将继续执行更新过程，返回false则当前组件更新停止，以此可用来减少组件的不必要渲染，优化组件性能。 componentWillUpdate(nextProps, nextState) 此方法在调用render方法前执行，在这边可执行一些组件更新发生前的工作，一般较少用。 render 只是重新调用。 componentDidUpdate(prevProps, prevState) 此方法在组件更新后被调用，可以操作组件更新的DOM，prevProps和prevState这两个参数指的是组件更新前的props和state 卸载阶段 componentWillUnmount 此方法在组件被卸载前调用，可以在这里执行一些清理工作，比如清楚组件中使用的定时器，清楚componentDidMount中手动创建的DOM元素等，以避免引起内存泄漏。 React v16.4 的生命周期变更缘由原来（React v16.0前）的生命周期在React v16推出的Fiber之后就不合适了，因为如果要开启async rendering，在render函数之前的所有函数，都有可能被执行多次。 原来（React v16.0前）的生命周期有哪些是在render前执行的呢？ componentWillMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate 如果开发者开了async rendering，而且又在以上这些render前执行的生命周期方法做AJAX请求的话，那AJAX将被无谓地多次调用。。。明显不是我们期望的结果。而且在componentWillMount里发起AJAX，不管多快得到结果也赶不上首次render，而且componentWillMount在服务器端渲染也会被调用到（当然，也许这是预期的结果），这样的IO操作放在componentDidMount里更合适。 因此引入两个新增的生命周期函数 getDerivedStateFromProps getSnapshotBeforeUpdate 随着getDerivedStateFromProps的推出，同时deprecate了一组生命周期API，包括： componentWillReceiveProps componentWillMount componentWillUpdate 按照官方说法，以前需要利用被deprecate的所有生命周期函数才能实现的功能，都可以通过getDerivedStateFromProps的帮助来实现。 这个getDerivedStateFromProps是一个静态函数，所以函数体内不能访问this，简单说，就是应该一个纯函数，纯函数是一个好东西啊，输出完全由输入决定。 static getDerivedStateFromProps(nextProps, prevState) { //根据nextProps和prevState计算出预期的状态改变，返回结果会被送给setState } 所有被deprecate的生命周期函数，目前还凑合着用，但是只要用了，开发模式下会有红色警告，在下一个大版本（也就是React v17)更新时会彻底废弃。 getSnapshotBeforeUpdate，这函数会在render之后执行，而执行之时DOM元素还没有被更新，给了一个机会去获取DOM信息，计算得到一个snapshot，这个snapshot会作为componentDidUpdate的第三个参数传入。 getSnapshotBeforeUpdate(prevProps, prevState) { console.log(&#39;#enter getSnapshotBeforeUpdate&#39;); return &#39;foo&#39;; } componentDidUpdate(prevProps, prevState, snapshot) { console.log(&#39;#enter componentDidUpdate snapshot = &#39;, snapshot); }. getDerivedStateFromProps无论是Mounting还是Updating，也无论是因为什么引起的Updating，全部都会被调用。 总结： 用一个静态函数getDerivedStateFromProps来取代被deprecate的几个生命周期函数，就是强制开发者在render之前只做无副作用的操作，而且能做的操作局限在根据props和state决定新的state，而已。 引用 程墨Morgan老师的React v16.3之后的组件生命周期函数]]></content>
      <tags>
        <tag>js</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对react-router的封装及api]]></title>
    <url>%2F2019%2F04%2F03%2Freact-router%2F</url>
    <content type="text"><![CDATA[对react-router的封装直接上代码吧 config.js // 该文件是对路由的配置 //组件的引入 import Home from &#39;../contentais/home/index&#39; import Login from &quot;../contentais/login/index&quot; import Business from &#39;./../contentais/home/business/index&#39;; import Finance from &#39;./../contentais/home/finance/index&#39;; import Tissue from &#39;./../contentais/home/tissue/index&#39;; import Statistics from &#39;./../contentais/home/statistics/index&#39;; import Order from &#39;./../contentais/home/order/index&#39;; import UserHome from &#39;./../contentais/home/userHome/index&#39;; import Loans from &#39;./../contentais/home/order/loans/index&#39;; import Transfer from &#39;./../contentais/home/order/transfer/index&#39;; import Insurance from &#39;./../contentais/home/order/insurance/index&#39;; const RouteConfig = [ { //title title: &quot;首页&quot;, //路由地址 path: &quot;/Home&quot;, //关键字重定向 defaultRedirect: true, //组件 component: Home, //二级路由 children: [ { key: &quot;1&quot;, defaultRedirect: true, title: &quot;首页&quot;, path: &quot;/Home/one&quot;, component: UserHome, }, { key: &quot;sub1&quot;, title: &quot;订单管理&quot;, path: &quot;/Home/order&quot;, component: Order, //三级路由 children: [ { defaultRedirect: true, key: &quot;2&quot;, title: &quot;贷款订单&quot;, path: &quot;/Home/order/loans&quot;, component: Loans, }, { key: &quot;3&quot;, title: &quot;转单订单&quot;, path: &quot;/Home/order/transfer&quot;, component: Transfer, }, { key: &quot;4&quot;, title: &quot;保险订单&quot;, path: &quot;/Home/order/insurance&quot;, component: Insurance, }, //三级路由的重定向 默认显示的页面 { path: &quot;/Home/order&quot;, redirect: &quot;/Home/order/loans&quot; } ] }, { key: &quot;5&quot;, title: &quot;财务管理&quot;, path: &quot;/Home/finance&quot;, component: Finance, } , { key: &quot;6&quot;, title: &quot;组织架构&quot;, path: &quot;/Home/tissue&quot;, component: Tissue, }, { key: &quot;7&quot;, title: &quot;数据统计&quot;, path: &quot;/Home/statistics&quot;, component: Statistics, }, { key: &quot;8&quot;, title: &quot;商务管理&quot;, path: &quot;/Home/business&quot;, component: Business, }, //二级路由的重定向 默认显示的页面 { path: &quot;/Home&quot;, redirect: &quot;/Home/one&quot; } ] }, { title: &quot;登陆&quot;, path: &quot;/Login&quot;, component: Login, }, { //一级路由的重定向 path: &quot;/&quot;, redirect: &quot;/Home&quot; } ] export default RouteConfig; routerView.js // 路由递归逻辑实现 import { Route, Switch, Redirect } from &quot;react-router-dom&quot; import React, { Component } from &#39;react&#39;; class RouteView extends Component { render() { // props接收配置文件 // routers 下一级路由的参数 // defaultConfig默认传参 const { routers, defaultConfig } = this.props // 这里判断【下一级路由的参数】是否有值 ? 【使用下一级路由的参数】 ： 【默认路由参数】 let routerDate = routers ? routers : defaultConfig; //数据二次处理 //筛除没有重定向的 let routerDatepath = routerDate.filter((item) =&gt; { return !item.redirect }) //筛选重定向 let defualtRouter = routerDate.filter((item) =&gt; { return item.redirect }) //重定向 let defualtRedirect = defualtRouter.map((item, i) =&gt; { return &lt;Redirect key={i} path={item.path} to={item.redirect}&gt;&lt;/Redirect&gt; }) return (&lt;Switch&gt; { routerDatepath &amp;&amp; routerDatepath.map((item, index) =&gt; { const Comp = item.component // 一个大坑 要用render 不然用component会导致页面的回流 return &lt;Route path={item.path} render={ //api 路由相关参数参数及其它 (api) =&gt; { //动态的title document.title = item.title || &quot;路由配置&quot; //把下一级路由参数存入props中 return &lt;Comp routers={item.children} {...api}&gt;&lt;/Comp&gt; } } key={&quot;key&quot; + item.key}&gt;&lt;/Route&gt; //重定向 }).concat(defualtRedirect) } &lt;/Switch&gt;) } } export default RouteView; app.js // 路由调用的使用方式 import React, { Component } from &#39;react&#39;; import { BrowserRouter as Router } from &quot;react-router-dom&quot; import RouteConfig from &#39;./config.js&#39;; // 引入路由的配置信息 import RouteView from &#39;./routeView,js&#39;; // 引入路由的逻辑实现 class App extends Component { render() { return &lt;div className=&quot;wrapper&quot;&gt; &lt;Router&gt; //传入默认路由配置文件 &lt;RouteView defaultConfig={RouteConfig}&gt;&lt;/RouteView&gt; &lt;/Router&gt; &lt;/div&gt; } } export default App; 二级路由的调用 import React, { Component } from &#39;react&#39;; import RouteView from &#39;./../../router/RouteView&#39;; import SiderMenu from &#39;./../../components/SiderMenu/index&#39;; import &quot;./index.css&quot; class Home extends Component { render() { //接收路由配置 const { routers } = this.props return &lt;div className=&quot;home-wrapper&quot;&gt; &lt;div className=&quot;left&quot;&gt; &lt;div className=&quot;user&quot;&gt; &lt;div className=&quot;user-img&quot;&gt; &lt;/div&gt; &lt;p className=&quot;mt12&quot;&gt;你瞅啥&lt;/p&gt; &lt;b className=&quot;mt12 radius&quot;&gt;&lt;/b&gt; &lt;/div&gt; //侧边栏的组件 &lt;SiderMenu style={{ background:"#2F3B4C"}} {...this.props}&gt;&lt;/SiderMenu&gt; &lt;div className=&quot;ri &lt;/div&gt;ght&quot;&gt; //传入RouteView当中进行处理 &lt;RouteView routers={routers}&gt;&lt;/RouteView&gt; &lt;/div&gt; &lt;/div&gt; } } export default Home; ‘react-router-dom的apireact-router-dom提供了BrowserRouter, Route, Link等api,我们可以通过dom的事件控制路由。例如点击一个按钮进行跳转，大多数情况下我们是这种情况，所以在开发过程中，我们更多是使用React-router-dom。安装很简单npm i react-router-dom –save,安装了淘宝镜像的就用cnpm吧。 常用的路由api HashRouter和BrowserRouter 它们两个是路由的基本，就像盖房子必须有地基一样，我们需要将它们包裹在最外层，我们只要选择其一就可以了。现在讲它们的不同： HashRouter 如果你使用过react-router2或3或者vue-router，你经常会发现一个现象就是url中会有个#，例如localhost:3000/#，HashRouter就会出现这种情况，它是通过hash值来对路由进行控制。如果你使用HashRouter，你的路由就会默认有这个#。 BrowserRouter 很多情况下我们则不是这种情况，我们不需要这个#，因为它看起来很怪，这时我们就需要用到BrowserRouter。 Route Route是路由的一个原材料，它是控制路径对应显示的组件。我们经常用的是exact、path以及component属性。 &lt;Route path=&#39;/&#39; component=&#39;&#39; exact&gt;&lt;/Route&gt; exact控制匹配到/路径时不会再继续向下匹配， path标识路由的路径 component表示路径对应显示的组件 Link和NavLink的选择 两者都是可以控制路由跳转的，不同点是NavLink的api更多，更加满足你的需求。 Link 主要api是to，to可以接受string或者一个object，来控制url。使用方法如下 NavLink 它可以为当前选中的路由设置类名、样式以及回调函数等。使用如下 &lt;Navlink to=&#39;&#39; activeClassName=&#39;actived&#39;&gt; activeClassName是选中状态的类名，我们可以为其添加样式 Switch Switch常常会用来包裹Route，它里面不能放其他元素，用来只显示一个路由。]]></content>
      <tags>
        <tag>js</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react组件优化及组件通讯]]></title>
    <url>%2F2019%2F04%2F03%2Freact-optimization%2F</url>
    <content type="text"><![CDATA[react组件优化key值在使用v-for的情况下，给每个变量的元素都加上key值，加key值得好处已经在上一文中提到过，主要为了提高渲染效率 shouldComponentUpdate该生命周期可以决定数据改变的时候是否进行render，返回值为boolean，返回true即为渲染，返回false及不渲染，默认不写为true 纯函数组件将单独的项封装成一个组件，已达到服用效果 组件通讯父传子 使用props传值 父组件 import React,{ Component } from &quot;react&quot;; import Sub from &quot;./SubComponent.js&quot;; import &quot;./App.css&quot;; export default class App extends Component{ render(){ return( &lt;div&gt; &lt;Sub title = &quot;今年过节不收礼&quot; /&gt; &lt;/div&gt; ) } } 子组件 import React from &quot;react&quot;; const Sub = (props) =&gt; { return( &lt;h1&gt; { props.title } &lt;/h1&gt; ) } export default Sub; 子传父父组件 import React,{ Component } from &quot;react&quot;; import Sub from &quot;./SubComponent.js&quot;; import &quot;./App.css&quot;; export default class App extends Component{ callback(msg){ console.log(msg); } render(){ return( &lt;div&gt; &lt;Sub callback = { this.callback.bind(this) } /&gt; &lt;/div&gt; ) } } 子组件 import React from &quot;react&quot;; const Sub = (props) =&gt; { const cb = (msg) =&gt; { return () =&gt; { props.callback(msg) } } return( &lt;div&gt; &lt;button onClick = { cb(&quot;我们通信把&quot;) }&gt;点击我&lt;/button&gt; &lt;/div&gt; ) } export default Sub; 跨组件传值 16.3版本提供了新的context api,并且用了生产者消费者模式， const {Provider, Consumer} = React.createContext({ color: &#39;white&#39; }); class Item extends Component { static contextTypes = { color: React.PropTypes.string, }; render() { const {value} = this.props; return ( &lt;Consumer&gt; {context =&gt; ( &lt;li style={{background: context.color}}&gt; &lt;span&gt;{value}&lt;/span&gt; &lt;/li&gt; )} &lt;/Consumer&gt; ); } } class List extends Component { render() { const {list} = [{id: &#39;1&#39;, text: 1}, {id: &#39;1&#39;, text: 2}, {id: &#39;1&#39;, text: 3}] return ( &lt;Provider value={{color: 'green'}}&gt; &lt;div&gt; &lt;ul&gt; {list.map((entry, index) =&gt; ( &lt;Item key={entry.id} value={entry.text}/&gt; ))} &lt;/ul&gt; &lt;/div&gt; &lt;/Provider&gt; ); } } 上面的代码通过React.createContext创建出一个上下文：Context对象，然后这个Context对象又包含两个属性，一个叫Provider，另一个叫Consumer，这两个属性都是纯种的React组件。 在父组件中运用Provider，在子组件中运用Consumer即可，Provider中通过value属性可以向Consumer传递参数，而Consumer的子组件则是一个函数，在这个子组件中定义一个函数，Consumer会向它传递一个context，这个context来自于Provider，达到通信的目的 非嵌套组件间通信这里我们采用自定义事件的方式来实现非嵌套组件间的通信。 npm install events --save 新建一个 ev.js，引入 events 包，并向外提供一个事件对象，供通信时使用： import { EventEmitter } from &quot;events&quot;; export default new EventEmitter(); App.js： import React, { Component } from &#39;react&#39;; import Foo from &quot;./Foo&quot;; import Boo from &quot;./Boo&quot;; import &quot;./App.css&quot;; export default class App extends Component{ render(){ return( &lt;div&gt; &lt;Foo /&gt; &lt;Boo /&gt; &lt;/div&gt; ); } } Foo.js： import React,{ Component } from &quot;react&quot;; import emitter from &quot;./ev&quot; export default class Foo extends Component{ constructor(props) { super(props); this.state = { msg:null, }; } componentDidMount(){ // 声明一个自定义事件 // 在组件装载完成以后 this.eventEmitter = emitter.addListener(&quot;callMe&quot;,(msg)=&gt;{ this.setState({ msg }) }); } // 组件销毁前移除事件监听 componentWillUnmount(){ emitter.removeListener(this.eventEmitter); } render(){ return( &lt;div&gt; { this.state.msg } 我是非嵌套 1 号 &lt;/div&gt; ); } } Boo.js： import React,{ Component } from &quot;react&quot;; import emitter from &quot;./ev&quot; export default class Boo extends Component{ render(){ const cb = (msg) =&gt; { return () =&gt; { // 触发自定义事件 emitter.emit(&quot;callMe&quot;,&quot;Hello&quot;) } } return( &lt;div&gt; 我是非嵌套 2 号 &lt;button onClick = { cb(&quot;blue&quot;) }&gt;点击我&lt;/button&gt; &lt;/div&gt; ); } } 自定义事件是典型的发布/订阅模式，通过向事件对象上添加监听器和触发事件来实现组件间通信。 总结： 父传子：通过props 子传父：通过回调 跨组件传值： 引入react.createContext()中的{provider, consumer}，使用生产者和消费者模式，在父组件中使用provider 传入值，子组件通consumer 接收一个对象的函数回调[{context =&gt; (&lt;\li&gt;{context}&lt;\/li&gt;)}] 同级组件通讯：使用events插件，通过发布订阅者模式执行]]></content>
      <tags>
        <tag>js</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈React的最大亮点——虚拟DOM]]></title>
    <url>%2F2019%2F04%2F03%2FvirtualDom1%20%2F</url>
    <content type="text"><![CDATA[浅谈React的最大亮点——虚拟DOMReact非常快速是因为它从不直接操作DOM。 虚拟DOM是在DOM的基础上建立了一个抽象层，对数据和状态所做的任何改动，都会被自动且高效的同步到虚拟DOM，最后再批量同步到DOM中。 在React中，render执行的结果得到的并不是真正的DOM节点，而仅仅是JavaScript对象，称之为虚拟DOM。 虚拟DOM具有批处理和高效的Diff算法，可以无需担心性能问题而随时“刷新”整个页面，因为虚拟DOM可以确保只对界面上真正变化的部分进行实际的DOM操作。 虚拟DOM的原理：React会在内存中维护一个虚拟DOM树，对这个树进行读或写，实际上是对虚拟DOM进行。当数据变化时，React会自动更新虚拟DOM，然后将新的虚拟DOM和旧的虚拟DOM进行对比，找到变更的部分，得出一个diff，然后将diff放到一个队列里，最终批量更新这些diff到DOM中。 虚拟DOM的优点：最终表现在DOM上的修改只是变更的部分，可以保证非常高效的渲染。 虚拟DOM的缺点：首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。 虚拟DOM的理解误区对虚拟DOM的理解往往停留在：通过JavaScript对象模拟原生DOM，加上DOM Diff 极大提升了DOM操作的性能。然而，虚拟DOM最大的意义不在于性能的提升（JavaScript对象比DOM对象性能高），而在于抽象了DOM的具体实现（对DOM进行了一层抽象），这在浏览器中使用 React时不是特别明显，因为写的DOM标签跟原生的没有区别，并且最终都被渲染成了DOM，在React Native中将会有很好的说明。 模拟方法和渲染方法 调用 let virtualDom1 = createElement(&#39;ul&#39;, {class: &#39;list&#39;}, [ createElement(&#39;li&#39;, {class: &#39;item&#39;}, [&#39;a&#39;]), createElement(&#39;li&#39;, {class: &#39;item&#39;}, [&#39;b&#39;]), createElement(&#39;li&#39;, {class: &#39;item&#39;}, [&#39;c&#39;]), ]) let virtualDom2 = createElement(&#39;ul&#39;, {class: &#39;list&#39;}, [ createElement(&#39;li&#39;, {class: &#39;item&#39;}, [&#39;1&#39;]), createElement(&#39;li&#39;, {class: &#39;item&#39;}, [&#39;2&#39;]), createElement(&#39;li&#39;, {class: &#39;item&#39;}, [&#39;3&#39;]), ]) let el = render(virtualDom); renderDom(el, window.root); let patchs = diff(virtualDom1, virtualDom2); 生成虚拟对象的方法createElement function createElement(type, props, children) { return new Element(type, props, children) } class Element{ constructor(type, props, children){ this.type = type; this.props = props; this.children = children } } 将虚拟对象渲染成真实DOM的render方法 //render方法将vNode转化成真实DOM function render(eleObj){ //创建元素 let el = document.createElement(eleObj.type); //设置属性 for(let key in eleObj.props) { setAttr(el, key, eleObj.props[key]); } //递归渲染子元素 eleObj.children.foEach(child =&gt; { child = child instanceof Element ? render(child) : document.createTextNode(child); el.appendChild(child); }) } setAttr(node, key, value) { switch(key) { case &#39;value&#39;: if (node.tagName.toUpperCase() === &#39;INPUT&#39; || node.tagName.toUpperCase() === &#39;TEXTAREA&#39;) { node.value = value; }else { node.setAttribute(key, value); } break; case &#39;style&#39;: node.style.cssText = value; break; default: node.setAttribute(key, value); break; } } 渲染节点到页面的方法renderDom //将真实DOM渲染到页面 function renderDom(el, target) { target.appendChild(el); } DOM DIFF 算法DOM DIFF 就是比较两个虚拟DOM的区别，实际上就是比较两个对象的区别。根据两个虚拟对象创建出补丁，描述改变的内容。将这个补丁用来更新DOM。 【注意】不会更改所有节点，只更改有改变的部分 算法实现 差异计算：先序深度优先遍历 规则： 若节点类型不相同，直接采用替换模式，{type:’REPLACE’,newNode:newNode} 当节点类型相同时，去看一下属性是否相同，产生一个属性的补丁包，比如{type:’ATTRS’,attrs:{class: ‘list-group’} 新的DOM节点不存在，也返回一个不存在的补丁包{type:’REMOVE’,index:XXX} 文本的变化{type:’TEXT’, text:1} //diff 算法 let Index = 0; function diff(oldTree, newTree) { let patches = {}; let index = 0; //递归数比较后的结果放到补丁包中 walk(oldTree, newTree, index, patches); return patches; } function walk(oldTree, newTree, index, patches){ let currentPatch = [];//每个元素都有一个补丁对象 if (!newTree) { currentPatch.push({type:&#39;REMOVE&#39;, index}) } if (isString(oldTree) &amp;&amp; isString(newTree)) { // 判断文本是否一致 if (oldTree !== newTree) { currentPatch.push({type:&#39;TEXT&#39;,text:newTree}); } }else if(oldTree.type === newTree.type) { //比较属性是否有更改 let attrs = diffAttr(oldTree.props, newTree.props); if(Object.keys(attrs).length) { currentPatch.push({type:&#39;ATTRS&#39;, attrs}); } // 如果有儿子节点，遍历子节点 diffChildren(oldTree.children, newTree.children, index, patches); } else { // 节点类型不同的时候，直接替换 currentPatch.push({type:&#39;REPLACE&#39;, newTree}); } // 当前元素有补丁的情况下，将元素和补丁对应起来，放到大补丁包中 if(currentPatch.length) { patches[index] = currentPatch; } } function diffAttr(oldAttrs, newAttrs) { let patch = {}; for(let key in oldAttrs) { if(oldAttrs[key] !== newAttrs[key]) { patch[key] = newAttrs[key];//有可能是undefined，新节点没有旧节点的属性 } } for(let key in newAttrs) { //老节点没有新节点的属性 if(! oldAttrs.hasOwnProperty(key)) { patch[key] = newAttrs[key] } } return patch; } function diffChildren(oldChildren, newChildren, index, patches){ // 比较老的第一个和新的第一个 oldChildren.forEach((child, idx) =&gt; { // 记得索引得改 // Index 每次传递给walk时，index是递增的，所有节点都基于一个序号实现，因此需要维护一个全局Index walk(child, newChildren[idx], ++Index, patches); }) } function isString(node) { return Object.prototype.toString.call(node) === &#39;[object string]&#39;; } function patch(node, patches) { // 给某个元素打补丁 } 总结 dom结构发生改变： 直接卸载并重新create dom结构一样： 不会卸载，但是会更新 在同一层级的子节点，他们都可以通过key开区分【同时遵循上面两点】 衍生：加了key的好处: 加了key值可以具体确定哪些元素被修改，便于对比新旧dom树，加快虚拟dom的渲染速度 我们该不该把map的index作为key 最好将数据本身的id最为key值，如果使用index作为key值，如果前后两次两次arr分别为[1,2,3,4]和[5,6,7,8]和前后两次arr分别为[1,2,3,4]和[4,3,2,1]的情况,很明显前者可以认为是DOM改变了,后者可以认为是DOM节点的位移操作,那么对于第一种情况来说index作为key和没有key值无区别,但是第二种情况用index作为key值效果没有比用数据本身作为key值好 key值必须唯一且不重复么 前提条件是是否为同一父节点 参考文章：飞飞廉的简书]]></content>
      <tags>
        <tag>js</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React组件销毁中清理异步操作和取消请求]]></title>
    <url>%2F2019%2F04%2F03%2Freact-question%2F</url>
    <content type="text"><![CDATA[React组件销毁中清理异步操作和取消请求问题描述当我们在平时切换组件的时候，会遇到这种情况，如果组件中有异步请求任务，【当接口已经发出请求，但是组件已经销毁，那么接口返回数据后。。。】 会有这么一个警告 Warning: Can’t perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method. 翻译： 警告：无法对未安装的组件执行响应状态更新。这是一个禁止操作，但它表示应用程序内存泄漏。要修复，请取消componentwillunmount方法中的所有订阅和异步任务。 解决方法 情况一: 阻止异步操作 componentWillUnmount() { this.setState = (state, callback) =&gt; { return } } 情况二: 清除定时 var timer; ... componentDidMount = () =&gt; { timer = setTimeout(() =&gt; { this.setState({a:123}) },1000) } componentWillUnMount = () =&gt; { clearTimeout(timer) }]]></content>
      <tags>
        <tag>js</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react中的setState的使用和深入理解]]></title>
    <url>%2F2019%2F04%2F03%2FsetState%2F</url>
    <content type="text"><![CDATA[react中的setState的使用和深入理解React通过管理状态实现对组件的管理，通过this.state()方法更新state。当this.setState()被调用的时候，React会重新调用render方法来重新渲染UI。 在使用state的时候， 如果我们企图直接修改state中的某一个值之后直接打印（使用）他，就会发现，他其实并没有改变。 就像下面的例子，企图通过点击事件之后就使用修改之后的state的值，但是会发state中的并没有被立即修改，还是原先的值，我们都知道那是因为setState就相当于是一个异步操作，不能立即被修改 ClickChangeState () { this.setState({ isActive: true, }) console.log(this.state.isActive) // false } 那么我们也都知道为了解决上面的问题会有很多方法例如： 方法一： ClickChangeState () { this.setState({ isActive: true, }, () =&gt; { console.log(this.state.isActive) // true }) } 这个回调函数会在修改了state之后才会执行，这就就可以使用修改之后的state的值了 方法二： async ClickChangeState () { await this.setState({ isActive: true, }) console.log(this.state.isActive) // false } 操作异步函数，用的最舒服的还是async / await 在使用setState的时候，有两种格式;第一种setstate（）格式 第一个参数是一个对象，第二个参数是一个回调函数，这个回调函数是在setstate执行完并页面渲染了之后再执行ClickChangeState () { this.setState({ isActive: true, }, () =&gt; { console.log(this.state.isActive) // true }) } 但是这种修改的方式不稳妥，因为是直接修改 setstate的第二种格式，接收一个回调函数，而不是一个对象，这个回调函数有两个参数，一个是接收前一个状态值作为第一个参数，并将更新后的值作为第二个参数 ClickChangeState () { this.setState((prevState) =&gt; { isActive: !prevState.isActive, }, () =&gt; { console.log(this.state.isActive) // true }) } setState异步更新 setState通过一个队列机制实现state的更新。当执行setState时，会把需要更新的state合并后放入状态队列，而不会立刻更新this.state，利用这个队列机制可以高效的批量的更新state。 React文档中对setState的说明 void setState( function|object nextState, [function callback] ) The second (optional) parameter is a callback function that will be executed once setState is completed and the component is re-rendered. 翻译： 第二个（可选）参数是一个回调函数，它将在setstate完成并重新呈现组件后执行。 也就是说，我们可以通过这个回调来拿到更新的state的值。React也正是利用状态队列机制实现了setState的异步更新，避免频繁地重复更新state(pending的意思是未定的 //将新的state合并到状态更新队列中 var nextState = this._processPendingState(nextProps, nextContext); //根据更新队列和shouldComponent的状态来判断是否需要更新组件 var shouldUpdate = this._pendingForceUpdate || !inst.shouldComponentUpdate || inst.shouldComponentUpdate(nextProps, nextState, nextContext); setState循环调用风险如果在shouldComponentUpdate或者componentWillUpdate方法中调用setState，此时this._pending-StateQueue != null，就会造成循环调用，使得浏览器内存占满后崩溃 调用栈import React, { Component } from &#39;react&#39;; class Example extends Component { constructor(){ super(); //在组件初始化可以直接操作this.state this.state = { val: 0 } } componentDidMount(){ this.setState({ val: this.state.val + 1 }); //第一次输出 console.log(this.state.val); this.setState({ val: this.state.val + 1 }); //第二次输出 console.log(this.state.val); setTimeout(()=&gt;{ this.setState({val: this.state.val + 1}); //第三次输出 console.log(this.state.val); this.setState({ val: this.state.val + 1 }); //第四次输出 console.log(this.state.val); }, 0); } render(){ return null; } } 上述代码中，4次console.log打印出来的val分别是: 0，0，2 ，3 我们来看一个简化的setState的调用栈 this.setState(newState) =&gt; newState存入pending队列 =&gt; 调用enqueueUpdate =&gt; 是否处于批量更新模式 =&gt; 是的话将组件保存到dirtyComponents 不是的话遍历dirtyComponents，调用updateComponent,更新pending state or props 事务(transaction)事务就是将需要执行的方法用wrapper封装起来，再通过事务提供的perform方法执行。而再perform之前，先执行所wrapeer中的initialize方法，执行完需要执行的方法后，再执行close方法。一组initialize和close方法称为一个wrapper，事务支持多个wrapper叠加。 我们可以将4次setState简单规成两类，componentDidMount是一类，setTimeOut中的又是一类，因为这两次在不同的调用栈中执行。 我们先看看在componentDidMount中setState的调用栈： 再看看在setTimeOut中的调用栈： 前两次是整个将React组件渲染到DOM的过程就处于一个大的事务中 componentDidMount中调用setState时,两次setState的结果并没有立即生效，而是被放进了dirtyComponents中。因为新的state还没被应用到组件中。 setTimeOut中的两次setState，因为没有跟随组件到渲染dom的一个流程，导致了新的state马上生效，也就是说，setTimeOut中的第一次执行，setState时，this.state.val为1，而setState完成后打印时this.state.val变成了2。第二次的setState同理。 总结在执行setState并不是说他是异步的，官方给出的说明是 不保证this.state会立即更新，所以在调用这个方法后存取this.state可能会回传旧的值。 不保证调用setState就会同步地执行，而它们也可能最终被被批量调用(多次调用的情况下)。你可以提供额外的回调，回调将会在setState实际被完成时被执行。 在执行setState，他是跟随将react组件渲染到dom这个流程走的，会将新的state值放入到一个更新队列中，事务（transaction）会进行下一步操作。在批量调用的情况下，会对多个setState进行合并。setTimeout中setState和在生命周期里setState的区别在于，setTimeout中的setState会自己触发一个transaction，而生命周期中的setState已经处于React生命周期的transaction中了。]]></content>
      <tags>
        <tag>js</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React.Component 与 React.PureComponent（React之性能优化）]]></title>
    <url>%2F2019%2F04%2F03%2FPureComponent%2F</url>
    <content type="text"><![CDATA[React.Component 与 React.PureComponent（React之性能优化）提起React.PureComponent，首先要从一个生命周期函数【shouldComponentUpdate】说起，都知道这个函数是用来控制组件是否应该被渲染 shouldComponentUpdate 这个生命周期返回的是一个布尔值，如果返回为false的，其实就是不执行render函数，不执行就不会重新渲染，返回为true的时候，就会执行，如果不写这个生命周期，默认返回true 写入shouldComponentUpdate，可以提高性能，你可以在该函数根据业务需求来判断是否重新渲染 class CounterButton extends React.Component { constructor(props) { super(props); this.state = {count: 1}; } shouldComponentUpdate(nextProps, nextState) { if (this.props.color !== nextProps.color) { return true; } if (this.state.count !== nextState.count) { return true; } return false; } render() { return ( &lt;button color={this.props.color} onClick={() =&gt; this.setState(state =&gt; ({count: state.count + 1}))} &gt; Count: {this.state.count} &lt;/button&gt; ); } } React.Component 与 React.PureComponent通常情况下，我们会使用ES6的class关键字来创建React组件： class MyComponent extends React.Component { // some codes here ... } 但是，你也可以创建一个继承React.PureComponent的React组件，就像这样 class MyComponent extends React.PureComponent { // some codes here } 区别： 继承PureComponent时，不能再重写shouldComponentUpdate，否则会引发警告 Warning: ListOfWords has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used. 警告：ListOfWords有一个名为ShouldComponentUpdate（）的方法。扩展react.pureComponent时不应使用ShouldComponentUpdate。如果使用shouldComponentUpdate，请扩展react.component。 继承PureComponent时，进行的是浅比较，也就是说，如果是引用类型的数据，只会比较是不是同一个地址，而不会比较具体这个地址存的数据是否完全一致 PureComponent原理:当组件更新时，如果组件的 props 和 state 都没发生改变， render 方法就不会触发，省去 Virtual DOM 的生成和比对过程，达到提升性能的目的。具体就是 React 自动帮我们做了一层浅比较： if (this._compositeType === CompositeTypes.PureClass) { shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState); } 而 shallowEqual 又做了什么呢？会比较 Object.keys(state | props) 的长度是否一致，每一个 key 是否两者都有，并且是否是一个引用，也就是只比较了第一层的值，确实很浅，所以深层的嵌套数据是对比不出来的。 问题:大部分情况下，你可以使用React.PureComponent而不必写你自己的shouldComponentUpdate，它只做一个浅比较。但是由于浅比较会忽略属性或状态突变的情况，此时你不能使用它。 class ListOfWords extends React.PureComponent { render() { return &lt;div&gt;{this.props.words.join(&#39;,&#39;)}&lt;/div&gt;; } } class WordAdder extends React.Component { constructor(props) { super(props); this.state = { words: [&#39;marklar&#39;] }; this.handleClick = this.handleClick.bind(this); } handleClick() { // This section is bad style and causes a bug const words = this.state.words; words.push(&#39;marklar&#39;); this.setState({words: words}); } render() { return ( &lt;div&gt; &lt;button onClick={this.handleClick} /&gt; &lt;ListOfWords words={this.state.words} /&gt; &lt;/div&gt; ); } } 在ListOfWords中，this.props.words是WordAdder中传入的其state的一个引用。虽然在WordAdder的handelClick方法中被改变了，但是对于ListOfWords来说，其引用是不变的，从而导致并没有被更新。 解决方法在上面的问题中可以发现，当一个数据是不变数据时，可以使用一个引用。但是对于一个易变数据来说，不能使用引用的方式给到PureComponent。简单来说，就是我们在PureComponent外层来修改其使用的数据时，应该给其赋值一个新的对象或者引用，从而才能确保其能够进行重新渲染。例如上面例子中的handleClick可以通过以下几种来进行修改从而确认正确的渲染： handleClick() { this.setState(prevState =&gt; ({ words: prevState.words.concat([&#39;marklar&#39;]) })); } 或者 handleClick() { this.setState(prevState =&gt; ({ words: [...prevState.words, &#39;marklar&#39;], })); }; 或者针对对象结构： function updateColorMap(oldObj) { return Object.assign({}, oldObj, {key: new value}); } immutable.js是解决这个问题的另一种方法。它通过结构共享提供不可突变的，持久的集合： 详情参考immutable.js 总结 PureComponent 真正起作用的，只是在一些纯展示组件上，复杂组件使用的话shallowEqual 那一关基本就过不了。另外在使用的过程中为了确保能够正确的渲染，记得 props 和 state 不能使用同一个引用哦。]]></content>
      <tags>
        <tag>js</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue混入【mixins】]]></title>
    <url>%2F2019%2F04%2F02%2Fminxins%2F</url>
    <content type="text"><![CDATA[vue混入【mixins】混入 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。 // 定义一个混入对象 var myMixin = { created: function () { this.hello() }, methods: { hello: function () { console.log(&#39;hello from mixin!&#39;) } } } // 定义一个使用混入对象的组件 var Component = Vue.extend({ mixins: [myMixin] }) var component = new Component() // =&gt; &quot;hello from mixin!&quot; 选项合并当组件和混入对象含有同名选项时，这些选项将以恰当的方式混合。 比如，数据对象在内部会进行递归合并，在和组件的数据发生冲突时以组件数据优先。 var mixin = { data: function () { return { message: &#39;hello&#39;, foo: &#39;abc&#39; } } } new Vue({ mixins: [mixin], data: function () { return { message: &#39;goodbye&#39;, bar: &#39;def&#39; } }, created: function () { console.log(this.$data) // =&gt; { message: &quot;goodbye&quot;, foo: &quot;abc&quot;, bar: &quot;def&quot; } } }) 同名钩子函数将混合为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。 var mixin = { created: function () { console.log(&#39;混入对象的钩子被调用&#39;) } } new Vue({ mixins: [mixin], created: function () { console.log(&#39;组件钩子被调用&#39;) } }) // =&gt; &quot;混入对象的钩子被调用&quot; // =&gt; &quot;组件钩子被调用&quot; 值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。 var mixin = { methods: { foo: function () { console.log(&#39;foo&#39;) }, conflicting: function () { console.log(&#39;from mixin&#39;) } } } var vm = new Vue({ mixins: [mixin], methods: { bar: function () { console.log(&#39;bar&#39;) }, conflicting: function () { console.log(&#39;from self&#39;) } } }) vm.foo() // =&gt; &quot;foo&quot; vm.bar() // =&gt; &quot;bar&quot; vm.conflicting() // =&gt; &quot;from self&quot; 注意：Vue.extend() 也使用同样的策略进行合并。 全局混入也可以全局注册混入对象。注意使用！ 一旦使用全局混入对象，将会影响到 所有 之后创建的 Vue 实例。使用恰当时，可以为自定义对象注入处理逻辑。 // 为自定义的选项 &#39;myOption&#39; 注入一个处理器。 Vue.mixin({ created: function () { var myOption = this.$options.myOption if (myOption) { console.log(myOption) } } }) new Vue({ myOption: &#39;hello!&#39; }) // =&gt; &quot;hello!&quot; 谨慎使用全局混入对象，因为会影响到每个单独创建的 Vue 实例 (包括第三方模板)。大多数情况下，只应当应用于自定义选项，就像上面示例一样。也可以将其用作 Plugins 以避免产生重复应用]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue自定义指令]]></title>
    <url>%2F2019%2F04%2F02%2Fvue-directive%2F</url>
    <content type="text"><![CDATA[vue自定义指令 注册全局指令 // 注册一个全局自定义指令 `v-focus` Vue.directive(&#39;focus&#39;, { // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) { // 聚焦元素 el.focus() } }) 注册局部指令 directives: { focus: { // 指令的定义 inserted: function (el) { el.focus() } } } 使用方式 &lt;input v-focus&gt; 钩子函数一个指令定义对象可以提供如下几个钩子函数 (均为可选)： bind 只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted 被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update 所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 componentUpdated 指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind 只调用一次，指令与元素解绑时调用。]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue的路由导航守卫]]></title>
    <url>%2F2019%2F04%2F02%2Fvue-router-beforeEach%2F</url>
    <content type="text"><![CDATA[vue的路由导航守卫vue-router提供的导航守卫主要是用来通过跳转和取消的方式守卫导航。一共有三种植入路由导航的过程 全局前置(后置)守卫 const router = new VueRouter({ ... }) router.beforeEach((to, from, next) =&gt; { // 前置 // ... }) router.afterEach((to, from) =&gt; { // 后置 // ... }) 路由独享守卫 const router = new VueRouter({ routes: [ { path: &#39;/foo&#39;, component: Foo, beforeEnter: (to, from, next) =&gt; { // ... } } ] }) 组件内的守卫 beforeRouteEnter beforeRouteUpdate beforeRouteLeave const Foo = { template: `...`, beforeRouteEnter (to, from, next) { // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！获取组件实例 `this` // 因为当守卫执行前，组件实例还没被创建 }, beforeRouteUpdate (to, from, next) { // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` }, beforeRouteLeave (to, from, next) { // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` } } beforeRouteEnter 守卫 不能 访问 this，因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。 不过，你可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。 beforeRouteEnter (to, from, next) { next(vm =&gt; { // 通过 `vm` 访问组件实例 }) } 注意 beforeRouteEnter 是支持给 next 传递回调的唯一守卫。对于 beforeRouteUpdate 和 beforeRouteLeave 来说，this 已经可用了，所以不支持传递回调，因为没有必要了。 beforeRouteUpdate (to, from, next) { // just use `this` this.name = to.params.name next() } 这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消。 beforeRouteLeave (to, from , next) { const answer = window.confirm(&#39;Do you really want to leave? you have unsaved changes!&#39;) if (answer) { next() } else { next(false) } }]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue和react的区别]]></title>
    <url>%2F2019%2F04%2F01%2Fvue-react-diff%2F</url>
    <content type="text"><![CDATA[vue和react的区别 react和vue都是组件化，整体功能类似，但是设计思路有有所不同， 出身 react React是由Facebook创建的JavaScript UI框架，它的诞生改变了JavaScript世界，最大的一个改变就是React推广了Virtual DOM， 并且创造了新的语法 – JSX，JSX 允许在JavaScript中写html代码。 vue Vue是由尤大大开发的一个MVVM框架，它采用的是模板系统而不是JSX。 模板渲染方式不同 react React是通过JSX来渲染模板，React通过原生JS实现模板中的常见语法，比如说条件啊、循环啊、三元运算符啊等，都是通过JS语法实现 vue vue是通过扩展的HTML来进行模板的渲染，Vue是在和组件代码分离的单独模板中，通过指令v-if、v-for等实现 Virtual DOM react React默认是通过比较引用得方式进行，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。如果想避免不必要的子组件重新渲染，你需要在所有可能的地方使用PureComponent，或者手动实现shouldComponentUpdate方法。但是Vue中，你可以认定它是默认的优化。 vue Vue可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，由于vue会跟踪每一个组件的依赖收集，通过setter / getter 以及一些函数的劫持，能够精确地知道变化，并在编译过程标记了static静态节点，在接下来新的Virtual DOM 并且和原来旧的 Virtual DOM进行比较时候，跳过static静态节点。所以不需要重新渲染整个组件树。 数据流Vuex 和 Redux react 在React中，我们需要每一个组件都引入connect，目的就是把props和dispatch连接起来。redux只能通过dispatch，然后在reducer里，接收到action，通过判断action的type，从而进行对应的操作，redux不能直接调用reducer进行修改！！ vue 在vuex中，我们可以通过在main.js中，引入 store文件夹，并把store挂载到new Vue实例中，这样我们可以直接通过$store灵活使用。 你可以通过dispatch和commit进行更新数据， 通过this.$store.state.xx读取数据 你可以通过mapState / mapActions 进行vuex的操作 总结 组件的创建方式不一样 react使用class和函数创建组件【只有局部】 vue则使用vue的实例的components方法和components属性【有局部和全局一说】 在react中没有指令，计算属性，watch监听，computed，这些内容 在react组件中只有几个概念，生命周期，state。props。合成事件 在vue中可以使用v-modle完成数据的双向绑定，而在react并没有指令的概念，所以使用受控组件代替 在vue中使用getter，setter拦截器，处理数据的绑定，而react则使用的是setState手动触发]]></content>
      <tags>
        <tag>vue</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue路由的实现原理]]></title>
    <url>%2F2019%2F04%2F01%2Fvue-router-left%2F</url>
    <content type="text"><![CDATA[vue路由的实现原理 在vue中路由主要有 hash与History interface两种方式实现前端路由，单页路由的特点就是采用前端路由系统，通过改变URL，在不重新请求页面的情况下，更新页面视图。目前在浏览器环境中这一功能的实现主要有两种方式 hash 在浏览器的url中hash（“#”）符号的本来作用是加在URL中指示网页中的位置：#符号本身以及它后面的字符称之为hash，可通过window.location.hash属性读取。 特点： hash虽然出现在URL中，但不会被包括在HTTP请求中。它是用来指导浏览器动作的，对服务器端完全无用，因此，改变hash不会重新加载页面，并且可以为hash的改变添加hashchange监听事件，在一个就是每一次改变hash（window.location.hash），都会在浏览器的访问历史中增加一个记录，我就可以通过他的这几个特点实现一个hash模式的单页路由，通过对location.hash的修改实现push方法（跳转页面），通过对location.href的修改实现replace()方法，通过对hashchange事件的监听实现页面跳转后的数据更新 History History模式则是完全采用了h5的新特性，从HTML5开始，History interface提供了两个新的方法：pushState(), replaceState()使得我们可以对浏览器历史记录栈进行修改，以及popState事件可以监听到状态的变更 不过history模式有一个问题就是 对于单页应用来讲，理想的使用场景是仅在进入应用时加载index.html，后续在的网络操作通过Ajax完成，不会根据URL重新请求页面，但是如果用户直接在地址栏中输入并回车，浏览器重启重新加载的时候history模式则会将URL修改得就和正常请求后端的URL一样，在此情况下重新向后端发送请求，如后端没有配置对应 的路由处理，则会返回404错误。这种问题的解决，一般情况下我们都是在后端进行配置，将所有的路由请求都指向index.html文件]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue-router</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的几种数组排序算法JS实现]]></title>
    <url>%2F2019%2F04%2F01%2FSortt%2F</url>
    <content type="text"><![CDATA[常见的几种数组排序算法JS实现冒泡排序 故名思意 ，就是一个个冒泡到最前端或者最后端，主要是通过两两依次比较，以升序为例，如果前一项比后一项大则交换顺序，一直比到最后一对 function bubbleSort(arr) { var len = arr.length; // 定义该数组的长度 for (var i = 0; i &lt; len; i++) { // 遍历 console.log(arr[i], arr[i+1]) for (var j = 0; j &lt; len - 1 - i; j++) { if (arr[j] &gt; arr[j+1]) { //相邻元素两两对比 var temp = arr[j+1]; //元素交换 arr[j+1] = arr[j]; arr[j] = temp; } } } return arr; } var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48]; console.log(bubbleSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] ； 选择排序 获取到数组长度，遍历第一次【不遍历最后一个】，定义变量保存下标，遍历第二次【不遍历第一个】，将数组的第一个与数组的第二个值作比较，如果第二个值小于第一个值，将第一次保存的变量下标进行一个替换【替换成最小数的索引】，如果不小于就不做操作， function selectionSort(arr) { var len = arr.length; var minIndex, temp; console.time(&#39;选择排序耗时&#39;); for (var i = 0; i &lt; len - 1; i++) { minIndex = i; for (var j = i + 1; j &lt; len; j++) { if (arr[j] &lt; arr[minIndex]) { //寻找最小的数 minIndex = j; //将最小数的索引保存 } } temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; } console.timeEnd(&#39;选择排序耗时&#39;); return arr; } var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48]; console.log(selectionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]； 二分法插入排序 第一次遍历【不遍历第一个】，将遍历的第一个值保存起来，定义起始点 function binaryInsertionSort(array) { console.time(&#39;二分插入排序耗时：&#39;); for (var i = 1; i &lt; array.length; i++) { var key = array[i], left = 0, right = i - 1; // key = 3 ,left = 0, right = 0 // key = 44 ,left = 0, right = 1 while (left &lt;= right) { // 0 &lt;= -1 // 0 &lt;= 1 var middle = parseInt((left + right) / 2); // 0 // 0 if (key &lt; array[middle]) { // 3 &lt; arr[0] = 44 44 &lt; 44 right = middle - 1; // right = -1 } else { left = middle + 1; // left = 1 } } for (var j = i - 1; j &gt;= left; j--) { // 循环 array[j + 1] = array[j]; // arr[1] = arr[0] arr [2] = } array[left] = key; // arr[0] = 44 } console.timeEnd(&#39;二分插入排序耗时：&#39;); return array; } var arr=[44,3,38,5,47,15,36,26,27,2,46,4,19,50,48]; console.log(binaryInsertionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]; ###]]></content>
      <tags>
        <tag>js</tag>
        <tag>sort</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么叫优雅降级和渐进增强？]]></title>
    <url>%2F2019%2F03%2F29%2FDowngrade%2F</url>
    <content type="text"><![CDATA[什么叫优雅降级和渐进增强？优雅降级: Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。 如：border-shadow 优雅降级写法 .transition { transition: all .5s; -o-transition: all .5s; -moz-transition: all .5s; -webkit-transition: all .5s; } 渐进增强: 从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验； 渐进增强写法 .transition { -webkit-transition: all .5s; -moz-transition: all .5s; -o-transition: all .5s; transition: all .5s; } 前缀CSS3（-webkit- / -moz- / -o-）和正常CSS3在浏览器中的支持情况是这样的： 很久以前：浏览器前缀CSS3和正常CSS3都不支持； 不久之前：浏览器只支持前缀CSS3，不支持正常CSS3； 现在：浏览器既支持前缀CSS3，又支持正常CSS3； 未来：浏览器不支持前缀CSS3，仅支持正常CSS3. ps：从这里可以引申到其他有前缀的css3的属性，不要局限在这个属性里。 优雅降级的例子： 假如你写了一个表单，没有用到input type=”submit”表单元素，用了一个a标签的click事件做提交，但如果Javascript被禁用了怎么办？使用如下的文档结构，就可以在javascript被禁用时，依然可以提交。 &lt;form&gt; &lt;input type=&quot;text&quot;&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; 优雅降级需要正确地体现HTML标签的语义，符合“浏览器的预期”。让你的网页在各种情况—下——包括降级（javascript被禁用，css传输失败等等）的情形都可以运作良好。这是我理解的优雅降级的意义。 在网页布局中如何选择？ 如果软件开发的预算和时间充足，就不存在抉择的问题，可以两者都调整到一个最佳状态，而不用权衡，做选择题了。然而现实很残酷，要么开发周期短，要么开发预算少，或者二者兼而有之，这个时候该如何抉择？就我个人而言，讲讲我的观点。 分析使用你客户端程序的版本比例。 如果低版本用户居多，当然优先采用渐进增强的开发流程； 如果高版本用户居多，为了提高大多数用户的使用体验，那当然优先采用优雅降级的开发流程。 大多数公司是怎么处理这个问题的： 绝大多数的大公司都是采用渐进增强的方式，因为业务优先，提升用户体验永远不会排在最前面。 例如：新浪微博网站前端的更新，拥有这种亿级用户的网站，绝对不可能追求某个特效而不考虑低版本用户可不可用，一定是确保低版本到高版本的可访问性，再去渐进增强，采用新功能给高版本用户提供更好的用户体验。 但也不是没有反例。如果你开发的是一款面向青少年的软件（或网站） 你知道这个群体的人总是喜欢尝试新事物，总是喜欢酷炫的特效，总是喜欢把它们的软件更新到最新版本。面对这种情况，渐进增强的开发流程实为上选。]]></content>
      <tags>
        <tag>js</tag>
        <tag>兼容与优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面重构如何操作？]]></title>
    <url>%2F2019%2F03%2F29%2Foptimization%2F</url>
    <content type="text"><![CDATA[页面重构如何操作？网站重构： 在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。 也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。 对于传统的网站来说重构通常是： 表格(table)布局改为DIV+CSS 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) 对于移动平台的优化 针对于SEO进行优化 深层次的网站重构应该考虑的方面 减少代码间的耦合 让代码保持弹性 严格按规范编写代码 设计可扩展的API 代替旧有的框架、语言(如VB) 增强用户体验 通常来说对于速度的优化也包含在重构中 压缩JS、CSS、image等前端资源(通常是由服务器来解决) 程序的性能优化(如数据读写) 采用CDN来加速资源加载 对于JS DOM的优化 HTTP服务器的文件缓存]]></content>
      <tags>
        <tag>js</tag>
        <tag>兼容与优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js创建对象的几种方式]]></title>
    <url>%2F2019%2F03%2F29%2FCreatObject%2F</url>
    <content type="text"><![CDATA[js创建对象的几种方式对象字面两的方式person = { firstname:&quot;Mark&quot;, lastname:&quot;Yun&quot;, age:25, eyecolor:&quot;black&quot; } 用function来模拟无参的构造函数function Person () {} //定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Class var person=new Person(); person.name=“Mark&quot;; person.age=&quot;25&quot;; person.work = function () { alert(person.name+&quot; hello...&quot;); } person.work(); 用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）function Pet(name,age,hobby){ this.name=name; // this作用域：当前对象 this.age=age; this.hobby=hobby; this.eat=function(){ alert(&quot;我叫&quot;+this.name+&quot;,我喜欢&quot;+this.hobby+&quot;,是个程序员&quot;); } } var maidou =new Pet(&quot;麦兜&quot;,25,&quot;coding&quot;); // 实例化、创建对象 maidou.eat();//调用eat方法 用工厂方式来创建（内置对象）var wcDog =new Object(); wcDog.name=&quot;旺财&quot;; wcDog.age=3; wcDog.work=function(){ alert(&quot;我是&quot;+wcDog.name+&quot;,汪汪汪......&quot;); } wcDog.work(); 用原型方式来创建function Dog(){ } Dog.prototype.name=&quot;旺财&quot;; Dog.prototype.eat=function(){alert(this.name+&quot;是个吃货&quot;);} var wangcai =new Dog(); wangcai.eat(); 用混合方式来创建function Car(name,price){ this.name=name; this.price=price; } Car.prototype.sell=function(){ alert(&quot;我是&quot;+this.name+&quot;，我现在卖&quot;+this.price+&quot;万元&quot;); } var camry =new Car(&quot;凯美瑞&quot;,27); camry.sell();]]></content>
      <tags>
        <tag>js</tag>
        <tag>object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js继承的几种方式]]></title>
    <url>%2F2019%2F03%2F29%2Fextend%2F</url>
    <content type="text"><![CDATA[js继承的几种方式构造函数继承 在构造函数内部调用被继承对象的构造函数，，使用call将this传入 function Parent() { this.name = &#39;parent&#39;; } function Child() { Parent.call(this); this.type = &#39;child&#39;; } 缺点： 只能实现部分继承。不能继承构造函数原型上的属性和方法，应为本身的原型对象没有被修改 原型链继承 把原型修改为继承对象的实例化对象 function Parent() { this.name = &#39;parent&#39;; } function Child() { this.type = &#39;child&#39;; } Child.prototype = new Parent(); 缺点： 不能继承构造函数内部的属性和方法 不能像构造函数内部参数进行初始化 原型链+构造函数继承function Parent() { this.name = &#39;parent5&#39;; this.play = [1, 2, 3]; } function Child() { Parent.call(this); this.type = &#39;child5&#39;; } // 产生一个中间对象隔离`Child`的`prototype`属性和`Parent`的`prototype`属性引用的同一个原型。 Child.prototype = Object.create(Parent.prototype); // 给Child的原型对象重新写一个自己的constructor。 Child.prototype.constructor = Child;]]></content>
      <tags>
        <tag>js</tag>
        <tag>extend</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js事件机制]]></title>
    <url>%2F2019%2F03%2F29%2FJSevent%2F</url>
    <content type="text"><![CDATA[js事件机制、主要分为Dom0级事件和Dom2事件 Dom0级事件处理方式： btn.onclick = func; btn.onclick = null; Dom2级事件处理方式： // 非IE btn.addEventListener(&#39;click&#39;, func, false); btn.removeEventListener(&#39;click&#39;, func, false); // IE btn.attachEvent(&quot;onclick&quot;, func); btn.detachEvent(&quot;onclick&quot;, func); 事件的三个阶段 捕获 目标 冒泡 js冒泡和捕获的的区别 冒泡型事件： 事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。 捕获型事件: 事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)。 DOM事件流: 同时支持两种事件模型：捕获型事件和冒泡型事件，但是，捕获型事件先发生。两种事件流会触及DOM中的所有对象，从document对象开始，也在document对象结束。 事件捕获: 当你使用事件捕获时，父级元素先触发，子级元素后触发，即div先触发，p后触发。 事件冒泡: 当你使用事件冒泡时，子级元素先触发，父级元素后触发，即p先触发，div后触发。 阻止冒泡 非IE e.stopPropagation() IE cancelBubble = true 阻止捕获 非IE e.preventDefault() IE returnValue = false 事件“捕获”和“冒泡”执行顺序和事件的执行次数？按照W3C标准流程如下： 进入捕获阶段 →→→ 到达目标元素 →→→ 进入到冒泡阶段 事件执行次数 元素上绑定事件的个数 在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？ 该DOM上的事件如果被触发，会执行两次（执行次数等于绑定次数） 如果该DOM是目标元素，则按事件绑定顺序执行，不区分冒泡/捕获 如果该DOM是处于事件流中的非目标元素，则先执行捕获，后执行冒泡]]></content>
      <tags>
        <tag>js</tag>
        <tag>Event</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅拷贝与深拷贝]]></title>
    <url>%2F2019%2F03%2F29%2Fclone%2F</url>
    <content type="text"><![CDATA[浅拷贝与深拷贝 数据类型###数据类型分为两种【基本数据类型，复杂数据类型】 基本数据类型：直接存储在栈(stack)中的数据 String Number Boolean Null Undefined Symbol 引用数据类型：存储的是该对象在栈中引用，真实的数据存放在堆内存里 对象数据类型【object，function】 浅拷贝与深拷贝深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。赋值和浅拷贝的区别 当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。 浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。 浅拷贝的实现方式Object.assign() Object.assign()进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。 当object只有一层的时候，是深拷贝 Array.prototype.concat()let arr = [1, 3, { username: &#39;kobe&#39;, childran: [ { username: &#39;kobe&#39;, childran: [ { username: &#39;kobe&#39;, childran: [ ] } ] } ] }]; let arr2=arr.concat(); console.log(arr); 修改新对象会改到原对象: Array.prototype.slice()let arr = [1, 3, { username: &#39; kobe&#39; }]; let arr3 = arr.slice(); arr3[2].username = &#39;wade&#39; console.log(arr); 同样修改新对象会改到原对象: 关于Array的slice和concat方法的补充说明:Array的slice和concat方法不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。 深拷贝的实现方式JSON.parse(JSON.stringify())let arr = [1, 3, { username: &#39; kobe&#39; }]; let arr4 = JSON.parse(JSON.stringify(arr)); arr4[2].username = &#39;duncan&#39;; console.log(arr, arr4) 原理： 用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。 弊端： 这种方法虽然可以实现数组或对象深拷贝,但不能处理函数 递归方法 递归方法实现深度克隆原理: 遍历对象、数组直到里边都是基本数据类型，然后再去复制，就是深度拷贝 //定义检测数据类型的功能函数 function checkedType(target) { return Object.prototype.toString.call(target).slice(8, -1) } //实现深度克隆---对象/数组 function clone(target) { //判断拷贝的数据类型 //初始化变量result 成为最终克隆的数据 let result, targetType = checkedType(target) if (targetType === &#39;Object&#39;) { result = {} } else if (targetType === &#39;Array&#39;) { result = [] } else { return target } //遍历目标数据 for (let i in target) { //获取遍历数据结构的每一项值。 let value = target[i] //判断目标结构里的每一值是否存在对象/数组 if (checkedType(value) === &#39;Object&#39; || checkedType(value) === &#39;Array&#39;) { //对象/数组里嵌套了对象/数组 //继续遍历获取到value值 result[i] = clone(value) } else { //获取到value值是基本的数据类型或者是函数。 result[i] = value } } return result }]]></content>
      <tags>
        <tag>js</tag>
        <tag>拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开启nginx服务器压缩Gzip]]></title>
    <url>%2F2019%2F03%2F28%2Fgzipmd%2F</url>
    <content type="text"><![CDATA[开启nginx服务器压缩 nginx.conf(加入以下配置即可) server{ listen 80; server_name my.ignorantscholar.cn; gzip on; gzip_min_length 1k; gzip_buffers 4 16k; #gzip_http_version 1.0; gzip_comp_level 8; gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; gzip_vary off; gzip_disable &quot;MSIE [1-6]\.&quot;; location / { proxy_pass http://127.0.0.1:3001; } } 在浏览器端查看是否开启可压缩 Network 查看请求的Headers头，Accept-Encoding: gzip 即开启了压缩]]></content>
      <tags>
        <tag>nginx</tag>
        <tag>gzip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7中搭建nginx服务器]]></title>
    <url>%2F2019%2F03%2F28%2Fngsinx%2F</url>
    <content type="text"><![CDATA[centos7中搭建nginx服务器 nginx可以使用各平台的默认包来安装，本文是介绍使用源码编译安装，包括具体的编译参数信息。正式开始前，编译环境gcc g++ 开发库之类的需要提前装好，这里默认你已经装好。 centos平台编译环境使用如下指令 安装make： yum -y install gcc automake autoconf libtool make 安装g++: yum install gcc gcc-c++ 下面正式开始：一般我们都需要先装pcre, zlib，前者为了重写rewrite，后者为了gzip压缩。注：下面所使用的所有版本均为截止2017年8月14号，最新版本 1.选定源码目录可以是任何目录，本文选定的是/usr/local/src cd /usr/local/src 2.安装PCRE库ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/ 下载最新的 PCRE 源码包，使用下面命令下载编译和安装 PCRE 包： cd /usr/local/src wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.41.tar.gz tar -zxvf pcre-8.41.tar.gz cd pcre-8.41 ./configure make make install 3.安装zlib库http://zlib.net/zlib-1.2.11.tar.gz 下载最新的 zlib 源码包，使用下面命令下载编译和安装 zlib包： cd /usr/local/src wget http://zlib.net/zlib-1.2.11.tar.gz tar -zxvf zlib-1.2.11.tar.gz cd zlib-1.2.11 ./configure make make install 4.安装ssl（某些vps默认没装ssl) cd /usr/local/src wget https://www.openssl.org/source/openssl-1.0.2l.tar.gz tar -zxvf openssl-1.0.2l.tar.gz 5.安装nginx Nginx 一般有两个版本，分别是稳定版和开发版，您可以根据您的目的来选择这两个版本的其中一个，下面是把 Nginx 安装到 /usr/local/nginx 目录下的详细步骤： cd /usr/local/src wget http://nginx.org/download/nginx-1.13.4.tar.gz tar -zxvf nginx-1.13.4.tar.gz cd nginx-1.13.4 ./configure --sbin-path=/usr/local/nginx/nginx --conf-path=/usr/local/nginx/nginx.conf --pid-path=/usr/local/nginx/nginx.pid --with-http_ssl_module --with-pcre=/usr/local/src/pcre-8.41 --with-zlib=/usr/local/src/zlib-1.2.11 --with-openssl=/usr/local/src/openssl-1.0.2l make make install –with-pcre=/usr/local/src/pcre-8.41 指的是pcre-8.41 的源码路径。–with-zlib=/usr/local/src/zlib-1.2.11 指的是zlib-1.2.11 的源码路径。 安装成功： 安装成功后 /usr/local/nginx 会有此目录 6.启动 确保系统的 80 端口没被其他程序占用，运行/usr/local/nginx/nginx 命令来启动 Nginx， 打开浏览器访问此机器的 IP，如果浏览器出现 Welcome to nginx! 则表示 Nginx 已经安装并运行成功。 到这里nginx就安装完成了，如果只是处理静态html就不用继续安装了 如果你需要处理php脚本的话，还需要安装php-fpm。 常见错误：附：可能遇到的错误和一些帮助信息 1.1编译pcre错误 make[1]: Leaving directory `/usr/local/src/pcre-8.34&#39; make: *** [all] Error 2 解决办法：安装g++,别忘了重新configure apt-get install g++ apt-get install build-essential make clean ./configure make 1.2 make出错 make: *** No targets specified and no makefile found. Stop. 按照下面安装方法 yum -y install openssl openssl-devel 2.nginx编译选项（下面代码必须在一行） ./configure --sbin-path=/usr/local/nginx/nginx --conf-path=/usr/local/nginx/nginx.conf --pid-path=/usr/local/nginx/nginx.pid --with-http_ssl_module --with-pcre=/usr/local/src/pcre-8.41 --with-zlib=/usr/local/src/zlib-1.2.11 --with-openssl=/usr/local/src/openssl-1.0.2l]]></content>
      <tags>
        <tag>nginx</tag>
        <tag>linux服务器配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7中安装mysql的步骤]]></title>
    <url>%2F2019%2F03%2F28%2Fmysql%2F</url>
    <content type="text"><![CDATA[centos7中安装mysql的步骤一、 安装： 下载源码包，一般将源码包放在/usr/local/中； cd /usr/local/ mkdir -p tools cd tools wget http://repo.mysql.com/mysql57-community-release-el7-8.noarch.rpm (这里的版本可以随时去mysql官网进行选择) 查看系统中是否已安装 MySQL 服务 rpm -qa | grep mysql 或 yum list installed | grep mysql 如果已安装则删除 MySQL 及其依赖的包： yum -y remove mysql-libs.x86_64 安装 mysql57-community-release-el7-8.noarch.rpm： rpm -ivh mysql57-community-release-el7-8.noarch.rpm 安装完后，得到如下两个包：（在/etc/yum.repos.d/文件下） mysql-community.repo mysql-community-source.repo 安装mysql $ yum install mysql-server 根据步骤安装就可以了，不过安装完成后，没有密码，需要重置密码。 6.重置密码： mysql -u root； 报错：ERROR 2002 (HY000): Can‘t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock‘ (2)，原因是/var/lib/mysql的访问权限问题。下面的命令把/var/lib/mysql的拥有者改为当前用户： sudo chown -R openscanner:openscanner /var/lib/mysql 重启服务： service mysqld restart 再次登录: mysql -u root 报错： error 1045 (28000):Access denied for user ‘root’ @ ‘localhost’ (using password: NO） 此种情况是因为存在了默认密码问题，解决：（最保险的是重置root密码） 1、修改 /etc/my.cnf，在 [mysqld] 小节下添加一行：skip-grant-tables=1 这一行配置让 mysqld 启动时不对密码进行验证 2、重启 mysqld 服务：systemctl restart mysqld 3、使用 root 用户登录到 mysql：mysql -u root 4、切换到mysql数据库，更新 user 表： update user set authentication_string = password(&#39;root&#39;),host=&#39;%&#39;,password_expired = &#39;N&#39;, password_last_changed = now() where user = &#39;root&#39;; 在之前的版本中，密码字段的字段名是 password，5.7版本改为了 authentication_string 5、退出 mysql，编辑 /etc/my.cnf 文件，删除 skip-grant-tables=1 的内容 6、重启 mysqld 服务，再用新密码登录即可 开放防火墙： vim /etc/sysconfig/iptables 添加以下内容： -A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT 保存后重启防火墙： $ sudo service iptables restart 这样从其它客户机也可以连接上mysql服务了。 阿里云安全组设置： 如果此时在其他客户机上还是链接不上mysql，登录阿里云，查看实例的安全组有没有为3306端口开启规则；]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>linux服务器配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node配置]]></title>
    <url>%2F2019%2F03%2F28%2Fnodemd%2F</url>
    <content type="text"><![CDATA[node配置一、安装node： 1.下载并安装NVM脚本 curl https://raw.githubusercontent.com/creationix/nvm/v0.13.1/install.sh | bash source ~/.bash_profile 2.列出所需要的版本 nvm list-remote 3.安装相应的版本 nvm install v8.3.0 4.查看已安装的版本 nvm list 5.切换版本 nvm use v8.3.0 6.设置默认版本 nvm alias default v8.3.0]]></content>
      <tags>
        <tag>node</tag>
        <tag>linux服务器配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系统基础命令]]></title>
    <url>%2F2019%2F03%2F27%2FLinux%2F</url>
    <content type="text"><![CDATA[Linux系统基础命令连接远程服务器：ssh root@公网ip ls 查看目录cd 切换目录 （用户目录root~ 系统根目录 /） 创建文件 touch 文件名字删除文件 rm 文件路径移动文件 mv 要移动的文件 移动后的路径创建文件夹 mkdir 目录名称拷贝文件 cp 文件 目标路径 vim 编辑文件i 开始编辑esc :wq 退出并保存]]></content>
      <tags>
        <tag>js</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序实现瀑布流]]></title>
    <url>%2F2019%2F03%2F24%2Fwpy-cascade%2F</url>
    <content type="text"><![CDATA[微信小程序实现瀑布流简单，便捷 无需知道图片宽高（当然要实现懒加载是必须的） 一个判断 一句css 先用css3中的column-count属性把页面元素分为俩列及多列。 直接上代码 wxml &lt;view class=&quot;free-WaterfallFlow&quot;&gt; &lt;block&gt; &lt;view class=&quot;flex-wrap&quot; wx:for=&quot;{{images}}&quot; wx:key=&#39;{{item.src}}&#39; wx:if=&quot;{{item.id%2!=''}}&quot;&gt; &lt;image mode=&quot;widthFix&quot; src=&quot;{{item.src}}&quot;&gt;&lt;/image&gt; &lt;view&gt;{{item.name}}&lt;/view&gt; &lt;view&gt;{{item.data}}&lt;/view&gt; &lt;/view&gt; &lt;/block&gt; &lt;block&gt; &lt;view class=&quot;flex-wrap&quot; wx:for=&quot;{{images}}&quot; wx:key=&#39;{{item.src}}&#39; wx:if=&quot;{{item.id%2==''}}&quot;&gt; &lt;image mode=&quot;widthFix&quot; src=&quot;{{item.src}}&quot;&gt;&lt;/image&gt; &lt;view&gt;{{item.name}}&lt;/view&gt; &lt;view&gt;{{item.data}}&lt;/view&gt; &lt;/view&gt; &lt;/block&gt; &lt;/view&gt; wxss .free-WaterfallFlow{ width:94%; column-count:2;/*column-count 属性规定元素应该被分隔的列数：*/ } .free-WaterfallFlow .flex-wrap{ display: inline-block; width:98%; margin-bottom:2%; border:1px solid #ccc; padding:2%; padding-top:5%; margin-right:2%; box-shadow: 0 1px 2px rgba(34, 25, 25, 0.4); text-align: center; } .flex-wrap image{ width:95%; margin:0 auto; } .flex-wrap view:nth-child(2){ font-size:15px; padding:2% 0; color:#717171; } .flex-wrap view:nth-child(3){ font-size:13px; padding:2% 0; color:#aaa; text-align: right; } js Page({ data: { images:[ { id:&#39;1&#39;, src:&#39;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1531825645104&amp;di=0cfede1dd354581e22385b1862375a6a&amp;imgtype=0&amp;src=http%3A%2F%2Fpic.qiantucdn.com%2F58pic%2F13%2F71%2F35%2F24k58PICSiB_1024.jpg&#39;, name:&#39;照片01&#39;, data:&#39;2017/11/1&#39; }, { id: &#39;2&#39;, src: &#39;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1531825645032&amp;di=826b8cfa4f7c5a8765d5c2156913dcbb&amp;imgtype=0&amp;src=http%3A%2F%2Fimg382.ph.126.net%2Fp4dMCiiHoUGxf2N0VLspkg%3D%3D%2F37436171903673954.jpg&#39;, name: &#39;照片02&#39;, data: &#39;2017/11/2&#39; }, { id: &#39;3&#39;, src: &#39;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1531825645104&amp;di=2c9e1223e705806967640495e4bac26b&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.zcool.cn%2Fcommunity%2F0147a458783b1ba801219c77f9ec2e.jpg%402o.jpg&#39;, name: &#39;照片03&#39;, data: &#39;2017/11/3&#39; }, { id: &#39;4&#39;, src: &#39;http://t1.hxzdhn.com/uploads/tu/bj/slt/yezpvg0x23b.jpg&#39;, name: &#39;照片04&#39;, data: &#39;2017/11/4&#39; }, { id: &#39;5&#39;, src: &#39;http://t1.hxzdhn.com/uploads/tu/201807/9999/95ed87388b.jpg&#39;, name: &#39;照片05&#39;, data: &#39;2017/11/5&#39; }, { id: &#39;6&#39;, src: &#39;http://t1.hxzdhn.com/uploads/tu/201807/9999/99495c4cf4.jpg&#39;, name: &#39;照片06&#39;, data: &#39;2017/11/6&#39; }, { id: &#39;7&#39;, src: &#39;http://t1.hxzdhn.com/uploads/tu/201807/9999/f867c97e25.jpg&#39;, name: &#39;照片07&#39;, data: &#39;2017/11/7&#39; }, { id: &#39;8&#39;, src: &#39;http://t1.hxzdhn.com/uploads/tu/201807/9999/2cc7ab0bc5.jpg&#39;, name: &#39;照片08&#39;, data: &#39;2017/11/8&#39; }, { id: &#39;9&#39;, src: &#39;http://t1.hxzdhn.com/uploads/tu/201807/9999/2f4435caaf.jpg&#39;, name: &#39;照片09&#39;, data: &#39;2017/11/9&#39; }, { id: &#39;10&#39;, src: &#39;http://t1.hxzdhn.com/uploads/tu/201807/9999/ce76898540.jpg&#39;, name: &#39;照片10&#39;, data: &#39;2017/11/10&#39; }, { id: &#39;11&#39;, src: &#39;http://t1.hxzdhn.com/uploads/tu/201807/9999/a2ccc41e47.jpg&#39;, name: &#39;照片11&#39;, data: &#39;2017/11/11&#39; }, { id: &#39;12&#39;, src: &#39;http://t2.hddhhn.com/uploads/tu/201707/521/83.jpg&#39;, name: &#39;照片12&#39;, data: &#39;2017/11/12&#39; }, { id: &#39;13&#39;, src: &#39;http://t2.hddhhn.com/uploads/tu/20150700/2hndrjt0jxe.jpg&#39;, name: &#39;照片13&#39;, data: &#39;2017/11/13&#39; }, { id: &#39;14&#39;, src: &#39;http://t2.hddhhn.com/uploads/tu/20150700/2hndrjt0jxe.jpg&#39;, name: &#39;照片14&#39;, data: &#39;2017/11/14&#39; } ] } })]]></content>
      <tags>
        <tag>wx</tag>
        <tag>瀑布流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fetch封装]]></title>
    <url>%2F2019%2F03%2F14%2Ffetch%2F</url>
    <content type="text"><![CDATA[fetchfetch封装 解决了fetch的get。post的传递参数不同 添加了fetch默认不携带cookie的配置 解决了fetch不能处理错误状态的问题 解决了fetch，response控制返回值json 添加公共参数token 统一错误出路 是否允许跨域 const objParseQuery = (data) =&gt; { let paramsArray = []; let parameter = &#39;&#39; //拼接参数 Object.keys(data).forEach(key =&gt; { if (data[key]) { paramsArray.push(key + &#39;=&#39; + data[key]) } }) if (parameter.search(/\?/) === -1) { parameter += &#39;?&#39; + paramsArray.join(&#39;&amp;&#39;) } else { parameter += &#39;&amp;&#39; + paramsArray.join(&#39;&amp;&#39;) } return parameter } let fetchs = { /** * 基于 fetch 封装的 GET请求 * @param url * @param params {} * @param headers * @returns {Promise} */ get: (url, params) =&gt; { var fetchConfig = { method: &#39;get&#39;, headers: { authorization: window.sessionStorage.getItem(&#39;token&#39;) ? window.sessionStorage.getItem(&#39;token&#39;) : null, &#39;Content-Type&#39;: &#39;application/json; charset=utf-8&#39; }, credentials: &quot;include&quot;, mode: &#39;cors&#39;, } if(params){ url += objParseQuery(params.data); } console.log(url) return fetch(url, fetchConfig).then(response =&gt; { return response.json().then((res) =&gt; { console.log(res) if (response.ok &amp;&amp; res.code === 1) { return Promise.resolve(res) } else { return Promise.reject(res) } }) }) }, post: (url, options) =&gt; { return fetch(url, { method: &#39;post&#39;, headers: { authorization: window.sessionStorage.getItem(&#39;token&#39;) ? window.sessionStorage.getItem(&#39;token&#39;) : null, &#39;Content-Type&#39;: &#39;application/json; charset=utf-8&#39; }, credentials: &quot;include&quot;, mode: &#39;cors&#39;, body: JSON.stringify(options) }).then(response =&gt; { return response.json().then((res) =&gt; { if (response.ok &amp;&amp; res.code === 1) { console.log(window.sessionStorage.getItem(&#39;token&#39;)) return Promise.resolve(res) } else { return Promise.reject(res) } }) }) }, put: (url, options) =&gt; { return fetch(url, { method: &#39;post&#39;, headers: { authorization: window.sessionStorage.getItem(&#39;token&#39;) ? window.sessionStorage.getItem(&#39;token&#39;) : null, &#39;Content-Type&#39;: &#39;application/json; charset=utf-8&#39; }, credentials: &quot;include&quot;, mode: &#39;cors&#39;, body: JSON.stringify(options) }).then(response =&gt; { return response.json().then((res) =&gt; { if (response.ok &amp;&amp; res.code === 1) { console.log(window.sessionStorage.getItem(&#39;token&#39;)) return Promise.resolve(res) } else { return Promise.reject(res) } }) }) } } export default fetchs]]></content>
      <tags>
        <tag>js</tag>
        <tag>fetch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 堆&栈]]></title>
    <url>%2F2019%2F03%2F04%2Fstack%20heap%2F</url>
    <content type="text"><![CDATA[JS 堆&amp;栈两者都是存放临时数据的地方⊙ 栈是先进后出的，就像一个桶，后进去的先出来，它下面本来有的东西要等其他出来之后才能出来。⊙ 堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。对于堆，我们可以随心所欲的进行增加变量和删除变量，不用遵循次序。◎ 栈区（stack） 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。◎ 堆区（heap） 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。 堆是动态分配内存，内存大小不一，也不会自动释放。栈是自动分配相对固定大小的内存空间，并由系统自动释放. JS数据类型访问 基本数据类型 Undefined、Null、Boolean、String、Number、Symbol都是直接按值直接存在栈中，每种类型的数据占用的内存空间大小都是固定的，并且由系统自动分配自动释放 引用数据类型 Object，Array，Function这样的数据存在堆内存中，但是数据指针是存放在栈内存中的，当我们访问引用数据时，先从栈内存中获取指针，通过指针在堆内存中找到数据 var a = 2; var b = new Object(); 传值和传址 从一个向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终指向同一个对象。即复制的是栈中的地址而不是堆中的对象。 从一个变量复向另一个变量复制基本类型的值，会创建这个值的副本。]]></content>
      <tags>
        <tag>js</tag>
        <tag>堆&amp;栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mvvm原理]]></title>
    <url>%2F2019%2F03%2F03%2FMVVM%2F</url>
    <content type="text"><![CDATA[mvvm模式 MVVM 是Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式，其核心是提供对View 和 ViewModel 的双向数据绑定，这使得ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定。 mvvm原理源码地址 Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。 为什么会出现 MVVM 呢？###MVC 即 Model-View-Controller 的缩写，就是 模型—视图—控制器，也就是说一个标准的Web 应用程式是由这三部分组成的： View ：用来把数据以某种方式呈现给用户 Model ：其实就是数据 Controller ：接收并处理来自用户的请求，并将 Model 返回给用户 随着H5 的不断发展，人们更希望使用H5 开发的应用能和Native 媲美，或者接近于原生App 的体验效果，于是前端应用的复杂程度已不同往日，今非昔比。这时前端开发就暴露出了三个痛点问题： 开发者在代码中大量调用相同的 DOM API，处理繁琐 ，操作冗余，使得代码难以维护。 大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。 当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致 Model 发生变化，开发者同样需要将变化的数据同步到Model 中，这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。 MVVM 的出现，完美解决了以上三个问题。MVVM 由 Model、View、ViewModel 三部分构成，Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。 在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。 ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM， 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。Vue.js 的细节Vue.js 可以说是MVVM 架构的最佳实践，专注于 MVVM 中的 ViewModel，不仅做到了数据双向绑定，而且也是一款相对来比较轻量级的JS 库，API 简洁，很容易上手。Vue的基础知识网上有现成的教程，此处不再赘述， 下面简单了解一下 Vue.js 关于双向绑定的一些实现细节： Vue.js 是采用 Object.defineProperty 的 getter 和 setter，并结合观察者模式来实现数据绑定的。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。 Observer ：数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用Object.defineProperty的getter和setter来实现 Compile ：指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 Watcher ：订阅者，作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数 Dep ：消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法 从图中可以看出，当执行 new Vue() 时，Vue 就进入了初始化阶段，一方面Vue 会遍历 data 选项中的属性，并用 Object.defineProperty 将它们转为 getter/setter，实现数据变化监听功能；另一方面，Vue 的指令编译器Compile 对元素节点的指令进行扫描和解析，初始化视图，并订阅 Watcher 来更新视图， 此时Wather 会将自己添加到消息订阅器中(Dep)，初始化完毕。 当数据发生变化时，Observer 中的 setter 方法被触发，setter 会立即调用Dep.notify()，Dep 开始遍历所有的订阅者，并调用订阅者的 update 方法，订阅者收到通知后对视图进行相应的更新。 MVVM？比之 MVC 有什么区别？首先先来说下 View 和 Model View 很简单，就是用户看到的视图 Model 同样很简单，一般就是本地数据和数据库中的数据 基本上，我们写的产品就是通过接口从数据库中读取数据，然后将数据经过处理展现到用户看到的视图上。当然我们还可以从视图上读取用户的输入，然后又将用户的输入通过接口写入到数据库中。但是，如何将数据展示到视图上，然后又如何将用户的输入写入到数据中，不同的人就产生了不同的看法，从此出现了很多种架构设计。传统的 MVC 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。 ####但是 MVC 有一个巨大的缺陷就是控制器承担的责任太大了，随着项目愈加复杂，控制器中的代码会越来越臃肿，导致出现不利于维护的情况。 在 MVVM 架构中，引入了 ViewModel 的概念。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。 以 Vue 框架来举例，ViewModel 就是组件的实例。View 就是模板，Model 的话在引入 Vuex 的情况下是完全可以和组件分离的。####除了以上三个部分，其实在 MVVM 中还引入了一个隐式的 Binder 层，实现了 View 和 ViewModel 的绑定。 同样以 Vue 框架来举例，这个隐式的 Binder 层就是 Vue 通过解析模板中的插值和指令从而实现 View 与 ViewModel 的绑定。对于 MVVM 来说，其实最重要的并不是通过双向绑定或者其他的方式将 View 与 ViewModel 绑定起来，而是通过 ViewModel 将视图中的状态和用户的行为分离出一个抽象，这才是 MVVM 的精髓。]]></content>
      <tags>
        <tag>js</tag>
        <tag>mvvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[json web token【跨域认证的解决方案】]]></title>
    <url>%2F2019%2F02%2F25%2Fjson%20web%20token%2F</url>
    <content type="text"><![CDATA[json web token【跨域认证的解决方案】一般互联网认证用户流程 1.用户向服务器发送用户名和密码。 2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。 3、服务器向用户返回一个 session_id，写入用户的 Cookie。 4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。 5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。 缺点 扩展性不够好单机当然没有问题，如果是服务器集群，就要求 session 数据共享，每台服务器都能够读取 session。 JWT以及具体实现JWT鉴权的简单流程JWT分为三部分 Header（包含加密方式等） { &quot;alg&quot;: &quot;HS256&quot;,// 默认签名算法 &quot;typ&quot;: &quot;JWT&quot; // 类型 } Payload（包含用户必要信息，以及过期时间等） iss (issuer)：签发人 exp (expiration time)：过期时间 sub (subject)：主题 aud (audience)：受众 nbf (Not Before)：生效时间 iat (Issued At)：签发时间 jti (JWT ID)：编号 用来存放需要传递的实际数据 Signature（针对前两部分生成，防止数据篡改）。 流程用户登录成功后，后台根据用户信息加上一个用户唯一的密钥值，生成一串字符串，即Token串，将其设置 在Cookie中； 用户下次带Token访问，系统会先根据前两部分以及密钥值，对Token进行有效性以及正确性的验证，如果 验证通过的话，再执行下一步操作... 如果要写入私密数据时需要加密const token = jwt.sign({...getu},&quot;usermessag&quot;,{ expiresIn: 60*60*1 // 1小时过期 }) 解密jwt.verify(token,&#39;usermessag&#39;,(err, decode) =&gt; { console.log(decode) // n拿到解密的值 }]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
        <tag>json web token</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中使用高德地图定位]]></title>
    <url>%2F2019%2F02%2F22%2Fgao%20de%20map%2F</url>
    <content type="text"><![CDATA[高德地图APIjavascript API高德地图官网链接首先注册成为开发者 为项目添加key 在vue中使用高德地图定位 /index.html &lt;script type=&quot;text/javascript&quot; src=&quot;https://webapi.amap.com/maps?v=1.4.12&amp;key=添加你自己的key&quot;&gt;&lt;/script&gt; /build/webpack.base.conf.js module.exports = { externals: { AMap: &#39;AMap&#39; }, } 以模块的形式引入 /map.js import AMap from &#39;AMap&#39; /* eslint-disable */ let maps const map = { // 定位 geolocation () { return new Promise((resolve, reject) =&gt; { AMap.plugin(&#39;AMap.Geolocation&#39;, () =&gt; { var geolocation = new AMap.Geolocation({ // 是否使用高精度定位，默认：true enableHighAccuracy: true, // 设置定位超时时间，默认：无穷大 timeout: 10000 }) geolocation.getCurrentPosition() // 执行定位 AMap.event.addListener(geolocation, &#39;complete&#39;, (data) =&gt; { resolve(data) }) // 成功的回调 AMap.event.addListener(geolocation, &#39;error&#39;, (data) =&gt; { reject(data) }) // 失败的回调 }) }) }, citySearch () { // 当前所在城市信息 return new Promise((resolve, reject) =&gt; { AMap.plugin(&#39;AMap.CitySearch&#39;, () =&gt; { const citySearch = new AMap.CitySearch() citySearch.getLocalCity(function (status, result) { if (status === &#39;complete&#39; &amp;&amp; result.info === &#39;OK&#39;) { // 查询成功，result即为当前所在城市信息 resolve(result) } }) }) }) }, search (key, city) { // 根据城市搜索附近地区 return new Promise((resolve, reject) =&gt; { AMap.plugin([&#39;AMap.PlaceSearch&#39;], () =&gt; { var placeSearch = new AMap.PlaceSearch({ city: city }) placeSearch.search(key, (status, result) =&gt; { if (result.poiList) { resolve(result.poiList.pois) } }) }) }) }, renderMap (el) { // 渲染一张地图 console.log(el) maps = new AMap.Map(el, { resizeEnable: true, // 是否监控地图容器尺寸变化 zoom: 17, center: [116.408075, 39.950187], features: [&#39;bg&#39;, &#39;road&#39;, &#39;building&#39;, &#39;point&#39;] }) // AMap.plugin([&#39;AMap.ToolBar&#39;, &#39;AMap.Scale&#39;], function () { // maps.addControl(new AMap.ToolBar()) // maps.addControl(new AMap.Scale()) // }) } } export default map 使用的时候直接调用即可]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
        <tag>定位</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 防抖（debouce）与节流（throttle）]]></title>
    <url>%2F2019%2F02%2F21%2Fdebouce%2F</url>
    <content type="text"><![CDATA[JS 防抖（debouce）与节流（throttle）防抖和节流是针对响应跟不上触发频率这类问题的两种解决方案。 在给DOM绑定事件时，有些事件我们是无法控制触发频率的。 如鼠标移动事件onmousemove, 滚动滚动条事件onscroll，窗口大小改变事件onresize，瞬间的操作都会导致这些事件会被高频触发。 如果事件的回调函数较为复杂，就会导致响应跟不上触发，出现页面卡顿，假死现象。 在实时检查输入时，如果我们绑定onkeyup事件发请求去服务端检查，用户输入过程中，事件的触发频率也会很高，会导致大量的请求发出，响应速度会大大跟不上触发。 针对此类快速连续触发和不可控的高频触发问题，debounce 和 throttling 给出了两种解决策略； 防抖(debouce)定义 函数防抖的含义就是在一定时间段内只有一个同类的事件触发并执行；如果该时间段有同类的事件触发，则重新开始响应该事件 实例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;text&quot; name=&quot;input&quot; onkeyup=&quot;debouce(inputHandler);&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; let i = 0; function inputHandler () { console.log(i++); } let timer; function debouce (fn) { clearTimeout(timer); timer = setTimeout(() =&gt; { fn(); }, 500) } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 节流（throttle）定义 函数节流的含义就是在一定的时间段内相应的事件只能被触发一次；如果某段有已经有相应的事件在执行，则在该时间段内不再触发，直到本次事件执行结束； 实例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;text&quot; name=&quot;input&quot; onkeyup=&quot;debouce(inputHandler);&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; let i = 0; function inputHandler () { console.log(i++); } let timer; function throttle (fn) { if (timer) { return; } timer = setTimeout(() =&gt; { fn(); }, 200); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 区别 ——— 函数去抖和函数节流都是密集型操作中避免事件频繁出发造成性能损耗的解决方案；函数节流，顾名思义就是节约流量，所以每个时间段内只会执行一次，并在此时间段内屏蔽触发的同类事件；而函数去抖则是在用户连续操作中避免事件处理的处理效率不及时间触发速度，从而导致画面卡顿，操作不畅等不良用户体验，所以在很短的时间段内只响应最近触发的事件；]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
        <tag>debouce</tag>
        <tag>throttle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中封装axios方法]]></title>
    <url>%2F2019%2F02%2F20%2Faxios%2F</url>
    <content type="text"><![CDATA[vue中封装axios方法axios基本配置 /src/util/axios.js import axios from &#39;axios&#39; // 引入axios import vm from &#39;@/main&#39; // 引入vue实例化 // 创建axios实例 var instance = axios.create({ // 设置默认请求头，使post请求发送的是formdata格式数据// axios的header默认的Content-Type好像是&#39;application/json;charset=UTF-8&#39; headers: { &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;, &#39;token&#39;: &#39;asdasdasdasdasdasd&#39; // 也可以自定义请求头 }, withCredentials: true // 允许携带cookie }) // 添加响应拦截器 instance.interceptors.response.use(function (response) { // 对响应数据做点什么 return response.data }, function (error) { // 统一的错误处理 console.log(error.response.status) if (error.response.status !== 401) { vm.$error(error.response.data.message) } // 对响应错误做点什么 return Promise.reject(error) }) export const get = (url, data) =&gt; instance.get(url, { params: data }) // get方式 export const post = (url, data) =&gt; instance.post(url, data) //post方式 export const put = (url, data) =&gt; instance.put(url, data) //put方式 调用 api/index.js import {get, post} from &#39;@/utils/axios&#39; getCityList: () =&gt; get(&#39;/api/cityList&#39;)]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[session和cookie]]></title>
    <url>%2F2019%2F02%2F18%2Fsession%2F</url>
    <content type="text"><![CDATA[无状态的httphttp的请求和响应都是对应的，客户端向服务器发送请求数据，服务器端不会记录状态,因此服务器端想知道是哪个客户端提交的请求，通常使用cookie和session来完成Cookie【req.cookies】cookie是从服务端发送的，服务端给不同的客户端发送不同的标识，这个标识标识该用户的身份，服务器通过这个标识来识别用户的身份，从而将数据发送到该客户端【express使用cookie-parser 】，但是客户端的cookie具有局限性局限性：cookie的数量长度限制，每个cookie长度不能超过4kb，最多只能有20条Sessionexpress-session是express的一个中间件来创建session，服务端生成了一个session id，客户端使用cookie保存了session id这个请求的信息，而将用户的请求信息保存到客户端，session记录的客户端与服务端之间的会话状态，该状态是用来确定客户端的身份【req.session】cookie和session的区别1、最大的区别应该在于存储的地方不一样，cookie存储在客户端，session存储在服务器；2、从安全性方面来说，cookie存储在客户端，很容易被窃取，暴露用户信息，而session存储在服务器，被窃取的机会小很多，故session的安全性比cookie高；3、从性能方面来说，cookie存储在浏览器端消耗的是用户的资源，相对比较分散，而session消耗的服务器的内存，会造成服务器端的压力；4、cookie可以长期的存储在客户端，但是数量和大小都是有限制的；session存在服务器的时间较短，但是没有大小的限制。]]></content>
      <tags>
        <tag>js</tag>
        <tag>session</tag>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Mvc.]]></title>
    <url>%2F2019%2F02%2F17%2Fmvc%2F</url>
    <content type="text"><![CDATA[浅谈mvc定义： MVC即Model、View、Controller即模型、视图、控制器。我在和同行讨论技术，阅读别人的代码时发现，很多程序员倾向于将软件的业务逻辑放在Controller里，将数据库访问操作的代码放在Model里。 ####最终网站的代码结构是，View层是界面，Controller层是业务逻辑，Model层是数据库访问。 ###MVC要实现的目标是将软件用户界面和业务逻辑分离以使代码可扩展性、可复用性、可维护性、灵活性加强。 View层是界面，Model层是业务逻辑，Controller层用来调度View层和Model层，将用户界面和业务逻辑合理的组织在一起，起粘合剂的效果。所以Controller中的内容能少则少，这样才能提供最大的灵活性。 比方说，有一个View会提交数据给Model进行处理以实现具体的行为，View通常不会直接提交数据给Model，它会先把数据提交给Controller，然后Controller再将数据转发给Model。假如此时程序业务逻辑的处理方式有变化，那么只需要在Controller中将原来的Model换成新实现的Model就可以了，控制器的作用就是这么简单， 用来将不同的View和不同的Model组织在一起，顺便替双方传递消息，仅此而已。 各Model之间是可以相互调用的， Controller也可以无障碍的调用Model，因此将业务逻辑放在Model中可以灵活的使用组合的方式复用代码。 MVC的优缺点优点： 耦合性低（ MVC设计模式可以说实现了分层开发。各个层都有各个层的作用。 ） 重用性高 部署快，生命周期成本低 可维护性高（修改模型不会影响到视图，反过来，修改视图，也不会影响到模型。 ） 缺点： 完全理解MVC比较复杂。 调试困难。 不适合小型，中等规模的应用程序（对于简单页面，严格遵循mvc，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。 ） 增加系统结构和实现的复杂性 总结一下，关于MVC各层之间关系所对应的设计模式 View层，单独实现了组合模式 Model层和View层，实现了观察者模式 View层和Controller层，实现了策咯模式]]></content>
      <tags>
        <tag>js</tag>
        <tag>mvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域]]></title>
    <url>%2F2019%2F02%2F13%2Fcors%2F</url>
    <content type="text"><![CDATA[跨域###浏览器同源政策及其规避方法 跨域是由于浏览器的同源策略限制，而产生的一种安全模式。同源策略同源是指同协议，同域名，同端口，三者相同就是同源，如有一项不同就是跨域，而在浏览器中静态资源不受同源策略的影响（img,link，script,iframe）解决跨域利用同源策略的特点解决跨域问题方式一: jsonp请求利用静态资源不受跨域的限制解决跨域 ####封装jsonp const getParams = (data) =&gt; { // 创建一个函数，接收一个参数 console.log(data, &#39;444&#39;) let params = &#39;&#39; for (let key in data) { console.log(key) params += &#39;&amp;&#39; + key + &#39;=&#39; + data[key] } return params } const jsonp = (url, data) =&gt; { // 创建函数接收需要跨域请求的地址 return new Promise((resolve, reject) =&gt; { const script = document.createElement(&#39;script&#39;) // 动态创建script标签 const callbackName = &#39;a&#39; + (+new Date()) // 随机定义callback函数名 const params = getParams(data) // 拼接参数 script.src = url + &#39;?callback=&#39; + callbackName + &#39;&amp;&#39; + params // 设置src属性为接口地址 console.log(script) document.body.appendChild(script) // 动态插入到页面中 window[callbackName] = function (res) { // 动态设置callback函数到window上 resolve(res) // 成功后 document.body.removeChild(script) // 删除script标签 window[callbackName] = null // 清空window上的callback函数 } console.log(&#39;aaa&#39;) }) } export default jsonp ###后端【使用express来说】 router.get(&#39;/list&#39;, function(req,res){ console.log(req.query) let {callback} = req.query res.send(`${callback}(&#39;sssss&#39;)`) }) 优点 可以解决跨域，并且兼容所有浏览器 缺点 只能get请求，不能post请求 特性 利用了静态资源不受同源策略影响 原理 动态生成script标签，并且设置src属性为接口地址，动态插入到页面中，发出请求，后端接到请求，需要获取callback的参数，而callback的参数动态生成script标签的时候，动态生成函数名称 方式二：corscors跨域资源共享，这是浏览器的新增特性，只需要操作服务即可，客户端不变，常用场景就是小程序 Cors是一个w3c标准，全称是“跨域资源共享”（Corss-origin rsource sharing） 他允许浏览器向跨域服务器，发出XMLrequrest请求，从而克服了AJAX只能同源使用的限制 前端不需要做任何修改，只需要服务端设置允许的header头即可 app.use((req, res, next) =&gt; { res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;); // 允许所有跨域请求 res.header(&#39;Access-Control-Allow-Credentials&#39;, true) // 允许携带cookie res.header(&#39;Access-Control-Allow-Headers&#39;, &#39;Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild&#39;); //允许的header内容 res.header(&#39;Access-Control-Allow-Methods&#39;, &#39;PUT, POST, GET, DELETE, OPTIONS&#39;); // 允许的请求方法 next() }) 优点 前端不需要做任何处理，支持get，post任何请求 缺点 浏览器兼容，不兼容IE10以下浏览器 特性 浏览器新特性 方式三：代理一般情况下跨域产生的原因域名端口不一样，因为在开发环境中，前端启动的是自己的服务，后端启动也是自己的服务，而在后面上线了就不存在跨域了，这种情况下我们一般使用代理的形式（后端不需要做任何调整，只需要前端添加反向代理即可） 客户端发出去请求 – 本地服务器拦截 – 发现是api开头 – 本地服务发出请求请求(localhost:3000) – 跨域服务器返回数据 – 本地服务器接收数据 – 将数据返回给客户端 方式四：window.name+iframewindow.name通过在iframe（一般动态创建i）中加载跨域HTML文件来起作用。然后，HTML文件将传递给请求者的字符串内容赋值给window.name。然后，请求者可以检索window.name值作为响应。 iframe标签的跨域能力； window.name属性值在文档刷新后依旧存在的能力（且最大允许2M左右）。 每个iframe都有包裹它的window，而这个window是top window的子窗口。contentWindow属性返回iframe元素的Window对象。你可以使用这个Window对象来访问iframe的文档及其内部DOM。 &lt;!-- 下述用端口 10000表示：domainA 10001表示：domainB --&gt; &lt;!-- localhost:10000 --&gt; &lt;script&gt; var iframe = document.createElement(&#39;iframe&#39;); iframe.style.display = &#39;none&#39;; // 隐藏 var state = 0; // 防止页面无限刷新 iframe.onload = function() { if(state === 1) { console.log(JSON.parse(iframe.contentWindow.name)); // 清除创建的iframe iframe.contentWindow.document.write(&#39;&#39;); iframe.contentWindow.close(); document.body.removeChild(iframe); } else if(state === 0) { state = 1; // 加载完成，指向当前域，防止错误(proxy.html为空白页面) // Blocked a frame with origin &quot;http://localhost:10000&quot; from accessing a cross-origin frame. iframe.contentWindow.location = &#39;http://localhost:10000/proxy.html&#39;; } }; iframe.src = &#39;http://localhost:10001&#39;; document.body.appendChild(iframe); &lt;/script&gt; &lt;!-- localhost:10001 --&gt; &lt;!DOCTYPE html&gt; ... &lt;script&gt; window.name = JSON.stringify({a: 1, b: 2}); &lt;/script&gt; &lt;/html&gt; 注意： 直接嵌入其他域（localhots:10001）下的URL会报错，所以需要加载完成替换为当前域的URL(localhots:10000)，proxy.html为空白页面，只为解决该问题； 重新设置src（http://localhost:10000/proxy.html）后导致页面不断刷新，所以通过state来控制； 全部获取完结果后，清除该iframe。]]></content>
      <tags>
        <tag>js</tag>
        <tag>cors</tag>
        <tag>跨域</tag>
        <tag>jsonp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RESTful API]]></title>
    <url>%2F2019%2F02%2F12%2Fweb%20server%2F</url>
    <content type="text"><![CDATA[前后端交互？ 以前前后端是不分离的，随着ajax的出现，可以实现异步获取数据，不需要一直刷新页面，可以通过异步的形式获取数据，提升用户体验，后来随着一些前端框架的出现，开始有了前后端分离的开发模式，前端负责页面结构，样式，效果，数据渲染、（逻辑处理）后端只需要提供数据接口，提升了开发效率 前后端分离 前后端分离之后出现的问题，数据结构有时候不会特别便利（不太方便），接口报错的时候，接口描述不清晰，这个时候都需要前端和后台沟通，为了提升开发效率，现在所有的后端需要提供接口文档，描述每一个接口是干什么的，每一个参数是干什么的，但是还是避免不了又不清晰的地方，后端也有可能发生错误，所以现在一般接口都会有接口规范（最常用的RESTful API） 后端开发语言？####php,java,.net,…. 这些语言都可以输出html语言 php循环 &lt;div&gt; &lt;?php for ($x=0; $x&lt;=10; $x++) { exho &quot;&lt;li&gt; $x &lt;/li&gt;&quot;; } ?&gt; &lt;/div&gt; 在这个时候前后端的职责就是前端只做页面布局+js效果，写静态页面，将静态页面给后端作为模板，后端开始嵌套数据，这时候前后交互是前端需要协助后端做页面调试，前端会一直配合后台做样式，结构处理，造成工作效率低下的问题全栈工程师有了node的出现，前端也可以做数据库的操作呢，接口的开发，node开发接口一般用两个框架express。 koa ，数据库mysql ，mongdb （CRUD); 现在一般常用node做中间层处理【就是原有接口的转换】，node在企业开发中也会做一些提升开发效率的工具，node也可以用作桌面应用程序额的开发RESTful起源： REST这个词，是Roy Thomas Fielding在他2000年的博士论文中提出的。 名称： Fielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer的缩写（表现层状态转化）。 理解： RE:(表现层)：指的就是资源（把资源呈现出来就叫表现层） ST:(转态转换)：访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。 客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词： GET、POST、PUT、DELETE。 它们分别对应四种基本操作： GET用来获取资源， POST用来新建资源（也可以用于更新资源）， PUT用来更新资源， DELETE用来删除资源。 总结RESTful 看Url就知道要什么 看http method就知道干什么 看http status code就知道结果如何]]></content>
      <tags>
        <tag>js</tag>
        <tag>前后端交互</tag>
        <tag>Restful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex简单概述]]></title>
    <url>%2F2019%2F01%2F30%2Fvuex%2F</url>
    <content type="text"><![CDATA[Vuex Vuex是什么？ 引入官方提供的解释，vuex 是专门为 vue.js 设计的一套 状态管理模式 。什么是状态管理模式？说白了就是数据的集中管理。我们在使用 vue.js 时所用到的数据全部抽取出来放在一个state对象下，这样我们在任何组件内都可以访问得到该数据。下面我们通过一个例子来看下 vuex 是如何管理我们的数据的。 首先先通过npm来安装一下vuex：npm install vuex --save state状态属性在项目src目录下新建一个store文件夹(该文件夹不是必须的，你也可以直接新建一个store.js，只要你引入的路径正确即可)，在该文件夹下新建一个 index.js。store文件夹主要是单独管理我们的数据状态，包括行为触发等等。 store/index.js import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; Vue.use(Vuex) let store = new Vuex.Store({ state: { //要设置的全局访问的state对象 name: &quot;vuex&quot; } }) export default store 为了能在所有的组件中共享我们的数据，我们有必要给根实例下注入我们的store对象，所以我们在main.js文件中 main.js import Vue from &#39;vue&#39; import App from &#39;./App.vue&#39; import &quot;./commcss/index.scss&quot; import store from &#39;./store/index&#39; new Vue({ el: &#39;#app&#39;, render: h =&gt; h(App), store // 全局注册 }) App.vue &lt;template&gt; &lt;div class=&quot;app&quot;&gt; {{name}} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { mapState} from &#39;vuex&#39; /* *1.mapState 辅助函数 *当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。 *为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键： */ export default { computde: { ...mapState([&#39;name&#39;]) } } &lt;/script&gt; Getter(store的计算属性，例如对列表进行过滤) store/index.js state: { count: 1, arr: [ { sex: &#39;男&#39;, id: 1 }, { sex: &#39;男&#39;, id: 2 }, { sex: &#39;男&#39;, id: 3 }, { sex: &#39;男&#39;, id: 4 }, { sex: &#39;女&#39;, id: 5 }, { sex: &#39;男&#39;, id: 6 }, { sex: &#39;男&#39;, id: 7 } ] }, getters: { man (state) { return state.arr.filter(item=&gt;{return item.sex===&#39;男&#39;}) } }, App.vue &lt;template&gt; &lt;div class=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(item,index) in man&quot; :key=&quot;item.id&quot;&gt;{{item.sex}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { mapGetters } from &#39;vuex&#39; //mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性： export default { computde: { ...mapGetters([&#39;man&#39;]) } } &lt;/script&gt; mutation(更新state的唯一方法) store/index.js mutation: { change (state) { state.name = &#39;vue&#39; } } App.vue &lt;template&gt; &lt;div class=&quot;app&quot; @click=&quot;change&quot;&gt; {{name}} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { method: { change () { this.$store.commit(&#39;change&#39;) } } } &lt;/script&gt; 一条重要的原则就是要记住 mutation 必须是同步函数原因：(为什么不能执行一步操作) 现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。 因此：【我们需要一个action来进行异步操作】ActionAction 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 store/index.js state: { count: 0 }, mutations: { addcount (state) { state.count++ } }, actions: { getInfo (context) { setTimeout(()=&gt;{ context.commit(&#39;addcount&#39;) },2000) } } App.vue &lt;template&gt; &lt;div class=&quot;app&quot; @click=&quot;change&quot;&gt; {{count}} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { computed: { ...mapState([&#39;count&#39;]) }, method: { change () { this.$store.dispatch(&#39;getInfo&#39;) } } } &lt;/script&gt; 乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 mutation 必须同步执行这个限制么？Action 就不受约束！我们可以在 action 内部执行异步操作：Module由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。 为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：首先创建module/todo.js module/todo.js export default { namespaced: true, state: { count: 0 }, mutations: { addcount (state) { state.count++ } }, } store/index.js import todo from &quot;./modules/todo&quot; modules: { todo } App.vue &lt;template&gt; &lt;div class=&quot;app&quot; @click=&quot;change&quot;&gt; {{count}} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { computed: { ...mapState(&#39;todo&#39;,[&#39;count&#39;]) }, method: { change () { this.$store.commit(&#39;todo/addcount&#39;) } } } &lt;/script&gt;]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router路由]]></title>
    <url>%2F2019%2F01%2F28%2FNew%20Router%2F</url>
    <content type="text"><![CDATA[路由路由传参(query,params)在单页面应用中路由的传递方式常用的两种方法、(query,params) query 包含在路径后面以？作为分割符，多参数直接使用&amp;分割开发，名字和值使用=分隔，这种方式适合传递不必须的值，传递和不传递都不会影响页面的加载 params 包含在路由路径之中，这种方式是框架内部的参数传递实现的，这种方式适合传递必须传递的值(/detail/:id) (/detail/11213),可以出现在路径中的任何位置 如何获取($router) 在vue中路由参数通过，$route获取，$route.params获取params传递的参数，$route.query获取query传递的参数，而$route就是代表的是当前页面的路由信息对象###而$router是获取的是路由实例，$route只是$router中一个参数的指针而已（） 常识： 1.router-link组件是用来跳转路由的，to属性是将要跳转的路由页地址。 2.router-view组件是用来展示组件页的。]]></content>
      <tags>
        <tag>vue-router</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue构造器及其实例化概念]]></title>
    <url>%2F2019%2F01%2F28%2Fvue%20extend%2F</url>
    <content type="text"><![CDATA[Vue构造器及其实例化概念 Vue构造器附官方文档 简单介绍 Vue.extend(options)参数: 对象用法: 使用Vue构造器，创建一个“子类”，参数是一个包含组件选项的对象，其中,data选项中必须是函数描述：Vue.extend返回的是一个“扩展实例构造器”，也就是预设了部分选项的Vue的实例构造器，它常常服务于Vue.component用来生成组件，可以简单理解为当在模板中遇到该组件作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂在到自定义元素上 简单举例 自定义无参数标签下面的代码中的author就是返回的“扩展实例构造器” var author = Vue.extend({ template: &quot;&lt;p&gt;&lt;a :href=&#39;url&#39;&gt;{{author}}&lt;/a&gt;&lt;/p&gt;&quot;, data : function() { return { author : &#39;vamous&#39;, url : &#39;http://blog.csdn.net/Dear_Mr/article/details/72614370&#39; } } }); ###对应的html如下： &lt;author&gt;&lt;/author&gt; 此时的页面必然是没有任何效果的，因为扩展实例构造器还需要挂载，如下new author().$mount(&#39;author&#39;); 使用propsDatavar author = Vue.extend({ template: &quot;&lt;p&gt;&lt;a :href=&#39;url&#39;&gt;{{author}} &amp; {{name}}&lt;/a&gt;&lt;/p&gt;&quot;, data : function() { return { author : &#39;vamous&#39;, url : &#39;http://blog.csdn.net/Dear_Mr/article/details/72614370&#39; } }, props : [&#39;name&#39;] }); new author({propsData: {name : &#39;dear_mr&#39;}}).$mount(&#39;#author&#39;); 可以利用propsData传递参数挂载在普通标签上 返回的扩展实例构造器的方式和上面还是一样的，只是html里不再是自定义标签，而是一个普通标签，比如div &lt;div id=&quot;author&quot;&gt;&lt;/div&gt; new author().$mount(&#39;author&#39;); 其实对于同一个扩展构造器而言，它的每一个实例其实是可以挂载到不同的标签上的，比如我可以这样 new author().$mount(&#39;#author&#39;); new author().$mount(&#39;author&#39;); 这两个标签的内容会一同显示，结果一样 总结 Vue。extend(object)//扩展的子类需要Vue实例化才能使用，如果需要传递props，需要在new的时候通过propsData传递 $mount()手动执行组件的渲染，如果传递一个选择器，就会渲染选择器内部，如果传递只会生成dom不会执行渲染，需要手动将el挂载到页面 $destroy()手动销毁组件，但是如果将dom移动将不会销毁dom，需要手动销毁 $nextTick()生命周期updated的替代方案，因为在updated中只是得知组件需要重新渲染，但并不知道是哪个属性改变了，而nextTick()当属性改变并且渲染完成的回调，类似于react中的setState的回调函数 适用场景 使用扩展子类方式创建的组件适合开发使用api的方法调用 以上就是对Vue.extend构造器的实例详解]]></content>
      <tags>
        <tag>vue</tag>
        <tag>vue构造器</tag>
        <tag>vue extend</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Vue全局的扩展]]></title>
    <url>%2F2019%2F01%2F28%2Fvue%20block%2F</url>
    <content type="text"><![CDATA[关于Vue全局的扩展 Vue的全局组件我们平时使用组件，需要经过引入，绑定两个步骤。那么，如果我们需要使用一些全局组件或者第三方的组件库怎么办呢？在Vue官方文档中介绍的是使用Vue.component(tagName, options)来创建一个全局组件。但是这种方法是与根实例写在同一个文件中，如果要同时注册多个全局组件，就会使根实例文件过重，因此使用Vue.use()来“安装”全局组件，就显得更轻一些。方法： 1.新建一个plugins文件夹 2.在文件夹中创建放置全局组件的文件components.js 3.在components.js文件中引入所有要注册的全局组件 4.在app.js根实例文件中，引入components.js 以login组件为例login.jsimport Login from &#39;../components/eg.vue&#39;; export default (Vue)=&gt;{ Vue.component(&quot;Login&quot;,Login); } app.jsimport components from &#39;./plugins/components.js&#39;; Vue.use(components); 经过上述编写后，就注册了全局组件Login。Vue全局指令对于全局指令的注册，官方文档给出的方法是使用Vue.directive()，位置同样是在根实例文件下，那么问题来了，如果多个全局指令，再加上多个全局组件，那么app.js文件将变得臃肿无比。因此，同上面的注册全局组件方法相似，也是使用Vue.use()来“安装”全局指令。方法： 1.新建一个plugins文件夹 2.在文件夹中创建放置全局组件的文件directives.js 3.在directives.js文件中引入所有要注册的全局指令 4.在app.js根实例文件中，引入directives.js 以v-focus指令为例：directives.js: export default (Vue)=&gt;{ Vue.directive(&quot;focus&quot;,{ inserted:function(el){ el.focus(); } }) } app.jsimport directives from &quot;./plugins/directives.js&quot; Vue.use(directives); 这样就注册了全局指令扩展Vue类方法很简单再此不做更多描述…..直接看代码。》 。Vue.coke = function () { console.log(&quot;扩展了coke类方法&quot;) } 简单吧！！！！！扩展Vue原型，在vue组件中就可以通过this来访问废话不多说上代码Vue.prototype.$api = function () { console.log(&quot;扩展了$api方法&quot;) } ……………….Vue过滤器Vue.js允许自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和v-bind表达式。过滤器应该被添加在JavaScript表达式的尾部，由“管道”符号指示：|&lt;!-- 在双花括号中 --&gt; {{ message | capitalize }} &lt;!-- 在 `v-bind` 中 --&gt; &lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt; 可以在一个组件的选项中定义本地的过滤器：以截取手机为例filters: { phones (num) { let phoneStr = num.toString() let res = /(\d{1,})(\d{4})/ while (reg.test(phoneStr.replace)) { phoneStr = phoneStr.replace(reg, &#39;$1-$2&#39;) } return phoneStr } } //调用 {{17603446842 | phones}} //返回结果 176-0344-6842 全局过滤器Vue.filter(&quot;phones&quot;,function(num){ let phoneStr = num.toString() let res = /(\d{1,})(\d{4})/ while (reg.test(phoneStr.replace)) { phoneStr = phoneStr.replace(reg, &#39;$1-$2&#39;) } return phoneStr }) 来吧，举一个实用一点的例子上代码var app5 = new Vue({ el: &#39;#app5&#39;, data: { shoppingList: [ &quot;Milk&quot;, &quot;Donuts&quot;, &quot;Cookies&quot;, &quot;Chocolate&quot;, &quot;Peanut Butter&quot;, &quot;Pepto Bismol&quot;, &quot;Pepto Bismol (Chocolate flavor)&quot;, &quot;Pepto Bismol (Cookie flavor)&quot; ], key: &quot;&quot; }, computed: { filterShoppingList: function () { // `this` points to the vm instance var key = this.key; var shoppingList = this.shoppingList; //在使用filter时需要注意的是，前面调用的是需要使用filter的数组，而给filter函数传入的是数组中的每个item，也就是说filter里面的函数，是每个item要去做的，并将每个结果返回。 return shoppingList.filter(function (item) { return item.toLowerCase().indexOf(key.toLowerCase()) != -1 });; } } }) template &lt;ul&gt; Filter Key &lt;input type=&quot;text&quot; v-model=&quot;key&quot;&gt; &lt;li v-for=&quot;item in filterShoppingList&quot;&gt; {{ item }} &lt;/li&gt; &lt;/ul&gt; 最终效果实现了根据关键字来过滤列表的功能。]]></content>
      <tags>
        <tag>vue</tag>
        <tag>vue全局组件</tag>
        <tag>vue指令</tag>
        <tag>vue过滤器</tag>
        <tag>directive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue transfrom属性]]></title>
    <url>%2F2019%2F01%2F27%2Ftransition%2F</url>
    <content type="text"><![CDATA[Vue transfrom属性vue中的动画可以使用transfrom组件完成transfrom组件提供两个过渡状态 进入 enter 离开 leave 每个状态有三个步骤【自动添加类名 v代表的是transfrom组件上的name属性指定的值】 v-enter v-enter-active v-enter-to v-leave v-leave-active v-leave-to 通过结合css过渡动画和关键帧动画可以实现切换动画 动画触发场景 跟组件初始化渲染 v-show，v-if，component动态组件切换的时候 router-view 路由切换的时候 transfrom 组件还可以通过属性去改变不同状态自动添加的class类名 enter-active-class=”animated slideInDown” leave-active-class=”animated bounceOutDown” 这种方式适合配合第三方动画库实现动画&lt;transition v-on:before-enter=&quot;berforeEnter&quot; //可以做一些初始化样式设置 v-on:enter=&quot;enter&quot; //执行js操作dom完成的动画效果 v-on:after-enter=&quot;afterEnter&quot; //动画执行结束（也就是在enter中调用了done函数） v-on:enter-cancelled=&quot;enterCancelled&quot; 动画还没有结束，就执行下一次动画了，这时候不会触发动画结束，而是触发这个时间（取消） v-on:before-leave=&quot;beforeLeave&quot; v-on:leave=&quot;leave&quot; v-on:after-leave=&quot;afterLeave&quot; v-on:leave-cancelled=&quot;leaveCancelled&quot; &gt; &lt;!--...--&gt; &lt;/transition&gt;]]></content>
      <tags>
        <tag>vue</tag>
        <tag>transfrom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中的Dom操作]]></title>
    <url>%2F2019%2F01%2F27%2Fvue-dom%2F</url>
    <content type="text"><![CDATA[vue中的Dom操作在vue，react，。。。。以数据驱动视图的框架，都是通过数据更新视图，一般不使用dom操作，但是也有一些特定的时候需要用到dom操作dom操作的方法 transition:组件中的钩子函数可以接受一个el属性，作用动画的dom，可以多dom添加实现动画效果 ref：ref可以作用在dom元素和组件元素上，作用在dom元素上通过refs获取到就是dom节点，作用在组件元素上获取到组件实例 在mounted生命周期中我们可以使用document的dom的操作方法，比如添加一些滚动事件… #el：可以获取组件的根节点元素 ￥mount()：可以手动渲染组件，成为真实的dom节点 事件中的e.target可以获取都绑定事件的dom，但不准确，因为获取到的是点击最内层的元素，当然如果作用在表单元素就无所谓 指令也可以操作dom的]]></content>
      <tags>
        <tag>vue</tag>
        <tag>dom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码整洁之道：程序员的职业素养]]></title>
    <url>%2F2019%2F01%2F25%2Findex%2F</url>
    <content type="text"><![CDATA[代码整洁之道：程序员的职业素养 我们并非是因为喜欢和其他人在一起工作才选择做程序员的。我们都认为人际关系难以应付而且毫无规律。编程用的机器则整洁，行为也可预见。如果可以一个人待在房间里数个小时沉浸在一些真正有趣的问题上，那将会是最开心的时光。 以下全部内容均为本人2019年读书过程中所喜欢或者有感触的片段的摘录，来自于不同的书目，每本书标注了书名，书籍排序仅仅是阅读顺序（倒时间顺序），版权归原作者所有，这里仅作摘录整理。 阿加莎·克里斯蒂的真实人生 你无法创作命运，命运会不请自来，就是这么回事。 人人都做梦，但他们的梦不一样。 那些夜里在脏兮兮的脑袋瓜里做梦的人， 白天一觉醒来发现不过是虚幻一场； 要小心那些在白天做梦的人， 因为他们会睁大眼睛做梦， 用行动让梦想变成现实。 天真是一种罪过，冷漠是一种爱。律师以为自己操纵着游戏，但不过是他想加害的人手中的玩偶。 牧羊少年奇幻之旅 不管是牧羊人、海员，还是推销员，总会有一个地方令他们魂牵梦萦，那里会有一个人让他们忘记自由自在周游世界的快乐。 当总是面对同样的面孔，像在神学院里那样，就会渐渐让那些人成为生活的一部分。而由于他们是你生活的一部分，当然就想改变你的生活。如果你不像他们所期望的那样，他们就会不高兴。因为，对于该怎样生活，所有人都有固定的观念。但是他们对于自己该怎样生活却一头雾水，就像那个给人解梦、却不会把梦变成现实的老妇人。 男孩心想，人总会说一些刁钻古怪的事情。有的时候，最好与羊群为伴，羊群不声不响，只顾吃草和水晶。与书为伴也行，书总是在人们最想听故事的时候，告诉你一些意想不到的事情。但是，当人与人交谈的时候，有些人说的话会让我们无所适从，不知该怎样把谈话继续下去。「天命就是你一直期望去做的事情。人一旦步入青年时期，就知道什么是自己的天命了。在人生的这个阶段，一切都那么明朗，没有做不到的事情。人们敢于梦想，期待完成他们一生中喜欢做的一切事情。但是，随着时光的流逝，一股神秘的力量开始企图证明，根本不可能实现天命。」实际上，每天都一成不变，是因为人们已经失去了对美好事物的敏锐感觉。我和别人没什么两样：总是以理想的眼光看待世界，以为事情会按理想的方式发展，而不会用现实的眼光看待世界，看不到事情真相。「因为麦加是支撑我活下去的希望，使我能够忍受平庸的岁月，忍受橱柜里那些不会说话的水晶，忍受那间糟糕透顶的餐厅里的午饭和晚饭。我害怕实现我的梦想，实现之后，我就没有活下去的动力了。」「你的梦想是羊群和金字塔。你与我不同，因为你希望实现你的梦想，而我只是想保有去麦加的梦想。我曾无数次地想象过，如何穿过沙漠，到达安放着圣石的广场，在触摸圣石之前，围着它绕行七圈。我曾想象过有些人站在我身旁，有些人站在我前面，还有我们的谈话和共同的祈祷。可是，我担心会大失所望，所以我宁愿只保留一个梦想。」「你一度成为我的福音。而今天我明白了一个道理，任何不被接纳的福音，都会变成诅咒。我对生活没有更多的要求。而你正迫使我盯着从未见过的财富和前景。现在，我知道了这些财富和前景，也知道了我完全有可能拥有它们。可是我的感觉却比以前糟糕了。因为我知道我自己可以拥有这一切，却不愿拥有它们。」别的事情不好说，但在这件事上，男孩坚信不疑，尽管他的父母以及先辈都说过，必须在恋爱、订婚、相互了解和有了钱之后才可以结婚。说这话的人大概从来不了解宇宙的语言，因为如果掌握了这种语言，很容易就能理解，世上总有人在等待着另外一个人，无论是在大沙漠还是在大城市。当这两个人最终相遇，四目相对的时候，过去的一切和将来的一切全都变得无足轻重了，只有眼前的这一刻最重要。因为生活永远是，也仅仅是我们现在经历的这一刻。这正是需要爱发挥力量的地方，因为当我们有爱的时候，总是希望自己变得更好。 且听风吟 说到底，写文章并非自我诊治的手段，充其量不过是自我疗养的一种小小的尝试。问题是，直言不讳是件极为困难的事。甚至越是想直言不讳，直率的言语越是遁入黑暗的深处。死去的祖母常说「心情抑郁的人只能做抑郁的梦，要是更加抑郁的，连梦都不做的。」如果你志在追求艺术追求文学，那么去读一读希腊人写的东西好了。因为要诞生真正的艺术，奴隶制度是必不可少的。而古希腊人便是这样：奴隶们耕种、烧饭、划船，而市民们则在地中海的阳光下陶醉于吟诗作赋，埋头于数学解析。所谓艺术便是这么一种玩意儿。至于半夜三点半在悄无声息的厨房寻找电冰箱里的食品的人，只能写出这等模样的文章。而那就是我。「我时常想：假如活着不给任何人添麻烦该有多好！你说能做到吗？」「怎么说呢，大概因为厌烦了吧。可我也在尽我的努力——就连自己都难以置信。我也在考虑别人，像考虑自己的事一样，也因此挨过警察的揍。但到时候人们终究要各归其位，唯独我无处可归，就像玩『抢椅子』游戏没了椅子。」「不过你认真想想看：条件大伙都一样，就像同坐一架出了故障的飞机。诚然，有的运气好些，有的运气差些，有的坚强些有的懦弱些，有的有钱有的没钱。但没有一个家伙怀有超乎常人的自信，大家一个样，拥有什么的家伙生怕一旦失去，一无所有的家伙担心永远一无所有，大家一个样。所以，早些察觉到这一点的人 应该力争使自己多少怀有自信，哪怕装模做样也好，对吧？什么自信之人，那样的人根本没有，有的不过是能够装出自信的人。」「把谁都知道的事写成小说，那究竟有何意味可言？」我有时说谎。最后一次说谎是在去年。说谎是非常令人讨厌的勾当。不妨说，说谎与沉默是现代人类中流行的两大罪过。我们实际上经常说谎，也往往沉默不语。然而，倘若我们一年四季都喋喋不休，而且喋喋不休的无不真实，那么真实的价值必然荡然无存。 超能力侦探事务所 和事件无关的人，只要时间够久，或有新的事件发生，就会很快忘记过往的事。世界上永远没有「感同身受」这件事，因为没有亲身经历，无法体会到当事人的痛苦。]]></content>
  </entry>
  <entry>
    <title><![CDATA[知识点总汇]]></title>
    <url>%2F2019%2F01%2F25%2Fall%2F</url>
    <content type="text"><![CDATA[react总汇图片查看下载下来进行查看 ** react知识点总汇图片查看 js基本知识总汇图片查看下载下来进行查看 ** js基本知识总汇图片查看]]></content>
  </entry>
  <entry>
    <title><![CDATA[px2rem 移动端自适应方案]]></title>
    <url>%2F2019%2F01%2F25%2Fpx2rem%2F</url>
    <content type="text"><![CDATA[1/25/2019 4:36:42 PM px2remvue-cli中如何使用px2rem实际开发中，我们通过设计稿得到的值单位是 px，所以要将 px 转换成 rem 再写进样式中。将 px 转换成 rem 我们将使用 px2rem 这个工具，它有 webpack 的 loader：px2rem-loader安装 px2rem-loader在命令行中运行如下安装：npm i px2rem-loader --save-dev 配置 px2rem-loader1/25/2019 4:36:17 PM 在 vue-cli 生成的 webpack 配置中，vue-loader 的 options 和其他样式文件 loader 最终是都是由 build/utils.js 里的一个方法生成的。我们只需在 cssLoader 后再加上一个 px2remLoader 即可，px2rem-loader 的 remUnit 选项意思是 1rem=多少像素，结合 lib-flexible 的方案，我们将 px2remLoader 的 options.remUnit 设置成设计稿宽度的 1/10，这里我们假设设计稿宽为 750px。// utils.js var cssLoader = { loader: &#39;css-loader&#39;, options: { sourceMap: options.sourceMap } } var px2remLoader = { loader: &#39;px2rem-loader&#39;, options: { remUnit: 75 } } 并放进 loaders 数组中// utils.js function generateLoaders(loader, loaderOptions) { var loaders = [cssLoader, px2remLoader] } 也可以动态的根据可视窗口的大小来设置[在这里写一个计算]const size = 200 const screen = 375 const flexFn = () =&gt; { const windowWidth = window.outerWidth const ratio = windowWidth / screen const newSize = ratio * (size / 2) document.querySelector(&#39;html&#39;).style.fontSize = newSize + &quot;px&quot; } flexFn() window.addEventListener(&quot;resize&quot;, () =&gt; { flexFn() },false) 直接将该js引入到main.js中即可 修改配置后需要重启，然后我们在组件中写单位直接写 px，设计稿量多少就可以写多少了，舒服多了。]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
        <tag>vue-cli</tag>
        <tag>px2rem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue概述]]></title>
    <url>%2F2019%2F01%2F25%2Fvue%2F</url>
    <content type="text"><![CDATA[1/25/2019 4:34:55 PM 此文章只是对VUE常用的知识进行了一个简述，详情请访问官方文档 什么是vue？vue是一个框架(渐进式开发框架),其实就是一个框架的名称，其特点是(数据双向绑定，组件开发，单页面路由，指令，插件)什么叫渐进式框架通过开发组件的形式，进行组件的组件的组合，来组合出来的一个页面而已最重要的特性就是组件组件类似于模块，设计组建的目的是为了更好的解耦业务，和模块化的区别就在于(组件的组成包含了(结构，逻辑，样式))而模块只是逻辑组件的特性 组建的状态(data,props) 组件和组件的通讯 自己的生命周期 组件的渲染和组件的创建方式 设计组件组件一般分为，展示组件和受控组件 展示组件：纯粹的展示功能 业务组件：单个的业务功能独立出来的组件 控件：内置表单元素不能满足网页开发，有一些特殊需要自定义的表单组件，称为控制，一般需要结合v-model去做数据双向绑定的控制 容器组件：作为页面的容器，用来管理当前页面的数据，通过数据去控制展示组件的显示 api组件：通过api形式调用的组件（提示，loading，验证等之类的需要通过js调用方法控制的组件。vue.extend创建） 组合式组件：组件和组件之间有特定关系的组件（slot元素作为插槽） 如何拆分组件 按照设计ui提供的ui图，提取公共展示功能，作为展示组件的提取，在页面开发过程中提取页面中独立业务单独出来业务组件，在表单页面提取公共的非内置表单元素作为控件处理（地区选择，选择日期，选择…..） 组件的创建方式 vue.component(componnetName,option) (自动渲染) 在每一个组件中都有component选项，用来注册局部组件 (自动渲染) 通过Vue.extends()扩展子类的形式创建 (手动渲染) 组建的实例选项 @[function] data @[object] method @[object] compoted @[object] watch @[object] conponents @[function] 生命周期 beforeCreated () {} // 初始化数据之前 created () {} // 数据初始化之后 beforeMout () {} // 开始渲染 mounted () {} // 渲染完成 beforeUpdate () {} // 开始更新 当一个数据的改变引起了视图的重新的渲染才会执行，单独的一个数据改变是不会执行的 uppdated () {} // 更新完成 //当使用keep-alive组件时才会 执行 activated () {} // 组件启用时 deactivated () {} // 组件停用时 //组件销毁 v-if销毁组件，或者切换路由(在没有启用缓存的前提)，或者手动执行this.$destroy () {} // 清理组件中绑定的data，通过v-on绑定事件，如果有手动绑定的内容需要，在这个生命周期中手动销毁 beforeDestroy () {} destroyed () {} errorCaptured () {} // 当组件中发生错误时 组件的通讯方式通讯创建：父子，子父，同级，跨级通讯其实就是谁用谁的数据 父子：子组件使用父组件数据，props(常用)，子组件内部通过$parent 子父：父组件使用子组件数据，通过自定事件，子组件通过$emit(事件名称，发送数据)给父组件传递数据(常用)$children $refs 同级：代理(一个子组件将数据发送到父级，父在发送到另一个子级)，eventBus vuex 跨级：逐层传递，vuex eventsBus 组件的嵌套组件内部通过slot内置组件，可以用来承载嵌套组件(单个slot，和命名slot)内置组件 template 单文件组件中代替了template选项，可以用作一个包裹元素，不会被渲染 component 动态组件，通过is属性动态渲染某一个组件 slot 插槽，用来承载组件潜逃的子组件 transition vue用来实现动画的组件(提供了，进入和离开两个状态) transitions-group 用来实现多动画(列表动画，排序，添加，删除) keep-alive 用来启动vue缓存功能，缓存组件的状态 vue的实例属性实例属性 vm.$data // 访问定义的data vm.$props // 访问props对象 vm.$el // 访问组件的根节点 vm.$options // 访问所有配置项 vm.$parent // 访问父组件实例 vm.$root vm.$children vm.$slots vm.$scopedSlots vm.$refs vm.$isServer vm.$attrs vm.$listeners 实例方法 / 数据 vm.$watch vm.$set vm.$delete 实例方法 / 事件 vm.$on vm.$once vm.$off vm.$emit 实例方法 / 生命周期 vm.$mount vm.$forceUpdate vm.$nextTick //数据改变后回调 vm.$destroy //手动渲染]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue slot-scope的理解（适合初学者）]]></title>
    <url>%2F2018%2F08%2F04%2Fvue%20slot-scope%2F</url>
    <content type="text"><![CDATA[Vue slot-scope的理解（适合初学者） 1/26/2019 2:58:04 PM Vue中关于插槽的文档说明很短，语言又写的很凝练，再加上其和方法，数据，计算机等常用选项在使用频率，使用先后上的差别，这就有可能造成初次接触插槽的开发者容易产生“算了吧，回头再学，反正已经可以写基础组件了”的想法，于是就关闭了VUE的说明文档。 实际上，插槽的概念很简单 slot 概念：插槽，也就是槽，是组件的一块HTML模板，这块模板显示不显示，以及怎样显示由父组件来决定。 插槽可以分为3部分来说 单个插槽 首先是单个插槽，单个插槽的英文VUE的官方叫法，但是其实也可以叫它默认插槽，或者与具名插槽相对，我们可以叫它匿名插槽。因为它不用设置名称属性。 单个插槽可以放置在组件的任意位置，但是就像它的名字一样，一个组件中只能有一个该类插槽。相对应的，具名插槽就可以有很多个，只要名字（名称属性）不同就可以了。 下面通过一个例子来展示。 父组件： &lt;div class=&quot;slot-righ&quot;&gt; &lt;p&gt;22222&lt;/p&gt; &lt;Slo&gt; &lt;div class=&quot;con&quot;&gt; 111111 &lt;/div&gt; &lt;/Slo&gt; &lt;/div&gt; 子组件： &lt;div class=&quot;sol&quot;&gt; &lt;p&gt;11111&lt;/p&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; 具名插槽 匿名插槽没有名称属性，所以是匿名插槽，那么，插槽加了名称属性，就变成了具名插槽。具名插槽可以在一个组件中出现Ñ次，出现在不同的位置。下面的例子，一个就是有两个具名插槽状语从句：单个插槽的组件，这三个插槽被父组件用同一套的CSS样式显示了出来，不同的是内容上略有区别。 下面通过一个例子来展示。 父组件： &lt;div class=&quot;slot-righ&quot;&gt; &lt;p&gt;22222&lt;/p&gt; &lt;Slo&gt; &lt;div class=&quot;con&quot; slot=&quot;up&quot;&gt; 111111 &lt;/div&gt; &lt;/Slo&gt; &lt;/div&gt; 子组件： &lt;div class=&quot;sol&quot;&gt; &lt;p&gt;11111&lt;/p&gt; &lt;slot name=&quot;up&quot;&gt;&lt;/slot&gt;//具名插槽 &lt;/div&gt; 作用域插槽| 带数据的插槽 最后，就是我们的作用域插槽。这个稍微难理解一点。官方叫它作用域插槽，实际上，对比前面两种插槽，我们可以叫它带数据的插槽。什么意思呢，就是前面两种，都是在组件的模板里面写 下面通过一个例子来展示。 父组件： &lt;div class=&quot;slot-righ&quot;&gt; &lt;p&gt;22222&lt;/p&gt; &lt;Slo&gt; &lt;div class=&quot;con&quot; slot-scope=&quot;user&quot;&gt;//父组件拿到数据 {{user.data}} &lt;/div&gt; &lt;/Slo&gt; &lt;/div&gt; 子组件： &lt;template&gt; &lt;div class=&quot;sol&quot;&gt; &lt;p&gt;11111&lt;/p&gt; &lt;slot :data=&quot;data&quot;&gt;&lt;/slot&gt;//这里再插槽上绑定数据 &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data(){ return { data:11111111 } } } &lt;/script&gt; 正因为作用域插槽绑定了一套数据，父组件可以拿来用于是，情况就变成了这样：样式父组件说了算，但内容可以显示子组件插槽绑定的。]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
        <tag>slot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sass基本语法使用]]></title>
    <url>%2F2018%2F08%2F04%2Fsass%2F</url>
    <content type="text"><![CDATA[1/26/2019 10:54:49 AM sass学过CSS的人都知道，它不是一种编程语言。你可以用它开发网页样式，但是没法用它编程。也就是说，CSS基本上是设计师的工具，不是程序员的工具。在程序员眼里，CSS是一件很麻烦的东西。它没有变量，也没有条件语句，只是一行行单纯的描述，写起来相当费事。基本语法 变量SASS允许使用变量，所有变量以$开头。 $blue : #1875e7; div { color : $blue; } 如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。 $side : left; .rounded { border-#{$side}-radius: 5px; } 计算功能SASS允许在代码中使用算式： body { margin: (14px/2); top: 50px + 100px; right: $var * 10%; } 嵌套SASS允许选择器嵌套。比如，下面的CSS代码： div h1 { color : red; } 可以写成： div { hi { color:red; } } 代码的重用 【继承】 SASS允许一个选择器，继承另一个选择器。比如，现有class1： .class1 { border: 1px solid #ddd; } class2要继承class1，就要使用@extend命令： .class2 { @extend .class1; font-size:120%; } MixinMixin有点像C语言的宏（macro），是可以重用的代码块。使用@mixin命令，定义一个代码块。 @mixin left { float: left; margin-left: 10px; } 使用@include命令，调用这个mixin。 div { @include left; } mixin的强大之处，在于可以指定参数和缺省值。 @mixin left($value: 10px) { float: left; margin-right: $value; } 使用的时候，根据需要加入参数： div { @include left(20px); } 下面是一个mixin的实例，用来生成浏览器前缀。 @mixin rounded($vert, $horz, $radius: 10px) { border-#{$vert}-#{$horz}-radius: $radius; -moz-border-radius-#{$vert}#{$horz}: $radius; -webkit-border-#{$vert}-#{$horz}-radius: $radius; } 使用的时候，可以像下面这样调用： .navbar li { @include rounded(top, left); } .footer { @include rounded(top, left, 5px); } 插入文件@import命令，用来插入外部文件。 @import &quot;path/filename.scss&quot;; 如果插入的是.css文件，则等同于css的import命令。 @import &quot;foo.css&quot;; 高级用法 ### 1. 条件语句 #### @if可以用来判断： p { @if 1 + 1 == 2 { border: 1px solid; } @if 5 &lt; 3 { border: 2px dotted; } } #### 配套的还有@else命令： @if lightness($color) &gt; 30% { background-color: #000; } @else { background-color: #fff; } ### 2. 循环语句 #### SASS支持for循环： @for $i from 1 to 10 { .border-#{$i} { border: #{$i}px solid blue; } } #### 也支持while循环： $i: 6; @while $i &gt; 0 { .item-#{$i} { width: 2em * $i; } $i: $i - 2; } #### each命令，作用与for类似： @each $member in a, b, c, d { .#{$member} { background-image: url(&quot;/image/#{$member}.jpg&quot;); } } ### 3. 自定义函数 #### SASS允许用户编写自己的函数。 @function double($n) { @return $n * 2; } #sidebar { width: double(5px); }]]></content>
      <tags>
        <tag>css</tag>
        <tag>scss</tag>
        <tag>sass</tag>
      </tags>
  </entry>
</search>
