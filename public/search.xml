<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>TypeScript 基础</title>
    <url>/2022/04/25/typescript/</url>
    <content><![CDATA[<h1 id="TypeScript-基础"><a href="#TypeScript-基础" class="headerlink" title="TypeScript 基础"></a>TypeScript 基础</h1><h2 id="TS-与-JS-的区别"><a href="#TS-与-JS-的区别" class="headerlink" title="TS 与 JS 的区别"></a>TS 与 JS 的区别</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>TypeScript 是一种由微软开发的自由和开源的编程语言，他是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类和基于类的面向对象编程</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">TypeScript</th>
<th align="center">JavaScript</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JavaScript的超集，用于解决大型项目的代码复杂性</td>
<td align="center">一种脚本语言，用于创建动态网页</td>
</tr>
<tr>
<td align="center">强类型，支持静态和动态类型</td>
<td align="center">动态弱语言类型</td>
</tr>
<tr>
<td align="center">可以在编译的时候发现并纠正错误</td>
<td align="center">只能在编译完成后发现错误（运行时）</td>
</tr>
<tr>
<td align="center">不允许改变变量的数据类型</td>
<td align="center">变量可以被赋值任意类型的值</td>
</tr>
</tbody></table>
<h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><h3 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bool: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str: <span class="built_in">string</span> = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="number"><a href="#number" class="headerlink" title="number"></a>number</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> variable: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>

<h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">object</span>: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>undefined</code> 和 <code>null</code> 是所有类型的字类型，可以把<code>undefined</code> <code>null</code> 赋值给任意的其他基础类型</li>
<li><strong>但是如果在<code>tsconfig.json</code>指定<code>strictNullChecks</code>的话,则只能赋值给void以及他们自身，不然就会报错</strong></li>
</ul>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> str: <span class="built_in">string</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>

<h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str: <span class="built_in">any</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> num: <span class="built_in">any</span> = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">let</span> bool: <span class="built_in">any</span> = <span class="literal">true</span>;</span><br><span class="line">bool = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str = <span class="number">11</span>;</span><br><span class="line">bool = <span class="number">22</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>any类型可以赋值给任意类型</p>
</blockquote>
<h3 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num: unknown;</span><br><span class="line"><span class="comment">// 配合断言使用  不写as断言的话，报错：运算符“+”不能应用于类型“unknown”和“10”。</span></span><br><span class="line">num = (num <span class="keyword">as</span> <span class="built_in">number</span>) + <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a;</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>用来表示没返回任何类型</p>
</blockquote>
<h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;this is a error&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>never表示永远不存在值的类型</p>
</blockquote>
<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">number</span>[] = [<span class="number">11</span>, <span class="number">122</span>];</span><br><span class="line"><span class="keyword">let</span> arr1: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">11</span>, <span class="number">122</span>];</span><br></pre></td></tr></table></figure>

<h3 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tuple: [<span class="built_in">number</span>, <span class="built_in">string</span>] = [<span class="number">11</span>, <span class="string">&quot;122&quot;</span>];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>元组Tuple表示一个已知（数量，类型）数组元素</p>
</blockquote>
<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义函数类型需要定 参数类型 和 输出类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数没有返回值的时候，返回void</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;log&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选参数，参数后加问号，可选参数在函数入参的最后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y?: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y ? x + y : x </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认参数 与js一样在参数上直接赋值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span> = <span class="number">10</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">any</span></span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>);</span><br><span class="line">add(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="literal">true</span>); <span class="comment">// 报错</span></span><br><span class="line"><span class="comment">// 没有与此调用匹配的重载。</span></span><br><span class="line"><span class="comment">//   第 1 个重载(共 2 个)，“(x: number): number”，出现以下错误。</span></span><br><span class="line"><span class="comment">//     类型“boolean”的参数不能赋给类型“number”的参数。</span></span><br><span class="line"><span class="comment">//   第 2 个重载(共 2 个)，“(x: string): string”，出现以下错误。</span></span><br><span class="line"><span class="comment">//     类型“boolean”的参数不能赋给类型“string”的参数。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>实现函数重载，需要多次声明这个函数，前几次是函数定义，列出所有情况，最后一次是啊函数实现，函数实现是需要定义包含以上重载的类型</p>
</blockquote>
<h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><h3 id="root"><a href="#root" class="headerlink" title="root"></a>root</h3><blockquote>
<p>interface (接口) 是用来定义对象类型的，可以对对象类型进行描述，定义时一般字母大写</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user: Person = &#123;</span><br><span class="line">  name: <span class="string">&quot;111&quot;</span>,</span><br><span class="line">  age: <span class="number">22</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user: Person = &#123;</span><br><span class="line">  name: <span class="string">&quot;111&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>和函数的可选参数类似，在属性上加？，就代表这个属性是可选的</p>
</blockquote>
<h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  <span class="keyword">readonly</span> name: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user: Person = &#123;</span><br><span class="line">  name: <span class="string">&quot;111&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.name = <span class="string">&quot;22&quot;</span> <span class="comment">// Error: 无法分配到 &quot;name&quot; ，因为它是只读属性。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>只读属性：只可以读取不可以修改，修改时会报错</p>
</blockquote>
<h3 id="描述函数类型"><a href="#描述函数类型" class="headerlink" title="描述函数类型"></a>描述函数类型</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Func &#123;</span><br><span class="line">    (x: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> adds: Func = <span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义函数类型"><a href="#自定义函数类型" class="headerlink" title="自定义函数类型"></a>自定义函数类型</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Params &#123;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> callback = <span class="function"><span class="keyword">function</span> (<span class="params">obj: Params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">callback(&#123;</span><br><span class="line">    a: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">    b: <span class="string">&quot;line&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当属性上的类型定义完全一样的话，同时不确定有多少属性的时候使用</p>
</blockquote>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><blockquote>
<p>ts 通过<code>public, private, protected</code> 三个修饰符来增强js中的类</p>
</blockquote>
<h3 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">&quot;lilei&quot;</span>);</span><br><span class="line">p1.speak();</span><br></pre></td></tr></table></figure>

<h3 id="Public"><a href="#Public" class="headerlink" title="Public"></a>Public</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">&quot;lilei&quot;</span>);</span><br><span class="line">p1.speak();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>public 公有的，一个类里面默认所有方法属性都是public（可写可不写）</p>
</blockquote>
<h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">&quot;lilei&quot;</span>);</span><br><span class="line">p1.speak();</span><br><span class="line">p1.name; <span class="comment">// 报错： 属性“name”为私有属性，只能在类“Person”中访问。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person1</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name:  <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); <span class="comment">// 报错： 属性“name”为私有属性，只能在类“Person”中访问。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>private 私有的，只属于类自己，他的实例和继承他的子类都访问不到</p>
</blockquote>
<h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">&quot;lilei&quot;</span>);</span><br><span class="line">p1.speak();</span><br><span class="line">p1.name; <span class="comment">// 报错： 属性“name”受保护，只能在类“Person”及其子类中访问。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person1</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name:  <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); <span class="comment">// 可以访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>protected代表是受保护的，继承他的子类可以访问到</p>
</blockquote>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> surname = <span class="string">&quot;张&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> nickName: <span class="built_in">string</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.nickName = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(Person.surname + <span class="built_in">this</span>.nickName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">&quot;li lei&quot;</span>);</span><br><span class="line">p1.speak();</span><br><span class="line">p1.surname <span class="comment">// 报错</span></span><br><span class="line"><span class="comment">// 属性“surname”在类型“Person”上不存在。你的意思是改为访问静态成员“Person.surname”吗?</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>static 是静态属性，类上的常量，实例不能访问</p>
</blockquote>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><blockquote>
<p>抽象类不能被实例化，只能被继承【抽象类中的方法必须被子类实现】抽象类使用<code>abstract</code>关键字来定义</p>
</blockquote>
<p><strong>抽象类不能被实例化</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">new</span> Animal() <span class="comment">// 报错：无法创建抽象类的实例。</span></span><br></pre></td></tr></table></figure>

<p><strong>抽象类中的抽象方法必须被子类实现</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line">  <span class="keyword">abstract</span> printMeeting(): <span class="built_in">void</span>; <span class="comment">// 这个方法必须在派生类中实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountingDepartment</span> <span class="keyword">extends</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line">  printMeeting(): <span class="built_in">void</span> &#123;&#125; <span class="comment">// 如果不实现该方法则会报错</span></span><br><span class="line">  <span class="comment">//非抽象类“AccountingDepartment”不会实现继承自“Department”类的抽象成员“printMeeting”。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>通俗来说抽象类是用来定义一个基类，声明共有的属性和方法。目的是为了被继承</li>
<li>好处是可以抽离出事物的共性，有利于提高代码的复用率</li>
</ul>
</blockquote>
<h2 id="interface-与-class"><a href="#interface-与-class" class="headerlink" title="interface 与 class"></a>interface 与 class</h2><blockquote>
<p>interface 是用来定义对象类型的，对对象进行描述，但是他也可以对class进行约束。需要使用到<code>implements</code>关键字</p>
</blockquote>
<h3 id="implements"><a href="#implements" class="headerlink" title="implements"></a>implements</h3><blockquote>
<p>implements 是实现的意思，class实现interface</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockInterface &#123;</span><br><span class="line">  currentTime: <span class="built_in">Date</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了约束后，需要满足接口上的所有条件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="title">implements</span> <span class="title">ClockInterface</span> </span>&#123;</span><br><span class="line">  currentTime: <span class="built_in">Date</span>; <span class="comment">// 不实现该变量则会报错： 如下</span></span><br><span class="line">  <span class="comment">// 类“Clock”错误实现接口“ClockInterface”。</span></span><br><span class="line">  <span class="comment">// 类型 &quot;Clock&quot; 中缺少属性 &quot;currentTime&quot;，但类型 &quot;ClockInterface&quot; 中需要该属性。</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理公共的属性和方法"><a href="#处理公共的属性和方法" class="headerlink" title="处理公共的属性和方法"></a>处理公共的属性和方法</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> MusicInterface &#123;</span><br><span class="line">  playMusic(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> <span class="title">implements</span> <span class="title">MusicInterface</span> </span>&#123;</span><br><span class="line">  playMusic(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ipad</span> <span class="title">implements</span> <span class="title">MusicInterface</span> </span>&#123;</span><br><span class="line">  playMusic(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多约束写法</span></span><br><span class="line"><span class="keyword">interface</span> MusicInterface &#123;</span><br><span class="line">  playMusic(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> EmailInterface &#123;</span><br><span class="line">  sendEmail(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> <span class="title">implements</span> <span class="title">MusicInterface</span>, <span class="title">EmailInterface</span> </span>&#123;</span><br><span class="line">  playMusic(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">  &#125;</span><br><span class="line">  sendEmail(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="约束构造结构和静态属性"><a href="#约束构造结构和静态属性" class="headerlink" title="约束构造结构和静态属性"></a>约束构造结构和静态属性</h3><blockquote>
<p>使用implements 只能约束实例上的属性和方法，要想约束构造函数和静态属性需要给class定义一个变量</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ParamsInterface &#123;</span><br><span class="line">    <span class="keyword">new</span>(name: <span class="built_in">string</span>): <span class="built_in">void</span></span><br><span class="line">    nickName: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Person2: ParamsInterface = <span class="class"><span class="keyword">class</span> <span class="title">Person2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> nickName:<span class="built_in">string</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="枚举（Enum）"><a href="#枚举（Enum）" class="headerlink" title="枚举（Enum）"></a>枚举（Enum）</h2><h3 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> Week &#123;</span><br><span class="line">  Monday,</span><br><span class="line">  Tuesday,</span><br><span class="line">  Wednesday,</span><br><span class="line">  Thursday,</span><br><span class="line">  Friday,</span><br><span class="line">  Saturday,</span><br><span class="line">  Sunday</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如上定义了一个数字枚举 Monday 初始值为0 ，其他值进行自增</span></span><br><span class="line"><span class="built_in">console</span>.log(Week[<span class="number">0</span>])      <span class="comment">// Monday</span></span><br><span class="line"><span class="built_in">console</span>.log(Week[<span class="number">1</span>])      <span class="comment">// Tuesday</span></span><br><span class="line"><span class="built_in">console</span>.log(Week[<span class="number">2</span>])      <span class="comment">// Wednesday</span></span><br><span class="line"><span class="built_in">console</span>.log(Week[<span class="number">3</span>])      <span class="comment">// Thursday</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以设定默认值。</span></span><br><span class="line"><span class="built_in">enum</span> Week &#123;</span><br><span class="line">  Monday = <span class="number">1</span>,</span><br><span class="line">  Tuesday,</span><br><span class="line">  Wednesday,</span><br><span class="line">  Thursday,</span><br><span class="line">  Friday,</span><br><span class="line">  Saturday,</span><br><span class="line">  Sunday</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这样就会从 1 开始递增（从初始值开始递增）</span></span><br><span class="line"><span class="built_in">console</span>.log(Week[<span class="number">1</span>])      <span class="comment">// Monday</span></span><br><span class="line"><span class="built_in">console</span>.log(Week[<span class="number">2</span>])      <span class="comment">// Tuesday</span></span><br><span class="line"><span class="built_in">console</span>.log(Week[<span class="number">3</span>])      <span class="comment">// Wednesday</span></span><br><span class="line"><span class="built_in">console</span>.log(Week[<span class="number">4</span>])      <span class="comment">// Thursday</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h3><blockquote>
<p>字符串枚举：在每一个字符串枚举中，每个成员都必须用字符串的字面量（初始化）</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多用于映射</span></span><br><span class="line"><span class="built_in">enum</span> Direction &#123;</span><br><span class="line">    Up = <span class="string">&quot;UP&quot;</span>,</span><br><span class="line">    Down = <span class="string">&quot;DOWN&quot;</span>,</span><br><span class="line">    Left = <span class="string">&quot;LEFT&quot;</span>,</span><br><span class="line">    Right = <span class="string">&quot;RIGHT&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反相映射"><a href="#反相映射" class="headerlink" title="反相映射"></a>反相映射</h3><blockquote>
<p>数字枚举具有反射映射特性，从枚举值到枚举值枚举名字</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> Enum &#123;</span><br><span class="line">    A</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = Enum.A; <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">let</span> nameOfA = Enum[a]; <span class="comment">//Enum[0]  =  &quot;A&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>枚举的意义在于可以定义一些名字的常量集合，可以更清晰的调试和理解<br>多用于定义一些状态值（提高代码的阅读性）</p>
</blockquote>
<h2 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h2><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><blockquote>
<p>如果希望一个变量可以支持多种类型（例如：一个变量可以支持number 又可以支持string）</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">num = <span class="number">8</span>;</span><br><span class="line">num = <span class="string">&quot;str&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>联合类型只能访问他们身上的公有属性</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">num.length <span class="comment">// 报错</span></span><br><span class="line"><span class="comment">// 类型“string | number”上不存在属性“length”。</span></span><br><span class="line"><span class="comment">// 类型“number”上不存在属性“length”。</span></span><br></pre></td></tr></table></figure>

<h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><blockquote>
<p>如果想要对对象进行扩展可以使用交叉类型 <code>&amp;</code></p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比如 Person 有 name 和 age 的属性，而 Student 在 name 和 age 的基础上还有 grade 属性，就可以这么写，</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">    age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student = Person &amp; &#123; <span class="attr">grade</span>: <span class="built_in">number</span> &#125; <span class="comment">// 类似于extend</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="类型别名-（type）"><a href="#类型别名-（type）" class="headerlink" title="类型别名 （type）"></a>类型别名 （type）</h3><blockquote>
<p>类型别名会给类型起一个新的名字，可以作用于原始值，联合类型，元组以及其他需要手写的类型</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Name = <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> NameResolver = <span class="function">() =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> NameOrResolver = Name | NameResolver;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">n: NameOrResolver</span>): <span class="title">Name</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> n === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="interface-和-type-的区别"><a href="#interface-和-type-的区别" class="headerlink" title="interface 和 type 的区别"></a>interface 和 type 的区别</h3><ul>
<li><p>相同点： </p>
<ul>
<li>都可以定义一个对象和函数</li>
<li>都可以允许继承</li>
</ul>
</li>
<li><p>不同点：</p>
<ul>
<li>interface是用来专门定义对象类型的，对对象类型进行藐视</li>
<li>type 是类型别名，可以声明任何类型，interface 不行（只能声明对象和函数）</li>
<li>interface 可以合并重复声明，type 不行</li>
</ul>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重复声明 interface，就合并了</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person: Person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;lin&#x27;</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用type 就报错了</span></span><br><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报错：标识符“Person”重复。</span></span><br><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">    age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报错：对象文字可以只指定已知属性，并且“name”不在类型“Person”中。</span></span><br><span class="line"><span class="keyword">const</span> person: Person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;lin&#x27;</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><blockquote>
<p>对于一些ts无法识别的类型同时开发者清楚这些变量的类型，就是可以使用，语法：<code>值 as 类型</code></p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">arg: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> str = arg <span class="keyword">as</span> <span class="built_in">string</span> <span class="comment">// 先断言为字符串</span></span><br><span class="line">    <span class="keyword">if</span> (str.length) &#123; <span class="comment">// 如果有length属性，则输出 </span></span><br><span class="line">        <span class="keyword">return</span> str.length</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有length 属性 则断言为 number类型</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">number</span> = arg <span class="keyword">as</span> <span class="built_in">number</span></span><br><span class="line">        <span class="comment">// 转为字符串输出length</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">number</span>.toString().length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意⚠️：类型断言不是类型转换，把一个类型断言成联合类型不存在的类型就会报错</strong></p>
</blockquote>
<h3 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Size = <span class="string">&quot;mini&quot;</span> | <span class="string">&quot;small&quot;</span> | <span class="string">&quot;large&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果乱取值就会报错：不能将类型“&quot;normal&quot;”分配给类型“Size”。</span></span><br><span class="line"><span class="keyword">let</span> size:Size = <span class="string">&quot;normal&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><blockquote>
<p>使用泛型解决重用性的问题,使其可以支持多种类型的数据</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写一个函数，并定义其参数类型是string，并且返回这个参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">arg: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg)</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line">print(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="comment">// 如果想要将其参数变为number，可以使用联合类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">arg: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg)</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 但是如果还有其他类型，不可能一直用联合类型写，any当然也不行，不能保证返回类型与参数类型一致</span></span><br><span class="line"><span class="comment">// 可以使用泛型来处理</span></span><br></pre></td></tr></table></figure>
<h3 id="使用泛型处理函数"><a href="#使用泛型处理函数" class="headerlink" title="使用泛型处理函数"></a>使用泛型处理函数</h3><blockquote>
<p>泛型的语法是 <code>&lt;&gt;</code> 里面写参数，一般可以用 <code>T</code> 来表示</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prints</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg)</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line">prints&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;1&quot;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>泛型中的  <code>T</code>  就像一个占位符，或者说是一个变量，在使用的时候可以把定义的类型像参数一样传入，他可以原封不动的输出</p>
</blockquote>
<p><strong>泛型可以使用两种方式进行指定类型</strong></p>
<ul>
<li>定义自己要使用的类型</li>
<li>TS类型推断，自动推导出类型</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">prints&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;1&quot;</span>) <span class="comment">// 定义T为string</span></span><br><span class="line"></span><br><span class="line">prints(<span class="string">&quot;1&quot;</span>) <span class="comment">// ts类型推断，自动推导</span></span><br></pre></td></tr></table></figure>

<p><strong>使用 <code>type</code> <code>interface</code> 方式定义函数类型</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用type定义</span></span><br><span class="line"><span class="keyword">type</span> Print = &lt;T&gt;<span class="function">(<span class="params">arg: T</span>) =&gt;</span> T;</span><br><span class="line"><span class="keyword">const</span> printFn: Print = <span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用interface定义</span></span><br><span class="line"><span class="keyword">interface</span> Print&lt;T&gt; &#123;</span><br><span class="line">    (arg: T): T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> printFn: Print&lt;<span class="built_in">string</span>&gt; = <span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型默认参数"><a href="#泛型默认参数" class="headerlink" title="泛型默认参数"></a>泛型默认参数</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类似函数的默认参数</span></span><br><span class="line"><span class="keyword">interface</span> Print&lt;T = number&gt; &#123;</span><br><span class="line">    (arg: T): T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> printFn: Print = <span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理多个函数参数"><a href="#处理多个函数参数" class="headerlink" title="处理多个函数参数"></a>处理多个函数参数</h3><p><strong>创建一个函数，参数为只有两项的元组数据，交换元组数据并返回</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">tuple: [T, U]</span>): [<span class="title">U</span>, <span class="title">T</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [tuple[<span class="number">1</span>], tuple[<span class="number">0</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// let result: [number, string]</span></span><br><span class="line"><span class="keyword">let</span> result = swap([<span class="string">&quot;string&quot;</span>, <span class="number">2</span>]);</span><br></pre></td></tr></table></figure>

<h3 id="函数的副作用操作"><a href="#函数的副作用操作" class="headerlink" title="函数的副作用操作"></a>函数的副作用操作</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这样可以清晰的获取到返回的类型是什么数据结构，提高了开发效率</span></span><br><span class="line"><span class="keyword">interface</span> UserInfo &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">    age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>&lt;<span class="title">T</span>&gt;(<span class="params">url:<span class="built_in">string</span></span>): <span class="title">Promise</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fetch(url).then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">&#125;</span><br><span class="line">request&lt;UserInfo&gt;(<span class="string">&#x27;user/info&#x27;</span>).then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="约束泛型"><a href="#约束泛型" class="headerlink" title="约束泛型"></a>约束泛型</h3><p>新建一个函数，打印传入参数的长度</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLength</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为 T 属于泛型，则只能在函数被调用的时候才能知道他是什么类型</span></span><br><span class="line">    <span class="comment">// 这里要获取length，ts不知道该变量是否有length属性，则会报错</span></span><br><span class="line">    <span class="comment">// 类型“T”上不存在属性“length”。</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg.length)</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方法：使用interface 来约束泛型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ILength &#123;</span><br><span class="line">    length: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 让泛型继承接口 ILength ，这样就能约束泛型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLength</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">ILength</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length)</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义的变量一定要有length属性，才会通过编译</span></span><br><span class="line"><span class="keyword">const</span> str = printLength(<span class="string">&#x27;lin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> arr = printLength([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="keyword">const</span> obj = printLength(&#123; <span class="attr">length</span>: <span class="number">10</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果该参数上没有 length 属性则会报错： 类型“number”的参数不能赋给类型“ILength”的参数。</span></span><br><span class="line"><span class="keyword">const</span> num = printLength(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h3 id="泛型的应用"><a href="#泛型的应用" class="headerlink" title="泛型的应用"></a>泛型的应用</h3><hr>
<ul>
<li>泛型约束类</li>
</ul>
<hr>
<p><strong>定义栈，有入栈和出栈两个方法，如果想让入栈和出栈的数据类型一样，可以这样写</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> data: T[] = [];</span><br><span class="line">  <span class="function"><span class="title">push</span>(<span class="params">item: T</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.data.push(item);</span><br><span class="line">  &#125;</span><br><span class="line">  pop(): T | <span class="literal">undefined</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.data.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> Stack&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">s1.push(<span class="number">1</span>)</span><br><span class="line">s1.pop() <span class="comment">// 返回最后一位</span></span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>泛型约束接口</li>
</ul>
<hr>
<blockquote>
<p>对接口进行改造，是interface 更灵活</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IkeyVlaue&lt;T, U&gt; &#123;</span><br><span class="line">  key: T;</span><br><span class="line">  value: U;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> k1: IkeyVlaue&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt; = &#123; <span class="attr">key</span>: <span class="string">&quot;111&quot;</span>, <span class="attr">value</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> k2: IkeyVlaue&lt;<span class="built_in">number</span>, <span class="built_in">string</span>&gt; = &#123; <span class="attr">key</span>: <span class="number">2</span>, <span class="attr">value</span>: <span class="string">&quot;22&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>泛型定义数组</li>
</ul>
<hr>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr:<span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// 如果数组中包含不属于number类型的值则会报错：不能将类型“string”分配给类型“number”。</span></span><br><span class="line"><span class="keyword">const</span> arr:<span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="string">&quot;1&quot;</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>总结：</strong></p>
<ul>
<li>泛型是指在定义函数，接口或类的时候，不预先指定具体类型，而是在使用的时候进行指定</li>
<li>泛型中的 <code>T</code> 就像一个占位符或者说是一个变量 ，在使用的时候可以把定义 的类型像参数一样传入，他可以原封不动的输出</li>
<li>泛型在成员之间提供有意义 的约束，这些成员可以是： 函数参数，函数返回值，类的实例成员，类的方法</li>
</ul>
</blockquote>
<hr>
<blockquote>
<p><strong>好处：</strong></p>
<ul>
<li>函数和类可以轻松的支持多种类型，增强程序的扩展性</li>
<li>不必写冗余的联合类型，增强代码的可读性</li>
<li>灵活控制类型之间的约束</li>
</ul>
</blockquote>
<h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><p>从对象中抽取一些属性的值，然后拼接成数组</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userInfo = &#123;</span><br><span class="line">  name: <span class="string">&quot;lin&quot;</span>,</span><br><span class="line">  age: <span class="number">22</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValues</span>(<span class="params">userInfo: <span class="built_in">any</span>, keys: <span class="built_in">string</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> keys.map(<span class="function"><span class="params">key</span> =&gt;</span> userInfo[key]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getValues(userInfo, [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>])); <span class="comment">// [&quot;lin&quot;, 22]</span></span><br><span class="line"><span class="built_in">console</span>.log(getValues(userInfo, [<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;outlook&quot;</span>])); <span class="comment">// [undefined, undefined]</span></span><br></pre></td></tr></table></figure>
<p>虽然对象中没有 sex 和 outlook，但是ts检测并未报错</p>
<p><strong>此时使用ts索引类型，对这种情况做类型约束，实现动态属性的检查</strong></p>
<blockquote>
<p>要想使用索引类型，需要先理解 <code>keyof (索引查询)，T[K] (索引访问), extends (泛型约束)</code></p>
</blockquote>
<h3 id="keyof-索引查询"><a href="#keyof-索引查询" class="headerlink" title="keyof (索引查询)"></a>keyof (索引查询)</h3><blockquote>
<p>keyof 操作符可以用于获取某种类型的所有键值，其返回的类型是联合类型</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test = keyof IPerson; <span class="comment">// &quot;name&quot; | &quot;age&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> names: Test = <span class="string">&quot;name&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错：不能将类型“&quot;11&quot;”分配给类型“keyof IPerson”。</span></span><br><span class="line"><span class="keyword">const</span> names: Test = <span class="string">&quot;11&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="T-K-索引访问"><a href="#T-K-索引访问" class="headerlink" title="T[K] 索引访问"></a>T[K] 索引访问</h3><blockquote>
<p>T[K]，表示接口 T 的属性 K 所代表的类型</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> type1: IPerson[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;11&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> type2: IPerson[<span class="string">&quot;age&quot;</span>] = <span class="number">11</span>;</span><br></pre></td></tr></table></figure>

<h3 id="extends-泛型约束"><a href="#extends-泛型约束" class="headerlink" title="extends (泛型约束)"></a>extends (泛型约束)</h3><blockquote>
<p>T extends U ，表示泛型变量可以通过继承某个类型，获得某些属性</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ILength &#123;</span><br><span class="line">    length: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 让泛型继承接口 ILength ，这样就能约束泛型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLength</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">ILength</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length)</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义的变量一定要有length属性，才会通过编译</span></span><br><span class="line"><span class="keyword">const</span> str = printLength(<span class="string">&#x27;lin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> arr = printLength([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="keyword">const</span> obj = printLength(&#123; <span class="attr">length</span>: <span class="number">10</span> &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="检测动态属性"><a href="#检测动态属性" class="headerlink" title="检测动态属性"></a>检测动态属性</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userInfo = &#123;</span><br><span class="line">  name: <span class="string">&quot;lin&quot;</span>,</span><br><span class="line">  age: <span class="number">22</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValues</span>(<span class="params">userInfo: <span class="built_in">any</span>, keys: <span class="built_in">string</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> keys.map(<span class="function"><span class="params">key</span> =&gt;</span> userInfo[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>定义泛型T U ， 用于约束userInfo和keys</li>
<li>为K增加一个泛型约束,使 K 继承userInfo的所有属性的联合类型，即 <code>U extends keyof T</code></li>
</ul>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValues</span>&lt;<span class="title">T</span>, <span class="title">U</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  userInfo: T,</span></span></span><br><span class="line"><span class="function"><span class="params">  keys: <span class="built_in">Array</span>&lt;U&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Array</span>&lt;<span class="title">T</span>[<span class="title">U</span>]&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> keys.map(<span class="function"><span class="params">key</span> =&gt;</span> userInfo[key]);</span><br><span class="line">&#125;</span><br><span class="line">getValues(userInfo, [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>]);</span><br><span class="line"><span class="comment">// 如果指定的属性不在对象里的时候，就会报错：不能将类型“&quot;sex&quot;”分配给类型“&quot;name&quot; | &quot;age&quot;”</span></span><br><span class="line">getValues(userInfo, [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;ages&quot;</span>]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h2><blockquote>
<p>ts 允许将一个类型映射成另一个类型</p>
</blockquote>
<h3 id="in"><a href="#in" class="headerlink" title="in"></a><code>in</code></h3><blockquote>
<p><code>in</code>操作符，用来对联合类型实现遍历</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Persons = <span class="string">&quot;name&quot;</span> | <span class="string">&quot;school&quot;</span> | <span class="string">&quot;magor&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Obj = &#123;</span><br><span class="line">    [p <span class="keyword">in</span> Persons]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解析出来如下</span></span><br><span class="line"><span class="keyword">type</span> Obj = &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    school: <span class="built_in">string</span>;</span><br><span class="line">    magor: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial</h3><blockquote>
<p>Partial<T> 将 T 的所有属性映射成可选的</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPersons &#123;</span><br><span class="line">    name: <span class="built_in">string</span>,</span><br><span class="line">    age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3: IPerson = &#123;</span><br><span class="line">    name: <span class="string">&quot;li lei&quot;</span>,</span><br><span class="line">    age: <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 要想讲 IPersons 中的类型变为可选属性，就可以使用 Partial</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IPartial = Partial&lt;IPersons&gt;;</span><br><span class="line"><span class="comment">// 解析出来，如下</span></span><br><span class="line"><span class="keyword">type</span> IPartial = &#123;</span><br><span class="line">    name?: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p4: IPartial = &#123;&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Partail 原理： 使用  in 和 keyof</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IPartial&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> p4: IPartial&lt;IPersons&gt; = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>[P in keyof T]</code> 遍历 T 上的所有属性</li>
<li><code>?</code>  设置可选属性类型</li>
<li><code>T[P]</code> 设置类型为原来属性的类型</li>
</ul>
<h3 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly</h3><blockquote>
<p>Readonly<T> 将 T 的所有属性映射为只读</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPersons &#123;</span><br><span class="line">    name: <span class="built_in">string</span>,</span><br><span class="line">    age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IReadonly = Readonly&lt;IPersons&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2: IReadonly = &#123;</span><br><span class="line">  name: <span class="string">&quot;lin&quot;</span>,</span><br><span class="line">  age: <span class="number">12</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 只读属性不能修改，报错：无法分配到 &quot;name&quot; ，因为它是只读属性。</span></span><br><span class="line">p2.name = <span class="string">&quot;lihua&quot;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>原理和<code>Partail</code> 一样</strong></p>
<h3 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a>Pick</h3><blockquote>
<p> <code>Pick</code> 用于抽取对象子集，挑选一组属性并组成一个新的类型</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson1 &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  sex: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 name 和 age 抽取</span></span><br><span class="line"><span class="keyword">type</span> IPick = Pick&lt;IPerson1, <span class="string">&quot;name&quot;</span> | <span class="string">&quot;age&quot;</span>&gt;;</span><br><span class="line"><span class="comment">// 解析出来如下</span></span><br><span class="line"><span class="keyword">type</span> IPick = &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p5: IPick = &#123;</span><br><span class="line">  name: <span class="string">&quot;li lei&quot;</span>,</span><br><span class="line">  age: <span class="number">22</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Pick 原理</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IPicks&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个参数 T 代表要抽取的目标对象</li>
<li>第二参数 K 代表要分离的属性key 值，但是他必须被约束在 参数 T 的key值范围内</li>
</ul>
<h3 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h3><blockquote>
<p>Record 是会创建新的非同态映射类型</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson3 &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IRecord = Record&lt;<span class="built_in">string</span>, IPerson3&gt;;</span><br><span class="line"><span class="comment">// 解析出来，如下</span></span><br><span class="line"><span class="keyword">type</span> IRecord = &#123;</span><br><span class="line">    [x: <span class="built_in">string</span>]: IPerson3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> PersonMap: IRecord = &#123;</span><br><span class="line">  person1: &#123;</span><br><span class="line">    name: <span class="string">&quot;lilei&quot;</span>,</span><br><span class="line">    age: <span class="number">12</span></span><br><span class="line">  &#125;,</span><br><span class="line">  person2: &#123;</span><br><span class="line">    name: <span class="string">&quot;lilei&quot;</span>,</span><br><span class="line">    age: <span class="number">12</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Record 原理</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RecordPlus&lt;K <span class="keyword">extends</span> keyof <span class="built_in">any</span>, T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个参数可以是任意类型，因此约束与any的各种类型</li>
<li>第二参数作为，新创建对象的值被传入</li>
</ul>
<h2 id="条件类型"><a href="#条件类型" class="headerlink" title="条件类型"></a>条件类型</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果类型 T 可以被赋值给类型 U ，那么结果类型就是 X 类型，否则就是 Y 类型</span></span><br><span class="line">T <span class="keyword">extends</span> U ? X : Y</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Exclude 和 Extract 的实现就用到了条件类型</p>
</blockquote>
<h3 id="Exclude-排除的意思"><a href="#Exclude-排除的意思" class="headerlink" title="Exclude: 排除的意思"></a><code>Exclude</code>: 排除的意思</h3><blockquote>
<p>Exclude 的意思是不包含，<code>Exclude&lt;T, U&gt;</code> 会返回联合类型 T 中 不包含 联合类型 U 的部分</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Test1 = Exclude&lt;<span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span>, <span class="string">&quot;a&quot;</span>&gt;</span><br><span class="line"><span class="comment">// 解析出来，如下</span></span><br><span class="line"><span class="keyword">type</span> Test1 = <span class="string">&quot;b&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Exclude原理：</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Exclude&lt;T, U&gt; = T <span class="keyword">extends</span> U ? <span class="built_in">never</span> : T</span><br><span class="line"><span class="keyword">type</span> Test1 = Exclude&lt;<span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span>, <span class="string">&quot;a&quot;</span>&gt;</span><br><span class="line"><span class="comment">// 解析</span></span><br><span class="line"><span class="string">&quot;a&quot;</span> <span class="keyword">extends</span> <span class="string">&quot;a&quot;</span> = <span class="built_in">never</span> </span><br><span class="line"><span class="keyword">type</span> Test1 = <span class="built_in">never</span></span><br><span class="line"><span class="string">&quot;b&quot;</span> <span class="keyword">extends</span> <span class="string">&quot;a&quot;</span> = <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="keyword">type</span> Test1 = <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="keyword">type</span> Test1 = <span class="built_in">never</span> | <span class="string">&quot;b&quot;</span> </span><br></pre></td></tr></table></figure>

<h3 id="Extract-提取的意思"><a href="#Extract-提取的意思" class="headerlink" title="Extract: 提取的意思"></a><code>Extract</code>: 提取的意思</h3><blockquote>
<p><code>Extract&lt;T, U&gt;</code> 提取联合类型 T 和联合类型 U 的所有交集</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Test2 = Extract&lt;<span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span>, <span class="string">&quot;a&quot;</span>&gt;</span><br><span class="line"><span class="comment">// 解析出来如下：</span></span><br><span class="line"><span class="keyword">type</span> Test2 = <span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Extract原理：</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Extract&lt;T, U&gt; = T <span class="keyword">extends</span> U ? T : <span class="built_in">never</span></span><br><span class="line"><span class="keyword">type</span> Test2 = Extract&lt;<span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span>, <span class="string">&quot;a&quot;</span>&gt;</span><br><span class="line"><span class="comment">// 解析</span></span><br><span class="line"><span class="string">&quot;a&quot;</span> <span class="keyword">extends</span> <span class="string">&quot;a&quot;</span> = <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="string">&quot;b&quot;</span> <span class="keyword">extends</span> <span class="string">&quot;a&quot;</span> = <span class="built_in">never</span></span><br><span class="line"><span class="keyword">type</span> Test2 = <span class="string">&quot;a&quot;</span> | <span class="built_in">never</span></span><br></pre></td></tr></table></figure>

<h2 id="工具类型-（util-type）"><a href="#工具类型-（util-type）" class="headerlink" title="工具类型 （util type）"></a>工具类型 （util type）</h2><h3 id="Omit"><a href="#Omit" class="headerlink" title="Omit"></a>Omit</h3><blockquote>
<p><code>Omit&lt;T, U&gt;</code> 从类型 T 中 删除 U 中的所有属性</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson4 &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">    age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> IOmit = Omit&lt;IPerson4, <span class="string">&quot;age&quot;</span>&gt;</span><br><span class="line"><span class="comment">// 结果如下</span></span><br><span class="line"><span class="keyword">type</span> IOmit = &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Omit 原理</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Omits&lt;T, K <span class="keyword">extends</span> keyof <span class="built_in">any</span>&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pick: 用于从 T 中 挑选 一组属性组成一个新的类型</span></span><br><span class="line"><span class="comment">// Exclude: 排除 T 中 的 k 属性  </span></span><br><span class="line"><span class="comment">// 组合 = Omit</span></span><br></pre></td></tr></table></figure>

<h3 id="NonNullable"><a href="#NonNullable" class="headerlink" title="NonNullable"></a>NonNullable</h3><blockquote>
<p><code>NonNullable&lt;T&gt;</code> 用来过滤类型中的null 以及 undefined 类型</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T0 = NonNullable&lt;<span class="built_in">string</span> | <span class="built_in">number</span> | <span class="literal">undefined</span>&gt;; <span class="comment">// string number</span></span><br><span class="line"><span class="keyword">type</span> T1 = NonNullable&lt;<span class="built_in">string</span> | <span class="built_in">number</span> | <span class="literal">null</span>&gt;; <span class="comment">// string number</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>NonNullable 原理</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> NonNullable&lt;T&gt; = T <span class="keyword">extends</span> <span class="literal">undefined</span> | <span class="literal">null</span> ? <span class="built_in">never</span> : T;</span><br><span class="line"><span class="comment">// ....</span></span><br></pre></td></tr></table></figure>

<h3 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h3><blockquote>
<p>Parameters 获取函数的参数类型，并将每一个参数放入一个元组中</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Fn = <span class="function">(<span class="params">arg: <span class="built_in">string</span>, arg2: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">type</span> P1 = Parameters&lt;Fn&gt;;</span><br><span class="line"><span class="comment">// 结果为</span></span><br><span class="line"><span class="keyword">type</span> P1 = [arg: <span class="built_in">string</span>, <span class="attr">arg2</span>: <span class="built_in">number</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Parameters 原理</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ParametersPlus&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (...args: infer P) =&gt; <span class="built_in">any</span> ? P : <span class="built_in">never</span> </span><br><span class="line"><span class="keyword">type</span> Fn = <span class="function">(<span class="params">arg: <span class="built_in">string</span>, arg2: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">type</span> P1 = ParametersPlus&lt;Fn&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Paramaters 首先必须约束参数 T 必须是一个函数类型</span></span><br><span class="line"><span class="comment">// 判断 T 是否为函数类型，如果是 则定义 P 暂存 函数的参数类型 ，否则就返回never</span></span><br></pre></td></tr></table></figure>

<h3 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h3><blockquote>
<p>ReturnType 获取函数类型的返回类型</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Fn = <span class="function">(<span class="params">arg: <span class="built_in">string</span>, arg2: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">type</span> R1 = ReturnType&lt;Fn&gt;</span><br><span class="line"><span class="comment">// 结果为</span></span><br><span class="line"><span class="keyword">type</span> R1 = <span class="built_in">void</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>ReturnType 原理</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同 Parameters 原理</span></span><br><span class="line"><span class="keyword">type</span> ReturnTypePlus&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; infer P ? P : <span class="built_in">never</span></span><br><span class="line"><span class="keyword">type</span> R1 = ReturnTypePlus&lt;Fn&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>ts</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>清除单文件应用浏览器缓存</title>
    <url>/2022/02/23/clearCache/</url>
    <content><![CDATA[<h1 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a>清除缓存</h1><blockquote>
<p>开发网页时，需要清除用户的页面缓存，各个厂商标准不一致，也不给类似说明，是个令人头疼的问题，经调研，有一种方式可以清除页面的缓存，甚至是小程序里webview页面类似牛皮鲜一样顽固的缓存都可以清除掉</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> href = location.href, origin = location.origin, pathname = location.pathname, search = location.search, hash = location.hash;</span><br><span class="line">  <span class="keyword">var</span> searchs = search.replace(<span class="regexp">/_t_=[^&amp;\?]*[&amp;\?]*/g</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="regexp">/(^[&amp;\?]*)|([&amp;\?]*$)/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> ct = <span class="built_in">parseInt</span>(<span class="keyword">new</span> <span class="built_in">Date</span>().valueOf() / <span class="number">10000</span>);</span><br><span class="line">  <span class="keyword">var</span> _t_ = (<span class="regexp">/_t_=[^&amp;\?]*[&amp;\?]*/</span>.exec(href) || [])[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span>(_t_)&#123;</span><br><span class="line">    _t_ = +_t_.replace(<span class="regexp">/(_t_=)|\?|&amp;/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> _t_p = +(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;_t_&#x27;</span>) || ct);</span><br><span class="line">    _t_p !== ct ? add() : clear();</span><br><span class="line">  &#125; <span class="keyword">else</span> add(<span class="literal">true</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">bol</span>)</span>&#123;</span><br><span class="line">    (<span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;html&#x27;</span>)[<span class="number">0</span>] || &#123;&#125;).innerHTML = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;_t_&#x27;</span>, ct);</span><br><span class="line">    <span class="keyword">if</span>(bol) location.replace(origin + pathname + <span class="string">&#x27;?&#x27;</span> + searchs + (searchs ? <span class="string">&#x27;&amp;&#x27;</span> : <span class="string">&#x27;&#x27;</span>) + <span class="string">&#x27;_t_=&#x27;</span> + ct + hash);</span><br><span class="line">    <span class="keyword">else</span> location.replace(origin + pathname + <span class="string">&#x27;?&#x27;</span> + searchs + (searchs ? <span class="string">&#x27;&amp;&#x27;</span> : <span class="string">&#x27;&#x27;</span>) + <span class="string">&#x27;_t_=&#x27;</span> + ct + hash);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">clear</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    history.replaceState(&#123;&#125;, <span class="literal">null</span>, origin + pathname + (searchs ? <span class="string">&#x27;?&#x27;</span> : <span class="string">&#x27;&#x27;</span>) + searchs + hash);</span><br><span class="line">    clear = <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将以下代码复制到页面里，写到最顶部的script,就可以清除页面的缓存了，速度快，不影响使用</p>
</blockquote>
<blockquote>
<p>可以有效解决meta nocha标签，链接加时间戳不生效的缓存</p>
</blockquote>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>catch</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2.0 某些原理概述</title>
    <url>/2021/07/06/vueSource/</url>
    <content><![CDATA[<h1 id="Vue2-0"><a href="#Vue2-0" class="headerlink" title="Vue2.0"></a>Vue2.0</h1><h2 id="Vue初始化过程中（new-Vue-options-）-都做了什么"><a href="#Vue初始化过程中（new-Vue-options-）-都做了什么" class="headerlink" title="Vue初始化过程中（new Vue(options)） 都做了什么"></a>Vue初始化过程中（new Vue(options)） 都做了什么</h2><ul>
<li><p>处理组件配置项</p>
<ul>
<li>初始化根组件进行了 选项合并操作，将全局配置合并到根组件的局部配置上</li>
<li>初始化每个子组件做了一些性能优化，将组件配置对象上的一些深层次的属性放到vm.$options选项中，提高代码执行效率</li>
</ul>
</li>
<li><p>初始化组件实例的关系属性，如$pranet, $children, $root, $refs</p>
</li>
<li><p>处理自定义事件</p>
</li>
<li><p>调用beforeCreate 钩子函数</p>
</li>
<li><p>初始化inject 配置项，得到<code>ret[key] = val</code>形式的配置对象，然后对该配置进行响应式处理，并代理每个key到vm实例上</p>
</li>
<li><p>数据响应式，处理props methods data watch 等选项</p>
</li>
<li><p>解析组件配置上的provide对象，将其挂载到vm_provoded属性上</p>
</li>
<li><p>调用created钩子函数</p>
</li>
<li><p>如果发现配置选项中有el选项，则自动调用$mount方法，如果没有el选项则需要调用$mount</p>
</li>
<li><p>接下来进入挂载阶段</p>
</li>
</ul>
<h2 id="vue-响应式原理实现"><a href="#vue-响应式原理实现" class="headerlink" title="vue 响应式原理实现"></a>vue 响应式原理实现</h2><ul>
<li><p>响应式的核心是通过Object.defondProperty 拦截对数据的访问和设置</p>
</li>
<li><p>响应式的数据分为两类</p>
<ul>
<li>对象，循环遍历对象的所有属性，为每个属性设置getter，setter，以达到拦截访问和设置的母的，如果属性值依旧为对象<br>，则递归为属性值上的每一个key设置getter，setter<ul>
<li>访问数据是<code>&#123;obj.key&#125;</code>进行依赖收集，在dep中存储相关的watcher</li>
<li>设置数据时有dep通知相关的watcher去更新</li>
</ul>
</li>
<li>数组，增强数组的那7个可以更改自身的原型方法，然后拦截对这些方法的操作<ul>
<li>添加新数据进行响应式处理，然后dep通知watcher去更新</li>
<li>删除数据时，也要有dep通知watcher去更新</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="methods-computed-和-watch有什么区别"><a href="#methods-computed-和-watch有什么区别" class="headerlink" title="methods, computed, 和 watch有什么区别"></a>methods, computed, 和 watch有什么区别</h2><ul>
<li><p>使用场景</p>
<ul>
<li>methods 一般用于封装一写较为复杂的处理逻辑（同步 or 异步）</li>
<li>computed 一般用于封装一些简单的同步逻辑，将处理的数据返回，然后显示在模版中，以减轻模版的重量</li>
<li>watch 一般用于当需要在数据变化时需要执行操作</li>
</ul>
</li>
<li><p>区别</p>
<ul>
<li>methods VS conputed</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>vue</tag>
        <tag>vue2</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3 新特性</title>
    <url>/2021/04/26/vue3%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="vue3-新特性"><a href="#vue3-新特性" class="headerlink" title="vue3 新特性"></a>vue3 新特性</h1><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a><code>v-model</code></h2><h3 id="不同版本使用方式"><a href="#不同版本使用方式" class="headerlink" title="不同版本使用方式"></a>不同版本使用方式</h3><blockquote>
<p>vue2.0</p>
</blockquote>
<p>在 2.0 中 v-model 指令必须使用为 value 的 prop，如果想使用别的 prop，就不得不使用 b-bind.sync</p>
<blockquote>
<p>vue2.2</p>
</blockquote>
<p>在 2.2 中组件中出现了 model 的选项，允许组件自定义用于<code>v-model</code>的 prop 和事件中，【组件中只能允许一个 <code>v-model</code>出现】</p>
<blockquote>
<p>vue3.0</p>
</blockquote>
<p>在 3.0 中可以在同一组件中使用多个<code>v-model</code>进行双向绑定，可以自定义<code>v-model</code>修饰符</p>
<h3 id="2-x-语法"><a href="#2-x-语法" class="headerlink" title="2.x 语法"></a>2.x 语法</h3><blockquote>
<p>在 2.x 中<code>v-modle</code>是 value 和 input 事件的语法糖</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">v-model</span>=<span class="string">&quot;pageTitle&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">||等同于</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">:value</span>=<span class="string">&quot;pageTitle&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;pageTitle = $event&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果要将属性或者事件名称修改为自定义名称，则需要在组件中添加<code>modle</code>选项</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">v-model</span>=<span class="string">&quot;pageTitle&quot;</span> /&gt;</span>; // ChildComponent.vue</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;handleChange&quot;</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    model: &#123;</span><br><span class="line"><span class="javascript">      prop: <span class="string">&quot;msg&quot;</span>, <span class="comment">// 自定义变量名</span></span></span><br><span class="line"><span class="javascript">      event: <span class="string">&quot;change&quot;</span> <span class="comment">// 自定义事件名</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    props: &#123;</span><br><span class="line"><span class="javascript">      value: <span class="built_in">String</span>,</span></span><br><span class="line">      msg: &#123;</span><br><span class="line"><span class="javascript">        type: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">        <span class="keyword">default</span>: <span class="string">&quot;Default title&quot;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">handleChange</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$emit(<span class="string">&quot;change&quot;</span>, <span class="string">&quot;12&quot;</span>);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用<code>v-bind.sync</code> —- 大体代码同上</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">:title.sync</span>=<span class="string">&quot;pageTitle&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">// 使用 update:myPropName 抛出事件 this.$emit(&#x27;update:title&#x27;, newValue)</span><br></pre></td></tr></table></figure>

<h3 id="3-x-语法"><a href="#3-x-语法" class="headerlink" title="3.x 语法"></a>3.x 语法</h3><p>在 3.x 中，自定义组件上的 v—modle 相当于传递了<code>modelVaule</code>prop 并收了<code>update:modelValue</code>事件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">v-model:title</span>=<span class="string">&quot;pageTitle&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 是以下的简写: --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">:title</span>=<span class="string">&quot;pageTitle&quot;</span> @<span class="attr">update:title</span>=<span class="string">&quot;pageTitle = $event&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;first&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;title&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">&quot;ChildComponent&quot;</span>,</span></span><br><span class="line">    props: &#123;</span><br><span class="line">      title: &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">default</span>: <span class="function">() =&gt;</span> <span class="string">&quot;????&quot;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">first</span>(<span class="params">e</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$emit(<span class="string">&quot;update:title&quot;</span>, e.target.value);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以支持多个<code>v-model</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">v-model:title</span>=<span class="string">&quot;title&quot;</span> <span class="attr">v-model:name</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;first :value=&quot;</span><span class="attr">title</span>&quot;&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;last&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">&quot;ChildComponent&quot;</span>,</span></span><br><span class="line">    props: &#123;</span><br><span class="line">      title: &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">default</span>: <span class="function">() =&gt;</span> <span class="string">&quot;????&quot;</span></span></span><br><span class="line">      &#125;,</span><br><span class="line">      name: &#123;</span><br><span class="line"><span class="javascript">        defaule: <span class="function">() =&gt;</span> <span class="string">&quot;???&quot;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">first</span>(<span class="params">e</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$emit(<span class="string">&quot;update:title&quot;</span>, e.target.value);</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">last</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$emit(<span class="string">&quot;update:name&quot;</span>, e.target.value);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><h3 id="2-x-用法"><a href="#2-x-用法" class="headerlink" title="2.x 用法"></a>2.x 用法</h3><ul>
<li>bind - 指令绑定到元素后发生【只发生一次】</li>
<li>inserted - 元素插入父 DOM 后发生</li>
<li>update - 当元素更新，但子元素尚未更新时，调用此函数</li>
<li>componentUpdated - 所造组件以及其子元素更新后，就会调用此函数</li>
<li>unbind - 指令被移除，调用此函数</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-highlight</span>=<span class="string">&quot;&#x27;yellow&#x27;&quot;</span>&gt;</span>高亮显示此文本亮黄色<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 注册一个全局自定义指令</span></span></span><br><span class="line"><span class="javascript">  Vue.directive(<span class="string">&quot;highlight&quot;</span>, &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">bind</span>(<span class="params">el, binding, vnode</span>)</span> &#123;</span></span><br><span class="line">      el.style.background = binding.value;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">inserted</span>(<span class="params"></span>)</span> &#123;&#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">update</span>(<span class="params"></span>)</span> &#123;&#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">componentupdated</span>(<span class="params"></span>)</span> &#123;&#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">unbind</span>(<span class="params"></span>)</span> &#123;&#125;</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="javascript">  <span class="comment">// 注册一个局部的指令【组件内部】</span></span></span><br><span class="line">  directives: &#123;</span><br><span class="line">    highlight: &#123;</span><br><span class="line"><span class="javascript">      bind: <span class="function">() =&gt;</span> &#123;&#125;,</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-x"><a href="#3-x" class="headerlink" title="3.x"></a>3.x</h3><ul>
<li>beforeMount - 当指令第一次绑定到元素并且在挂载到父组件之前调用<code>【替换bind】</code></li>
<li>mounted - 在挂载绑定元素的父组件时调用 <code>【替换 inserted】</code></li>
<li>beforeUpdata - 在更新包含组件的子元素之前调用 <code>【新增】</code></li>
<li>updated - 更新之后调用 <code>【替换update】</code></li>
<li>beforeUnmount - 在卸载绑定之前调用 <code>【新增】</code></li>
<li>unmounted - 与元素解除绑定且父组件卸载时调用 <code>【替换unbind】</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-highlight</span>=<span class="string">&quot;&#x27;yellow&#x27;&quot;</span>&gt;</span>高亮显示此文本亮黄色<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = Vue.createApp(&#123;&#125;);</span></span><br><span class="line"><span class="javascript">  app.directive(<span class="string">&quot;highlight&quot;</span>, &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">beforeMount</span>(<span class="params">el, binding, vnode</span>)</span> &#123;</span></span><br><span class="line">      el.style.background = binding.value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><h3 id="2-x"><a href="#2-x" class="headerlink" title="2.x"></a>2.x</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Bank Account Balance<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; accountBalance | currencyUSD &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    props: &#123;</span><br><span class="line">      accountBalance: &#123;</span><br><span class="line"><span class="javascript">        type: <span class="built_in">Number</span>,</span></span><br><span class="line"><span class="javascript">        required: <span class="literal">true</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    filters: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">currencyUSD</span>(<span class="params">value</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="string">&quot;$&quot;</span> + value;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-x-1"><a href="#3-x-1" class="headerlink" title="3.x"></a>3.x</h3><blockquote>
<p>3.x 中，过滤器已被移除，不在支持，官方建议使用计算属性替换</p>
</blockquote>
<h2 id="是否支持多根节点"><a href="#是否支持多根节点" class="headerlink" title="是否支持多根节点"></a>是否支持多根节点</h2><h2 id="2-x-1"><a href="#2-x-1" class="headerlink" title="2.x"></a>2.x</h2><blockquote>
<p>不支持多根节点</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span>...<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">main</span>&gt;</span>...<span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span>...<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-x-2"><a href="#3-x-2" class="headerlink" title="3.x"></a>3.x</h3><blockquote>
<p>支持多根节点。必要明确定义属性的分布</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span>...<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span>...<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="v-if-与-v-for-的优先级"><a href="#v-if-与-v-for-的优先级" class="headerlink" title="v-if 与 v-for 的优先级"></a><code>v-if</code> 与 <code>v-for</code> 的优先级</h2><h3 id="2-x-2"><a href="#2-x-2" class="headerlink" title="2.x"></a>2.x</h3><blockquote>
<p>在一个元素上同时使用这两个指令，<code>v-for</code>优先级最高</p>
</blockquote>
<h3 id="3-x-3"><a href="#3-x-3" class="headerlink" title="3.x"></a>3.x</h3><blockquote>
<p>在一个元素上同时使用这两个指令，<code>v-if</code>优先级最高</p>
</blockquote>
<h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><h3 id="2-x-3"><a href="#2-x-3" class="headerlink" title="2.x"></a>2.x</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">    person: &#123;</span><br><span class="line">      <span class="function"><span class="title">handler</span>(<span class="params">newVal,oldVal</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      &#125;,</span><br><span class="line">      deep: <span class="literal">true</span>,</span><br><span class="line">      immediate: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-x-4"><a href="#3-x-4" class="headerlink" title="3.x"></a>3.x</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>count is: &#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; watch, ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> count = ref(<span class="number">0</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> isShow = ref(<span class="literal">true</span>);</span></span><br><span class="line">      watch(</span><br><span class="line">        [count, isShow],</span><br><span class="line">        ([newCount, newIsShow], [oldCount, oldIsShow]) =&gt; &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(newCount, newIsShow);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(oldCount, oldIsShow);</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line"><span class="javascript">          deep: <span class="literal">true</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line">        count,</span><br><span class="line">        isShow</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数说明 <code>watch(source, callback, [options])</code></p>
</blockquote>
<ul>
<li>source - 指定监听的响应式变量 【支持<code>string, object, array, function</code>】</li>
<li>callback - 执行的回调函数</li>
<li>options - 支持 deep、immediate 和 flush 选项</li>
</ul>
<h4 id="3-x-新增watchEffect"><a href="#3-x-新增watchEffect" class="headerlink" title="3.x 新增watchEffect"></a>3.x 新增<code>watchEffect</code></h4><p><code>watchEffect</code>回传入一个函数，然后立即执行这个函数，并在更改依赖时重新运行他</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>count is: &#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; watchEffect, ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> count = ref(<span class="number">0</span>);</span></span><br><span class="line"><span class="javascript">      watchEffect(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(count.value);</span></span><br><span class="line">      &#125;);</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line">        count</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>停止执行</strong></p>
</blockquote>
<ul>
<li>2.x 中<code>$watch</code>会在调用的时候返回一个函数，执行这个函数可以停止 <code>watch</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> unwatch = <span class="built_in">this</span>.$watch(<span class="string">&quot;count&quot;</span>, <span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="comment">// 两秒后停止监听</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  unwatch();</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>在 3.x 中<code>watch</code>和<code>watchEffect</code>同样也会返回一个 unwatch 函数，用于取消执行</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> count = ref(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> unwatch = watchEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 仅仅输出0</span></span><br><span class="line">      <span class="built_in">console</span>.log(count.value);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      count.value = <span class="number">2</span>;</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">    <span class="comment">// 1秒后取消watch，所以上面的代码只会输出0</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      unwatch();</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><h3 id="2-x-4"><a href="#2-x-4" class="headerlink" title="2.x"></a>2.x</h3><p>在 2.x 中<code>&lt;template&gt;</code>标记中不能包含 key，只能将<code>key</code>放到子元素中</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-x-5"><a href="#3-x-5" class="headerlink" title="3.x"></a>3.x</h3><p>在 3.x 中，<code>key</code> 值应该放置到<code>&lt;template&gt;</code>标签上</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="数据建立-data"><a href="#数据建立-data" class="headerlink" title="数据建立 data"></a>数据建立 data</h2><h3 id="2-x-5"><a href="#2-x-5" class="headerlink" title="2.x"></a>2.x</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    strProp: <span class="built_in">String</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      value1: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      value2: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-x-6"><a href="#3-x-6" class="headerlink" title="3.x"></a>3.x</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    strProp: <span class="built_in">String</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params">props, &#123; emit, attrs, slot &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">      value1: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      value2: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; state &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>setup(props, context)</p>
</blockquote>
<ul>
<li>props - 组件传入到属性</li>
<li>context - 包含三个属性【<code>&#123;emit, attrs. slot&#125;</code>】</li>
</ul>
<blockquote>
<p><code>setup</code>中接受的 props 是响应式的，当传入新的 props 时，会被及时更新，由于是响应式的，所以不可以使用 ES6 解构，解决办法就是使用 toRefs。</p>
</blockquote>
<ul>
<li><p><code>toRef</code> 就是把不是响应式的对象转化为响应式</p>
</li>
<li><p><code>toRefs</code> 用于将一个<code>reactive</code>对象转化为属性全部为<code>ref</code>对象的普通对象</p>
</li>
<li><p><code>Ref</code> 接受一个内部值并返回一个响应式且可变的<code>ref</code>对象, <code>ref</code>对象具有片指向内部值的单个 <code>property.value</code></p>
</li>
<li><p><code>reactive</code> 返回对象的响应式副本</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> obj = ref(&#123;<span class="attr">count</span>:<span class="number">1</span>, <span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>&#125;);<span class="comment">//ref处理对象</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">      obj.value.count = obj.value.count + <span class="number">1</span>;</span><br><span class="line">      obj.value.name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">return</span>&#123;obj&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> year = ref(<span class="number">0</span>);<span class="comment">//ref处理基础类型</span></span><br><span class="line">  <span class="keyword">const</span> user = reactive(&#123; <span class="attr">nickname</span>: <span class="string">&quot;xiaofan&quot;</span>, <span class="attr">age</span>: <span class="number">26</span>, <span class="attr">gender</span>: <span class="string">&quot;女&quot;</span> &#125;);<span class="comment">//reactive处理对象</span></span><br><span class="line">  <span class="keyword">return</span> &#123;year,user&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用toRefs</span></span><br><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> year = ref(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> user = reactive(&#123; <span class="attr">nickname</span>: <span class="string">&quot;xiaofan&quot;</span>, <span class="attr">age</span>: <span class="number">26</span>, <span class="attr">gender</span>: <span class="string">&quot;女&quot;</span> &#125;);</span><br><span class="line">  <span class="keyword">return</span> &#123;year,...toRefs(user)&#125;;<span class="comment">//使用toRefs处理reactive对象为 ref 对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="2-x-6"><a href="#2-x-6" class="headerlink" title="2.x"></a>2.x</h3><ul>
<li><code>beforeCreate</code></li>
<li><code>created</code></li>
<li><code>beforeMount</code></li>
<li><code>mounted</code></li>
<li><code>beforeUpdate</code></li>
<li><code>updated</code></li>
<li><code>beforeUnmount</code></li>
<li><code>unmounted</code></li>
<li><code>errorCaptured</code></li>
<li><code>renderTracked</code></li>
<li><code>renderTriggered</code></li>
</ul>
<h2 id="3-x-7"><a href="#3-x-7" class="headerlink" title="3.x"></a>3.x</h2><p>在<code>setup()</code>内部调用生命周期钩子函数</p>
<blockquote>
<p>因为<code>setup</code>是围绕<code>beforeCreate</code>和 <code>Created</code>生命周期钩子运行的，所以不需要显示的定义他们</p>
</blockquote>
<ul>
<li><code>onBeforeMount</code> - 【替换 <code>beforeMount</code>】</li>
<li><code>onMounted</code> - 【替换 <code>mounted</code>】</li>
<li><code>onBeforeUpdate</code> - 【替换 <code>beforeUpdate</code>】</li>
<li><code>onUpdated</code> - 【替换 <code>updated</code>】</li>
<li><code>onBeforeUnmount</code> - 【替换 <code>beforeUnmount</code>】</li>
<li><code>onUnmounted</code> - 【替换 <code>unmounted</code>】</li>
<li><code>onErrorCaptured</code> - 【替换 <code>errorCaptured</code>】</li>
<li><code>onRenderTracked</code> - 【替换 <code>renderTracked</code>】</li>
<li><code>onRenderTriggered</code> - 【替换 <code>renderTriggered</code>】</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  onMounted(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;mounted!&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  onUpdated(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;updated!&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  onUnmounted(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;unmounted!&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>vue</tag>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>🤑Hooks进阶-03🤑</title>
    <url>/2021/04/20/useCallback+useMemo+memo/</url>
    <content><![CDATA[<h1 id="😲useCallback-useMemo-memo性能优化场景使用😲"><a href="#😲useCallback-useMemo-memo性能优化场景使用😲" class="headerlink" title="😲useCallback+useMemo+memo性能优化场景使用😲"></a>😲useCallback+useMemo+memo性能优化场景使用😲</h1><blockquote>
<p><strong>转载： <a class="link"   href="https://blog.csdn.net/weixin_43902189/article/details/99689963" >https://blog.csdn.net/weixin_43902189/article/details/99689963<i class="fas fa-external-link-alt"></i></a></strong></p>
</blockquote>
<p><strong>当父组件引入子组件的情况下，往往会照成一些不必要的性能浪费，下面我们通过例子了解一下啊</strong></p>
<blockquote>
<p>创建一个test.tsx文件</p>
</blockquote>
<pre><code>import React, &#123; useState &#125; from &#39;react&#39;;
function Test() &#123;
    const [count, setCount] = useState&lt;number&gt;(100);
    return (
        &lt;&gt;
            &lt;h2&gt;&#123;count&#125;&lt;/h2&gt;
            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;++&lt;/button&gt;
            &lt;TestChild/&gt;
        &lt;/&gt;
    )
&#125;
export default Test;
//创建一个子组件
function TestChild(): JSX.Element &#123;
    console.log(&#39;TestChild运行了?&#39;);
    return(
        &lt;h3&gt;我是子组件&lt;/h3&gt;
    );
&#125;
</code></pre>
<blockquote>
<p><strong>这时我们开启服务运行一下这个小案例,会发现，我们的子组件并没有对应的需要更新的操作但是还是触发了，这时候我们需要使用React的memo来优化一下代码</strong></p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/hooks0.png"
                     
                ></p>
<h2 id="🤓使用memo优化react性能🤓"><a href="#🤓使用memo优化react性能🤓" class="headerlink" title="🤓使用memo优化react性能🤓"></a>🤓使用memo优化react性能🤓</h2><pre><code>import React, &#123; useState,memo &#125; from &#39;react&#39;;
//在TestChild子组件使用之前，使用memo包裹一下
const MemoTestChild = memo(TestChild);//对子组件进行处理
function Test() &#123;
    const [count, setCount] = useState&lt;number&gt;(100);
    return (
        &lt;&gt;
            &lt;h2&gt;&#123;count&#125;&lt;/h2&gt;
            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;++&lt;/button&gt;
            &#123;/* 引入子组件 */&#125;
            &#123;/* &lt;TestChild/&gt; */&#125;
            &lt;MemoTestChild/&gt;
        &lt;/&gt;
    )
&#125;
export default Test;
//创建一个子组件
function TestChild(): JSX.Element &#123;
    console.log(&#39;TestChild运行了?&#39;);
    return(
        &lt;h3&gt;我是子组件&lt;/h3&gt;
    );
&#125;
</code></pre>
<blockquote>
<p>我们在看一下，会不会产生上述的问题</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/hooks1.png"
                     
                ></p>
<p><strong>从上面可以看出，除了初始化的执行之外，这时候父组件发生状态的改变，子组件不会发生对应的重新执行，优化了代码的性能，个人建议多使用这些性能优化的函数,以提高性能</strong></p>
<blockquote>
<p><strong>通俗的说： 场景 : 在子组件不需要父组件的值和函数的情况下，来使用</strong></p>
</blockquote>
<hr>
<p><strong>我们再看一个父组件传值传函数的例子(相同的例子改造)</strong></p>
<pre><code>import React, &#123; useState, memo &#125; from &#39;react&#39;;
//memo性能优化后的子组件
const MemoTestChild = memo(TestChild);
function Test(): JSX.Element &#123;
    const [count, setCount] = useState&lt;number&gt;(100);
    const [name, setName] = useState&lt;string&gt;(&#39;TestChild组件&#39;);
    return (
        &lt;&gt;
            &lt;h2&gt;&#123;count&#125;&lt;/h2&gt;
            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;++&lt;/button&gt;
            &#123;/* 引入子组件 */&#125;
            &#123;/* &lt;TestChild/&gt;       把父组件的状态和设置状态的函数传递给子组件     */&#125;   
            &lt;MemoTestChild name=&#123;name&#125; onClick=&#123;(newName: string) =&gt; setName(newName)&#125; /&gt;
        &lt;/&gt;
    )
&#125;
export default Test;

//子组件部分
interface TestChildPropsType &#123;
    name: string;
    onClick: Function;
&#125;
function TestChild(&#123; name,onClick &#125;: TestChildPropsType): JSX.Element &#123;
    console.log(&#39;TestChild运行了?&#39;);
    return (
        &lt;&gt;
            &lt;h3&gt;我是子组件,这是父组件传递过来的数据:&#123;name&#125;&lt;/h3&gt;
            &lt;button onClick=&#123;onClick.bind(null,&#39;新的子组件name&#39;)&#125;&gt;改变name&lt;/button&gt;
        &lt;/&gt;
    );
&#125;
</code></pre>
<blockquote>
<p>这是传递给子组件一个新的状态，然后我们看看点击父组件后的情况</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/hooks2.png"
                     
                ></p>
<p><strong>我们从图中可以看出，子组件有执行了多次，这时我们就要使用useCallback / useMemo来解决这个问题</strong></p>
<h2 id="🤧useCallback🤧"><a href="#🤧useCallback🤧" class="headerlink" title="🤧useCallback🤧"></a>🤧useCallback🤧</h2><blockquote>
<p>useCallback有两个参数，【 参数是一个回调，参数二是一个依赖数组 】，使用：把内联的回调函数以及依赖项数组作为u参数传递到useCallback，他将返回函数的memeized版本，该回调仅在某个依赖项改变时才会更新，当你把回调函数传递给经过优化的，避免非必要渲染的子组件时，他将非常有用</p>
</blockquote>
<p>**这时我们在对上述代码进行优化【 加入useCallback 】</p>
<pre><code>import React, &#123; useState, memo, useCallback &#125; from &#39;react&#39;;
//memo性能优化后的子组件
const MemoTestChild = memo(TestChild);
function Test(): JSX.Element &#123;
    const [count, setCount] = useState&lt;number&gt;(100);
    const [name, setName] = useState&lt;string&gt;(&#39;TestChild组件&#39;);
    return (
        &lt;&gt;
            &lt;h2&gt;&#123;count&#125;&lt;/h2&gt;
            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;++&lt;/button&gt;
            &#123;/* 引入子组件 */&#125;
            &#123;/* &lt;TestChild/&gt;       把父组件的状态和设置状态的函数传递给子组件     */&#125;
            &lt;MemoTestChild name=&#123;name&#125; onClick=&#123;useCallback((newName: string) =&gt; setName(newName),[])&#125; /&gt;
            &#123;/* useCallback((newName: string) =&gt; setName(newName),[]) */&#125;
            &#123;/* 这里使用了useCallback优化了传递给子组件的函数，只初始化一次这个函数，下次不产生新的函数 */&#125;
        &lt;/&gt;
    )
&#125;
export default Test;

//子组件部分
interface TestChildPropsType &#123;
    name: string;
    onClick: Function;
&#125;
function TestChild(&#123; name, onClick &#125;: TestChildPropsType): JSX.Element &#123;
    console.log(&#39;TestChild运行了?&#39;);
    return (
        &lt;&gt;
            &lt;h3&gt;我是子组件,这是父组件传递过来的数据:&#123;name&#125;&lt;/h3&gt;
            &lt;button onClick=&#123;onClick.bind(null, &#39;新的子组件name&#39;)&#125;&gt;改变name&lt;/button&gt;
        &lt;/&gt;
    );
&#125;
</code></pre>
<blockquote>
<p>这时候我们看见子组件不会在父组件与子组件无关状态改变的时候执行，不会一直产生重新产生新函数,useCallback第二个参数，是依赖项，可以确定在什么状态改变的情况下产生一个新的回调函数</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/hooks3.png"
                     
                ></p>
<blockquote>
<p><strong>通俗的说： 场景： 在使用值和函数的情况下，需要考虑有没有函数传递给子组件</strong></p>
</blockquote>
<p><strong>我们上面提到的useMemo，好奇他在什么场景下使用</strong></p>
<blockquote>
<p>我们继续改造一下这个案例，把name改成一个对象</p>
</blockquote>
<pre><code>import React, &#123; useState, memo, useCallback &#125; from &#39;react&#39;;
//memo性能优化后的子组件
const MemoTestChild = memo(TestChild);
function Test(): JSX.Element &#123;
    const [count, setCount] = useState&lt;number&gt;(100);
    const [name, setName] = useState&lt;string&gt;(&#39;TestChild组件&#39;);
    return (
        &lt;&gt;
            &lt;h2&gt;&#123;count&#125;&lt;/h2&gt;
            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;++&lt;/button&gt;
            &#123;/* 引入子组件 */&#125;
            &#123;/* &lt;TestChild/&gt;       把父组件的状态和设置状态的函数传递给子组件     */&#125;
            &lt;MemoTestChild
                name=&#123;&#123; name, color: name.indexOf('name') !== -1 ? 'red' : 'green' &#125;&#125;
                onClick=&#123;useCallback((newName: string) =&gt; setName(newName), [])&#125;
            /&gt;
            &#123;/* useCallback((newName: string) =&gt; setName(newName),[]) */&#125;
            &#123;/* 这里使用了useCallback优化了传递给子组件的函数，只初始化一次这个函数，下次不产生新的函数 */&#125;
        &lt;/&gt;
    )
&#125;
export default Test;

//子组件部分
interface TestChildPropsType &#123;
    name: &#123; name: string; color: string &#125;;
    onClick: Function;
&#125;
function TestChild(&#123; name, onClick &#125;: TestChildPropsType): JSX.Element &#123;
    console.log(&#39;TestChild运行了?&#39;);
    return (
        &lt;&gt;
            &lt;h3 style=&#123;&#123; color: name.color &#125;&#125;&gt;我是子组件,这是父组件传递过来的数据:&#123;name.name&#125;&lt;/h3&gt;
            &lt;button onClick=&#123;onClick.bind(null, &#39;新的子组件name&#39;)&#125;&gt;改变name&lt;/button&gt;
        &lt;/&gt;
    );
&#125;
</code></pre>
<p><strong>这时候我们会发现，子组件还是一样的执行了，在父组件更新其它状态的情况下，子组件的name对象属性会一直发生重新渲染改变，从而导致一直执行,这也是不必要的性能浪费</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/hooks4.png"
                     
                ></p>
<blockquote>
<p>这个时候我们就要使用useMemo来优化传递的子属性了</p>
</blockquote>
<pre><code>import React, &#123; useState, memo, useCallback, useMemo &#125; from &#39;react&#39;;
//memo性能优化后的子组件
const MemoTestChild = memo(TestChild);
function Test(): JSX.Element &#123;
    const [count, setCount] = useState&lt;number&gt;(100);
    const [name, setName] = useState&lt;string&gt;(&#39;TestChild组件&#39;);
    return (
        &lt;&gt;
            &lt;h2&gt;&#123;count&#125;&lt;/h2&gt;
            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;++&lt;/button&gt;
            &#123;/* 引入子组件 */&#125;
            &#123;/* &lt;TestChild/&gt;       把父组件的状态和设置状态的函数传递给子组件     */&#125;
            &lt;MemoTestChild
                // 使用useMemo，返回一个和原本一样的对象，第二个参数是依赖性，当name发生改变的时候，才产生一个新的对象
                name=&#123;useMemo(() =&gt; (&#123; name, color: name.indexOf(&#39;name&#39;) !== -1 ? &#39;red&#39; : &#39;green&#39; &#125;),[name])&#125;
                onClick=&#123;useCallback((newName: string) =&gt; setName(newName), [])&#125;
            /&gt;
            &#123;/* useCallback((newName: string) =&gt; setName(newName),[]) */&#125;
            &#123;/* 这里使用了useCallback优化了传递给子组件的函数，只初始化一次这个函数，下次不产生新的函数 */&#125;
        &lt;/&gt;
    )
&#125;
export default Test;

//子组件部分
interface TestChildPropsType &#123;
    name: &#123; name: string; color: string &#125;;
    onClick: Function;
&#125;
function TestChild(&#123; name, onClick &#125;: TestChildPropsType): JSX.Element &#123;
    console.log(&#39;TestChild运行了?&#39;);
    return (
        &lt;&gt;
            &lt;h3 style=&#123;&#123; color: name.color &#125;&#125;&gt;我是子组件,这是父组件传递过来的数据:&#123;name.name&#125;&lt;/h3&gt;
            &lt;button onClick=&#123;onClick.bind(null, &#39;新的子组件name&#39;)&#125;&gt;改变name&lt;/button&gt;
        &lt;/&gt;
    );
&#125;
</code></pre>
<blockquote>
<p><strong>通俗的说： 场景：子组件调用父组件传递的函数，来改变父组件传递给子组件的属性</strong></p>
</blockquote>
<p>**！因此我们因该在不同的场景下来使用这些hooks，而不是盲目的去使用</p>
]]></content>
      <tags>
        <tag>hooks</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>💪🏼Hooks进阶-04💪🏼</title>
    <url>/2021/04/20/useRef,useImperativeHandle%E5%92%8CforwardRef/</url>
    <content><![CDATA[<h1 id="💪🏼useRef-useImperativeHandle和forwardRef的结合使用💪🏼"><a href="#💪🏼useRef-useImperativeHandle和forwardRef的结合使用💪🏼" class="headerlink" title="💪🏼useRef,useImperativeHandle和forwardRef的结合使用💪🏼"></a>💪🏼useRef,useImperativeHandle和forwardRef的结合使用💪🏼</h1><blockquote>
<p><strong>转载： <a class="link"   href="https://blog.csdn.net/weixin_43902189/article/details/99694359" >https://blog.csdn.net/weixin_43902189/article/details/99694359<i class="fas fa-external-link-alt"></i></a></strong></p>
</blockquote>
<h2 id="👆🏻useRef👆🏻"><a href="#👆🏻useRef👆🏻" class="headerlink" title="👆🏻useRef👆🏻"></a>👆🏻useRef👆🏻</h2><blockquote>
<p>返回一个可变的ref对象，其.current属性被初始化为传入的参数【initialValue】，返回的ref对象在整个组件的生命周期内保持不变*</p>
</blockquote>
<h2 id="🤞forwardRef🤞"><a href="#🤞forwardRef🤞" class="headerlink" title="🤞forwardRef🤞"></a>🤞forwardRef🤞</h2><blockquote>
<p>引用父组件的热风实例，成为i子组件的一个参数，可以引用父组件的ref绑定到子组件自身的节点上</p>
</blockquote>
<h2 id="🤘useImperativeHandle🤘"><a href="#🤘useImperativeHandle🤘" class="headerlink" title="🤘useImperativeHandle🤘"></a>🤘useImperativeHandle🤘</h2><blockquote>
<p>第一个参数，接收一个通过forwardRef引用父组件的ref实例，第二个参数一个回调函数，返回一个对象，对象里面存储需要暴露给父组件的属性和方法</p>
</blockquote>
<p><strong>useImperativeHandle和forwardRef的组合代码</strong></p>
<pre><code>//Test.tsx文件
import React, &#123; FC, Fragment, useRef, MutableRefObject, forwardRef, ForwardRefExoticComponent, Ref, useImperativeHandle, ChangeEvent, SyntheticEvent, memo &#125; from &quot;react&quot;;
const Test: FC = (): JSX.Element =&gt; &#123;
    const testRef: MutableRefObject&lt;any&gt; = useRef(&#39;test&#39;);
    const handleClick = (e:SyntheticEvent&lt;HTMLButtonElement&gt;):void =&gt;&#123;
        console.log(&#39;自身button的内容：&#39;,e.currentTarget.innerText);
        console.log(&#39;子组件input的对象:&#39;,testRef.current);
        console.log(&#39;子组件input的value值：&#39;,testRef.current.value);
        console.log(&#39;子组件input的类型：&#39;,testRef.current.type());
    &#125;
    return (
        &lt;Fragment&gt;
            &lt;TestChildForward ref=&#123;testRef&#125; /&gt;
            &lt;button onClick=&#123;handleClick&#125;&gt;获取子组件的input的value和type&lt;/button&gt;
        &lt;/Fragment&gt;
    );
&#125;
export default Test;
function TestChild(props:&#123;&#125;,ref: Ref&lt;any&gt;): JSX.Element &#123;
    const testRef: MutableRefObject&lt;any&gt; = useRef();//创建一个自身的ref，绑定到标签节点上
    //暴露出一个想要让父组件知道的对象,里面可以是属性也可以是函数
    useImperativeHandle(ref,()=&gt;&#123;//第一个参数，要暴露给哪个(ref)？第二个参数要暴露出什么？
        return &#123;
            //(testRef.current as HTMLInputElement) 类型断言，自己肯定就是这样的类型
            value:(testRef.current as HTMLInputElement).value,//暴露出input的value
            type:()=&gt;(testRef.current as HTMLInputElement).type//暴露出input的type类型
        &#125;
    &#125;);
    return (
        &lt;&gt;
            &lt;input type=&quot;text&quot; value=&#123;&#39;input的内容&#39;&#125; ref=&#123;testRef&#125; onChange=&#123;(e:ChangeEvent&lt;HTMLInputElement&gt;)=&gt;&#123;
                console.log(e.currentTarget.value);
                console.log(e.currentTarget.type);
            &#125;&#125;/&gt;
        &lt;/&gt;
    );
&#125;
const TestChildForward:ForwardRefExoticComponent&lt;any&gt; = memo(forwardRef(TestChild));
</code></pre>
<blockquote>
<p>执行·</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/hooks7.png"
                     
                ></p>
<blockquote>
<p>从上面的结果可以看到，当我们不想向父组件暴露太多的东西的时候，可以使用useImperativeHandle来按需暴露给父组件一些东西</p>
</blockquote>
<h1 id="🖐useLayoutEffect和useDebugValue的简单使用🖐"><a href="#🖐useLayoutEffect和useDebugValue的简单使用🖐" class="headerlink" title="🖐useLayoutEffect和useDebugValue的简单使用🖐"></a>🖐useLayoutEffect和useDebugValue的简单使用🖐</h1><h2 id="👌useLayouusetEffect👌"><a href="#👌useLayouusetEffect👌" class="headerlink" title="👌useLayouusetEffect👌"></a>👌useLayouusetEffect👌</h2><blockquote>
<p>该钩子与useEffect差不多相似，官方介绍，其签名函数与useEffect相同，但会在所有的Dom变更之后同步调用effect。可以使用他来读取dom布局并同步触发渲染，在浏览器执行绘制之前，useLayouusetEffect内部的更新计划将会同步刷新，尽可能的使用标准的useEffect以避免视觉阻塞</p>
</blockquote>
<p><strong>通俗来说：就是当你的所有dom变更后，同时执行所有的useEffect的时候来使用，可以用来读取dom，之后同步触发render ===========  emmmm…  ================ 反正很少用到。。。。。</strong></p>
<h2 id="👍useDebugValue👍"><a href="#👍useDebugValue👍" class="headerlink" title="👍useDebugValue👍"></a>👍useDebugValue👍</h2><blockquote>
<p>目的是能在react的浏览器调试工具上显示你自定义的hooks，或者给hooks标记一些东西，当使用一个参数的时候，就是把第一个参数标记在react的调试工具上</p>
</blockquote>
<pre><code>import React, &#123; useDebugValue, useState &#125; from &#39;react&#39;;

const useTest = () =&gt; &#123;
    const [str, setStr] = useState&lt;string&gt;(&#39;&#39;);
    useDebugValue(&#39;debug&#39;);
    return &#123;
        str, setStr
    &#125;
&#125;
export default (): JSX.Element =&gt; &#123;
    const &#123; str, setStr &#125; = useTest();
    return (
        &lt;&gt;
            &lt;h2&gt;&#123;str&#125;&lt;/h2&gt;
            &lt;button onClick=&#123;() =&gt; &#123;
                setStr(&#39;重新渲染&#39;);
            &#125;&#125;&gt;这是？？？&lt;/button&gt;
        &lt;/&gt;
    );
&#125;
</code></pre>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/hooks8.png"
                     
                ></p>
<p><strong>会在自定义的hooks标记到react的调试工具上面,主要用于调试工具调试使用</strong></p>
<blockquote>
<p>当传入第二个参数的情况下，第二个参数是一个回调函数，会把第一个参数当成自己的形参传入，进行一系列的操作，return回去，然后才会在react调试工具的hooks中打印出来，不然不会显示</p>
</blockquote>
<pre><code>import React, &#123; useDebugValue, useState &#125; from &#39;react&#39;;

const useTest = () =&gt; &#123;
    const [str, setStr] = useState&lt;string&gt;(&#39;&#39;);
    useDebugValue(str, (value:string) =&gt; &#123;
        console.log(value);
        return &#39;这是改造后的&#39; + value;
    &#125;);
    return &#123;
        str, setStr
    &#125;
&#125;
export default (): JSX.Element =&gt; &#123;
    const &#123; str, setStr &#125; = useTest();
    return (
        &lt;&gt;
            &lt;h2&gt;&#123;str&#125;&lt;/h2&gt;
            &lt;button onClick=&#123;() =&gt; &#123;
                setStr(&#39;重新渲染&#39;);
            &#125;&#125;&gt;这是？？？&lt;/button&gt;
        &lt;/&gt;
    );
&#125;
</code></pre>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/hooks9.png"
                     
                ></p>
<p><strong>同时在控制台上打印了一个空字符</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/hooks10.png"
                     
                ></p>
<blockquote>
<p>由于str的初始值是空的，所以打印就是空的了，这只是调试使用</p>
</blockquote>
]]></content>
      <tags>
        <tag>hooks</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>😁Hooks进阶-01😁</title>
    <url>/2021/04/20/useState+useEffect/</url>
    <content><![CDATA[<h1 id="😁hooks的useState、useEffect的实际使用😁"><a href="#😁hooks的useState、useEffect的实际使用😁" class="headerlink" title="😁hooks的useState、useEffect的实际使用😁"></a>😁hooks的useState、useEffect的实际使用😁</h1><blockquote>
<p><strong>转载：<a class="link"   href="https://blog.csdn.net/weixin_43902189/article/details/99689186" >https://blog.csdn.net/weixin_43902189/article/details/99689186<i class="fas fa-external-link-alt"></i></a></strong></p>
</blockquote>
<p><strong>！注意：hooks只能在函数怕【无状态组件】中使用</strong></p>
<h2 id="🤣useState🤣"><a href="#🤣useState🤣" class="headerlink" title="🤣useState🤣"></a>🤣useState🤣</h2><blockquote>
<p>官方文档表明出，这个钩子就是在函数中能使用像class中使用state一样的状态管理，使用方式也比较简单</p>
</blockquote>
<pre><code>import React, &#123; useState &#125; from &#39;react&#39;;
export default (): JSX.Element =&gt; &#123;
    // 在typescript中，useState是一个泛型函数，可以传入对应的类型
    const [count, setCount] = useState&lt;number&gt;(100);
    return (
        &lt;&gt;
            &lt;h2&gt;&#123;count&#125;&lt;/h2&gt;
            &lt;button onClick=&#123;()=&gt;setCount(count + 1)&#125;&gt;++&lt;/button&gt;
            &#123;/*   还可以传入回调函数 */&#125;
            &lt;button onClick=&#123;()=&gt;setCount((count:number)=&gt;(count - 1))&#125;&gt;--&lt;/button&gt;
        &lt;/&gt;
    )
&#125;
</code></pre>
<p><strong>由于useState返回一个数组，第一个count参数就与有状态组件(类)中的state很相似，是无法改变的值，而第二个参数setCount就与有状态组件的setState差不多，较为简单</strong></p>
<h2 id="😄useEffect😄"><a href="#😄useEffect😄" class="headerlink" title="😄useEffect😄"></a>😄useEffect😄</h2><blockquote>
<p>useEffect 一个相当于，状态组件中componentDidMount + componentDidUpdate + componentWillUnmount三个钩子函数的结合体 ，如果不清楚的可以看 React有状态组件生命周期的官方中文介绍</p>
</blockquote>
<p><strong>通过useEffect+useState配合发送请求，获取数据</strong></p>
<pre><code>import React, &#123; useEffect, useState &#125; from &#39;react&#39;;
const useDate = (initialDate: String)=&gt; &#123;//初始化时间
    // 创建一个字符串state,存储当前系统时间
    const [date, setDate] = useState&lt;string&gt;();
    useEffect(() =&gt; &#123;// 使用useEffect，当date数据改变时，触发useEffect
        const times: NodeJS.Timeout = setInterval(() =&gt; setDate(Date.now().toLocaleString()), 1000);
        return ()=&gt; &#123;
            // 这里的return返回的应该函数和componentWillUnmount差不多一致，在组件销毁前执行,防止定时器没有销毁
            clearInterval(times);// 退出的时候清除定时器
        &#125;
    &#125;, [date]);// 第二个参数中的数组，就是依赖项，会相当于有状态组件的componentWillReceiveProps,每次执行useEffect前会对date进行一次浅比较
    return &#123; date &#125;;// 由于外部只需要使用date，可以只暴露出这个数据
&#125;

export default (): JSX.Element =&gt; &#123;
    const &#123; date &#125; = useDate(Date.now().toLocaleString());//使用自定义钩子，获取返回的对象
    return(
        &lt;&gt;
            &lt;h2&gt;当前时间&lt;/h2&gt;
            &lt;p&gt;&#123;date&#125;&lt;/p&gt;
        &lt;/&gt;
    );
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>hooks</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>🌍Hooks进阶-02🌍</title>
    <url>/2021/04/20/seReducer+useContext+createContext/</url>
    <content><![CDATA[<h1 id="🌈useReducer-useContext-createContext的使用、模拟redux合并reducer🌈"><a href="#🌈useReducer-useContext-createContext的使用、模拟redux合并reducer🌈" class="headerlink" title="🌈useReducer+useContext+createContext的使用、模拟redux合并reducer🌈"></a>🌈useReducer+useContext+createContext的使用、模拟redux合并reducer🌈</h1><blockquote>
<p><strong>转载： <a class="link"   href="https://blog.csdn.net/weixin_43902189/article/details/99690873" >https://blog.csdn.net/weixin_43902189/article/details/99690873<i class="fas fa-external-link-alt"></i></a></strong></p>
</blockquote>
<h2 id="✨createContext✨"><a href="#✨createContext✨" class="headerlink" title="✨createContext✨"></a>✨createContext✨</h2><blockquote>
<p>一个创建上下文函数，执行产生一个上下文对象，包含两个属性【 Provider组件和Consumer组件 】</p>
</blockquote>
<h3 id="🎍Provider🎍"><a href="#🎍Provider🎍" class="headerlink" title="🎍Provider🎍"></a>🎍Provider🎍</h3><blockquote>
<p>用来包裹整合组件，传递一个value属性，把context上下文注到整个组件当中</p>
</blockquote>
<h3 id="❄Consumer❄"><a href="#❄Consumer❄" class="headerlink" title="❄Consumer❄"></a>❄Consumer❄</h3><blockquote>
<p>在里面使用函数调用Provider的value传递的值成形参，并取出使用</p>
</blockquote>
<hr>
<p><a class="link"   href="https://zh-hans.reactjs.org/docs/hooks-reference.html" >useReducer和useContext官方直通车<i class="fas fa-external-link-alt"></i></a></p>
<hr>
<h2 id="⚡useReducer-useContext-createContext的简单使用-创建一个Test-tsx文件⚡"><a href="#⚡useReducer-useContext-createContext的简单使用-创建一个Test-tsx文件⚡" class="headerlink" title="⚡useReducer+useContext+createContext的简单使用,创建一个Test.tsx文件⚡"></a>⚡useReducer+useContext+createContext的简单使用,创建一个Test.tsx文件⚡</h2><pre><code>import React, &#123; useReducer, useContext, createContext, Context &#125; from &#39;react&#39;;
//初始化stroe的类型、初始化值、reducer
const ADD_COUNTER = &#39;ADD_COUNTER&#39;;
const initialReucer = &#123;
    count: 100
&#125;
function reducer(state: typeof initialReucer, action: &#123; type: typeof ADD_COUNTER &#125;) &#123;
    switch (action.type) &#123;
        case ADD_COUNTER:
            return &#123; ...state, count: state.count + 1 &#125;
        default:
            return state;
    &#125;
&#125;
const ProviderContext: Context&lt;any&gt; = createContext(&#39;provider&#39;);//创建上下文实例
//高阶组件，给函数组件注入上下文
const providerHoc = (reducer: Function, initialState: any) =&gt; (Com: React.FC&lt;any&gt;) =&gt; &#123;
    return () =&gt; &#123;
        const [state, dispatch] = useReducer&lt;any&gt;(reducer, initialState);
        return (
            &lt;ProviderContext.Provider value=&#123;&#123; state, dispatch &#125;&#125;&gt;
                &lt;Com /&gt;
            &lt;/ProviderContext.Provider &gt;
        );
    &#125;
&#125;
function Test(): JSX.Element &#123;
    const &#123; state, dispatch &#125; = useContext(ProviderContext);//通过ProviderContext这个上下文实例获取到value，解构出
    console.log(state);
    return (
        &lt;&gt;
            &lt;h2&gt;&#123;state.count&#125;&lt;/h2&gt;
            &#123;/*使用dispatch分发action，触发reducer返回新的state*/&#125;
            &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: ADD_COUNTER &#125;)&#125;&gt;++&lt;/button&gt;
        &lt;/&gt;
    );
&#125;
export default providerHoc(reducer, initialReucer)(Test);
// 注入reducer,initialReucer到Test组件中，通过高阶组件对Test组件进行包裹注入
</code></pre>
<blockquote>
<p>效果：==</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/hooks5.png"
                     
                ></p>
<blockquote>
<p><strong>我们会发现，这样的使用和redux的同步action的情况是一致的，这时候我们可以模拟异步action发送请求获得数据</strong></p>
</blockquote>
<p><strong>抽离reducer，, providerHoc, reducer, initialReucer，ADD_COUNTER到store.tsx文件</strong></p>
<pre><code>//stroe.tsx
import React, &#123; useReducer, createContext, Context &#125; from &#39;react&#39;;
const ADD_COUNTER = &#39;ADD_COUNTER&#39;;//action-type的类型

export const addActions =()=&gt; (&#123; type: ADD_COUNTER &#125;);//创建一个同步action

export const initialReucer = &#123;//初始化的state
    count: 100
&#125;                    //    state的类型,action的类型
export function reducer(state: typeof initialReucer, action: &#123; type: typeof ADD_COUNTER &#125;) &#123;
    switch (action.type) &#123;
        case ADD_COUNTER:
            return &#123; ...state, count: state.count + 1 &#125;
        default:
            return state;
    &#125;
&#125;
export const ProviderContext: Context&lt;any&gt; = createContext(&#39;provider&#39;);//创建上下文实例
//高阶组件，给函数组件注入上下文
export const providerHoc = (reducer: Function, initialState: any) =&gt; (Com: React.FC&lt;any&gt;) =&gt; &#123;
    return () =&gt; &#123;
        const [state, dispatch] = useReducer&lt;any&gt;(reducer, initialState);
        return (
            &lt;ProviderContext.Provider value=&#123;&#123; state, dispatch &#125;&#125;&gt;
                &lt;Com /&gt;
            &lt;/ProviderContext.Provider &gt;
        );
    &#125;
&#125;
</code></pre>
<blockquote>
<p>test.tsx文件</p>
</blockquote>
<pre><code>import React, &#123; useContext &#125; from &#39;react&#39;;
import &#123; ProviderContext, addActions, providerHoc, reducer, initialReucer &#125; from &#39;./store&#39;;
function Test(): JSX.Element &#123;
    const &#123; state, dispatch &#125; = useContext(ProviderContext);//通过ProviderContext这个上下文实例获取到value，解构出
    console.log(state);
    return (
        &lt;&gt;
            &lt;h2&gt;&#123;state.count&#125;&lt;/h2&gt;
            &lt;button onClick=&#123;() =&gt; dispatch(addActions())&#125;&gt;++&lt;/button&gt;
        &lt;/&gt;
    );
&#125;
export default providerHoc(reducer, initialReucer)(Test);
// 注入reducer,initialReucer到Test组件中，通过高阶组件对Test组件进行包裹注入
</code></pre>
<blockquote>
<p>这时我们只是将组件抽离出来，执行结果还是和以前一样======我们要对代码进行改造~  ~  ~ ~  ~    ~</p>
</blockquote>
<blockquote>
<p>store.ts</p>
</blockquote>
<pre><code>import React, &#123; useReducer, createContext, Context, Dispatch &#125; from &#39;react&#39;;
const ADD_COUNTER = &#39;ADD_COUNTER&#39;;

const addActions = () =&gt; (&#123; type: ADD_COUNTER &#125;);//创建一个同步action
// 创建一个异步action的函数，返回一个action对象
const asyncAction = (dispatch: Dispatch&lt;any&gt;) =&gt; &#123;
    return &#123;
        asyncAddaction() &#123;//这是一个异步的添加action,定时器模拟异步
            console.log(&#39;执行addActions之前,发送请求 : &#39; + Date.now());//打印一下时间
            setTimeout(() =&gt; &#123;
                console.log(&#39;执行addActions ,请求后: &#39; + Date.now());
                dispatch(addActions());//执行同步action
            &#125;, 1000);
        &#125;
    &#125;
&#125;
export const initialReucer = &#123;
    count: 100
&#125;
export function reducer(state: typeof initialReucer, action: &#123; type: typeof ADD_COUNTER &#125;) &#123;
    switch (action.type) &#123;
        case ADD_COUNTER:
            return &#123; ...state, count: state.count + 1 &#125;
        default:
            return state;
    &#125;
&#125;
export const ProviderContext: Context&lt;any&gt; = createContext(&#39;provider&#39;);//创建上下文实例
//高阶组件，给函数组件注入上下文
export const providerHoc = (reducer: Function, initialState: any) =&gt; (Com: React.FC&lt;any&gt;) =&gt; &#123;
    return () =&gt; &#123;
        const [state, dispatch] = useReducer&lt;any&gt;(reducer, initialState);
        const asyncActions: any = asyncAction(dispatch);//对dispatch进行注入包裹,然后返回
        return (
            &lt;ProviderContext.Provider value=&#123;&#123; state, asyncActions &#125;&#125;&gt;
                &lt;Com /&gt;
            &lt;/ProviderContext.Provider &gt;
        );
    &#125;
&#125;
</code></pre>
<blockquote>
<p>test.tsx如下</p>
</blockquote>
<pre><code>import React, &#123; useContext &#125; from &#39;react&#39;;
import &#123; ProviderContext, providerHoc, reducer, initialReucer &#125; from &#39;./store&#39;;
function Test(): JSX.Element &#123;
    const &#123; state, asyncActions &#125; = useContext(ProviderContext);//通过ProviderContext这个上下文实例获取到value，解构出
    const &#123; asyncAddaction &#125; = asyncActions;//取出asyncAddaction
    console.log(state);
    return (
        &lt;&gt;
            &lt;h2&gt;&#123;state.count&#125;&lt;/h2&gt;
            &lt;button onClick=&#123;() =&gt; asyncAddaction()&#125;&gt;++&lt;/button&gt;
        &lt;/&gt;
    );
&#125;
export default providerHoc(reducer, initialReucer)(Test);
//注入reducer,initialReucer到Test组件中，通过高阶组件对Test组件进行包裹注入
</code></pre>
<blockquote>
<p>执行结果：=&gt;</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/hooks6.png"
                     
                ></p>
<hr>
<hr>
<hr>
<blockquote>
<p>目前这种useReducer+useContext+createContext的组合使用看起来有些凌乱。</p>
</blockquote>
<blockquote>
<p>推荐使用mobx全局状态管理</p>
</blockquote>
<blockquote>
<p>🌍<a class="link"   href="http://my.ignorantscholar.cn/2019/12/06/mobx/#more" >Mobx全局状态管理参考<i class="fas fa-external-link-alt"></i></a>🌍</p>
</blockquote>
<hr>
<hr>
<hr>
]]></content>
      <tags>
        <tag>hooks</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>👑Mobx.👑</title>
    <url>/2020/08/06/mobx/</url>
    <content><![CDATA[<h1 id="👑Mobx👑"><a href="#👑Mobx👑" class="headerlink" title="👑Mobx👑"></a>👑Mobx👑</h1><blockquote>
<p>简单的，可扩展的状态管理器</p>
</blockquote>
<h2 id="👀-如何使用使用-👀"><a href="#👀-如何使用使用-👀" class="headerlink" title="👀 如何使用使用 👀"></a>👀 如何使用使用 👀</h2><pre><code>npm install mobx

npm install mobx-react
</code></pre>
<h2 id="👒-核心-API👒"><a href="#👒-核心-API👒" class="headerlink" title="👒 核心 API👒"></a>👒 核心 API👒</h2><h3 id="😻observable😻"><a href="#😻observable😻" class="headerlink" title="😻observable😻"></a>😻observable😻</h3><blockquote>
<p>使用</p>
</blockquote>
<pre><code>observable(value)
@observable classProperty = value
</code></pre>
<p><strong>observable 的值可以是 js 的基本类型，引用类型，普通对象，类实例，数组和映射，匹配类型应用转换规则：</strong></p>
<h4 id="🐢-observable🐢"><a href="#🐢-observable🐢" class="headerlink" title="🐢@observable🐢"></a>🐢@observable🐢</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; observer, inject &#125; <span class="keyword">from</span> <span class="string">&quot;mobx-react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Stores <span class="keyword">from</span> <span class="string">&quot;./store&quot;</span>;</span><br><span class="line">@inject(<span class="string">&quot;Pubcli&quot;</span>)</span><br><span class="line">@observer</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerStep</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>&lt;<span class="title">any</span>, <span class="title">any</span>&gt; </span>&#123;</span><br><span class="line">  Stores = Stores;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.props, <span class="string">&quot;Stores&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> &#123; changValue, total &#125; = <span class="built_in">this</span>.props.Pubcli;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;div&gt;&#123;total&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;button</span><br><span class="line">          onClick=&#123;<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            changValue();</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          change</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> IntegerStep;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable, configure, runInAction, action, computed &#125; <span class="keyword">from</span> <span class="string">&quot;mobx&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// configure(&#123; enforceActions: &#x27;always&#x27; &#125;) // 强制进行action</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pubcli</span> </span>&#123;</span><br><span class="line">  @observable price = <span class="number">1</span>;</span><br><span class="line">  changValue = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.price = <span class="built_in">this</span>.price + <span class="number">1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  @computed <span class="keyword">get</span> <span class="title">total</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.price * <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Pubcli();</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="🐍-规则：🐍"><a href="#🐍-规则：🐍" class="headerlink" title="🐍 规则：🐍"></a>🐍 规则：🐍</h4><ul>
<li><p>Map: 会返回一个新的 Observerable Map</p>
<p>observable.map(values, options?)</p>
</li>
</ul>
<hr>
<p><strong>创建一个动态键的 observerable 映射</strong></p>
<p><strong>下列 observable 映射所暴露的方法是依据 Es6 Map 规范</strong></p>
<blockquote>
<ul>
<li>has(key) : 返回映射是否有提供键对应的项</li>
<li>set(key, value) : 把定键的值设置为 value，提供的键如果不存在的话，那么他会被添加到映射中</li>
<li>delete(key) : 把给定键和它 的值从映射中删除</li>
<li>get(key) : 返回给定键的值（或 undefined）</li>
<li>keys() : 返回映射中所有存在的所有键的迭代器，插入顺序会被保留</li>
<li>value() : 返回映射中所有存在的所有值的迭代器，插入顺序会被保留</li>
<li>entries() : 返回一个（保留插入顺序）的数组迭代器，映射中的每个键值都会对应数组中的一项[key, value]</li>
<li>clean() : 移除映射中的所有项</li>
<li>size : 返回映射中项的数量</li>
</ul>
</blockquote>
<hr>
<ul>
<li>数组：会返回一个 Observerable Array</li>
</ul>
<hr>
<ul>
<li>没有原型的对象： 那么对象会被克隆并且所有属性都会被转成可观察的</li>
</ul>
<hr>
<ul>
<li>有原型的对象【javascript 原始数据类型或者函数】： 返回一个 Boxed Observerable</li>
</ul>
<h3 id="🌳-如何对-observable-做出响应-🌳"><a href="#🌳-如何对-observable-做出响应-🌳" class="headerlink" title="🌳 如何对 observable 做出响应 🌳"></a>🌳 如何对 observable 做出响应 🌳</h3><h4 id="🌲-computed-计算值-🌲"><a href="#🌲-computed-计算值-🌲" class="headerlink" title="🌲@computed 计算值 🌲"></a>🌲@computed 计算值 🌲</h4><blockquote>
<p>计算值是根据现有状态或其他计算值所衍生的值，计算是经过高度优化，因此在计算某些值的时候尽可能的使用它</p>
</blockquote>
<p><strong>计算值如何使用 observable 第一条以举出了例子</strong></p>
<ul>
<li>getter // 用来获取计算出的结果值</li>
</ul>
<hr>
<pre><code>get total() &#123;
    return this.price * this.amount
&#125;,
</code></pre>
<ul>
<li>setter // 不能直接改变值，但是可以做逆向衍生</li>
</ul>
<hr>
<pre><code>set total(total) &#123;
    this.price = total / this.amount // 从 total 中推导出 price
&#125;
</code></pre>
<h4 id="🍙autorun-自定义反应-🍙"><a href="#🍙autorun-自定义反应-🍙" class="headerlink" title="🍙autorun // 自定义反应 🍙"></a>🍙autorun // 自定义反应 🍙</h4><p><strong>适用于打印日志，持久化或更新 UI 代码，当使用 autorun 时，所提供的函数总时立即被触发，相比之下，computed 创建的函数只有当他有自己的观察者才会计算，否则认为他的值是不相关的</strong></p>
<pre><code>disposer = autorun(() =&gt; &#123;
    console.log(this.price)
&#125;);
</code></pre>
<h4 id="🎨when-自定义反应-🎨"><a href="#🎨when-自定义反应-🎨" class="headerlink" title="🎨when //自定义反应 🎨"></a>🎨when //自定义反应 🎨</h4><p><strong>when 观察值，当值满足条件的时，就会执行执行第二参数，when 需要写在 constructor 内，否者会被当做原生的 when 去执行</strong></p>
<pre><code>constructor () &#123;
    when(
        () =&gt; this.total &gt; 20,
        () =&gt; this.init()
    )
&#125;

@observable price = 1

@computed get total() &#123;
    return this.price * 10
&#125;

init() &#123;
    console.log(this.count++, &#39;否者&#39;)
&#125;
</code></pre>
<h4 id="👹reaction-autorun-的变种-👹"><a href="#👹reaction-autorun-的变种-👹" class="headerlink" title="👹reaction // autorun 的变种 👹"></a>👹reaction // autorun 的变种 👹</h4><p><strong>接受两个函数参数，第一个函数是根据可观察函数，数据变化后，返回的一个新值，该值作为第二个函数的参数</strong></p>
<pre><code>@observable todos = [
    &#123;
        title: &quot;Make coffee&quot;,
        done: true,
    &#125;,
    &#123;
        title: &quot;Find biscuit&quot;,
        done: false
    &#125;
]

reactions = reaction( // 当被观察的值改变时，执行
    () =&gt; this.todos.map(todo =&gt; todo.title),
    titles =&gt; console.log(&quot;reaction oy:&quot;, titles.join(&quot;, &quot;))
);

changValue = () =&gt; &#123;
    this.todos = [
        ...this.todos,
        &#123;
            title: &quot;Find biscuit&quot;,
            done: false
        &#125;
    ]
    this.price = this.price + 1
&#125;
</code></pre>
<h4 id="⌛-observer-mobx-react⌛"><a href="#⌛-observer-mobx-react⌛" class="headerlink" title="⌛@observer // mobx-react⌛"></a>⌛@observer // mobx-react⌛</h4><p><strong>observer 函数或装饰器可以将 react 组件转换成响应式组件，他用 mobx.autorun 包装了组件的 render 函数，以确保任何组件渲染的数据变化时都可以强制刷新组件，observer 是单独由 mobx-react 提供的</strong></p>
<pre><code>import &#123;observer, inject&#125; from &quot;mobx-react&quot;;
@inject(&#39;Pubcli&#39;)
@observer
class IntegerStep extends React.Component&lt;any, any&gt; &#123;
    render() &#123;
        console.log(this.props, &#39;Stores&#39;)
        let &#123; changValue, total &#125; = this.props.Pubcli
        return &lt;&gt;
            &lt;div&gt;&#123;total&#125;&lt;/div&gt;

            &lt;button onClick=&#123;() =&gt; &#123;
                changValue()
            &#125;&#125;&gt;change&lt;/button&gt;

        &lt;/&gt;
    &#125;
&#125;
export default IntegerStep
</code></pre>
<blockquote>
<p>无状态函数组件</p>
</blockquote>
<pre><code>import &#123;observer, inject&#125; from &quot;mobx-react&quot;;

const IntegerStep = inject(&#39;Pubcli&#39;)(observer((props) =&gt; &#123;
    let &#123; changValue, total &#125; = props.Pubcli
    console.log(props)
    return &lt;&gt;
        &lt;div&gt;&#123;total&#125;&lt;/div&gt;

        &lt;button onClick=&#123;() =&gt; &#123;
            changValue()
        &#125;&#125;&gt;change&lt;/button&gt;

    &lt;/&gt;
&#125;))
export default IntegerStep
</code></pre>
<blockquote>
<p>如上我们发现了 inject 这个函数【是将组件连接到提供的 store】</p>
</blockquote>
<ul>
<li>使用 Provider 注入 stores</li>
</ul>
<p><strong>mobx-react 提供了 Provider 组件，它使用了 react 的上下文（context）机制，可以用来向下传递 stores，要连接到这些 stores，需要传递一个 stores 名称给 inject，这使得 stores 可以做为组件得 props 使用</strong></p>
<p>上面有完整得例子 🔜⤴</p>
<blockquote>
<p>componentWillReact(生命周期钩子函数)</p>
</blockquote>
<p><strong>改变 react 组件有多种状态，这样我们很难知道，组件是通过什么改变来进行数据渲染，使用一个新得生命周期函数 componentWillReact，当组件因为他观察得数据发生改变时，这时候 componentWillReact 会被触发，从而找到渲染源</strong></p>
<pre><code>import &#123;observer, inject&#125; from &quot;mobx-react&quot;;
@inject(&#39;Pubcli&#39;)
@observer
class IntegerStep extends React.Component&lt;any, any&gt; &#123;

    componentWillReact() &#123;
        console.log(&quot;I will re-render, since the todo has changed!&quot;);
    &#125;
    render() &#123;
        console.log(this.props, &#39;Stores&#39;)
        let &#123; changValue, total &#125; = this.props.Pubcli
        return &lt;&gt;
            &lt;div&gt;&#123;total&#125;&lt;/div&gt;

            &lt;button onClick=&#123;() =&gt; &#123;
                changValue()
            &#125;&#125;&gt;change&lt;/button&gt;

        &lt;/&gt;
    &#125;
&#125;
export default IntegerStep
</code></pre>
<blockquote>
<ul>
<li>componentWillReac 不接受任何参数</li>
<li>componentWillReact 初始化渲染前不会触发</li>
</ul>
</blockquote>
<h3 id="🔗-改变-observables🔗"><a href="#🔗-改变-observables🔗" class="headerlink" title="🔗 改变 observables🔗"></a>🔗 改变 observables🔗</h3><h4 id="📙action-动作-📙"><a href="#📙action-动作-📙" class="headerlink" title="📙action (动作)📙"></a>📙action (动作)📙</h4><p><strong>任何应用都是有动作得，动作是用来修改状态得东西</strong></p>
<blockquote>
<p>action</p>
</blockquote>
<pre><code>import &#123; observable, action &#125; from &#39;mobx&#39;

class States &#123;

    @observable timer = null;
    @observable secend = 0;

    @action
    add = () =&gt; &#123;
        this.secend++
    &#125;
&#125;

export default new States()
</code></pre>
<blockquote>
<p>action.bound</p>
</blockquote>
<p><strong>action 装饰器/函数遵循 JavaScript 中标准得绑定规则，但是 action.bound 可以用来自动得将动作绑定到目标对象</strong></p>
<pre><code>import &#123; observable, action &#125; from &#39;mobx&#39;

class States &#123;

    @observable timer = null;
    @observable secend = 0;

    @action.bound
    add = () =&gt; &#123;
        this.secend++
    &#125;
&#125;

export default new States()
</code></pre>
<blockquote>
<p><strong>action.bound 不要和箭头函数一起使用；箭头函数已经是绑定过并且不能重复绑定</strong></p>
</blockquote>
<blockquote>
<p>runInAction</p>
</blockquote>
<p><strong>runInAction 是个简单得工具函数，他接受代码块并且（异步动作）中执行，这对即时创建和执行动作非常有用</strong></p>
<blockquote>
<p>runInAction(f) 是 action(f) 的语法糖</p>
</blockquote>
<pre><code>@observable showErrType = true
@observable money = 230

runInAction(() =&gt; &#123;
    this.showErrType = false
    this.money = 8888
&#125;)
</code></pre>
<blockquote>
<p>当然 runInAction 配合 async await 异步调用，会有更好的体验</p>
</blockquote>
<blockquote>
<p>flows</p>
</blockquote>
<p><strong>然而更好的方式是使用 flow 的内置概念，他们使用生成器，他们的工作原理和 async await 一样，他的优点是不需要手动用@action 来包装异步代码。这样代码更加简洁</strong></p>
<blockquote>
<p>flow 只能作为函数使用，不能作为装饰器使用</p>
</blockquote>
<pre><code>class Store &#123;
    @observable githubProjects = []
    @observable state = &quot;pending&quot;

    fetchProjects = flow(function * () &#123; // &lt;- 注意*号，这是生成器函数！
        this.githubProjects = []
        this.state = &quot;pending&quot;
        try &#123;
            const projects = yield fetchGithubProjectsSomehow() // 用 yield 代替 await
            const filteredProjects = somePreprocessing(projects)
            // 异步代码块会被自动包装成动作并修改状态
            this.state = &quot;done&quot;
            this.githubProjects = filteredProjects
        &#125; catch (error) &#123;
            this.state = &quot;error&quot;
        &#125;
    &#125;)
&#125;
</code></pre>
<h3 id="📢-工具函数-📢"><a href="#📢-工具函数-📢" class="headerlink" title="📢 工具函数 📢"></a>📢 工具函数 📢</h3><h4 id="🌀toJS🌀"><a href="#🌀toJS🌀" class="headerlink" title="🌀toJS🌀"></a>🌀toJS🌀</h4><p><strong>递归的将一个 observable 对象转换为 JavaScript 原始数据解构</strong></p>
<pre><code>var obj = mobx.observable(&#123;
    x: 1
&#125;);

var clone = mobx.toJS(obj);
</code></pre>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      <tags>
        <tag>js</tag>
        <tag>mobx</tag>
      </tags>
  </entry>
  <entry>
    <title>👮0.1+0.2 != 0.3??.👮</title>
    <url>/2020/08/06/duboule/</url>
    <content><![CDATA[<h1 id="👮0-1-0-2-0-3-👮"><a href="#👮0-1-0-2-0-3-👮" class="headerlink" title="👮0.1+0.2 != 0.3??👮"></a>👮0.1+0.2 != 0.3??👮</h1><blockquote>
<p>我们存储的数字在转化为2进制 的情况下有效数字大于52(#`O′)，就会出现精度丢失的问题</p>
</blockquote>
<pre><code>0.1【转化二进制】

0.0001100110011001100110011001100110011001100110011001101
</code></pre>
<hr>
<pre><code>0.2【转化二进制】

0.001100110011001100110011001100110011001100110011001101
</code></pre>
<hr>
<blockquote>
<p>js在存储的时候，超出52(#`O′)会被处理掉，所以设计js计算浮点数时会产生各种奇怪 的问题，因为你完全不知道，什么时候误差被省略了，什么时候误差刚好对上是正确结果</p>
</blockquote>
<h2 id="💄解决办法"><a href="#💄解决办法" class="headerlink" title="💄解决办法"></a>💄解决办法</h2><ul>
<li><p>使用toFixed去解决问题</p>
<p>  Number((0.1 + 0.2). toFixed(2)) === 0.3</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>🌑Flutter 页面导航及打包🌑</title>
    <url>/2019/10/12/Flutter_navigation/</url>
    <content><![CDATA[<h1 id="🌑Flutter-页面导航及打包🌑"><a href="#🌑Flutter-页面导航及打包🌑" class="headerlink" title="🌑Flutter 页面导航及打包🌑"></a>🌑Flutter 页面导航及打包🌑</h1><h2 id="🌓一般页面导航和返回"><a href="#🌓一般页面导航和返回" class="headerlink" title="🌓一般页面导航和返回"></a>🌓一般页面导航和返回</h2><h3 id="RaisedButton按钮组件"><a href="#RaisedButton按钮组件" class="headerlink" title="RaisedButton按钮组件"></a>RaisedButton按钮组件</h3><ul>
<li>child： 可以放入容器，图标，文字</li>
<li>onPressed：点击的相应事件，一般会调用Navigator组件</li>
</ul>
<h3 id="Navigator-push和Navigator-pop"><a href="#Navigator-push和Navigator-pop" class="headerlink" title="Navigator.push和Navigator.pop"></a>Navigator.push和Navigator.pop</h3><ul>
<li>Navigator.push: 是跳转到下一个页面，他要接受两个参数一个是上下文的context，另一个是要跳转的函数</li>
<li>Navigator.pop: 是返回到上一个页面，使用时传递一个context（上下文参数），使用的时候要注意是，你必须有上级页面，也就是说上级页面使用了Navgitor.push</li>
</ul>
<hr>
<pre><code>import &#39;package:flutter/material.dart&#39;;

void main() =&gt; runApp(MaterialApp(
    title:&#39;导航演示1&#39;,
    home:Home()
));

class Home extends StatelessWidget&#123;
    @override
    Widget build(BuildContext context) &#123;
        return Scaffold(
            appBar: AppBar(title: Text(&#39;首页&#39;),),
            body: Center(
                child: RaisedButton(
                    onPressed: ()&#123;
                        Navigator.push(context,MaterialPageRoute(builder: (context) =&gt; new Detail()));
                    &#125;,
                    child: Text(&#39;跳转到商品详情页&#39;),
                ),
            ),
        );
    &#125;
&#125;

class Detail extends StatelessWidget&#123;
    @override
    Widget build(BuildContext context) &#123;
        return Scaffold(
            appBar: AppBar(title: Text(&#39;商品详情页&#39;),),
            body: Center(
                child: RaisedButton(
                    onPressed: ()&#123;
                        Navigator.pop(context);
                    &#125;,
                    child: Text(&#39;该回去了，老弟&#39;),
                ),
            ),
        );
    &#125;
&#125;
</code></pre>
<h2 id="🌔导航参数的传递和接受"><a href="#🌔导航参数的传递和接受" class="headerlink" title="🌔导航参数的传递和接受"></a>🌔导航参数的传递和接受</h2><pre><code>import &#39;package:flutter/material.dart&#39;;

void main() =&gt; runApp(MaterialApp(
    title:&#39;导航演示1&#39;,
    home:TextWidget()
));

// 创建一个列表
class MyList extends StatelessWidget&#123;
    final List&lt;String&gt; items = new List&lt;String&gt;.generate(1000, (i)=&gt; &quot;Item $i&quot;);
    @override
    Widget build(BuildContext context) &#123;
        return ListView.builder(
            itemCount:items.length,
            itemBuilder:(context,index)&#123;
                return new ListTile(
                    title:new Text(&#39;$&#123;items[index]&#125;&#39;),
                    onTap: () &#123;
                        Navigator.push(
                            context, 
                            MaterialPageRoute(
                                builder: (context) =&gt; Detail(value: items[index]) // 传递参数
                            )
                        );
                    &#125;,
                );
            &#125;
        );
    &#125;
&#125;
class TextWidget extends StatelessWidget &#123;
    @override
    Widget build(BuildContext context) &#123;
        return MaterialApp(
            title: &quot;Flutter Demo&quot;,
            theme: ThemeData(
                primaryColor: Colors.blue,
            ),
            home: Scaffold(
                appBar: AppBar(title: Text(&quot;首页1&quot;)),
                body: Center(
                    child: Container(
                        child: MyList() // 调用列表组件
                    ),
                ),

            ),
        );
    &#125;
&#125;

class Detail extends StatelessWidget&#123;
    final String value;
    Detail(&#123;Key key,@required this.value&#125;):super(key:key); // 接受参数
    @override
    Widget build(BuildContext context) &#123;
        return Scaffold(
            appBar: AppBar(title: Text(&#39;商品详情页&#39;),),
            body: Center(
                child: RaisedButton(
                    onPressed: ()&#123;
                        Navigator.pop(context);
                    &#125;,
                    child: Text(&#39;来了，老弟 $value&#39;),
                ),
            ),
        );
    &#125;
&#125;
</code></pre>
<h2 id="🌙页面跳转并返回数据"><a href="#🌙页面跳转并返回数据" class="headerlink" title="🌙页面跳转并返回数据"></a>🌙页面跳转并返回数据</h2><blockquote>
<p>实际开发我们可能遇到这种需求，列表页跳转到详情页，详情页在跳转到列表页，需要把详情页的某些数据传递到列表页</p>
</blockquote>
<p><strong>先贴出代码</strong></p>
<pre><code>import &#39;package:flutter/material.dart&#39;;

void main() =&gt; runApp(MaterialApp(
    title:&#39;导航演示1&#39;,
    home:TextWidget()
));

class MyList extends StatelessWidget&#123;
    final List&lt;String&gt; items = new List&lt;String&gt;.generate(1000, (i)=&gt; &quot;Item $i&quot;);
    @override
    Widget build(BuildContext context) &#123;
        return ListView.builder(
            itemCount:items.length,
            itemBuilder:(context,index)&#123;
                return new ListTile(
                    title:new Text(&#39;$&#123;items[index]&#125;&#39;),
                    onTap: () &#123;
                        _navigatoreto(context, items, index);
                    &#125;,
                );
            &#125;
        );
    &#125;
    _navigatoreto(BuildContext context, List&lt;String&gt; items, index) async&#123;
        final result = await Navigator.push(
            context,
            MaterialPageRoute(
                builder: (context) =&gt; Detail(value: items[index],)
            )
        );
        Scaffold.of(context).showSnackBar(SnackBar(content: Text(&#39;$result&#39;),));
    &#125;
&#125;

class TextWidget extends StatelessWidget &#123;
    @override
    Widget build(BuildContext context) &#123;
        return MaterialApp(
            title: &quot;Flutter Demo&quot;,
            theme: ThemeData(
                primaryColor: Colors.blue,
            ),
            home: Scaffold(
                appBar: AppBar(title: Text(&quot;首页1&quot;)),
                body: Center(
                    child: Container(
                        child: MyList() // 调用列表组件
                    ),
                ),

            ),
        );
    &#125;
&#125;

class Detail extends StatelessWidget&#123;
    final String value;
    Detail(&#123;Key key,@required this.value&#125;):super(key:key);
    @override
    Widget build(BuildContext context) &#123;
        return Scaffold(
            appBar: AppBar(title: Text(&#39;商品详情页&#39;),),
            body: Center(
                child: RaisedButton(
                    onPressed: ()&#123;
                        Navigator.pop(context, &#39;恭喜你选中了$value&#39;);
                    &#125;,
                    child: Text(&#39;来了，老弟 $value&#39;),
                ),
            ),
        );
    &#125;
&#125;
</code></pre>
<h3 id="异步请求和等待"><a href="#异步请求和等待" class="headerlink" title="异步请求和等待"></a>异步请求和等待</h3><blockquote>
<p>Dart中的异步请求和ES6中的方法很像，可以直接使用async   await就可以实现</p>
</blockquote>
<pre><code>_navigatoreto(BuildContext context, List&lt;String&gt; items, index) async&#123;
    final result = await Navigator.push( // 这是一个异步的方法，我们等这个方法执行完毕以后，【等待结果回来】
        context,
        MaterialPageRoute(
            builder: (context) =&gt; Detail(value: items[index],)
        )
    );
    Scaffold.of(context).showSnackBar(SnackBar(content: Text(&#39;$result&#39;),)); // 我们在显示具体内容
&#125;
</code></pre>
<h3 id="SnackBar的使用"><a href="#SnackBar的使用" class="headerlink" title="SnackBar的使用"></a>SnackBar的使用</h3><blockquote>
<p>SnackBar使用户操作以后，显示提示信息的一个控件，类似Toast，会自动隐藏，SnackBar是以Scaffold的showSnackBar的方法来进行显示的</p>
</blockquote>
<pre><code>Scaffold.of(context).showSnackBar(SnackBar(content: Text(&#39;$result&#39;),)); // 我们在显示具体内容
</code></pre>
<h3 id="返回数据的方式"><a href="#返回数据的方式" class="headerlink" title="返回数据的方式"></a>返回数据的方式</h3><blockquote>
<p>返回数据其实特别容易，只要在返回的时候带上第二个参数就可以了</p>
</blockquote>
<pre><code>Navigator.pop(context,&#39;xxxx&#39;);  //xxx就是返回的参数
</code></pre>
<h2 id="🌛Flutter-客户端打包【Android】"><a href="#🌛Flutter-客户端打包【Android】" class="headerlink" title="🌛Flutter 客户端打包【Android】"></a>🌛Flutter 客户端打包【Android】</h2><h3 id="配置app的图标"><a href="#配置app的图标" class="headerlink" title="配置app的图标"></a>配置app的图标</h3><blockquote>
<p>找到目录</p>
</blockquote>
<pre><code>/android/app/src/main/res/
</code></pre>
<p><strong>进入之后你会看到很多mipomap-为前缀命名的文件夹，后面是像素密度，可以看出图标的分辨率</strong></p>
<ul>
<li>mdpi（中） ~ 160dpi</li>
<li>hdpi （高） ~240dip</li>
<li>xhdpi （超高） ~320dip</li>
<li>xxhdpi （超超高） ~480dip</li>
<li>xxxhdpi （超超超高） ~640dip</li>
</ul>
<blockquote>
<p>将对应的像素密度的图片放入对应的文件夹中，图片记得使用png格式，记得名字要统一，才能一次性进行配置</p>
</blockquote>
<h3 id="AndroidManifest-xml-文件"><a href="#AndroidManifest-xml-文件" class="headerlink" title="AndroidManifest.xml 文件"></a>AndroidManifest.xml 文件</h3><p><strong>这个文件主要用来配置APP的名称、图标和系统权限，所在的目录在:</strong></p>
<pre><code>/android/app/src/main/AndroidManifest.xml
</code></pre>
<hr>
<pre><code>android:label=&quot;flutter_app&quot;   //配置APP的名称，支持中文
android:icon=&quot;@mipmap/ic_launcher&quot; //APP图标的文件名称
</code></pre>
<h3 id="生成-keystore"><a href="#生成-keystore" class="headerlink" title="生成 keystore"></a>生成 keystore</h3><pre><code>keytool -genkey -v -keystore ~/key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias key
</code></pre>
<blockquote>
<p>这里会有报错： 如下</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/F1.0.png"
                     
                ></p>
<p><strong>很容易知道，没有环境变量，这里我们就不去配值，直接拿到他的根目录进行执行</strong></p>
<blockquote>
<p>通过下面的命令进行查找他的根目录</p>
</blockquote>
<pre><code>flutter doctor -v
</code></pre>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/F1.1.png"
                     
                ></p>
<p><strong>这时候你直接拷贝命令并进行输入，但这里也有个坑，就是如果文件夹中间带有空空，你需要用带引号扩上。</strong></p>
<p><strong>！！！有可能还会报错</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/F1.2.png"
                     
                ></p>
<p>这个错误的主要问题是目录不存在和没有写权限，所以我们要更换一个有写权限的目录。我们把命令改成了下面的形式。</p>
<pre><code>D:\Program\Android\&#39;Android Studio&#39;\jre\bin\keytool -genkey -v -keystore D:\key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias key
</code></pre>
<p><strong>有了这个key.jks文件后，可以到项目目录下的android文件夹下，创建一个名为key.properties的文件，并打开粘贴下面的代码。</strong></p>
<pre><code>storePassword=&lt;password from previous step&gt;    //输入上一步创建KEY时输入的 密钥库 密码
keyPassword=&lt;password from previous step&gt;    //输入上一步创建KEY时输入的 密钥 密码
keyAlias=key
storeFile=&lt;E:/key.jks&gt;    //key.jks的存放路径
</code></pre>
<p>我的文件最后是这样的：</p>
<pre><code>storePassword=123123
keyPassword=123123
keyAlias=key
storeFile=D:/key.jks
</code></pre>
<h3 id="配置key注册"><a href="#配置key注册" class="headerlink" title="配置key注册"></a>配置key注册</h3><p><strong>key生成好后，需要在build.gradle文件中进行配置。这个过程其实很简单，就是粘贴复制一些东西，你是不需要知道这些文件的具体用处的。</strong></p>
<blockquote>
<p>第一项：</p>
</blockquote>
<p>进入项目目录的/android/app/build.gradle文件，在android{这一行前面,加入如下代码:</p>
<pre><code>def keystorePropertiesFile = rootProject.file(&quot;key.properties&quot;)
def keystoreProperties = new Properties()
keystoreProperties.load(new FileInputStream(keystorePropertiesFile))
</code></pre>
<p>把如下代码进行替换</p>
<pre><code>buildTypes &#123;
    release &#123;
        signingConfig signingConfigs.debug
    &#125;
&#125;
</code></pre>
<p>替换成的代码：</p>
<pre><code>signingConfigs &#123;
    release &#123;
        keyAlias keystoreProperties[&#39;keyAlias&#39;]
        keyPassword keystoreProperties[&#39;keyPassword&#39;]
        storeFile file(keystoreProperties[&#39;storeFile&#39;])
        storePassword keystoreProperties[&#39;storePassword&#39;]
    &#125;
&#125;
buildTypes &#123;
    release &#123;
        signingConfig signingConfigs.release
    &#125;
&#125;
</code></pre>
<h3 id="生成apk"><a href="#生成apk" class="headerlink" title="生成apk"></a>生成apk</h3><blockquote>
<p>直接在终端中输入：</p>
</blockquote>
<pre><code>flutter build apk
</code></pre>
<p><strong>打包成功</strong></p>
<blockquote>
<p>打包成功的apk文件在根目录下的</p>
</blockquote>
<pre><code>/build/app/outputs/apk/app.apk
</code></pre>
]]></content>
      <tags>
        <tag>Dart</tag>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>😈Flutter 布局😈</title>
    <url>/2019/10/11/Flutter_layout/</url>
    <content><![CDATA[<h1 id="😈Flutter-布局😈"><a href="#😈Flutter-布局😈" class="headerlink" title="😈Flutter 布局😈"></a>😈Flutter 布局😈</h1><h2 id="👿水平布局Row的使用"><a href="#👿水平布局Row的使用" class="headerlink" title="👿水平布局Row的使用"></a>👿水平布局Row的使用</h2><blockquote>
<p>Flutter的row控件就是水平控件，它可以让Row的里面的子元素进行水平排列</p>
</blockquote>
<h3 id="不灵活水平布局"><a href="#不灵活水平布局" class="headerlink" title="不灵活水平布局"></a>不灵活水平布局</h3><pre><code>import &#39;package:flutter/material.dart&#39;;
void main () =&gt; runApp(MyApp());

class MyApp extends StatelessWidget&#123;
    @override
    Widget build(BuildContext context )&#123;
        return MaterialApp(
            title:&#39;ListView widget&#39;,
        
            home:Scaffold(
                appBar:new AppBar(title:new Text(&#39;水平方向布局&#39;)),
                body:new Row(
                    children: &lt;Widget&gt;[
                        new RaisedButton(
                            onPressed: ()&#123;
                            
                            &#125;,
                            color:Colors.redAccent,
                            child:new Text(&#39;红色按钮&#39;)
                        ),
                        new RaisedButton(
                            onPressed: ()&#123;
                        
                            &#125;,
                            color:Colors.orangeAccent,
                            child: new Text(&#39;黄色按钮&#39;),
                        ),  
                        new RaisedButton(
                            onPressed: ()&#123;
                            
                            &#125;,
                            color:Colors.pinkAccent,
                            child:new Text(&#39;粉色按钮&#39;)
                        )
                    ],
                )
            ),
        );
    &#125;
&#125;
</code></pre>
<blockquote>
<p>运行我们可以发现，按钮在一行没有平均分布，右侧还有空隙，如果想要他平均分布，我们就要使用灵活水平布局</p>
</blockquote>
<h3 id="灵活水平布局"><a href="#灵活水平布局" class="headerlink" title="灵活水平布局"></a>灵活水平布局</h3><blockquote>
<p>需要解决上面的问题，我们可以通过Expanded来进行解决，将按钮包在Expanded中</p>
</blockquote>
<pre><code>body: Row(
    children: &lt;Widget&gt;[
        Expanded(
            child:RaisedButton(
                onPressed: ()&#123;

                &#125;,
                color: Colors.red,
                child: Text(&#39;红褐色按钮&#39;)
            ),
        ),
        Expanded(
            child: RaisedButton(
                onPressed: ()&#123;

                &#125;,
                color: Colors.yellow,
                child: Text(&#39;黄褐色按钮&#39;)
            ),
        )
    ],
),
</code></pre>
<h2 id="👹垂直布局Column组件"><a href="#👹垂直布局Column组件" class="headerlink" title="👹垂直布局Column组件"></a>👹垂直布局Column组件</h2><blockquote>
<p>Column组件是垂直布局控件，可以将子组件垂直排列</p>
</blockquote>
<pre><code>import &#39;package:flutter/material.dart&#39;;
void main () =&gt; runApp(MyApp());

class MyApp extends StatelessWidget&#123;
    @override
    Widget build(BuildContext context )&#123;
        return MaterialApp(
            title:&#39;ListView widget&#39;,
            home:Scaffold(
                appBar:new AppBar(
                    title:new Text(&#39;垂直方向布局&#39;),
                ),
                body: Column(
                    children: &lt;Widget&gt;[
                        Text(&#39;data&#39;),
                        Text(&#39;wwwwwwwwwwwwwwwwwwwwwwwwww&#39;),
                        Text(&#39;data&#39;)
                    ],
                ),
            ),
        );
    &#125;
&#125;
</code></pre>
<p><strong>这样你会发现中间一段字母很长，并且整个布局是居中对齐的，如果我们希望他是靠左对齐的，需要加一个对齐属性</strong></p>
<ul>
<li>CrossAxisAlignment.star: 居左对齐</li>
<li>CrossAxisAlignment.end: 居右对齐</li>
<li>CrossAxisAlignment.center: 居中对齐</li>
</ul>
<h3 id="主轴和副轴的辨识【mainAxisAlignment】"><a href="#主轴和副轴的辨识【mainAxisAlignment】" class="headerlink" title="主轴和副轴的辨识【mainAxisAlignment】"></a>主轴和副轴的辨识【mainAxisAlignment】</h3><ul>
<li>main轴：如果你用cloumn组件，那垂直就是主轴，如果用的是Row组件，那么水平就是主轴</li>
<li>cross轴：Cross轴称为副轴，是和主轴垂直的方向，例：Row组件，垂直就是副轴，Column的副轴就是水平方向</li>
</ul>
<blockquote>
<p>现在将上面布局改为垂直居中</p>
</blockquote>
<pre><code>body: Column(
    crossAxisAlignment: CrossAxisAlignment.start,
    mainAxisAlignment: MainAxisAlignment.center,
    children: &lt;Widget&gt;[
        Text(&#39;data&#39;),
        Text(&#39;wwwwwwwwwwwwwwwwwwwwwwwwww&#39;),
        Text(&#39;data&#39;)
    ],
),
</code></pre>
<h3 id="Expanded属性的使用"><a href="#Expanded属性的使用" class="headerlink" title="Expanded属性的使用"></a>Expanded属性的使用</h3><blockquote>
<p>如果我们想要让中间部分变大，上下根据文字大小在底部显示，</p>
</blockquote>
<pre><code>body: Column(
    // crossAxisAlignment: CrossAxisAlignment.center,
    mainAxisAlignment: MainAxisAlignment.center,
    children: &lt;Widget&gt;[
        Center(child: Text(&#39;data&#39;),),
        Expanded(
            child: Container(
                color: Colors.red,
            )
        ),
        Center(child: Text(&#39;data&#39;),)
    ],
),
</code></pre>
<h2 id="👺Stack层叠布局"><a href="#👺Stack层叠布局" class="headerlink" title="👺Stack层叠布局"></a>👺Stack层叠布局</h2><blockquote>
<p>层叠布局就是就是放入一张图片，然后在图片上面加入文字，或者放入容器</p>
</blockquote>
<pre><code>import &#39;package:flutter/material.dart&#39;;
void main () =&gt; runApp(MyApp());

class MyApp extends StatelessWidget&#123;
    @override
    Widget build(BuildContext context )&#123;
        var stack = new Stack(
            alignment: const FractionalOffset(0.5, 0.8),
            children: &lt;Widget&gt;[
                new CircleAvatar(
                    backgroundImage: new NetworkImage(&#39;http://jspang.com/static//myimg/blogtouxiang.jpg&#39;),
                    radius: 100.0,
                ),
                new Container(
                    decoration: new BoxDecoration(
                        color: Colors.lightBlue,
                    ),
                    padding: EdgeInsets.all(5.0),
                    child: new Text(&quot;sssssssssssss&quot;),
                )
            ],
        );


        return MaterialApp(
            title:&#39;ListView widget&#39;,
            home:Scaffold(
                appBar:new AppBar(
                    title:new Text(&#39;垂直方向布局&#39;),
                ),
                body:Center(child:stack),
            ),
        );
    &#125;
&#125;
</code></pre>
<blockquote>
<p>运行以上代码，就可以得到我们想要的布局效果</p>
</blockquote>
<h3 id="alignment属性"><a href="#alignment属性" class="headerlink" title="alignment属性"></a>alignment属性</h3><blockquote>
<p>层叠布局alignment属性是控制层叠的位置的, 建议两个元素进行层叠时使用，他有两个值X轴距离和Y轴的距离，值是0到1，都是从上层容器的左上角开始算起的</p>
</blockquote>
<h3 id="CircleAvatar组件的使用"><a href="#CircleAvatar组件的使用" class="headerlink" title="CircleAvatar组件的使用"></a>CircleAvatar组件的使用</h3><blockquote>
<p>CircleAvatar这个组件是经常是用来制作头像的，组件里面有一个radius的值可以设置图片的弧度</p>
</blockquote>
<pre><code>new CircleAvatar(
    backgroundImage: new NetworkImage(&#39;http://jspang.com/static//myimg/blogtouxiang.jpg&#39;), // 放入一张背景图片
    radius: 100.0,
),
</code></pre>
<h2 id="👽Stack的Positioned属性"><a href="#👽Stack的Positioned属性" class="headerlink" title="👽Stack的Positioned属性"></a>👽Stack的Positioned属性</h2><blockquote>
<p>上述只是两个容器之间的嵌套，如果超过了两个容器之间的层叠嵌套，我们就要使用Positioned组件</p>
</blockquote>
<ul>
<li>bottom：距离层叠组件下面的距离</li>
<li>left：距离层叠组件左面的距离</li>
<li>top: 距离层叠组件上面的距离</li>
<li>right: 距离层叠组件右边的距离</li>
<li>width：层叠定位组件的宽度</li>
<li>height： 层叠定位组件的高度</li>
</ul>
<hr>
<pre><code>import &#39;package:flutter/material.dart&#39;;
void main () =&gt; runApp(MyApp());

class MyApp extends StatelessWidget&#123;
    @override
    Widget build(BuildContext context )&#123;
        var stack = Stack(
        alignment: const FractionalOffset(0.5, 0.8),
        children: &lt;Widget&gt;[
            CircleAvatar(
                backgroundImage: new NetworkImage(&#39;http://img5.mtime.cn/mt/2018/10/22/104316.77318635_180X260X4.jpg&#39;),
                radius: 100.0,
            ),
            Positioned(
                top:10.0,
                left:10.0,
                child: Container(
                    decoration: BoxDecoration(
                        color: Colors.blue
                    ),
                    padding: EdgeInsets.all(10.0),
                    child: Text(&#39;ssssssss&#39;)
                ),
            ),
            Positioned(
                bottom:10.0,
                right: 10.0,
                child: Container(
                    decoration: BoxDecoration(
                        color: Colors.red
                    ),
                    padding: EdgeInsets.fromLTRB(10.0, 20.0, 30.0, 40.0),
                    child: Text(&#39;data&#39;),
                ),
            )
            
        ],
    );


        return MaterialApp(
            title:&#39;ListView widget&#39;,
            home:Scaffold(
                appBar:new AppBar(
                    title:new Text(&#39;层叠布局&#39;),
                ),
                body:Center(child:stack),
            ),
        );
    &#125;
&#125;
</code></pre>
<p><strong>运行即可实现我们想要的效果</strong></p>
<h2 id="💣卡片组件布局"><a href="#💣卡片组件布局" class="headerlink" title="💣卡片组件布局"></a>💣卡片组件布局</h2><blockquote>
<p>卡片布局是撑满整个外部容器的，如果你想设置卡片的宽高，需要在外部容器进行制定</p>
</blockquote>
<pre><code>import &#39;package:flutter/material.dart&#39;;
void main () =&gt; runApp(MyApp());

class MyApp extends StatelessWidget&#123;
    @override
    Widget build(BuildContext context )&#123;
        var card = Card(
            child: Column(
                children: &lt;Widget&gt;[
                    ListTile(
                        title: Text(&#39;data&#39;,style: TextStyle(fontWeight: FontWeight.w800),),
                        subtitle: Text(&#39;data&#39;),
                        leading: Icon(Icons.access_alarms, color: Colors.blue),
                    ),
                    Divider(), // 分割线
                    ListTile(
                        title: Text(&#39;data&#39;,style: TextStyle(fontWeight: FontWeight.w800),),
                        subtitle: Text(&#39;data&#39;),
                        leading: Icon(Icons.access_alarms, color: Colors.blue),
                    ),
                    Divider(),
                    ListTile(
                        title: Text(&#39;data&#39;,style: TextStyle(fontWeight: FontWeight.w800),),
                        subtitle: Text(&#39;data&#39;),
                        leading: Icon(Icons.access_alarms, color: Colors.blue),
                    ),
                    Divider(),
                ],
            ),
        );
        return MaterialApp(
            title:&#39;ListView widget&#39;,
            home:Scaffold(
                appBar:new AppBar(
                    title:new Text(&#39;卡片布局&#39;),
                ),
                body:Center(child: card),
            ),
        );
    &#125;
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>Dart</tag>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>🥰Flutter 常用组件🥰</title>
    <url>/2019/10/10/Flutter_view/</url>
    <content><![CDATA[<h1 id="Flutter-常用组件"><a href="#Flutter-常用组件" class="headerlink" title="Flutter 常用组件"></a>Flutter 常用组件</h1><blockquote>
<p><strong>🥰Flutter 常用组件🥰</strong></p>
</blockquote>
<h2 id="🌟Text-Widget文本组件的使用"><a href="#🌟Text-Widget文本组件的使用" class="headerlink" title="🌟Text Widget文本组件的使用"></a>🌟Text Widget文本组件的使用</h2><pre><code>import &#39;package:flutter/material.dart&#39;;
void main () =&gt; runApp(MyApp());

class MyApp extends StatelessWidget&#123;
    @override
    Widget build(BuildContext context )&#123;
        return MaterialApp(
            title:&#39;Text widget&#39;,
            home:Scaffold(
                body:Center(
                    child:Text(&#39;hello Flutter， i like&#39;)
                ),
            ),
        );
    &#125;
&#125;
</code></pre>
<h3 id="TextAlign属性"><a href="#TextAlign属性" class="headerlink" title="TextAlign属性"></a>TextAlign属性</h3><blockquote>
<p>TextAlign属性就是文本的对齐方式</p>
</blockquote>
<ul>
<li>center ———- 文本以居中的形式对齐</li>
<li>left————– 文本以左对齐的方式对齐</li>
<li>right————- 文本以右对齐的方式对齐</li>
<li>start————- 文本以开始的位置对齐，类似left</li>
<li>end ————– 文本以结尾处对齐，类似于right</li>
</ul>
<hr>
<pre><code>child:Text(
    &#39;hello Flutter， i like&#39;,
    textAlign: TextAlign.left,
)
</code></pre>
<h3 id="maxLines属性"><a href="#maxLines属性" class="headerlink" title="maxLines属性"></a>maxLines属性</h3><blockquote>
<p>设置最多显示行数</p>
</blockquote>
<pre><code>child:Text(
    &#39;hello Flutter， i like&#39;,
    textAlign: TextAlign.left,
    maxLines: 1 // 最多显示一行
)
</code></pre>
<h3 id="overflow属性"><a href="#overflow属性" class="headerlink" title="overflow属性"></a>overflow属性</h3><blockquote>
<p>overflow属性是设置文本溢出的</p>
</blockquote>
<ul>
<li>clip：直接切断，相当于css中hidden</li>
<li>ellipsis：在后面显示省略号</li>
<li>fade：溢出部分采用渐变消失的状态(是上线渐变消失))</li>
</ul>
<hr>
<pre><code>child:Text(
    &#39;hello Flutter， i like&#39;,
    textAlign: TextAlign.left,
    maxLines: 1, // 最多显示一行
    overflow: TextOverflow.ellipsis // 超出部分以省略号的形式出现
)
</code></pre>
<h3 id="style属性"><a href="#style属性" class="headerlink" title="style属性"></a>style属性</h3><blockquote>
<p>style的属性比较多，这里只演示部分【下面制作一个字体大小为25.0，颜色为蓝色，有下划线的,下划线颜色为黄色】</p>
</blockquote>
<pre><code>child:Text(
    &#39;hello Flutter， i like&#39;,
    textAlign: TextAlign.left,
    maxLines: 1, // 最多显示一行
    overflow: TextOverflow.ellipsis, // 超出部分以省略号的形式出现
    style: TextStyle(
        fontSize: 25.0,
        color: Colors.blue,
        // color:Color.fromARGB(255, 255, 150, 150), // 颜色也可以用这种方式表示
        decoration: TextDecoration.underline,
        decorationStyle: TextDecorationStyle.solid,
        decorationColor: Colors.yellow
    ), 
)
</code></pre>
<p><strong>更多属性资料<a class="link"   href="https://api.flutter.dev/flutter/painting/TextStyle-class.html" > Flutter中文网 - 文本 Widget<i class="fas fa-external-link-alt"></i></a></strong></p>
<h2 id="⚡Container容器组件的使用"><a href="#⚡Container容器组件的使用" class="headerlink" title="⚡Container容器组件的使用"></a>⚡Container容器组件的使用</h2><blockquote>
<p>Container（容器组件）是经常使用的组件，相当于HTML的div标签</p>
</blockquote>
<pre><code>class MyApp extends StatelessWidget&#123;
    @override
    Widget build(BuildContext context )&#123;
        return MaterialApp(
            title:&#39;Text widget&#39;,
            home:Scaffold(
                body:Center(
                    child:Container(
                        child:new Text(&#39;hello Flutter， i like&#39;),
                    ),
                ),
            ),
        );
    &#125;
&#125;
</code></pre>
<h3 id="Alignment属性"><a href="#Alignment属性" class="headerlink" title="Alignment属性"></a>Alignment属性</h3><blockquote>
<p>这个属性是争对Container内child的对齐方式，也就是容器子内容的对齐方式</p>
</blockquote>
<ul>
<li>bottomCenter ————– 下部居中对齐</li>
<li>bottomLeft —————- 下部左对齐</li>
<li>bottomRight ————— 下部右对齐</li>
<li>center ——————– 纵横双向居中对齐</li>
<li>centerLeft —————- 纵向居中横向居左对齐。</li>
<li>centerRight ————— 纵向居中横向居右对齐。</li>
<li>topLeft ——————- 顶部左侧对齐。</li>
<li>topCenter —————– 顶部居中对齐。</li>
<li>topRight —————— 顶部居左对齐。</li>
</ul>
<hr>
<pre><code>home:Scaffold(
    body:Center(
        child:Container(
            child:new Text(&#39;hello Flutter， i like&#39;),
            alignment: Alignment.center,
        ),
    ),
),
</code></pre>
<h3 id="设置宽、高和颜色属性"><a href="#设置宽、高和颜色属性" class="headerlink" title="设置宽、高和颜色属性"></a>设置宽、高和颜色属性</h3><blockquote>
<p>设置宽高相对容易，只要在属性名称后面加入浮点数字就可以</p>
</blockquote>
<pre><code>home:Scaffold(
    body:Center(
        child:Container(
            child:new Text(&#39;hello Flutter， i like&#39;),
            alignment: Alignment.center,
            width:500.0,
            height:400.0,
            color: Colors.lightBlue,
        ),
    ),
),
</code></pre>
<h3 id="padding属性"><a href="#padding属性" class="headerlink" title="padding属性"></a>padding属性</h3><blockquote>
<p>padding指的的是Container和child内容器的距离</p>
</blockquote>
<pre><code>home:Scaffold(
    body:Center(
        child:Container(
            child:new Text(&#39;hello Flutter， i like&#39;),
            alignment: Alignment.center,
            width:500.0,
            height:400.0,
            color: Colors.lightBlue,
            padding: const EdgeInsets.all(10.0), // 代表上下左右的padding距离都是10
        ),
    ),
),
</code></pre>
<p><strong>上面主要说明了padding的一个统一的值，如果我们想分别设置呢</strong></p>
<pre><code>padding: const EdgeInsets.fromLTRB(10.0, 50.0, 0.0, 0.0)
</code></pre>
<p><strong>这样我们就可以分别设置各个方向的padding值</strong></p>
<h3 id="margin属性"><a href="#margin属性" class="headerlink" title="margin属性"></a>margin属性</h3><blockquote>
<p>用法同上</p>
</blockquote>
<pre><code>margin: const EdgeInsets.all(10.0), // 代表上下左右的margin距离都是10
            ||或
margin: const EdgeInsets.fromLTRB(10.0, 50.0, 0.0, 0.0)
</code></pre>
<h3 id="decoration属性"><a href="#decoration属性" class="headerlink" title="decoration属性"></a>decoration属性</h3><blockquote>
<p>decoration是container的修饰器，主要功能设置背景和边框</p>
</blockquote>
<p><strong>如果你想要给一个背景加一个渐变，这时候需要这个BoxDecoation</strong></p>
<pre><code>home:Scaffold(
    body:Center(
        child:Container(
            child:new Text(&#39;hello Flutter， i like&#39;),
            alignment: Alignment.center,
            width:500.0,
            height:400.0,
            // color: Colors.lightBlue,
            padding: const EdgeInsets.all(10.0), // 代表上下左右的padding距离都是10
            decoration: new BoxDecoration(
                gradient: const LinearGradient(
                    colors: [Colors.blue, Colors.red, Colors.white] // 设置渐变色
                ),
                border: Border.all(width: 2.0, color: Colors.red) // 设置边框线的样式
            ),
        ),
    ),
),
</code></pre>
<blockquote>
<p><strong>注意color和decoration不能共存,会有冲突</strong></p>
</blockquote>
<h2 id="🔥Image图片的使用"><a href="#🔥Image图片的使用" class="headerlink" title="🔥Image图片的使用"></a>🔥Image图片的使用</h2><ul>
<li>Image.asset: 加载资源图片,就是加载项目资源的目录中的图片,加入图片会增加打包的体积,以相对路径引入</li>
<li>Image.network: 网络资源图片,意思就是引入网络图片路径</li>
<li>Image.file: 加载本地图片,就是加载本地文件中的图片,不会增加打包体积,以绝对路径引入</li>
<li>Image.memory: 加载Uint8List资源图片</li>
</ul>
<hr>
<pre><code>home:Scaffold(
    body:Center(
        child:Container(
            child: Image.network(
                &#39;http://my.ignorantscholar.cn/images/headers.png&#39;,
                width: 300.0,
                height: 300.0,
            ),
            alignment: Alignment.center,
            width:500.0,
            height:400.0,
            // color: Colors.lightBlue,
            padding: const EdgeInsets.all(10.0), // 代表上下左右的padding距离都是10
            decoration: new BoxDecoration(
                gradient: const LinearGradient(
                    colors: [Colors.blue, Colors.red, Colors.white] // 设置渐变色
                ),
                border: Border.all(width: 2.0, color: Colors.red) // 设置边框线的样式
            ),
        ),
    ),
),
</code></pre>
<h3 id="fit属性"><a href="#fit属性" class="headerlink" title="fit属性"></a>fit属性</h3><blockquote>
<p>fit属性可以控制图片的拉伸和挤压,这些都是根据图片的父级容器来的</p>
</blockquote>
<ul>
<li>BoxFit.fill: 全图显示,图片会被拉伸,并且充满父容器</li>
<li>BoxFit.contain: 全图显示,显示原比例,可能会有空隙</li>
<li>BoxFit.cover: 显示可能拉伸,可能裁剪,充满(图片要充满整个容器,还不变形)</li>
<li>BoxFit.fitWidth: 宽度充满,(横向充满)</li>
<li>BoxFit.fitHeight: 高度充满 (属相充满)</li>
<li>BoxFit.scaleDown: 效果和contain差不多,但是此属性不能超过图片大小,可小不可大</li>
</ul>
<hr>
<pre><code>child: Image.network(
    &#39;http://my.ignorantscholar.cn/images/headers.png&#39;,
    width: 300.0,
    height: 300.0,
    fit: BoxFit.cover, // 不变形,充满整个容器
),
</code></pre>
<h3 id="图片混合模式"><a href="#图片混合模式" class="headerlink" title="图片混合模式"></a>图片混合模式</h3><blockquote>
<p>图片混合模式(colorBlendMode) 和 color 属性一起使用,可以让图片改变颜色</p>
</blockquote>
<p><strong>！！！！！！colorBlendMode和color需要同时使用,单独使用一个达不到预期效果</strong></p>
<pre><code>child: Image.network(
    &#39;http://my.ignorantscholar.cn/images/headers.png&#39;,
    width: 300.0,
    height: 300.0,
    color: Colors.yellow,
    colorBlendMode: BlendMode.modulate,
    fit: BoxFit.cover,
),
</code></pre>
<h3 id="使用项目资源图片"><a href="#使用项目资源图片" class="headerlink" title="使用项目资源图片"></a>使用项目资源图片</h3><pre><code>pubspec.yaml文件
</code></pre>
<blockquote>
<p>如果想配置项目资源文件，就需要使用pubspec.yaml文件，需要把资源文件在这里声明</p>
</blockquote>
<p><strong>比如在项目根目录下建立了一个文件images用来存放图片，文件夹下面有一个图片，pic.png，那我们在pubspec.yaml文件中进行声明</strong></p>
<pre><code>assets:
    - images/pic.png
</code></pre>
<hr>
<pre><code>child: Image.asset(&#39;images/pic.png&#39;),
</code></pre>
<h2 id="💧ListView列表组件"><a href="#💧ListView列表组件" class="headerlink" title="💧ListView列表组件"></a>💧ListView列表组件</h2><h3 id="ListView的声明"><a href="#ListView的声明" class="headerlink" title="ListView的声明"></a>ListView的声明</h3><pre><code>import &#39;package:flutter/material.dart&#39;;
void main () =&gt; runApp(MyApp());

class MyApp extends StatelessWidget&#123;
    @override
    Widget build(BuildContext context )&#123;
        return MaterialApp(
            title:&#39;Text widget&#39;,
            home:Scaffold(
                body:ListView(
                    child: &lt;Widget&gt;[
                        ListTile(
                            leading: Icon(Icons.assess_time),
                            title: new Text(&#39;assess_time&#39;)
                        ),
                        ListTile(
                            leading: Icon(Icons.assess_time),
                            title: new Text(&#39;assess_time&#39;)
                        )   
                    ]
                ),
            ),
        );
    &#125;
&#125;
</code></pre>
<blockquote>
<p>我们使用了ListView，然后在他的内部children中，使用了widget数组，因为是一个列表，所以他接受一个数组，然后使用了ListTile组件【列表瓦片】，具体效果可以在项目中查看</p>
</blockquote>
<h3 id="图片列表的使用"><a href="#图片列表的使用" class="headerlink" title="图片列表的使用"></a>图片列表的使用</h3><blockquote>
<p>我们使用网络的方式，插入两张图片</p>
</blockquote>
<pre><code>body: new ListView(
    children:&lt;Widget&gt;[
        new Image.network(&#39;http://jspang.com/static/upload/20181111/G-wj-ZQuocWlYOHM6MT2Hbh5.jpg&#39;),
        new Image.network(&#39;http://jspang.com/static/upload/20181109/1bHNoNGpZjyriCNcvqdKo3s6.jpg&#39;),
    ]
),
</code></pre>
<h3 id="横向列表的使用"><a href="#横向列表的使用" class="headerlink" title="横向列表的使用"></a>横向列表的使用</h3><blockquote>
<p>使用横向列表需要加一个属性scrollDirection</p>
</blockquote>
<ul>
<li>Axis.horizontal: 横向滚动</li>
<li>Axis.vertical: 纵向滚动 【默认纵向滚动】</li>
</ul>
<hr>
<pre><code>home:Scaffold(
    body:Center(
        child:Container(
        height:200.0,
        child:new ListView(
            scrollDirection: Axis.horizontal,
            children: &lt;Widget&gt;[
                new Container(
                    width:180.0,
                    color: Colors.lightBlue,
                ), 
                new Container(
                    width:180.0,
                    color: Colors.amber,
                ), 
                new Container(
                    width:180.0,
                    color: Colors.deepOrange,
                ),
                new Container(
                    width:180.0,
                    color: Colors.deepPurpleAccent,
                ),
            ],
        )
    ),
),
</code></pre>
<p><strong>从上面代码我们可以看出，代码嵌套比较深，进行优化，提取</strong></p>
<pre><code>class MyList extends StatelessWidget&#123;
    @override
    Widget build(BuildContext context) &#123;
        return ListView(
            scrollDirection: Axis.horizontal,
            children: &lt;Widget&gt;[
                Container(
                    width: 180.0,
                    color: Colors.red,
                ),
                Container(
                    width: 180.0,
                    color: Colors.yellow,
                ),
                Container(
                    width: 180.0,
                    color: Colors.red,
                ),
                Container(
                    width: 180.0,
                    color: Colors.yellow,
                )
            ]
        );
    &#125;
&#125;


home:Scaffold(
    body:Center(
        child:Container(
        height:200.0,
        child: MyList()
    ),
),
</code></pre>
<blockquote>
<p>这样看就简洁许多</p>
</blockquote>
<h3 id="动态列表的使用"><a href="#动态列表的使用" class="headerlink" title="动态列表的使用"></a>动态列表的使用</h3><blockquote>
<p>上面的列表是写死的，我们在实际开发中，大多数是不会死的</p>
</blockquote>
<pre><code>class MyList extends StatelessWidget&#123;
    final List&lt;String&gt; items = new List&lt;String&gt;.generate(1000, (i)=&gt; &quot;Item $i&quot;); // 使用list中的属性generate方法产生List里面的元素
    @override
    Widget build(BuildContext context) &#123;
        return ListView.builder( // 调用动态列表生成
            itemCount:items.length,
                itemBuilder:(context,index)&#123;
                    return new ListTile(
                        title:new Text(&#39;$&#123;items[index]&#125;&#39;),
                    );
                &#125;
            );
    &#125;
&#125;
</code></pre>
<h2 id="🌊GridView网格列表布局组件"><a href="#🌊GridView网格列表布局组件" class="headerlink" title="🌊GridView网格列表布局组件"></a>🌊GridView网格列表布局组件</h2><pre><code>import &#39;package:flutter/material.dart&#39;;
void main () =&gt; runApp(MyApp());

class MyApp extends StatelessWidget&#123;
    @override
    Widget build(BuildContext context )&#123;
        return MaterialApp(
            title:&#39;ListView widget&#39;,
            home:Scaffold(
                body:GridView.count(
                    padding:const EdgeInsets.all(20.0),
                    crossAxisSpacing: 10.0,
                    crossAxisCount: 3,
                    children: &lt;Widget&gt;[
                        Container(
                            color: Colors.red,
                        ),
                        Container(
                            color: Colors.red,
                        ),
                        Container(
                            color: Colors.red,
                        ),
                        Container(
                            color: Colors.red,
                        ),
                        Container(
                            color: Colors.red,
                        )
                    ],
                )
            ),
        );
    &#125;
&#125;
</code></pre>
<ul>
<li>crossAxisSpacing: 网格之间 的空隙</li>
<li>crossAxisSpacing：网格列数，相当于一行放置的网格数量</li>
</ul>
<blockquote>
<p>现在做一个图片的网格布局</p>
</blockquote>
<pre><code>body: GridView.count(
    padding: const EdgeInsets.all(10.0),
    crossAxisSpacing: 2.0,
    crossAxisCount: 3,
    mainAxisSpacing: 2,
    childAspectRatio: 0.7,
    children: &lt;Widget&gt;[
        new Image.network(&#39;http://img5.mtime.cn/mt/2018/10/22/104316.77318635_180X260X4.jpg&#39;,fit: BoxFit.cover),
        new Image.network(&#39;http://img5.mtime.cn/mt/2018/10/10/112514.30587089_180X260X4.jpg&#39;,fit: BoxFit.cover),
        new Image.network(&#39;http://img5.mtime.cn/mt/2018/11/13/093605.61422332_180X260X4.jpg&#39;,fit: BoxFit.cover),
        new Image.network(&#39;http://img5.mtime.cn/mt/2018/11/07/092515.55805319_180X260X4.jpg&#39;,fit: BoxFit.cover),
        new Image.network(&#39;http://img5.mtime.cn/mt/2018/11/21/090246.16772408_135X190X4.jpg&#39;,fit: BoxFit.cover),
        new Image.network(&#39;http://img5.mtime.cn/mt/2018/11/17/162028.94879602_135X190X4.jpg&#39;,fit: BoxFit.cover),
        new Image.network(&#39;http://img5.mtime.cn/mt/2018/11/19/165350.52237320_135X190X4.jpg&#39;,fit: BoxFit.cover),
        new Image.network(&#39;http://img5.mtime.cn/mt/2018/11/16/115256.24365160_180X260X4.jpg&#39;,fit: BoxFit.cover),
        new Image.network(&#39;http://img5.mtime.cn/mt/2018/11/20/141608.71613590_135X190X4.jpg&#39;,fit: BoxFit.cover),
    ],
),
</code></pre>
<ul>
<li>childAspectRatio： 宽高比， 这个值的意思是宽是高的多少倍</li>
</ul>
]]></content>
      <tags>
        <tag>Dart</tag>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>🍉Dart学习【基础】🍉</title>
    <url>/2019/10/09/Flutter_Dart/</url>
    <content><![CDATA[<h1 id="🍉Dart学习【基础】🍉"><a href="#🍉Dart学习【基础】🍉" class="headerlink" title="🍉Dart学习【基础】🍉"></a>🍉Dart学习【基础】🍉</h1><h2 id="🍌Dart简介"><a href="#🍌Dart简介" class="headerlink" title="🍌Dart简介"></a>🍌Dart简介</h2><ul>
<li><p>在Dart中，一切都是对象，一切对象都是class实例，哪怕是数字类型，方法甚至是null都是对象，所有对象继承于Object</p>
</li>
<li><p>Dart是强语言类型，但是Dart可以自动推变变量类型，所以也可以支持动态类型</p>
</li>
<li><p>Dart具有强大的异步编程能力</p>
</li>
</ul>
<h2 id="🍍Dart用法"><a href="#🍍Dart用法" class="headerlink" title="🍍Dart用法"></a>🍍Dart用法</h2><blockquote>
<p>import 导入库</p>
</blockquote>
<pre><code>import &#39;package:flutter/material.dart&#39;;
</code></pre>
<blockquote>
<p>注释【和js一样】</p>
</blockquote>
<pre><code>//单行注释
/****/多行注释
</code></pre>
<blockquote>
<p>=&gt; [Dart的箭头函数，即Lambda表达式]</p>
</blockquote>
<pre><code>void main() =&gt; runApp(MyApp());
</code></pre>
<blockquote>
<p>extends 继承</p>
</blockquote>
<pre><code>class MyApp extends StatelessWidget &#123;

    var content = &#39;Dart&#39;; // 声明并初始化变量
    String _name = &quot;Flutter&quot;;

    @override
    Widget build(BuildContext context) &#123;

        print(&#39;display $content&#39;); // 打印【对应js的console】

        // return a Widget
        return MaterialApp(
        title: &quot;Flutter Demo&quot;,
        theme: ThemeData(
            primaryColor: Colors.blue,
        ),
        home: Scaffold(
            appBar: AppBar(title: Text(&quot;Flutter Dart 语法&quot;)),
            body: Text(content+_name)
            ),
        );
    &#125;
&#125;
</code></pre>
<blockquote>
<p>var 变量申明并且不指定其类型的方法</p>
</blockquote>
<pre><code>var content = &#39;Dart 语法&#39;; // 声明并初始化变量
</code></pre>
<blockquote>
<p>_  以下划线 _ 开头的类或成员变量是私有的</p>
</blockquote>
<p><strong>Dart 没有 Public、Protected、Private 的关键字，在 Dart 里，类或成员变量默认都是 Public 的，以下划线 _ 开头的就是私有的，例如成员变量 _name 就是私有的。</strong></p>
<pre><code>String _name = &quot;Flutter&quot;;
</code></pre>
<blockquote>
<p>String 在声明变量时也可以指定具体类型，String 是字符串，还有其他的数据类型：int、double等。</p>
</blockquote>
<pre><code>String _name = &quot;Flutter&quot;;
</code></pre>
<blockquote>
<p>$variableName 或 ${expression} </p>
</blockquote>
<p><strong>字符串插值：将变量的值直接插入字符串中。</strong></p>
<pre><code>print(&#39;display $content&#39;);
</code></pre>
<h2 id="🍑变量声明（一共有四种方式）"><a href="#🍑变量声明（一共有四种方式）" class="headerlink" title="🍑变量声明（一共有四种方式）"></a>🍑变量声明（一共有四种方式）</h2><ul>
<li><ol>
<li>var</li>
</ol>
</li>
</ul>
<hr>
<pre><code>var content = &#39;Dart 语法&#39;

var switchOn = false

var current = 0
</code></pre>
<p><strong>使用var来申明变量，不需要指定变量的数据类型，因为Dart会自动推断其数据类型，所以可以使用var来定义任何变量</strong></p>
<blockquote>
<p>var不是直接储存值，而是存储的对象的引用，例如：var content = ‘Dart’,是名字为content的var的变量存储了值为Dart的String对象的引用，因此var可以定义定义任何变量</p>
</blockquote>
<ul>
<li><ol start="2">
<li>明确数据类型</li>
</ol>
</li>
</ul>
<hr>
<pre><code>String name = &#39;Flutter&#39;
int count = 0
</code></pre>
<p><strong>就是在声明变量的时候，使用明确的数据类型</strong></p>
<ul>
<li>dynamic</li>
</ul>
<hr>
<pre><code>dynamic example = &#39;example&#39;
</code></pre>
<p><strong>意思是数据类型是动态可变的，也可以定义任何变量，但是和var不同，var一旦赋值以后，就不能改变数据类型了</strong></p>
<ul>
<li>Object</li>
</ul>
<hr>
<pre><code>Object index = 100
</code></pre>
<p><strong>Dart里面的所有东西都是对象，因为Dart的所有东西都是对象，都继承于Object，因此可以定义任意类型，而且赋值以后也可以更改</strong></p>
<pre><code>Object index = 100

index = &#39;string&#39; √  因为&#39;string&#39;也是object
</code></pre>
<p><strong>！！！注意： 请不要滥用dynamic，一般情况下都可以使用Object来代替</strong></p>
<h3 id="dynamic-使用场景"><a href="#dynamic-使用场景" class="headerlink" title="dynamic 使用场景"></a>dynamic 使用场景</h3><blockquote>
<p>在与native对接时，对传入的参数类型不确定时，进行使用</p>
</blockquote>
<h3 id="常量：final-和-const"><a href="#常量：final-和-const" class="headerlink" title="常量：final 和 const"></a>常量：final 和 const</h3><pre><code>final content = &#39;Dart

static const bool switch = false
</code></pre>
<p><strong>使用的时候需要注意一下几点</strong></p>
<ul>
<li>使用final和const时候可以把var省略</li>
<li>final和const变量只能赋值一次，并且他在声明的时候就已经赋值</li>
<li>const是隐式的const</li>
<li>在使用const的时候，如果是在全局声明的话，不需要加static属性，如果是在类里面声明，则需要加上</li>
</ul>
<blockquote>
<p>final与const的区别</p>
</blockquote>
<p><strong>const是编译时常量，在编译的时候就已经初始化了，而final变量是当类创建的时候才初始化</strong></p>
<h2 id="🍓Dart支持的数据类型"><a href="#🍓Dart支持的数据类型" class="headerlink" title="🍓Dart支持的数据类型"></a>🍓Dart支持的数据类型</h2><ul>
<li>int</li>
</ul>
<blockquote>
<p>整数，范围带-2^63到2^63-1</p>
</blockquote>
<pre><code>int x = 1; // 没有小数点就是int
</code></pre>
<ul>
<li>double</li>
</ul>
<blockquote>
<p>浮点数，64位，双精度- 浮点数</p>
</blockquote>
<pre><code>double y = 1.1; // 有小数的就是浮点数
</code></pre>
<ul>
<li>num</li>
</ul>
<blockquote>
<p>num是数字类型，既可以表示整数，也可以表示浮点数，具体看赋值</p>
</blockquote>
<pre><code>num x = 1;

num y = 2;
</code></pre>
<ul>
<li>String</li>
</ul>
<blockquote>
<p>字符串【Dart字符串采用UTF-8编码，可以采用单引号或双引号】</p>
</blockquote>
<pre><code>var s1 = &#39;string&#39;

String s1 = &#39;string&#39;
</code></pre>
<ul>
<li>bool </li>
</ul>
<blockquote>
<p>布尔值</p>
</blockquote>
<pre><code>var isShow = true

bool isShow = true
</code></pre>
<ul>
<li>List</li>
</ul>
<blockquote>
<p>List[E] E表示List里面的数据类型</p>
</blockquote>
<pre><code>List&lt;int&gt; = [1, 2, 3]
</code></pre>
<ul>
<li>Set</li>
</ul>
<blockquote>
<p>Set&lt;\E&gt; E表示Set的数据类型，使用大括号进行赋值</p>
</blockquote>
<pre><code>Set&lt;String&gt; halong = &#123;&#39;hellow&#39;, &#39;world&#39;, &#39;koal&#39;&#125;
</code></pre>
<ul>
<li>Map</li>
</ul>
<blockquote>
<p>Map&lt;\k, v&gt;k是Key的数据类型，V是Value的数据类型</p>
</blockquote>
<pre><code>Map&lt;String, String&gt; gits = &#123;
    &#39;first&#39;: &#39;partridge&#39;,
    &#39;second&#39;: &#39;turtledoves&#39;,
&#125;
</code></pre>
<ul>
<li>Runes</li>
</ul>
<blockquote>
<p>表示采用UTF-32字符串，用于显示Unicode，因为Dart字符串是UTF-16，因此在Dart中表示32位的Unicode需要Runes这个特殊的语法</p>
</blockquote>
<pre><code>Runes input = new Runes(&#39;\u&#123;1f600&#125;&#39;);
print(new String.fromCharCodes(input));
打印出来的是笑脸emoji：😆
</code></pre>
<h2 id="🍄函数"><a href="#🍄函数" class="headerlink" title="🍄函数"></a>🍄函数</h2><blockquote>
<p>在Dart中函数也是对象,函数的类型是Function</p>
</blockquote>
<h3 id="函数的写作格式"><a href="#函数的写作格式" class="headerlink" title="函数的写作格式"></a>函数的写作格式</h3><pre><code>bool say(String msg , String from, int clock)&#123;
    print(msg+&quot; from &quot; + from + &quot; at &quot; + clock?.toString());
    return true;
&#125;

返回类型 函数名(函数参数)&#123;

&#125;   
</code></pre>
<h3 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h3><pre><code>print(say is Function) // 判断say是否为函数
</code></pre>
<h3 id="函数的参数：-必选参数-可选参数"><a href="#函数的参数：-必选参数-可选参数" class="headerlink" title="函数的参数： 必选参数 ===== 可选参数"></a>函数的参数： 必选参数 ===== 可选参数</h3><blockquote>
<p>首先必选参数必须在前面，和普通函数一样，后面跟可选参数，可选参数需要用{}或者[]包起来，用不同的括号，可选参数的意义也不一样</p>
</blockquote>
<p><strong>必选参数和普通函数一样，这里不多阐述，主要说明可选参数</strong></p>
<blockquote>
<p><strong>可选参数</strong></p>
</blockquote>
<ul>
<li><strong>可选命名参数：</strong>：使用{}包起来的参数是可选命名参数</li>
<li><strong>可选位置参数：</strong>：使用[]包起来的参数是可选位置参数</li>
</ul>
<blockquote>
<p>可选命名参数：{}</p>
</blockquote>
<p><strong>用{}包起来的参数，前面说的数据类型，使用{}来赋值的数据类型是Map，所以可选参数的的类型也是Map，因此调用函数时，可选参数的赋值必须是key: value这种格式的，如下：</strong></p>
<pre><code>bool say(String msg , &#123;String from, int clock&#125;)&#123;
    print(msg+&quot; from &quot; + from + &quot; at &quot; + clock.toString());
    return true;
&#125;

// 调用

say(&#39;Hello Flutter&#39;);//✅ 因为 from 和 clock 是可选参数，所以可以不填

say(&#39;Hello Flutter&#39;, from: &#39;XiaoMing&#39;);//对 用命名参数格式 paramName: value 为 from 赋值
say(&#39;Hello Flutter&#39;, clock: 11);//✅
say(&#39;Hello Flutter&#39;, from: &#39;XiaoMing&#39;, clock: 11);//✅
</code></pre>
<p><strong>同时也可以给命名参数加@required，意思是这个也是必选参数，如下：</strong></p>
<pre><code>bool say(String msg , &#123;@required String from, int clock&#125;)&#123;
    print(msg+&quot; from &quot; + from + &quot; at &quot; + clock.toString());
    return true;
&#125;

// 调用

say(&#39;Hello Flutter&#39;);//❌  错误调用方式，因为 from 是必选参数，不填的话会报错

say(&#39;Hello Flutter&#39;, from: &#39;XiaoMing&#39;);//✅ 正确调用方式
say(&#39;Hello Flutter&#39;, from: &#39;XiaoMing&#39;, clock: 11);//✅ 这个调用方式也是正确的
</code></pre>
<blockquote>
<p>可选位置参数：[]</p>
</blockquote>
<p><strong>用[ ]包起来的参数是可选位置参数，前面说的数据类型的时候，使用[ ]来赋值的数据类型是List，所以可选参数的命名参数也是List，所以赋值和参数是一一对应的，如下：</strong></p>
<pre><code>bool say(String msg , [String from , int clock])&#123;
    print(msg+&quot; from &quot; + from + &quot; at &quot; + clock.toString());
    return true;
&#125;

// 调用

say(&#39;Hello Flutter&#39;);//✅ 因为 from 和 clock 是可选参数，所以可以不填

say(&#39;Hello Flutter&#39;, &#39;XiaoMing&#39;,1);//✅ 为可选位置参数赋值，只能一个参数一个参数对应的赋值，所以要全部赋值
    
say(&#39;Hello Flutter&#39;, &#39;XiaoMing&#39;)//✅
say(&#39;Hello Flutter&#39;, 1)//❌ 因为  1 赋值给了 from,但是 from 是String，所以会报错
</code></pre>
<blockquote>
<p>可选参数的默认值： =</p>
</blockquote>
<p><strong>因为参数是可选的，那么参数的值很可能没有赋值，也就是null，我们如果需要用到该参数，可以赋值给他一个默认值</strong></p>
<pre><code>bool say(String msg , &#123;String from = &#39;empty&#39;, int clock = 0&#125;)&#123;
    print(msg+&quot; from &quot; + from + &quot; at &quot; + clock.toString());
    return true;
&#125;
</code></pre>
<h2 id="🍒-gt-箭头语法"><a href="#🍒-gt-箭头语法" class="headerlink" title="🍒=&gt; 箭头语法"></a>🍒=&gt; 箭头语法</h2><blockquote>
<p>=&gt; 语句后面的只能加一行代码，而且这一行代码只能一个表达式，而且不能跟语句，表达式可以使函数或值</p>
</blockquote>
<pre><code>void main() =&gt; runApp(MyApp());
</code></pre>
<p>等价于：</p>
<pre><code>void main()&#123;
    return runApp(MyApp());//runApp() 返回的是 void
&#125;
</code></pre>
<h2 id="🍭操作符"><a href="#🍭操作符" class="headerlink" title="🍭操作符"></a>🍭操作符</h2><blockquote>
<p>类型判断操作符</p>
</blockquote>
<ul>
<li>as</li>
</ul>
<p><strong>类型转换</strong></p>
<pre><code>(emp as Person).firstName = &#39;Bob&#39;;
</code></pre>
<ul>
<li>is</li>
</ul>
<p><strong>判断是否为某个类型，如果是的话，就返回true</strong></p>
<pre><code>if (emp is Person) &#123;    // 如果 emp 是 Person 类型
    emp.firstName =&#39;Bob&#39;;
&#125;
</code></pre>
<ul>
<li>is!</li>
</ul>
<p><strong>判断是否不是某个类型，如果不是的话就返回true</strong></p>
<pre><code>if (emp is! Person) &#123;
    // 如果 emp 不是 Person 类型
&#125;
</code></pre>
<h2 id="🍬条件运算符"><a href="#🍬条件运算符" class="headerlink" title="🍬条件运算符"></a>🍬条件运算符</h2><pre><code>condition ? expr1 : expr2
</code></pre>
<blockquote>
<p>如果condition为true的时候，返回expr1，否则返回expr2</p>
</blockquote>
<pre><code>var visibility = isPublic ? &#39;public&#39; : &#39;private&#39;;
</code></pre>
<hr>
<pre><code>expr1 ?? expr2
</code></pre>
<blockquote>
<p>如果 expr1 为 null，就返回 expr2 的值，否则返回 expr1 的值。</p>
</blockquote>
<p><strong>如果需要根据一个 boolean 表达式是否为 null 来作为条件，可以使用 ??，例如：</strong></p>
<pre><code>String playerName(String name) =&gt; name ?? &#39;Guest&#39;;
</code></pre>
]]></content>
      <tags>
        <tag>Dart</tag>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>🍉js执行机制🍉</title>
    <url>/2019/10/09/js%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="S"><a href="#S" class="headerlink" title="S"></a>S</h1><p>js 是一门非阻塞脚本语言，同一时刻只会允许一个代码执行，在单线程的机制中，执行异步任务是，在等待返回结果前，后面代码无法执行</p>
<h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><h2 id="设计单线程原因"><a href="#设计单线程原因" class="headerlink" title="设计单线程原因"></a>设计单线程原因</h2><p>如果 js 是多线程的话，因为 DOM 可以通过 js 去操作，如果此时有两个线程操作同一个 DOM，线程一删除了这个 DOM，而线程<br>二要操作这个 DOM，则会产生矛盾。</p>
<h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><h3 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h3><ul>
<li>Script</li>
<li>setTimeout, setInterval</li>
<li>I/O</li>
<li>UI 渲染</li>
<li>…</li>
</ul>
<h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><ul>
<li>Promise</li>
<li>…</li>
</ul>
<h2 id="执行规则"><a href="#执行规则" class="headerlink" title="执行规则"></a>执行规则</h2><blockquote>
<p>js 是通过事件循环机制（EventLoop）来解决这一弊端</p>
</blockquote>
<ul>
<li>所有代码进入到主线程执行栈，开始执行</li>
<li>执行过程中，同步代码会立即执行，宏任务会进入到宏任务队列，微任务进入微任务队列</li>
<li>当前宏任务执行完成出队，读取微任务列表有则执行，直至全部执行完毕</li>
</ul>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>😎flutter环境搭建（window）🤔</title>
    <url>/2019/10/08/flutter-windows/</url>
    <content><![CDATA[<h1 id="😎flutter环境搭建（window）🤔"><a href="#😎flutter环境搭建（window）🤔" class="headerlink" title="😎flutter环境搭建（window）🤔"></a>😎flutter环境搭建（window）🤔</h1><h2 id="🤣搭建-Android-开发环境"><a href="#🤣搭建-Android-开发环境" class="headerlink" title="🤣搭建 Android 开发环境"></a>🤣搭建 Android 开发环境</h2><hr>
<blockquote>
<p><strong>具体环境搭建参考<a class="link"   href="http://my.ignorantscholar.cn/2019/05/22/react-native-windows/" >使用react-native基础环境搭建<i class="fas fa-external-link-alt"></i></a></strong></p>
</blockquote>
<hr>
<h2 id="😁配置flutter环境变量"><a href="#😁配置flutter环境变量" class="headerlink" title="😁配置flutter环境变量"></a>😁配置flutter环境变量</h2><blockquote>
<p>打开高级系统设置 =&gt; 配置环境变量</p>
</blockquote>
<blockquote>
<p>用户变量下，选择新建环境变量</p>
</blockquote>
<pre><code>FLUTTER_STORAGE_BASE_URL     https://storage.flutter-io.cn

PUB_HOSTED_URL               https://pub.flutter-io.cn
</code></pre>
<h3 id="Flutter-SDK"><a href="#Flutter-SDK" class="headerlink" title="Flutter SDK"></a>Flutter SDK</h3><blockquote>
<p>Flutter 开发需要安装 Flutter SDK，这里只介绍 Flutter SDK 在 Windows 这个平台上的安装过程。</p>
</blockquote>
<h4 id="下载-Flutter-SDK"><a href="#下载-Flutter-SDK" class="headerlink" title="下载 Flutter SDK"></a>下载 Flutter SDK</h4><ul>
<li><p>你可以在 Flutter SDK 的下载页面，选择你想要的版本，一般选择稳定版的，目前最新的稳定版是 v1.9.1+hotfix.2。</p>
</li>
<li><p>将 Flutter SDK 的 zip 包解压到一个目录下，例如 E:\src\flutter（目录随意，但是不要放在需要权限的目录下，例如 C:\Program Files\ ）</p>
</li>
</ul>
<h4 id="设置-Flutter-SDK-的环境变量"><a href="#设置-Flutter-SDK-的环境变量" class="headerlink" title="设置 Flutter SDK 的环境变量"></a>设置 Flutter SDK 的环境变量</h4><blockquote>
<p>计算机 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量，打开环境变量设置框。</p>
</blockquote>
<blockquote>
<p>在用户变量下, 将 Flutter SDK 的完整路径 E:\src\flutter\bin 添加到[Path]变量上。</p>
</blockquote>
<h4 id="运行-flutter-doctor"><a href="#运行-flutter-doctor" class="headerlink" title="运行 flutter doctor"></a>运行 flutter doctor</h4><blockquote>
<p>为了验证 Flutter 是否安装成功，在 cmd 运行：</p>
</blockquote>
<pre><code>flutter doctor


C:\Users\Administrator&gt;flutter doctor
Doctor summary (to see all details, run flutter doctor -v):
[✓] Flutter (Channel stable, v1.9.1-hotfix.2, on Microsoft Windows [Version 6.1.7601], locale zh-CN)
[✓] Android toolchain - develop for Android devices (Android SDK 27.0.3)
[✓] Android Studio (version 3.1)
[!] Connected device 
    ! No devices available

! Doctor found issues in 1 categories.
</code></pre>
<h4 id="可能会遇到的报错"><a href="#可能会遇到的报错" class="headerlink" title="可能会遇到的报错"></a>可能会遇到的报错</h4><pre><code>Some Android licenses not accepted（Android证书的问题）
</code></pre>
<blockquote>
<p>运行 <strong>flutter doctor –android-licenses</strong> 修护</p>
</blockquote>
<p><strong>得到X:\xxxxsdk\tool\bin\sdkmanager –update</strong></p>
<p><strong>复制运行[会出现的报错]]</strong></p>
<ul>
<li><p>Exception in thread “main” java.lang.UnsupportedClassVersionError</p>
<blockquote>
<p>查看Java版本 [如果Java版本大于8,去下载8版本的Java包,下载完成后,将Java的环境变量进行替换,并且Java的环境变量要优先于flutter],修复完成后继续运行X:\xxxxsdk\tool\bin\sdkmanager –update</p>
</blockquote>
</li>
<li><p>Warning: An error occured during installation: Failed to move away or delete existing target file: X盘:\androidSDK\sdk\tools</p>
</li>
</ul>
<blockquote>
<p>把sdk下面的tools文件夹，重命名一下tool或者随意，然后打开cmd，前往其目录下的bin\sdkmanager</p>
</blockquote>
<blockquote>
<p>执行–update，也就是你的X:\xxxxsdk\tool\bin\sdkmanager –update，执行</p>
</blockquote>
<blockquote>
<p>这里会有警告，也就是你刚刚重命名了，给你提醒一下，直接忽略警告等待完成，过程有点久，逛逛小网站，该干嘛干嘛</p>
</blockquote>
<blockquote>
<p>最终会在刚刚的sdk目录下生成新的tools文件夹，然后覆盖刚刚重命名的tool文件夹里的内容，删掉tools</p>
</blockquote>
<blockquote>
<p>就是把刚刚更新下来的tools里面的东西copy到tool里去，然后抛弃它</p>
</blockquote>
<blockquote>
<p>最后再次执行flutter doctor –android-licenses</p>
</blockquote>
<blockquote>
<p>并且在指令里跳出来的y/N那里，全部选y</p>
</blockquote>
<blockquote>
<p>最后提示所有的都接受了, 问题应该解决了。</p>
</blockquote>
<h2 id="🤑如何鏈接模擬器進行debug開發"><a href="#🤑如何鏈接模擬器進行debug開發" class="headerlink" title="🤑如何鏈接模擬器進行debug開發"></a>🤑如何鏈接模擬器進行debug開發</h2><blockquote>
<p>這裏我下載的是逍遙模擬器【👄进入D:\Microvirt\MEmu文件夹下，打开cmd输入以下代码】</p>
</blockquote>
<pre><code>adb connect 127.0.0.1:21503
</code></pre>
<p><strong>可能遇到的问题</strong></p>
<blockquote>
<p>拒绝连接 ‼ ‼ ‼</p>
</blockquote>
<hr>
<ul>
<li><ol>
<li>确定全局的adb版本是否与逍遥模拟器的adb版本一致</li>
</ol>
</li>
<li><ol start="2">
<li>如果不一致, 将全局变量代表的adb.exe文件复制到逍遥模拟器中的adb.exe进行替换</li>
</ol>
</li>
<li><ol start="3">
<li>版本一致后, 继续执行adb connect 127.0.0.1:21503</li>
</ol>
</li>
<li><ol start="4">
<li>出现successfully, 表示连接成功</li>
</ol>
</li>
</ul>
<h2 id="😍使用vscode启动项目"><a href="#😍使用vscode启动项目" class="headerlink" title="😍使用vscode启动项目"></a>😍使用vscode启动项目</h2><h3 id="创建-Flutter-项目"><a href="#创建-Flutter-项目" class="headerlink" title="创建 Flutter 项目"></a>创建 Flutter 项目</h3><blockquote>
<p>在 VS Code 中，点击 View &gt; Command Palette…，或者快捷键 Shift+cmd+P(MacOS) /Ctrl+Shift+P(Windows、Linux)，打开命令面板,输入 Flutter</p>
</blockquote>
<blockquote>
<p>选择 Flutter: New Project,会弹出出入框</p>
</blockquote>
<blockquote>
<p>然你输入 Flutter 工程的名字，你可以自己起一个，例如： hello_world。输入 Flutter 工程的名字后，回车，会弹出保存文件的目录地址,选择好等待即可 (大约1-2分钟) ：</p>
</blockquote>
<h3 id="运行Flutter-APP"><a href="#运行Flutter-APP" class="headerlink" title="运行Flutter APP"></a>运行Flutter APP</h3><blockquote>
<p>VS Code 有两种方式运行 Flutter APP：</p>
</blockquote>
<pre><code>Start Debugging
Start Without Debugging
</code></pre>
<h2 id="😱报错-1"><a href="#😱报错-1" class="headerlink" title="😱报错( 1 )"></a>😱报错( 1 )</h2><ul>
<li>Error running Gradle:<br>ProcessException: Process “C:\Users\asus\Desktop\myflutter\android\gradlew.bat” exited abnormally:<br>Starting a Gradle Daemon, 1 incompatible Daemon could not be reused, use –status for details</li>
</ul>
<blockquote>
<p>修改 android目录下的build.gradle文件，将google()和jcenter()注释掉，新加如下代码；</p>
</blockquote>
<pre><code>buildscript &#123;
    ext.kotlin_version = &#39;1.2.71&#39;
    repositories &#123;
        // google()
        // jcenter()
        maven &#123; url &#39;https://maven.aliyun.com/repository/google&#39; &#125;
        maven &#123; url &#39;https://maven.aliyun.com/repository/jcenter&#39; &#125;
        maven &#123; url &#39;http://maven.aliyun.com/nexus/content/groups/public&#39; &#125;
    &#125;

    dependencies &#123;
        classpath &#39;com.android.tools.build:gradle:3.2.1&#39;
        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;
    &#125;
&#125;

allprojects &#123;
    repositories &#123;
        // google()
        // jcenter()
        maven &#123; url &#39;https://maven.aliyun.com/repository/google&#39; &#125;
        maven &#123; url &#39;https://maven.aliyun.com/repository/jcenter&#39; &#125;
        maven &#123; url &#39;http://maven.aliyun.com/nexus/content/groups/public&#39; &#125;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>修改Flutter SDK包下的 flutter.gradle 文件</p>
</blockquote>
<pre><code>buildscript &#123;
    repositories &#123;
        // google()
        // jcenter()
        maven &#123; url &#39;https://maven.aliyun.com/repository/google&#39; &#125;
        maven &#123; url &#39;https://maven.aliyun.com/repository/jcenter&#39; &#125;
        maven &#123; url &#39;http://maven.aliyun.com/nexus/content/groups/public&#39; &#125;
    &#125;
    dependencies &#123;
        classpath &#39;com.android.tools.build:gradle:3.2.1&#39;
    &#125;
&#125;
</code></pre>
<h2 id="😇VSCode-开发-Flutter-必用插件"><a href="#😇VSCode-开发-Flutter-必用插件" class="headerlink" title="😇VSCode 开发 Flutter 必用插件"></a>😇VSCode 开发 Flutter 必用插件</h2><ul>
<li>Flutter Widget Snippets       //提供 Widget 代码片段，</li>
<li>Awesome Flutter Snippets      //插件提供常用函数的代码片段。</li>
<li>Bracket Pair Colorizer        // 高亮</li>
</ul>
<h2 id="😇附：模拟器名称-默认连接端口"><a href="#😇附：模拟器名称-默认连接端口" class="headerlink" title="😇附：模拟器名称 默认连接端口"></a>😇附：模拟器名称 默认连接端口</h2><pre><code>夜神安卓模拟器                   62001
逍遥模拟器                       21503
蓝叠模拟器                       5555
雷电                             5555
天天                             5037
mumu                             7555
Genymotion                       5555
腾讯手游助手 adb connect 127.0.0.1:5555
</code></pre>
<h2 id="😇附：连接真机命令"><a href="#😇附：连接真机命令" class="headerlink" title="😇附：连接真机命令"></a>😇附：连接真机命令</h2><pre><code>flutter devices
</code></pre>
]]></content>
      <tags>
        <tag>Dart</tag>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>node + koa2基础</title>
    <url>/2019/09/26/koa/</url>
    <content><![CDATA[<h1 id="node-koa2基础"><a href="#node-koa2基础" class="headerlink" title="node + koa2基础"></a>node + koa2基础</h1><blockquote>
<p><strong>使用koa2，必须保持你的node版本在7.6以上，最好实在10以上，如低于7.6版本请更新您的node版本</strong></p>
</blockquote>
<h2 id="搭建http服务"><a href="#搭建http服务" class="headerlink" title="搭建http服务+"></a>搭建http服务+</h2><blockquote>
<p>使用koa2搭建服务，只需要三步</p>
</blockquote>
<pre><code>/index.js

const Koa = require(&#39;koa&#39;)
const app = new Koa()

app.listen(3000)
</code></pre>
<p><strong>使用node命令运行即可</strong></p>
<pre><code>node index.js
</code></pre>
<blockquote>
<p>打开浏览器输入<a href="http://loaclhost:3000访问，页面中会显示Not">http://loaclhost:3000访问，页面中会显示Not</a> Found，这是因为我们没有去指定koa该返回什么内容，这一点与express不同，koa内部会自动判断，是否有返回内容</p>
</blockquote>
<h2 id="Context对象"><a href="#Context对象" class="headerlink" title="Context对象"></a>Context对象</h2><p><strong>koa内部提供了一个Context对象，表示一次对话的上下文【包括http的请求对象和响应对象】，通过操控这个对象我们可以控制返回给用户的内容</strong></p>
<pre><code>/index.js

const Koa = require(&#39;koa&#39;)
const app = new Koa()

app.use(async (ctx, next) =&gt; &#123;  
    ctx.response.body = &#39;hello&#39;
    await next()
&#125;)
app.listen(3000)
</code></pre>
<h2 id="路由【koa-router】的使用"><a href="#路由【koa-router】的使用" class="headerlink" title="路由【koa-router】的使用"></a>路由【koa-router】的使用</h2><pre><code>const router = require(&#39;koa-router&#39;)()
const Koa = require(&#39;koa&#39;)
const app = new Koa()

router.get(&#39;/list&#39;, ctx =&gt; &#123;
    ctx.response.body = &#39;hellow, list&#39;
&#125;)

router.get(&#39;/home&#39;, ctx =&gt; &#123;
    ctx.response.body = &#39;hellow, home&#39;
&#125;)

app.use(router.routes()).use(router.allowedMethods()) // 启动路由
</code></pre>
<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><h3 id="应用级别中间件"><a href="#应用级别中间件" class="headerlink" title="应用级别中间件"></a>应用级别中间件</h3><blockquote>
<p>任何路由都会经过应用级别中间件,当执行玩成后next()去匹配相应的路由</p>
</blockquote>
<pre><code>app.use(async (ctx, next) =&gt; &#123;
    await next()
&#125;)
</code></pre>
<h3 id="错误处理中间件"><a href="#错误处理中间件" class="headerlink" title="错误处理中间件"></a>错误处理中间件</h3><pre><code>app.use(async (ctx, next) =&gt; &#123;
    await next()
    if (ctx.status == 404) &#123;
        ctx.body = &#39;404&#39;
    &#125;
&#125;)
</code></pre>
<h3 id="路由中间件"><a href="#路由中间件" class="headerlink" title="路由中间件"></a>路由中间件</h3><blockquote>
<p>在匹配路由的过程中匹配到的路由会依次执行中间件,知道最后一个没有next参数</p>
</blockquote>
<pre><code>router.get(&#39;/&#39;, async (ctx, next) =&gt; &#123;
    ctx.response.body = &#39;hellow&#39;
    ctx.response.status = 200
    await next()
&#125;)

router.get(&#39;/home&#39;, ctx =&gt; &#123;
    ctx.body = &#39;hellow, world&#39;
&#125;)
</code></pre>
<h2 id="中间件的合成"><a href="#中间件的合成" class="headerlink" title="中间件的合成"></a>中间件的合成</h2><blockquote>
<p>koa-compose 模块可以将多个中间件合成为一个</p>
</blockquote>
<pre><code>const Koa = require(&#39;koa&#39;)
const app = new Koa()
const compose = require(&#39;koa-compose&#39;)

const logger = (ctx,next) =&gt; &#123;
    console.log(new Date())
    next()
&#125;

const main = (ctx,next) =&gt; &#123;
    ctx.response.body =  &#39;hello world&#39;
&#125;

const middleWares = compose([logger,main])
app.use(middleWares)
app.listen(3000)
</code></pre>
<h2 id="xtemplate模板渲染【koa-xtpl】"><a href="#xtemplate模板渲染【koa-xtpl】" class="headerlink" title="xtemplate模板渲染【koa-xtpl】"></a>xtemplate模板渲染【koa-xtpl】</h2><pre><code>app.use(xtpl(&#123;
    root: path.join(__dirname, &#39;template&#39;), // 获取到模板所在的文件夹
    extname: &#39;xtpl&#39;, // 模板后缀
    commands: &#123;&#125;
&#125;))
</code></pre>
<blockquote>
<p>新建template/login/index.xtpl（模板必须以xtpl后缀结尾）</p>
</blockquote>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;后台管理系统&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;container-fluid&quot;&gt;
        hellow, world
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<blockquote>
<p>打开index.js</p>
</blockquote>
<pre><code>router.get(&#39;/&#39;, async (ctx, next) =&gt; &#123;
    await ctx.render(&#39;login/index&#39;, &#123; title: new Date() &#125;)
    await next()
&#125;)
</code></pre>
<p><strong>运行就可以看到页面中出现  hellow, world</strong></p>
<h2 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h2><blockquote>
<p>如果网站提供了静态资源（图片，字体，样式，脚本），为他们一个个写路由就很麻烦，也没必要  koa-static 模块封装了这部分的请求</p>
</blockquote>
<pre><code>const Koa = require(&#39;koa&#39;)
const app = new Koa()
const serve = require(&#39;koa-static&#39;)
const path = require(&#39;path&#39;)

const main = serve(path.join(__dirname))

app.use(main)


app.listen(3000)
</code></pre>
<p><strong>设置之后可以直接在URL地址中输入静态资源文件名进行访问</strong></p>
]]></content>
      <tags>
        <tag>node</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title>node简单的压缩/解压缩</title>
    <url>/2019/08/10/node_zip/</url>
    <content><![CDATA[<h1 id="node简单的压缩-解压缩"><a href="#node简单的压缩-解压缩" class="headerlink" title="node简单的压缩/解压缩"></a>node简单的压缩/解压缩</h1><blockquote>
<p>为了减少网络传输数据量，http传输过程中会采用通用的压缩算法来压缩数据，gzip属于最常用的压缩算法。</p>
</blockquote>
<h2 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h2><pre><code>//压缩文件

let zlib=require(&quot;zlib&quot;)
let fs=require(&quot;fs&quot;)

var gzip=zlib.createGzip()
let rs=fs.createReadStream(&#39;./copy.js&#39;)
let ws=fs.createWriteStream(&#39;./copy.js.gz&#39;)

re.pipe(gzip).pipe.(ws)
</code></pre>
<h2 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h2><pre><code>//解压文件
let zlib=require(&quot;zlib&quot;)
let fs=require(&quot;fs&quot;)

var gzip=zlib.createGzip()
let rs=fs.createReadStream(&#39;./copy.js.gz&#39;)
let ws=fs.createWriteStream(&#39;./copy.js&#39;)

re.pipe(gzip).pipe.(ws)
</code></pre>
<h2 id="服务端的gzip压缩"><a href="#服务端的gzip压缩" class="headerlink" title="服务端的gzip压缩"></a>服务端的gzip压缩</h2><pre><code>//服务端的gzip压缩

//先起一个服务，判断req.headers[&#39;accept-encoding&#39;]是否包含gzip

let server=http.createServer(function(req,res)&#123;
    console.log(req)
    var zp=req.headers[[&#39;accept-encoding&#39;]]
    console.log(zp)
    if(zp.indexOf(&#39;gzip&#39;)!=-1)&#123;//判断是否需要gzip压缩
    
        var gzip = zlib.createGzip();
        res.writeHead(200, &#123;//记得响应 Content-Encoding，告诉浏览器：文件被 gzip 压缩过
            &#39;Content-Encoding&#39;: &#39;gzip&#39;
        &#125;);
        let ws=fs.createWriteStream(&quot;./cop.js.gz&quot;)
        fs.createReadStream(&quot;./cop.js&quot;).pipe(gzip).pipe(ws);
    &#125;else&#123;
        
        fs.createReadStream(&quot;./cop.js&quot;).pipe(res);
    &#125;
    res.end()
    
&#125;).listen(3000)
</code></pre>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>flooks:可能是最简单的 React Hooks 状态管理器【转载】</title>
    <url>/2019/08/09/React_Hook_flooks/</url>
    <content><![CDATA[<h1 id="🍸-flooks-福禄克斯"><a href="#🍸-flooks-福禄克斯" class="headerlink" title="🍸 flooks 福禄克斯"></a>🍸 flooks <sup><sup><sub><sub>福禄克斯</sub></sub></sup></sup></h1><p>一个 React Hooks 状态管理器。也许是最简单的那个。^_^</p>
<p><a href="https://www.npmjs.com/package/flooks"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img.shields.io/npm/v/flooks?style=flat-square"
                      alt="npm"
                ></a><br><a href="https://travis-ci.org/nanxiaobei/flooks"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img.shields.io/travis/nanxiaobei/flooks?style=flat-square"
                      alt="Travis (.org)"
                ></a><br><a href="https://codecov.io/gh/nanxiaobei/flooks"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img.shields.io/codecov/c/github/nanxiaobei/flooks?style=flat-square"
                      alt="Codecov"
                ></a><br><a href="https://github.com/nanxiaobei/flooks/blob/master/src/index.ts"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img.shields.io/npm/types/typescript?style=flat-square"
                      alt="npm type definitions"
                ></a><br><a href="https://github.com/nanxiaobei/flooks/blob/master/LICENSE"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img.shields.io/github/license/nanxiaobei/flooks?style=flat-square"
                      alt="GitHub"
                ></a></p>
<p>🍰 简单易用 | 🍭 自动 loading | 🍕 模块化 | 🥂 灵活</p>
<hr>
<h2 id="转载🍸-flooks-可能是最简单的-React-Hooks-状态管理器"><a href="#转载🍸-flooks-可能是最简单的-React-Hooks-状态管理器" class="headerlink" title="转载🍸 flooks: 可能是最简单的 React Hooks 状态管理器 !!!!"></a>转载<a class="link"   href="https://juejin.im/post/5d40b2436fb9a06ae835e7ed" >🍸 flooks: 可能是最简单的 React Hooks 状态管理器<i class="fas fa-external-link-alt"></i></a> !!!!</h2><hr>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>yarn add flooks
</code></pre>
<p>或</p>
<pre><code>npm install flooks
</code></pre>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><pre><code>import &#123; setModel, useModel &#125; from &#39;flooks&#39;;

const counter = &#123;
    state: &#123;
    count: 0,
    &#125;,
    actions: (&#123; model, setState &#125;) =&gt; (&#123;
    increment() &#123;
        const &#123; count &#125; = model();
        setState(&#123; count: count + 1 &#125;);
    &#125;,
    decrement() &#123;
        const &#123; count &#125; = model();
        setState(&#123; count: count - 1 &#125;);
    &#125;,
    async incrementAsync() &#123;
        const &#123; increment &#125; = model();
        await new Promise((resolve) =&gt; setTimeout(resolve, 1000));
        increment();
    &#125;,
    &#125;),
&#125;;

setModel(&#39;counter&#39;, counter);

function Counter() &#123;
    const &#123; count, increment, decrement, incrementAsync &#125; = useModel(&#39;counter&#39;);
    return (
    &lt;&gt;
        Count: &#123;count&#125;
        &lt;button onClick=&#123;increment&#125;&gt;+&lt;/button&gt;
        &lt;button onClick=&#123;decrement&#125;&gt;-&lt;/button&gt;
        &lt;button onClick=&#123;incrementAsync&#125;&gt;+ async&#123;incrementAsync.loading &amp;&amp; &#39;...&#39;&#125;&lt;/button&gt;
    &lt;/&gt;
    );
&#125;
</code></pre>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><a href="https://codesandbox.io/s/flooks-gqye5"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://codesandbox.io/static/img/play-codesandbox.svg"
                      alt="Edit flooks"
                ></a></p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="setModel"><a href="#setModel" class="headerlink" title="setModel()"></a>setModel()</h3><pre><code>setModel(name, model);
</code></pre>
<p>接收一个名称字符串和一个 model 对象，初始化 model。</p>
<p>model 对象需包含一个 <code>state</code> 对象和一个 <code>actions</code> 函数。</p>
<h3 id="useModel"><a href="#useModel" class="headerlink" title="useModel()"></a>useModel()</h3><pre><code>const &#123; someState, someAction &#125; = useModel(name);
</code></pre>
<p>一个 React Hook。接收一个名称，返回初始化后的 model，包含其所有 state 和 actions。</p>
<h3 id="model-setState-gt-realActions"><a href="#model-setState-gt-realActions" class="headerlink" title="({ model, setState }) =&gt; realActions"></a>({ model, setState }) =&gt; realActions</h3><pre><code>actions: (&#123; model, setState &#125;) =&gt; (&#123;
    someAction() &#123;&#125;,
&#125;);
</code></pre>
<p><code>actions</code> 的参数中包含两个函数，<code>model()</code> 和 <code>setState()</code>。</p>
<h4 id="model"><a href="#model" class="headerlink" title="model()"></a>model()</h4><pre><code>const &#123; someState, someAction &#125; = model(name?);
</code></pre>
<p>返回与 <code>useModel()</code> 相同，但当获取自身 model 时，<code>name</code> 可以忽略。</p>
<p>即 <code>model()</code> 获取自身 model，<code>model(&#39;other&#39;)</code> 获取其它 model。</p>
<h4 id="setState"><a href="#setState" class="headerlink" title="setState()"></a>setState()</h4><pre><code>setState(payload);
</code></pre>
<p>用于更新自身 model 的 state，传入 <code>payload</code> 对象，无法更新其它 model。</p>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="自动-loading-？"><a href="#自动-loading-？" class="headerlink" title="自动 loading ？"></a>自动 loading ？</h3><pre><code>actions: (&#123; model, setState &#125;) =&gt; (&#123;
    async someAsyncAction() &#123;&#125;,
&#125;);
</code></pre>
<p>当一个 action 为异步时，<code>someAsyncAction.loading</code> 可供使用。</p>
<h3 id="代码分割？"><a href="#代码分割？" class="headerlink" title="代码分割？"></a>代码分割？</h3><p>天然支持。在组件中调用 <code>setModel()</code>，然后使用像 <a href="https://github.com/smooth-code/loadable-components"><code>loadable-components</code></a> 这样的库。</p>
<h3 id="统一设置-model？"><a href="#统一设置-model？" class="headerlink" title="统一设置 model？"></a>统一设置 model？</h3><pre><code>import &#123; setModel &#125; from &#39;flooks&#39;;
import a from &#39;...&#39;;
...

const models = &#123; a, b, c &#125;;
Object.entries(models).forEach(([name, model]) =&gt; &#123;
    setModel(name, model);
&#125;);
</code></pre>
<p>不推荐统一设置。请在组件中分别调用 <code>setModel()</code>，那样更加清晰和灵活。</p>
<h2 id="理念"><a href="#理念" class="headerlink" title="理念"></a>理念</h2><p>1. 我们的理念是去中心化，因此我们建议将 model 和路由入口组件绑定为一个模块，在组件中调用 <code>setModel()</code> 来绑定二者。</p>
<p>2. 不需要添加像 <code>store.js</code> 或 <code>models.js</code> 这样的文件，因为现在不需要从顶部分发 store。没有了中心化的 store，只有下层由组件和 model 组成的一个个模块。</p>
<p>3. 一个 model 有自己的空间，使用 <code>useModel()</code> 和 <code>model()</code>，可以访问到其他所有的 model。model 都是独立的，但同时也是连接的。</p>
<p>4. 不要使用 <code>setmodel()</code> 多次初始化同一个 model，如果有一个 “common” model 在多个地方使用，建议在一个上层组件中进行初始化，比如 <code>App.jsx</code>。</p>
<p>5. 就这些，完事啦~</p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p><a class="link"   href="https://github.com/nanxiaobei/flooks/blob/master/LICENSE" >MIT License<i class="fas fa-external-link-alt"></i></a> (c) <a class="link"   href="https://mrlee.me/" >nanxiaobei<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>hooks</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>React Hook</title>
    <url>/2019/08/08/Hooks/</url>
    <content><![CDATA[<h1 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h1><p><strong>有状态的组件没有渲染，有渲染的组件没有状态。在现在回过头来看，这个原则会为我们后续向Hooks的迁移提供非常大的便利。</strong></p>
<h2 id="🔥-Hook简介"><a href="#🔥-Hook简介" class="headerlink" title="🔥 Hook简介"></a>🔥 Hook简介</h2><blockquote>
<p>Hook是react16.8的新增特性，可以在不编写class类的情况下使用state以及react的其他特性<br>React Hooks要解决的问题是状态共享，不会产生jsx嵌套问题</p>
</blockquote>
<h2 id="🏆-Hooks的运行规则"><a href="#🏆-Hooks的运行规则" class="headerlink" title="🏆 Hooks的运行规则"></a>🏆 Hooks的运行规则</h2><ul>
<li>不能再循环中，条件语句和嵌套函数中调用hooks</li>
<li>只在react中函数组件中的hooks</li>
</ul>
<h2 id="🌟-React-Hooks的特点"><a href="#🌟-React-Hooks的特点" class="headerlink" title="🌟 React Hooks的特点"></a>🌟 React Hooks的特点</h2><ul>
<li>多个状态不会产生嵌套</li>
<li>Hooks还可以引用其他Hooks</li>
<li>更容易【更清晰】将组件的UI和状态进行分离</li>
<li>Hooks函数必须使用‘use’命名开头</li>
</ul>
<h2 id="📌-State-Hook"><a href="#📌-State-Hook" class="headerlink" title="📌 State Hook"></a>📌 State Hook</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">function Example() &#123;</span><br><span class="line">  &#x2F;&#x2F; 声明一个叫 “count” 的 state 变量。</span><br><span class="line">  const [count, setCount] &#x3D; useState(0); &#x2F;&#x2F; 使用useState来定义state [参数名字, 改变参数的方法]</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 也可以多个声明state 【但是必须保证调用的顺序一样】</span><br><span class="line"></span><br><span class="line">  const [tods, settods] &#x3D; useState(&#39;this is count&#39;)</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>函数组件会有特殊的处理方式</li>
<li>在render阶段，再将函数Fiber内容的实例化的时候去处理全局中的Hooks对象的指向</li>
<li>最终userState是调用内部函数mountState去设置state的stringif</li>
<li>在mountState会对传入的参数如果是函数会对其先执行，得出返回值在继续运行</li>
<li>在mountState中会创建一个闭包事件，将当前的Hooks所在的Fiber节点以及Hooks队列对象作为参数绑定在函数，并返回0</li>
</ul>
<h2 id="⚡️-Effect-Hook"><a href="#⚡️-Effect-Hook" class="headerlink" title="⚡️ Effect Hook"></a>⚡️ Effect Hook</h2><blockquote>
<p>useEffect 给函数组件添加副作用，他和class组件中的componentDidMount、componentDidUpdate 和 componentWillUnmount具有相同的用途</p>
</blockquote>
<h3 id="实现componentDidMount-副作用函数"><a href="#实现componentDidMount-副作用函数" class="headerlink" title="实现componentDidMount 副作用函数"></a>实现componentDidMount 副作用函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 使用浏览器的 API 更新页面标题</span><br><span class="line">  document.title &#x3D; &#96;You clicked $&#123;count&#125; times&#96;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实现componentDidUpdate-副作用函数"><a href="#实现componentDidUpdate-副作用函数" class="headerlink" title="实现componentDidUpdate 副作用函数"></a>实现componentDidUpdate 副作用函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 使用浏览器的 API 更新页面标题</span><br><span class="line">  document.title &#x3D; &#96;You clicked $&#123;count&#125; times&#96;;</span><br><span class="line">&#125;, [count]); &#x2F;&#x2F; 只在count发生改变的情况下调用</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实现componentWillUnmount-副作用函数"><a href="#实现componentWillUnmount-副作用函数" class="headerlink" title="实现componentWillUnmount 副作用函数"></a>实现componentWillUnmount 副作用函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 使用浏览器的 API 更新页面标题</span><br><span class="line">  document.title &#x3D; &#96;You clicked $&#123;count&#125; times&#96;;</span><br><span class="line">  return () &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 清除副作用操作</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>userEffect的执行时机都发生在每次渲染之后，无论首次渲染还是更新渲染</li>
<li>userEffect只有在函数组件中执行，不能再非函数组件中执行</li>
<li>userEffect可以在函数组件中执行多次，是按调用顺序执行的</li>
<li>userEffect传入的函数，return是在组件卸载的时候执行的</li>
<li>userEffect的执行，是由他的第二参数来控制的，而且第二的参数必须是一个数组，react会对数组中的每一项与上次的数组进行比较，如果不同，则才会去执行函数</li>
<li>userEffect采用的是异步的方案执行，类似于js中的setTimeout，将userEffect进行异步执行</li>
</ul>
<p><strong>实用之处</strong></p>
<p>  再实现重复的数据请求中使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getData() &#123;</span><br><span class="line">  const [data, setdata] &#x3D; useState(null)</span><br><span class="line"></span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    axios(&#39;&#x2F;a&#x2F;b&#39;).then(res &#x3D;&gt; &#123;</span><br><span class="line">      setdata(res.data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  return data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在别的函数组件中直接调用即可获取到数据【当然加入第二参数是为了防止数据更新的时候再次触犯请求数据执行】【灵活 的写法有很多种】</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="🔐-注意事项"><a href="#🔐-注意事项" class="headerlink" title="🔐 注意事项"></a>🔐 注意事项</h2><ul>
<li>不可以在hooks中使用条件语句【会影响hooks的调用规则（顺序）】，会导致调用混乱，产生bug</li>
<li>如果我们想执行一个判断可以将其放在内部来使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 将条件语句放置在hooks中</span><br><span class="line">  if (val !&#x3D; &#39;&#39;) &#123;</span><br><span class="line">    document.title &#x3D; val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>我们可以去自定义hooks，但我们自定义的hooks必须以use开头，这是一种约定，它可以识别我们是否遵循了规范，他是hooks的规范，不是react的</li>
</ul>
<h2 id="💕-useContent"><a href="#💕-useContent" class="headerlink" title="💕 useContent"></a>💕 useContent</h2><p><strong>可以使用useContext进行跨组件传值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 父组件</span><br><span class="line">import React, &#123;useState&#125; from &#39;react&#39;</span><br><span class="line">export const myContent &#x3D; React.createContext(null)</span><br><span class="line">function Content() &#123;</span><br><span class="line">  const [val, setval] &#x3D; useState(myContent)</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;input val &#x3D; &#123;val&#125; onChange((e) &#x3D;&gt; &#123;setval(e.target.value)&#125;)&#x2F;&gt;</span><br><span class="line">      &lt;myContent.Provider&gt;</span><br><span class="line">        &lt;Ptemp&gt;&lt;&#x2F;Ptemp&gt;</span><br><span class="line">      &lt;myContent.Provider&gt;</span><br><span class="line">    &lt;&#x2F;&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">export default Content</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 子组件</span><br><span class="line"></span><br><span class="line">import React, &#123;useContext&#125; from &#39;react&#39;</span><br><span class="line">import &#123;myContent&#125; from &#39;.&#x2F;home&#39;</span><br><span class="line">function Ptemp() &#123;</span><br><span class="line">  const val &#x3D; useContext(myContent)</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;p&gt;&#123;val&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="🍭-useReducer"><a href="#🍭-useReducer" class="headerlink" title="🍭 useReducer"></a>🍭 useReducer</h2><p>**useReducer是useState的另一种替代，他接收(state, action) =&gt; newState, 并且返回了一个与当前state成对的dispatch方法</p>
<h3 id="例1：最小的简单模式【计数器】"><a href="#例1：最小的简单模式【计数器】" class="headerlink" title="例1：最小的简单模式【计数器】"></a>例1：最小的简单模式【计数器】</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reducer.ts</span><br><span class="line"></span><br><span class="line">export const initialState &#x3D; 0</span><br><span class="line">const renducer &#x3D; (state, action) &#x3D;&gt; &#123;</span><br><span class="line">  switch(action) &#123;</span><br><span class="line">    case &#39;count&#39;:</span><br><span class="line">      console.log(state)</span><br><span class="line">      return state + 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default renducer</span><br><span class="line"></span><br><span class="line">PgReducer.tsx</span><br><span class="line"></span><br><span class="line">import React, &#123;useState, useReducer&#125; from &#39;react&#39;</span><br><span class="line"></span><br><span class="line">import renducer, &#123;initialState&#125; from &#39;..&#x2F;..&#x2F;renducer&#x2F;expamel&#39;</span><br><span class="line"></span><br><span class="line">function testRenducer() &#123;</span><br><span class="line">  const [count, dispatch] &#x3D; useReducer(renducer, initialState)</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;p&gt;&#123;count&#125;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;p onClick&#x3D;&#123;() &#x3D;&gt; &#123;dispatch(&#39;count&#39;)&#125;&#125;&gt;+&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default testRenducer</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="⚽-useRef"><a href="#⚽-useRef" class="headerlink" title="⚽ useRef"></a>⚽ useRef</h2><p><strong>useRef返回一个可变的ref对象其.current属性被初始化为传入参数，返回的ref对象在组件的整个生命周期内保持不变</strong></p>
<ul>
<li>常见的就是访问子组件</li>
<li>获取一些dom元素的参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; useState, useRef, useEffect &#125; from &#39;react&#39;</span><br><span class="line"></span><br><span class="line">function PgRef() &#123;</span><br><span class="line">  const ulRef &#x3D; useRef(null)</span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(ulRef.current.offsetHeight)</span><br><span class="line">  &#125;)</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;p className&#x3D;&#39;testP&#39; ref&#x3D;&#123;ulRef&#125;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default PgRef</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="🏹-原理实现"><a href="#🏹-原理实现" class="headerlink" title="🏹 原理实现"></a>🏹 原理实现</h2><h3 id="🔨-useState"><a href="#🔨-useState" class="headerlink" title="🔨 useState"></a>🔨 useState</h3><p><strong>首先我们来看一下useState的调用方式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const [count, setCount] &#x3D; useState(0)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>实现</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let memoizedState &#x3D; [] &#x2F;&#x2F; memoizedState存储状态的数组</span><br><span class="line">let curson &#x3D; 0 &#x2F;&#x2F; 当前memoizedState的下标</span><br><span class="line">function useState(ininvalState) &#123;</span><br><span class="line">  memoizedState[curson] &#x3D; memoizedState[curson] || ininvalState</span><br><span class="line">  function setState(newState) &#123;</span><br><span class="line">    memoizedState[curson] &#x3D; newState</span><br><span class="line">    render()</span><br><span class="line">  &#125;</span><br><span class="line">  return [memoizedState[curson++], setState] &#x2F;&#x2F; 每个hooks调用都会递增curson, 从当前组件中取出状态</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>只是简单 的实现了一下useState【<strong>useState这个hooks这后台使用useReducer，他的返回结果其实已经是Reducer状态</strong>】</p>
</blockquote>
<h3 id="🔨-useEffect"><a href="#🔨-useEffect" class="headerlink" title="🔨 useEffect"></a>🔨 useEffect</h3><p><strong>首先我们来看一下useEffect的调用方式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(count)</span><br><span class="line">&#125;, [count])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>实现</p>
</blockquote>
<p><strong>useEffect存在两个参数（callback, dep数组），如果dep数组不存在的话，每次render函数执行后，都会去执行callback函数，如果dep数组存在的时候，当dep发生改变的时候callback才会去执行</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let memoizedState &#x3D; []; &#x2F;&#x2F; hooks 存放在这个数组</span><br><span class="line">let cursor &#x3D; 0; &#x2F;&#x2F; 当前 memoizedState 下标</span><br><span class="line">function useEffect(callback, dep) &#123;</span><br><span class="line">  const hasDeps &#x3D; !dep &#x2F;&#x2F; 是否有dep数组</span><br><span class="line">  const deps &#x3D; memoizedState[cursor]</span><br><span class="line">  const hasChangeDeps &#x3D; deps ? !dep.every((el, i ) &#x3D;&gt; el &#x3D;&#x3D;&#x3D; deps[i]) : true</span><br><span class="line">  if (hasDeps || hasChangeDeps) &#123;</span><br><span class="line">    callback();</span><br><span class="line">    memoizedState[cursor] &#x3D; dep</span><br><span class="line">  &#125;</span><br><span class="line">  cursor++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>只是简单 的实现了一下useEffect, 在react调用会有自己的调用机制<br>react中是通过单链表的方式来代替数组的，通过next来串联所有的hooks的</p>
</blockquote>
<h2 id="🔫-原理链接-https-juejin-im-post-5c99a75af265da60ef635898-comment"><a href="#🔫-原理链接-https-juejin-im-post-5c99a75af265da60ef635898-comment" class="headerlink" title="🔫 原理链接 https://juejin.im/post/5c99a75af265da60ef635898#comment"></a>🔫 原理链接 <a class="link"   href="https://juejin.im/post/5c99a75af265da60ef635898#comment" >https://juejin.im/post/5c99a75af265da60ef635898#comment<i class="fas fa-external-link-alt"></i></a></h2><h2 id="🛡-Hooks队列"><a href="#🛡-Hooks队列" class="headerlink" title="🛡 Hooks队列"></a>🛡 Hooks队列</h2><ul>
<li>在初次渲染的时候，他的初始状态会被创建</li>
<li>他的状态可以在运行的时候进行更改</li>
<li>react可以在后续的渲染中记住hooks的状态</li>
<li>react可以根据调用的顺序提供给你正确的状态</li>
<li>react知道当前的hooks属于哪个部分</li>
</ul>
]]></content>
      <tags>
        <tag>hooks</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>React-Native填坑之删除第三方开源组件的依赖包</title>
    <url>/2019/05/24/react-native%20unlink/</url>
    <content><![CDATA[<h2 id="React-Native填坑之删除第三方开源组件的依赖包"><a href="#React-Native填坑之删除第三方开源组件的依赖包" class="headerlink" title="React-Native填坑之删除第三方开源组件的依赖包"></a>React-Native填坑之删除第三方开源组件的依赖包</h2><p><strong>今天遇到了一个问题：下载了react-native-webview的开源组件，可是在Android中遇到了问题，编译不通过，我想删除这个组件，然后写其他的功能，以后再添加这个地图功能，可是发现无法删除干净，android和ios原生都编译失败。就这个问题研究了下，现将方法卸载下面：</strong></p>
<pre><code>npm uninstall -s -D -O react-native-webview
</code></pre>
<hr>
<blockquote>
<p>进入Android目录，找到setting.gradle文件</p>
</blockquote>
<pre><code>删除所有有关该包的依赖
</code></pre>
<hr>
<blockquote>
<p>然后进入android/app目录下，打开build.gradle</p>
</blockquote>
<pre><code>删除所有有关该包的依赖
</code></pre>
<hr>
<blockquote>
<p>打开android/app/src/main/java/com/包名/MainApplication.java,</p>
</blockquote>
<pre><code>删除所有有关该包的依赖
</code></pre>
<hr>
<blockquote>
<p>然后终端运行</p>
</blockquote>
<pre><code>npm install
react-native run-android
</code></pre>
<hr>
<blockquote>
<p>成功！！！</p>
</blockquote>
]]></content>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title>使用react-native基础环境搭建</title>
    <url>/2019/05/22/react-native-windows/</url>
    <content><![CDATA[<h2 id="使用react-native基础环境搭建"><a href="#使用react-native基础环境搭建" class="headerlink" title="使用react-native基础环境搭建"></a>使用react-native基础环境搭建</h2><h2 id="Android-Studio开发window环境搭建"><a href="#Android-Studio开发window环境搭建" class="headerlink" title="Android Studio开发window环境搭建"></a>Android Studio开发window环境搭建</h2><h3 id="Android-开发环境搭建"><a href="#Android-开发环境搭建" class="headerlink" title="Android 开发环境搭建"></a>Android 开发环境搭建</h3><p><strong>下载jdk</strong> </p>
<blockquote>
<p>在这里你可以点击<a class="link"   href="https://www.oracle.com/technetwork/java/javase/downloads/index.html" >链接<i class="fas fa-external-link-alt"></i></a>去下载</p>
</blockquote>
<p><strong>操作步骤按照下图进行操作</strong></p>
<blockquote>
<p> 点进去以后是这么个页面</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.0.png"
                     
                ></p>
<hr>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.1.png"
                     
                ></p>
<hr>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.2.png"
                     
                ></p>
<hr>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.3.png"
                     
                ></p>
<hr>
<p><strong>傻瓜式操作</strong></p>
<h3 id="接下来是配置环境变量"><a href="#接下来是配置环境变量" class="headerlink" title="接下来是配置环境变量"></a>接下来是配置环境变量</h3><blockquote>
<p>小娜搜索</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.4.png"
                     
                ></p>
<hr>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.5.png"
                     
                ></p>
<hr>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.6.png"
                     
                ></p>
<hr>
<p>变量名：JAVA_HOME<br>变量值：当然是你安装的jdk目录了</p>
<blockquote>
<p>编辑Path变量值</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.7.png"
                     
                ></p>
<p>在Path值的前头加上 %JAVA_HOME%\bin;</p>
<blockquote>
<p>CLASSPATH变量</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.8.png"
                     
                ></p>
<hr>
<p>看一下如果你的系统变量中没有CLASSPATH变量，就新建一个输入变量值 </p>
<pre><code>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;
</code></pre>
<blockquote>
<p>测试</p>
</blockquote>
<p>好了，现在我们来测试一下我们的环境变量是否配置成功 “开始”–“cmd”打开我们的dos命了窗口输入 </p>
<pre><code>javac
</code></pre>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.9.png"
                     
                ></p>
<hr>
<h3 id="安装Android-Studio"><a href="#安装Android-Studio" class="headerlink" title="安装Android Studio"></a>安装Android Studio</h3><p><strong>地址： <a class="link"   href="http://www.android-studio.org/"  title="http://www.android-studio.org/">http://www.android-studio.org/<i class="fas fa-external-link-alt"></i></a></strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.10.png"
                     
                ></p>
<hr>
<blockquote>
<p>现在的安装包一般没有sdk安装，直接下一步，不要慌<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.11.png"
                     
                ></p>
</blockquote>
<hr>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.12.png"
                     
                ></p>
<hr>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.13.png"
                     
                ></p>
<hr>
<p><strong>成功安装后，</strong></p>
<h3 id="Android-Studio配置"><a href="#Android-Studio配置" class="headerlink" title="Android Studio配置"></a>Android Studio配置</h3><p>加载本地配置信息提示</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.14.png"
                     
                ></p>
<p><strong>刚开始打开的时候会问我们是否加载本地的配置信息，其实就是android studio的配置环境信息等，如果你以前没有用过，忽略掉就好了。直接按默认的点ok启动android studio</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.15.png"
                     
                ></p>
<hr>
<p><strong>接下来如果还有，直接Cancel</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.16.png"
                     
                ></p>
<hr>
<p><strong>这时候我们需要sdk</strong></p>
<p>附上链接<a class="link"   href="https://www.androiddevtools.cn/"  title="https://www.androiddevtools.cn/">https://www.androiddevtools.cn/<i class="fas fa-external-link-alt"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.17.png"
                     
                ></p>
<hr>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.18.png"
                     
                ></p>
<hr>
<blockquote>
<p>安装完以后是这个样子</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.19.png"
                     
                ></p>
<hr>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.20.png"
                     
                ></p>
<hr>
<h3 id="设置sdk的环境变量"><a href="#设置sdk的环境变量" class="headerlink" title="设置sdk的环境变量"></a>设置sdk的环境变量</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.21.png"
                     
                ></p>
<hr>
<p><strong>设置adb环境变量【用来链接手机，这里不过多阐述】</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.22.png"
                     
                ></p>
<hr>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.23.png"
                     
                ></p>
<hr>
<p><strong>验证</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.24.png"
                     
                ></p>
<hr>
<p><strong>基础环境以搭建完成</strong></p>
<blockquote>
<p><strong>这里需要着重强调必须node版本为10以上</strong></p>
</blockquote>
<blockquote>
<p>如何安装node就不都在过多阐述</p>
</blockquote>
<p>*** 安装 react-native-cli ***</p>
<pre><code>npm install -g react-native-cli
</code></pre>
<p><strong>安装完成后，通过 react-native-cli -v 查看版本，确定是否安装成功</strong></p>
<h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p><strong>到指定目录下，通过命令行初始化一个项目：</strong></p>
<pre><code>react-native init NewProject
</code></pre>
<p>随后开始初始化项目，下载资源：</p>
<p>运行项目</p>
<p>来到项目根目录下，通过输入如下命令来运行项目：</p>
<pre><code>react-native run-android
</code></pre>
<p><strong>输入命令后，项目开始初始化运行，运行过程中会打开一个 node 服务窗口，如下所示：</strong></p>
<ul>
<li><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.25.png"
                     
                ></li>
</ul>
<hr>
<p><strong>然后重新输入命令 react-native run-android 来初始化运行项目，程序首先会解压 gradle 压缩文件，第一次初始化可能需要一点时间：</strong></p>
<p><strong>初始化完成后，项目运行成功，可以在手机上看到如下界面：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/2.26.png"
                     
                ></p>
<hr>
<blockquote>
<p>到现在为止，一个环境就搭建完成了，中还有少许挫折，但是还是成功了。。。。。。。。。</p>
</blockquote>
]]></content>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title>ts的学习历程 -- 02</title>
    <url>/2019/05/16/ts-02/</url>
    <content><![CDATA[<h2 id="ts的学习历程-–-02"><a href="#ts的学习历程-–-02" class="headerlink" title="ts的学习历程 – 02"></a>ts的学习历程 – 02</h2><h2 id="ts接口"><a href="#ts接口" class="headerlink" title="ts接口"></a>ts接口</h2><p><strong>ts的核心原则之一是对该值所对应的数据类型进行一个检测</strong></p>
<blockquote>
<p>作用：为你规定的这些类型命名，【签订契约】</p>
</blockquote>
<pre><code>/**
 * 通过ts对函数的参数进行检测
 */
function lable(lable: &#123;lable: string&#125;)&#123;
  console.log(lable)
&#125;

let lables = &#123;
  lable: &#39;storing&#39;,
  mine: 1
&#125;

lable(lables)
</code></pre>
<blockquote>
<p>对参数lable进行检测，必须包括一个lable属性，并且值为string类型</p>
</blockquote>
<p><strong>使用接口进行描述</strong></p>
<pre><code>interface lableV &#123;
  lable: string;
&#125;
function lable(lable: lableV)&#123;
  console.log(lable)
&#125;

let lables = &#123;
  lable: &#39;storing&#39;,
  mine: 1
&#125;

lable(lables)
</code></pre>
<blockquote>
<p>lableV此接口就相当于一个名字，用来描述参数的要求【它代表了有一个label属性且类型为string的对象】</p>
</blockquote>
<h2 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h2><blockquote>
<p>接口里面的属性不全是必须的，根据页面需求，有些参数可传可不传：</p>
</blockquote>
<pre><code>interface lableV &#123;
  lable?: string;
  mine?: number
&#125;
function lable(lable: lableV)&#123;
  console.log(lable)
&#125;

let lables = &#123;
  lable: &#39;storing&#39;,
  mine: 1
&#125;

lable(lables)
</code></pre>
<h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><p><strong>一些对象属性只能在对象创建的时候进行创建的时候修改他的值，你可以使用readonly指定只读属性</strong></p>
<pre><code>interface lableV &#123;
  readonly a?: string;
  readonly b?: number
&#125;

let str: lableV = &#123;
  a: &#39;1&#39;,
  b: 1
&#125;

str.a = 1  // 报错 。 Cannot assign to &#39;a&#39; because it is a read-only property.ts(2540)
</code></pre>
<blockquote>
<p>确保创建完以后不能再修改</p>
</blockquote>
<blockquote>
<p>typeScript具有ReadonlyArray<T>类型，它与Array<T>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</p>
</blockquote>
<pre><code>let a: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray&lt;number&gt; = a;
ro[0] = 12; // error!         类型“readonly number[]”中的索引签名仅允许读取。ts(2542)
ro.push(5); // error!         类型“readonly number[]”上不存在属性“push”。ts(2339)
ro.length = 100; // error!    Cannot assign to &#39;length&#39; because it is a read-only property.ts(2540)
a = ro; // error!             Type &#39;readonly number[]&#39; is missing the following properties from type &#39;number[]&#39;: pop, push, reverse, shift, and 6 more.ts(2740)

    ||

  //使用类型断言重写
a = ro as number[];
</code></pre>
<blockquote>
<p>最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用const，若做为属性则使用readonly。</p>
</blockquote>
<h2 id="额外的属性检测"><a href="#额外的属性检测" class="headerlink" title="额外的属性检测"></a>额外的属性检测</h2><p><strong>当我们在传参的过程中，对于某个属性，写错的时候，如下</strong></p>
<pre><code>interface lableV &#123;
    lable?: string;
    mine?: number;
    maxs: number;
  &#125;
  function lable(lable: lableV)&#123;
    console.log(lable)
  &#125;
  
  let lables = &#123;
    lable: &#39;storing&#39;,
    mine: 1,
    max: 20,
    min: 10,
    array: [1,2,3,5]
  &#125;
  
  lable(lables)

  //类型“&#123; lable: string; mine: number; max: number; min: number; array: number[]; &#125;”的参数不能赋给类型“lableV”的参数。
  //Property &#39;maxs&#39; is missing in type &#39;&#123; lable: string; mine: number; max: number; min: number; array: number[]; &#125;&#39; but required in type &#39;lableV&#39;.ts(2345)
  //type.ts(50, 5): &#39;maxs&#39; is declared here
</code></pre>
<blockquote>
<p>在js中没什么问题，如果传递的参数在函数中没有使用到，则可以正确执行，但是在ts中会认为这段代码存在bug，最佳的解决方法如下</p>
</blockquote>
<pre><code>interface SquareConfig &#123;
    color?: string;
    width?: number;
    [propName: string]: any;
&#125;
</code></pre>
<h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p><strong>接口也可以用来描述函数类型</strong></p>
<pre><code>interface SearchFunc &#123;
    (source: string, subString: string): boolean;
&#125;


let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) &#123;
  let result = source.search(subString);
  return result &gt; -1;
&#125;

 //不能将类型“(source: string, subString: string) =&gt; string”分配给类型“SearchFunc”。
   //不能将类型“string”分配给类型“boolean”。ts(2322)
</code></pre>
<blockquote>
<p>SearchFunc 该接口规定了函数的参数类型，以及该函数的返回值，如果与接口中定义的不匹配，则会出错</p>
</blockquote>
<h2 id="可索引类型"><a href="#可索引类型" class="headerlink" title="可索引类型"></a>可索引类型</h2><p><strong>接口可以描述那些能够通过索引得到的类型，可索引类型具有一个索引签名，它描述了对象索引的类型，还有相应的索引值类型，索引签名支持两种类型：number 和 string，但是由于 number 实际上会被转化为 string 类型（根据对象 key 的性质），所以需要遵守：number 索引的返回值类型是 string 索引的返回值类型的子类型。</strong></p>
<pre><code>interface IPerson &#123;
    [index: string]: string;
&#125;
let me: IPerson = &#123;love: &#39;TS&#39;&#125;
me.name = &#39;funlee&#39;;
me.age = 18; // error 不能将类型“18”分配给类型“string”。ts(2322)
</code></pre>
<blockquote>
<p>如果 interface 里还声明了一个和索引签名索引返回值类型不匹配的属性，会报错</p>
</blockquote>
<pre><code>interface ITest &#123;
    [index: string]: string;
    name: string;
    age: 18; // 报错，因为返回值类型是number，不符合string类型  [类型“18”的属性“age”不能赋给字符串索引类型“string”。ts(2411)]
 &#125;
</code></pre>
<blockquote>
<p>还可以声明一个 readonly 的索引签名</p>
</blockquote>
<pre><code>  interface IPerson &#123;
    readonly [index: string]: string;
  &#125;
  let p: IPerson = &#123;name: &#39;funlee&#39;&#125;;
  p.love = &#39;TS&#39;; // error   类型“IPerson”中的索引签名仅允许读取。ts(2542)
</code></pre>
<h2 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h2><p><strong>typeScript也可以使用class来实现一个接口，只不过他描述得是类的公共部分，因此不会检查类是否具有某些私有成员</strong></p>
<pre><code>interface ISome &#123;
  prop: string // 描述一个属性
  method(paramA: string, paramB: number) // 描述一个方法
&#125;
class A implements ISome &#123;
  prop: &#39;propValue&#39;
  method(a: string, b: number) &#123;
    // ...
  &#125;
  constructor(paramA: number)&#123;
    // ...
  &#125;
&#125;
</code></pre>
<h2 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h2><p><strong>和类一样，接口也可以互相继承</strong></p>
<pre><code>interface Shape &#123;
  color: string;
&#125;
interface Square extends Shape &#123;
  sideLength: number;
&#125;
const square = &lt;Square&gt;&#123;&#125;;
square.color = &#39;blue&#39;;
square.sideLength = 10;
</code></pre>
<p><strong>同时，一个接口也可以继承多个接口，创建出多个接口的合成接口，如：</strong></p>
<pre><code>interface Shape &#123;
  color: string;
&#125;
interface PenStroke &#123;
  penWidth: number;
&#125;
interface Square extends Shape, PenStroke &#123;
  sideLength
&#125;
const square = &lt;Square&gt;&#123;&#125;;
square.color = &#39;blue&#39;;
square.sideLength = 10;
square.penWidth = 5.0;
</code></pre>
]]></content>
      <tags>
        <tag>ts</tag>
      </tags>
  </entry>
  <entry>
    <title>ts的学习历程 -- 01</title>
    <url>/2019/05/10/ts-01/</url>
    <content><![CDATA[<h2 id="ts的学习历程-–-01"><a href="#ts的学习历程-–-01" class="headerlink" title="ts的学习历程 – 01"></a>ts的学习历程 – 01</h2><h2 id="ts是什么？"><a href="#ts是什么？" class="headerlink" title="ts是什么？"></a>ts是什么？</h2><blockquote>
<p>TypeScript 是 JavaScript 的一个超集，支持 ECMAScript 6 标准。</p>
</blockquote>
<hr>
<blockquote>
<p>TypeScript 由微软开发的自由和开源的编程语言。</p>
</blockquote>
<hr>
<blockquote>
<p>TypeScript 设计目标是开发大型应用，它可以编译成纯 JavaScript，编译出来的 JavaScript 可以运行在任何浏览器上。</p>
</blockquote>
<h2 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h2><h3 id="ts是一种给js添加特性的扩展性语言，扩展功能如下："><a href="#ts是一种给js添加特性的扩展性语言，扩展功能如下：" class="headerlink" title="ts是一种给js添加特性的扩展性语言，扩展功能如下："></a>ts是一种给js添加特性的扩展性语言，扩展功能如下：</h3><ul>
<li>基础类型</li>
<li>接口</li>
<li>类</li>
<li>函数</li>
<li>泛型</li>
<li>类型兼容性</li>
<li>高级类型</li>
<li>模块</li>
<li>命名空间</li>
<li>混入</li>
</ul>
<h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><h3 id="js是弱语言类型，而ts类似c-这种强语言，可以对变量进行处理，规定变量的类型，让程序变得可维护性强，有价值。"><a href="#js是弱语言类型，而ts类似c-这种强语言，可以对变量进行处理，规定变量的类型，让程序变得可维护性强，有价值。" class="headerlink" title="js是弱语言类型，而ts类似c++这种强语言，可以对变量进行处理，规定变量的类型，让程序变得可维护性强，有价值。"></a>js是弱语言类型，而ts类似c++这种强语言，可以对变量进行处理，规定变量的类型，让程序变得可维护性强，有价值。</h3><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>我们可以在ts中进行如下声明：</p>
<pre><code>let isDone: boolean = false
</code></pre>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>和js一样，ts中的数字都是浮点数，类型为number.</p>
<pre><code>let num: number = 6
</code></pre>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><pre><code>let str: string = &quot;26&quot;
</code></pre>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>有两种可以定义数组的方式</p>
<pre><code>let list: number[] = [1, 2, 3]   // 表示由此类型元素组成的一个数组
</code></pre>
<hr>
<pre><code>let list: Array&lt;number&gt; = [1, 2, 3] // 使用数组泛型Array&lt;元素类型&gt;
</code></pre>
<h3 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h3><p>元组类型表示允许一个已知元素数量和类型的数组，各元素的类型不必相同</p>
<pre><code>let x: [string, number];

x = [&#39;hello&#39;, 10];
</code></pre>
<h3 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举 enum"></a>枚举 enum</h3><p>类型是对JavaScript标准数据类型的一个补充</p>
<pre><code>enum Color &#123;Red, Green, Blue&#125;

let c: Color = Color.Green;
</code></pre>
<p>默认情况下，从0开始为元素编号。你也可以手动的指定成员的数值</p>
<pre><code>enum Color &#123;Red = 1, Green, Blue&#125;

let c: Color = Color.Green;
</code></pre>
<p>或者，全部都采用手动赋值：</p>
<pre><code>enum Color &#123;Red = 1, Green = 2, Blue = 4&#125;

let c: Color = Color.Green;
</code></pre>
<p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字</p>
<pre><code>enum Color &#123;Red = 1, Green, Blue&#125;

let colorName: string = Color[2]; // Green
</code></pre>
<h3 id="任意值-any"><a href="#任意值-any" class="headerlink" title="任意值 any"></a>任意值 any</h3><p>有的时候我们或许还不知到该变量到底该赋什么类型的值，比如对象</p>
<pre><code>let notSure: any = 4;
</code></pre>
<p>当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p>
<pre><code>let list: any[] = [1, true, &quot;free&quot;];

list[1] = 100;
</code></pre>
<h3 id="空值-void"><a href="#空值-void" class="headerlink" title="空值 void"></a>空值 void</h3><p>你可以理解为和any相反的类型，他表示没有任何类型</p>
<pre><code>function warnUser(): void &#123;
    alert(&quot;This is my warning message&quot;);
&#125;
</code></pre>
<p>在声明变量的时候，你只能赋予它undefined和null</p>
<pre><code>let unusable: void = undefined;
            ||或
let unusable: void = null;
</code></pre>
<h3 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h3><p>undefined和null两者各自有自己的类型分别叫做undefined和null。 和void相似</p>
<pre><code>let u: undefined = undefined;

let n: null = null;
</code></pre>
<h3 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h3><p>never类型表示的是那些永不存在的值的类型。</p>
<p><strong>返回never的函数必须存在无法达到的终点</strong></p>
<pre><code>function infiniteLoop(): never &#123;
    while (true) &#123;
    
    &#125;
&#125;
</code></pre>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>有的时候会或许更了解你的一些变量【两种写法】</p>
<p><strong>尖括号</strong></p>
<pre><code>let someValue: any = &quot;this is a string&quot;;

let strLength: number = (&lt;string&gt;someValue).length;
</code></pre>
<p><strong>as语法</strong></p>
<pre><code>let someValue: any = &quot;this is a string&quot;;

let strLength: number = (someValue as string).length;
</code></pre>
<h3 id="！"><a href="#！" class="headerlink" title="！"></a>！</h3><p>表示非null的意思</p>
<blockquote>
<p>有时候获取的节点有可能为null，但是我们可以明确的使用ts表达自己的意向，明确自己想要的值</p>
</blockquote>
<pre><code>const a = document.getElementById(&#39;id&#39;)!
</code></pre>
]]></content>
      <tags>
        <tag>ts</tag>
      </tags>
  </entry>
  <entry>
    <title>ajax</title>
    <url>/2019/04/05/ajax-task/</url>
    <content><![CDATA[<h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><h3 id="什么是ajax"><a href="#什么是ajax" class="headerlink" title="什么是ajax?"></a>什么是ajax?</h3><p><strong>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。Ajax 是一种用于创建快速动态网页的技术。Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。</strong></p>
<h3 id="原生js-ajax请求有几个步骤？分别是什么"><a href="#原生js-ajax请求有几个步骤？分别是什么" class="headerlink" title="原生js ajax请求有几个步骤？分别是什么"></a>原生js ajax请求有几个步骤？分别是什么</h3><pre><code>//创建 XMLHttpRequest 对象
var ajax = new XMLHttpRequest();
//规定请求的类型、URL 以及是否异步处理请求。
ajax.open(&#39;GET&#39;,url,true);
//发送信息至服务器时内容编码类型
ajax.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); 
//发送请求
ajax.send(null);  
//接受服务器响应数据
ajax.onreadystatechange = function () &#123;
    if (ajax.readyState == 4 &amp;&amp; (ajax.status == 200 || ajax.status == 304)) &#123; 
    &#125;
&#125;;
</code></pre>
<h3 id="ajax几种请求方式？他们的优缺点？"><a href="#ajax几种请求方式？他们的优缺点？" class="headerlink" title="ajax几种请求方式？他们的优缺点？"></a>ajax几种请求方式？他们的优缺点？</h3><p><strong>常用的post,get,delete。</strong></p>
<pre><code> // 代码上的区别
 1: get通过url传递参数
 2: post设置请求头  规定请求数据类型

 // 使用上的区别
 1: post比get安全(因为post参数在请求体中。get参数在url上面)
 2: get传输速度比post快 根据传参决定的。 (post通过请求体传参，后台通过数据流接收。速度稍微慢一些。而get通过url传参可以直接获取) 
 3: post传输文件大理论没有限制  get传输文件小大概7-8k ie4k左右
 4: get获取数据    post上传数据(上传的数据比较多  而且上传数据都是重要数据。所以不论在安全性还是数据量级 post是最好的选择)
</code></pre>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><blockquote>
<p>1.减轻服务器的负担,按需取数据,最大程度的减少冗余请求</p>
<p>2.局部刷新页面,减少用户心理和实际的等待时间,带来更好的用户体验</p>
<p>3.基于xml标准化,并被广泛支持,不需安装插件等,进一步促进页面和数据的分离</p>
</blockquote>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><blockquote>
<p>1.AJAX大量的使用了javascript和ajax引擎,这些取决于浏览器的支持.在编写的时候考虑对浏览器的兼容性.</p>
<p>2.AJAX只是局部刷新,所以页面的后退按钮是没有用的.</p>
<p>3.对流媒体还有移动设备的支持不是太好等</p>
</blockquote>
<h3 id="请求头："><a href="#请求头：" class="headerlink" title="请求头："></a>请求头：</h3><pre><code>header(&#39;Access-Control-Allow-Origin:*&#39;);  //支持全域名访问，不安全，部署后需要固定限制为客户端网址

header(&#39;Access-Control-Allow-Methods:POST,GET,OPTIONS,DELETE&#39;); //支持的http 动作

header(&#39;Access-Control-Allow-Headers:x-requested-with,content-type&#39;);  //响应头 请按照自己需求添加。
</code></pre>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>react-redux</title>
    <url>/2019/04/05/redux/</url>
    <content><![CDATA[<h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><h3 id="为什么需要redux"><a href="#为什么需要redux" class="headerlink" title="为什么需要redux"></a>为什么需要redux</h3><p><strong>学过react的都知道，react用state和props控制组件的渲染情况，而对于JavaScript单页面日趋复杂的今天，JavaScript需要管理越来越多的state，而这些state包括着各种乱七八糟途径来的数据。甚至有的应用的state会关系到另一个组件的状态。所以为了方便对这些state的管理以及对state变化的可控性。这个时候Redux这个东西就出来了，它可以让state的变化变得可预测。</strong></p>
<h3 id="Redux的基本概念"><a href="#Redux的基本概念" class="headerlink" title="Redux的基本概念"></a>Redux的基本概念</h3><p><strong>什么是redux？这里非权威的解释：就是一个应用的state管理库，甚至可以说是前端数据库。更包括的是管理数据。</strong></p>
<h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><p><strong>state是整个应用的数据，本质上是一个普通对象。</strong></p>
<h4 id="action"><a href="#action" class="headerlink" title="action"></a>action</h4><p><strong>数据state已经有了，那么我们是如何实现管理这些state中的数据的呢？那就是action，什么是action？按字面意思解释就是动作，也可以理解成，一个可能！改变state的动作包装。就这么简单。。。。</strong></p>
<p><strong>比如有一个counter数量加减应用，我们就有两个action，一个decrement，一个increment。 所以这里的action creator写成如下：</strong></p>
<pre><code>export function decrement() &#123;
    return&#123;
        type:DECREMENT_COUNTER
    &#125;
&#125;

export function increment()&#123;
    return&#123;
        type:INCREMENT_COUNTER
    &#125;
&#125;
</code></pre>
<p><strong>那么，当action创建完成了之后呢，我们怎么触发这些action呢，这时我们是要利用dispatch，比如我们执行count增减减少动作。</strong></p>
<pre><code>export function incrementIfOdd()&#123;
    return(dispatch,getState)=&gt;&#123;
        const &#123;counter&#125; = getState();
        if(counter%2==0) &#123;
            return;
        &#125;
        dispatch(increment());
    &#125;
&#125;

export function incrementAsync() &#123;
    return dispatch =&gt; &#123;
        setTimeout(() =&gt; &#123;
            dispatch(increment());
        &#125;, 1000);
    &#125;;
&#125;
</code></pre>
<p><strong>为了减少样板代码，我们使用单独的模块或文件来定义 action type 常量</strong></p>
<pre><code>export const INCREMENT_COUNTER = &#39;INCREMENT_COUNTER&#39;;
export const DECREMENT_COUNTER = &#39;DECREMENT_COUNTER&#39;;
</code></pre>
<p><strong>这么做不是必须的，在大型应用中把它们显式地定义成常量还是利大于弊的。</strong></p>
<h4 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h4><p><strong>既然这个可能改变state的动作已经包装好了，那么我们怎么去判断并且对state做相应的改变呢？对，这就是reducer干的事情了。</strong></p>
<p><strong>reducer是state最终格式的确定。它是一个纯函数，也就是说，只要传入参数相同，返回计算得到的下一个 state 就一定相同。没有特殊情况、没有副作用，没有 API 请求、没有变量修改，单纯执行计算。</strong></p>
<p><strong>reducer对传入的action进行判断，然后返回一个通过判断后的state，这就是reducer的全部职责。如我们的counter应用：</strong></p>
<pre><code>import &#123;INCREMENT_COUNTER,DECREMENT_COUNTER&#125; from &#39;../actions&#39;;

export default function counter(state = 0, action) &#123;
    switch (action.type)&#123;
        case INCREMENT_COUNTER:
            return state+1;
        case DECREMENT_COUNTER:
            return state-1;
        default:
            return state;
    &#125;
&#125;
</code></pre>
<p><strong>对于一个比较大一点的应用来说，我们是需要将reducer拆分的，最后通过redux提供的combineReducers方法组合到一起。 如此项目上的：</strong></p>
<pre><code>const rootReducer = combineReducers(&#123;
    counter
&#125;);
export default rootReducer;
</code></pre>
<p><strong>每个reducer只负责管理全局state中它负责的一部分。每个reducer的state参数都不同，分别对应它管理的那部分state数据。combineReducers()所做的只是生成一个函数，这个函数来调用你的一系列reducer，每个reducer根据它们的key来筛选出state中的一部分数据并处理， 然后这个生成的函数再将所有reducer的结果合并成一个大的对象。</strong></p>
<h4 id="store"><a href="#store" class="headerlink" title="store"></a>store</h4><p><strong>store是对之前说到一个联系和管理。具有如下职责</strong></p>
<blockquote>
<ul>
<li>维持应用的state；</li>
<li>提供getState()方法获取 state</li>
<li>提供dispatch(action)方法更新 state；</li>
<li>通过subscribe(listener)注册监听器;</li>
<li>通过subscribe(listener)返回的函数注销监听器。</li>
</ul>
</blockquote>
<p><strong>强调一下 Redux 应用只有一个单一的store。当需要拆分数据处理逻辑时，你应该使用reducer组合,而不是创建多个store。store的创建通过redux的createStore方法创建，这个方法还需要传入reducer，很容易理解：毕竟我需要dispatch一个action来改变state嘛。 应用一般会有一个初始化的state，所以可选为第二个参数，这个参数通常是有服务端提供的，传说中的Universal渲染。 第三个参数一般是需要使用的中间件，通过applyMiddleware传入。</strong></p>
<h3 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux-thunk"></a>redux-thunk</h3><p><strong>一个比较流行的redux的action中间件，它可以让actionCreator暂时不返回action对象，而是返回一个函数，函数传递两个参数(dispatch, getState)，在函数体内进行业务逻辑的封装，比如异步操作，我们至少需要触发两个action，这时候我们可以通过redux-thunk将这两个action封装在一起，如下：</strong></p>
<blockquote>
<p>store.js</p>
</blockquote>
<pre><code>import &#123; createStore, applyMiddleware &#125; from &quot;redux&quot;;
import RankReducer from &quot;./reducers/reducer&quot;
import thunk from &quot;redux-thunk&quot;;
const store = createStore(RankReducer, applyMiddleware(thunk));
export default store
</code></pre>
<blockquote>
<p>reducer.jsx</p>
</blockquote>
<pre><code>const defaultState = &#123;
    rankList: []
&#125;
const RankReducer = (state = defaultState, action) =&gt; &#123;
    const &#123; type, layload &#125; = action;
    switch (type) &#123;
        case &quot;UPDATE&quot;:
            return &#123; ...state, rankList: layload &#125;
        default:
            return state;
    &#125;
&#125;
export default RankReducer;
</code></pre>
<blockquote>
<p>rank.js</p>
</blockquote>
<pre><code>import axios from &quot;axios&quot;

export function updata(layload)&#123;
    return function(dispatch)&#123;
        return axios.get(&quot;/getrankList&quot;).then(result=&gt;&#123;
            return dispatch(&#123;
                type:&quot;UPDATA&quot;,
                layload:result.data.data
            &#125;)
        &#125;)
    &#125;
&#125;
</code></pre>
<blockquote>
<p>index.jsx</p>
</blockquote>
<pre><code>import &#123;updata&#125; from &quot;../../store/action/rank&quot;
const mapdispatchToprops=(dispatch)=&gt;&#123;
    return &#123;
        updata()&#123;
            dispatch(updata())
        &#125;,
        add(layload)&#123;
            dispatch(&#123;
                type:&quot;ADD&quot;,
                layload:layload
            &#125;)
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="react-redux-1"><a href="#react-redux-1" class="headerlink" title="react-redux"></a>react-redux</h3><p><strong>redux和react的桥梁工具。</strong></p>
<blockquote>
<p>index.js</p>
</blockquote>
<pre><code>import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;
import &quot;./common/css/index.css&quot;
import App from &#39;../src/containers/app&#39;;
import &#123;Provider&#125; from &quot;react-redux&quot;
import &#123;store&#125; from &quot;./store/store&quot;

ReactDOM.render(
        &lt;Provider store=&#123;store&#125;&gt;
          
                &lt;App /&gt;
            
        &lt;/Provider&gt;
     ,document.getElementById(&#39;root&#39;)
);
</code></pre>
<blockquote>
<p>home.js</p>
</blockquote>
<pre><code>import React from &quot;react&quot;
import &#123;connect&#125; from &quot;react-redux&quot;
class Home extends React.Component&#123;


&#125;

const mapstateToprops=(state)=&gt;&#123;
    return state
&#125;
const mapdispatchToprops=(dispatch)=&gt;&#123;
    return &#123;
        updata()&#123;
            dispatch(updata())
        &#125;,
        add(layload)&#123;
            dispatch(&#123;
                type:&quot;ADD&quot;,
                layload:layload
            &#125;)
        &#125;
    &#125;
&#125;
export default connect(mapstateToprops,mapdispatchToprops)(Home) 
</code></pre>
<h3 id="redux-saga"><a href="#redux-saga" class="headerlink" title="redux-saga"></a>redux-saga</h3><p><strong>上面介绍了redux-thunk是异步操作的方法，我们可以看出，他的函数内部比较复杂，如果需要每个异步操作都定义一个action的话，显然是不易维护的</strong></p>
<h3 id="redux-saga的API"><a href="#redux-saga的API" class="headerlink" title="redux-saga的API"></a>redux-saga的API</h3><p><strong>redux-saga是通过ES6中的generator实现的（babel的基础版本不包含generator语法，因此需要在使用saga的地方import ‘babel-polyfill’）。redux-saga本质是一个可以自执行的generator。</strong></p>
<h4 id="redux-saga中的Effect"><a href="#redux-saga中的Effect" class="headerlink" title="redux-saga中的Effect"></a>redux-saga中的Effect</h4><p><strong>redux-saga中定义了Effect，Effect是什么呢，本质就是一个特定的函数，返回的是纯文本对象。简单理解，通过Effect函数，会返回一个字符串，saga-middleware根据这个字符串来执行真正的异步操作，可以具体表现成如下形式：</strong></p>
<blockquote>
<p>异步操作——&gt;Effect函数——&gt;纯文本对象——&gt;saga-middleware——&gt;执行异步操作</p>
</blockquote>
<p><strong>因为Effect的存在，方便saga测试异步操作。</strong></p>
<h4 id="Effect具体函数"><a href="#Effect具体函数" class="headerlink" title="Effect具体函数"></a>Effect具体函数</h4><p><strong>Effect函数有很多个，在redux-saga/effects提供，主要包括call，fork，put，take，select等，它们都与middleware中的操作一一对应。</strong></p>
<ul>
<li>call 和 fork</li>
</ul>
<blockquote>
<p>call和fork表示异步调用，其中call表示的是阻塞调用，fork表示的是非阻塞调用。</p>
</blockquote>
<ul>
<li>put和select</li>
</ul>
<blockquote>
<p>put对应的是middleware中的dispatch方法，参数是一个plain object，一般在异步调用返回结果后，接着执行put。select相当于getState，用于获取store中的相应部分的state。</p>
</blockquote>
<ul>
<li>take、takeEvery、takeLatest</li>
</ul>
<blockquote>
<p>redux-saga中如果在非阻塞调用下（fork）,那么遵循的是worker/watcher模式，通过take可以监听某个action是否被发起，此外通过take结合fork，可以实现takeEvery和takeLatest的效果。</p>
</blockquote>
<blockquote>
<p>如果一个异步操作的action被发起多次，takeEvery会执行多次action，而takeLatest只会执行最近的一次。</p>
</blockquote>
<h3 id="redux-saga的优缺点"><a href="#redux-saga的优缺点" class="headerlink" title="redux-saga的优缺点"></a>redux-saga的优缺点</h3><blockquote>
<p>优点：</p>
</blockquote>
<p>（1）集中处理了所有的异步操作，异步接口部分一目了然</p>
<p>（2）action是普通对象，这跟redux同步的action一模一样</p>
<p>（3）通过Effect，方便异步接口的测试</p>
<p>（4）通过worker 和watcher可以实现非阻塞异步调用，并且同时可以实现非阻塞调用下的事件监听</p>
<p>（5） 异步操作的流程是可以控制的，可以随时取消相应的异步操作。</p>
<blockquote>
<p>缺点：</p>
</blockquote>
<p> 太复杂，学习成本较高</p>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><blockquote>
<p>sagas.js</p>
</blockquote>
<pre><code>import &#123; takeEvery, takeLatest &#125; from &#39;redux-saga&#39;;
import &#123; call, put &#125; from &#39;redux-saga/effects&#39;;
import axios from &#39;axios&#39;;
import &#123; BEGIN_GET_POSTS, GET_POSTS, GET_POSTS_ERROR &#125; from &#39;../reducers&#39;;

// worker saga
function* showPostsAsync(action) &#123;
    try &#123;
        const response = yield call(axios.get, &#39;https://jsonplaceholder.typicode.com/posts&#39;);
        yield put(GET_POSTS(response.data));
    &#125; catch(e) &#123;
        yield put(GET_ERROR(e));
    &#125;
&#125;
</code></pre>
<blockquote>
<p>reducers.js</p>
</blockquote>
<pre><code>import &#123; combineReducers &#125; from &#39;redux&#39;

// actions
export const RECEIVE_USERS = &#39;RECEIVE_USERS&#39;;
export const FETCH_USERS_ERROR = &#39;FETCH_USERS_ERROR&#39;;
export const RECEIVE_POSTS = &#39;RECEIVE_POPTS&#39;;
export const FETCH_POSTS_ERROR = &#39;FETCH_USERS_ERROR&#39;;
export const BEGIN_GET_POSTS = &#39;BEGIN_GET_POSTS&#39;;

// action creators
export function GET_USERS(users) &#123;
    return &#123; type: RECEIVE_USERS, users &#125;
&#125;

export function GET_ERROR(error) &#123;
    return &#123; type: FETCH_USERS_ERROR, error &#125;
&#125;

export function GET_POSTS(posts) &#123;
    return &#123; type: RECEIVE_POSTS, posts &#125;
&#125;

export function Begin_GET_POSTS() &#123;
    return &#123; type: BEGIN_GET_POSTS &#125;
&#125;

export function GET_POSTS_ERROR(error) &#123;
    return &#123; type: FETCH_POSTS_ERROR, error &#125;
&#125;

// reducer
const initialState = &#123; 
    fetched: false, 
    users: [&#123;
        key: &#39;1&#39;,
        name: &#39;张三&#39;,
        email: &#39;zhangsan@126.com&#39;
    &#125;],
    posts: [&#123;
        key: &#39;1&#39;,
        id: &#39;1&#39;,
        title: &#39;test&#39;
    &#125;],
    error: null
&#125;;

const appReducer = (state = initialState, action) =&gt; &#123;
    switch(action.type) &#123;
        case FETCH_USERS_ERROR: &#123;
            return &#123;...state, error: action.error&#125; 
            break;
        &#125;
        case RECEIVE_USERS: &#123;
            return &#123;...state, fetched: true, users: action.users&#125; 
            break;
        &#125;
        case FETCH_POSTS_ERROR: &#123;
            return &#123;...state, error: action.error&#125; 
            break;
        &#125;
        case RECEIVE_POSTS: &#123;
            return &#123;...state, fetched: true, posts: action.posts&#125; 
            break;
        &#125;
    &#125;
    return state;
&#125;

export default appReducer
</code></pre>
<blockquote>
<p>app.js</p>
</blockquote>
<pre><code>&#39;use strict&#39;;

import &#39;../asset/css/style.scss&#39;;
import &#39;antd/dist/antd.min.css&#39;;
import React from &#39;react&#39;;
import &#123; render &#125; from &#39;react-dom&#39;;
import &#123; Provider &#125; from &#39;react-redux&#39;;
import &#123; createStore, applyMiddleware, combineReducers &#125; from &#39;redux&#39;;
import logger from &#39;redux-logger&#39;;
import thunk from &#39;redux-thunk&#39;;
import createSagaMiddleware from &#39;redux-saga&#39;;
import axios from &#39;axios&#39;;

import appReducer from &#39;./reducers&#39;;
import AppRouter from &#39;./router&#39;;
import rootSaga from &#39;./sagas&#39;;

const sagaMiddleware = createSagaMiddleware();
const middlewares = [thunk, sagaMiddleware, logger];

const store = createStore(appReducer, applyMiddleware(...middlewares));
sagaMiddleware.run(rootSaga);

render(
    &lt;Provider store=&#123;store&#125;&gt;
        &lt;AppRouter /&gt;
    &lt;/Provider&gt;,
    document.getElementById(&#39;app&#39;)
);
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="本文介绍了react-redux基本使用方法："><a href="#本文介绍了react-redux基本使用方法：" class="headerlink" title="本文介绍了react-redux基本使用方法："></a>本文介绍了react-redux基本使用方法：</h3><p><strong>首先需要创建仓库，使用redux创建仓库，创建reducer，页面中使用dispatch执行action，将改变的值传递到renducer中，然而链接页面与仓库需要react-redux中的{provider,connect},在根目录进行链接，将组件使用provider包裹起来，将创建的仓库，传入到provider中，视图中使用connect链接仓库。</strong></p>
<h3 id="redux-thunk-1"><a href="#redux-thunk-1" class="headerlink" title="redux-thunk"></a>redux-thunk</h3><p><strong>使用applymiddle引入插件thunk，创建一个函数，他返回一个函数，这个函数可以接收dispatch，他可以在异步任务执行完以后在，dispatch</strong></p>
<h3 id="redux-saga-1"><a href="#redux-saga-1" class="headerlink" title="redux-saga"></a>redux-saga</h3><p><strong>redux-sage中的effect中有put，call，select…几个属性，call使用来提交一个异步操作，有两个参数，第一个要执行的异步函数，第二个是要传递的参数，put是用来执行reducer，使用时需要创建一个sage</strong></p>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react的概述</title>
    <url>/2019/04/03/react-task/</url>
    <content><![CDATA[<h2 id="react的概述"><a href="#react的概述" class="headerlink" title="react的概述"></a>react的概述</h2><h3 id="什么是react"><a href="#什么是react" class="headerlink" title="什么是react"></a>什么是react</h3><blockquote>
<p>react是一个前端的js库，用于构建用户界面，尤其是单页面应用程序</p>
</blockquote>
<h3 id="react的特点："><a href="#react的特点：" class="headerlink" title="react的特点："></a>react的特点：</h3><blockquote>
<p>单向数据流，组件化开发，虚拟dom，jsx，只关注mv*中的m这一层，渲染性能好</p>
</blockquote>
<h3 id="react组件的划分"><a href="#react组件的划分" class="headerlink" title="react组件的划分"></a>react组件的划分</h3><ul>
<li>业务组件</li>
</ul>
<p><strong>每个功能对应的业务逻辑划分</strong></p>
<ul>
<li>展示组件</li>
</ul>
<p><strong>列表，按钮表单。。。ui组件</strong></p>
<ul>
<li>容器组件</li>
</ul>
<p><strong>包装的盒子，页面组件</strong></p>
<ul>
<li>木偶组件</li>
</ul>
<p><strong>展示组件，功能组件【一些效果】</strong></p>
<blockquote>
<p>components[业务组件]（展示组件，木偶组件，容器组件）<br>views[页面组件]</p>
</blockquote>
<h3 id="创建组件方式"><a href="#创建组件方式" class="headerlink" title="创建组件方式"></a>创建组件方式</h3><blockquote>
<p><strong>class组件创建：业务组件，页面组件</strong></p>
<p><strong>函数式创建：展示组件，包装类型组件</strong></p>
</blockquote>
<h3 id="render用法"><a href="#render用法" class="headerlink" title="render用法"></a>render用法</h3><ul>
<li>在react中有两个render，一个是组件内部的render，一个是reactdom的render</li>
<li>组建的render用来返回一个虚拟dom，在里面不能修改state，只能读取</li>
<li>虚拟dom是通过编译器，将jsx转化为react.createElement()的方法调用，这个方法的返回结果就是一个jsx对象【虚拟dom】</li>
<li>每一个组件都必须有render这个方法</li>
<li>reactdom的render只是将虚拟dom渲染到页面中</li>
</ul>
<h3 id="react中的state"><a href="#react中的state" class="headerlink" title="react中的state"></a>react中的state</h3><p><strong>state只能定义在construct中的this.state中，函数式的组件没有state</strong></p>
<p><strong>修改state只能通过setState方法，只能修改一级属性，不能修改索引数组，不能通过属性修改对象</strong></p>
<p><strong>读取使用this.state.xxx，this.props.xxx</strong></p>
<p><strong>定义props默认值使用static defaultProps</strong></p>
<h3 id="react的生明周期"><a href="#react的生明周期" class="headerlink" title="react的生明周期"></a>react的生明周期</h3><blockquote>
<p><strong>组件初始化阶段</strong></p>
</blockquote>
<pre><code>import React, &#123; Component &#125; from &#39;react&#39;;

class Test extends Component &#123;
  constructor(props) &#123;
    super(props);
  &#125;
&#125;
</code></pre>
<blockquote>
<p><strong>组件挂载阶段</strong></p>
</blockquote>
<pre><code>componentWillMount:
</code></pre>
<p><strong>在组件挂载到DOM前调用，且只会被调用一次，在这边调用this.setState不会引起组件重新渲染，也可以把写在这边的内容提前到constructor()中，所以项目中很少用。</strong></p>
<pre><code>render:
</code></pre>
<p><strong>根据组件的props和state（无两者的重传递和重赋值，论值是否有变化，都可以引起组件重新render） ，return 一个React元素（描述组件，即UI），不负责组件实际渲染工作，之后由React自身根据此元素去渲染出页面DOM。render是纯函数（Pure function：函数的返回结果只依赖于它的参数；函数执行过程里面没有副作用），不能在里面执行this.setState，会有改变组件状态的副作用。</strong></p>
<pre><code>componentDidMount:
</code></pre>
<p><strong>组件挂载到DOM后调用，且只会被调用一次</strong></p>
<blockquote>
<p><strong>组件更新阶段</strong></p>
</blockquote>
<p><strong>setState引起的state更新或父组件重新render引起的props更新，更新后的state和props相对之前无论是否有变化，都将引起子组件的重新render。</strong></p>
<h4 id="造成组件更新有两类（三种）情况："><a href="#造成组件更新有两类（三种）情况：" class="headerlink" title="造成组件更新有两类（三种）情况："></a>造成组件更新有两类（三种）情况：</h4><ul>
<li>父组件重新render</li>
</ul>
<p><strong>每当父组件重新render的导致的重传props，子组件将直接跟着重新渲染，可以通过shouldComponentUpdate方法进行优化</strong></p>
<pre><code>class Child extends Component &#123;
   shouldComponentUpdate(nextProps)&#123; // 应该使用这个方法，否则无论props是否有变化都将会导致组件跟着重新渲染
        if(nextProps.someThings === this.props.someThings)&#123;
          return false
        &#125;
    &#125;
    render() &#123;
        return &lt;div&gt;&#123;this.props.someThings&#125;&lt;/div&gt;
    &#125;
&#125;
</code></pre>
<p><strong>在componentWillReceiveProps方法中，将props转换成自己的state</strong></p>
<pre><code>class Child extends Component &#123;
    constructor(props) &#123;
        super(props);
        this.state = &#123;
            someThings: props.someThings
        &#125;;
    &#125;
    componentWillReceiveProps(nextProps) &#123; // 父组件重传props时就会调用这个方法
        this.setState(&#123;someThings: nextProps.someThings&#125;);
    &#125;
    render() &#123;
        return &lt;div&gt;&#123;this.state.someThings&#125;&lt;/div&gt;
    &#125;
&#125;
</code></pre>
<ul>
<li>. 组件本身调用setState，无论state有没有变化。可通过shouldComponentUpdate方法优化。</li>
</ul>
<hr>
<pre><code>class Child extends Component &#123;
   constructor(props) &#123;
        super(props);
        this.state = &#123;
          someThings:1
        &#125;
   &#125;
   shouldComponentUpdate(nextStates)&#123; // 应该使用这个方法，否则无论state是否有变化都将会导致组件重新渲染
        if(nextStates.someThings === this.state.someThings)&#123;
          return false
        &#125;
    &#125;

   handleClick = () =&gt; &#123; // 虽然调用了setState ，但state并无变化
        const preSomeThings = this.state.someThings
         this.setState(&#123;
            someThings: preSomeThings
         &#125;)
   &#125;

    render() &#123;
        return &lt;div onClick = &#123;this.handleClick&#125;&gt;&#123;this.state.someThings&#125;&lt;/div&gt;
    &#125;
&#125;
</code></pre>
<hr>
<h2 id="执行顺序："><a href="#执行顺序：" class="headerlink" title="执行顺序："></a><strong>执行顺序：</strong></h2><pre><code>componentWillReceiveProps

shouldComponentUpdate

componentWillUpdate

render

componentDidUpdate
</code></pre>
<hr>
<pre><code>componentWillReceiveProps(nextProps)
</code></pre>
<p><strong>此方法只调用于props引起的组件更新过程中，参数nextProps是父组件传给当前组件的新props。但父组件render方法的调用不能保证重传给当前组件的props是有变化的，所以在此方法中根据nextProps和this.props来查明重传的props是否改变，以及如果改变了要执行啥，比如根据新的props调用this.setState出发当前组件的重新render</strong></p>
<pre><code>shouldComponentUpdate(nextProps, nextState)
</code></pre>
<p><strong>此方法通过比较nextProps，nextState及当前组件的this.props，this.state，返回true时当前组件将继续执行更新过程，返回false则当前组件更新停止，以此可用来减少组件的不必要渲染，优化组件性能。</strong></p>
<pre><code>componentWillUpdate(nextProps, nextState)
</code></pre>
<p><strong>此方法在调用render方法前执行，在这边可执行一些组件更新发生前的工作，一般较少用。</strong></p>
<pre><code>render
</code></pre>
<p><strong>只是重新调用。</strong></p>
<pre><code>componentDidUpdate(prevProps, prevState)
</code></pre>
<p><strong>此方法在组件更新后被调用，可以操作组件更新的DOM，prevProps和prevState这两个参数指的是组件更新前的props和state</strong></p>
<blockquote>
<p><strong>卸载阶段</strong></p>
</blockquote>
<pre><code>componentWillUnmount
</code></pre>
<p><strong>此方法在组件被卸载前调用，可以在这里执行一些清理工作，比如清楚组件中使用的定时器，清楚componentDidMount中手动创建的DOM元素等，以避免引起内存泄漏。</strong></p>
<h2 id="React-v16-4-的生命周期"><a href="#React-v16-4-的生命周期" class="headerlink" title="React v16.4 的生命周期"></a>React v16.4 的生命周期</h2><h3 id="变更缘由"><a href="#变更缘由" class="headerlink" title="变更缘由"></a>变更缘由</h3><p><strong>原来（React v16.0前）的生命周期在React v16推出的Fiber之后就不合适了，因为如果要开启async rendering，在render函数之前的所有函数，都有可能被执行多次。</strong></p>
<p><strong>原来（React v16.0前）的生命周期有哪些是在render前执行的呢？</strong></p>
<ul>
<li>componentWillMount</li>
<li>componentWillReceiveProps</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
</ul>
<p><strong>如果开发者开了async rendering，而且又在以上这些render前执行的生命周期方法做AJAX请求的话，那AJAX将被无谓地多次调用。。。明显不是我们期望的结果。而且在componentWillMount里发起AJAX，不管多快得到结果也赶不上首次render，而且componentWillMount在服务器端渲染也会被调用到（当然，也许这是预期的结果），这样的IO操作放在componentDidMount里更合适。</strong></p>
<p><strong>因此引入两个新增的生命周期函数</strong></p>
<pre><code>getDerivedStateFromProps

getSnapshotBeforeUpdate
</code></pre>
<p><strong>随着getDerivedStateFromProps的推出，同时deprecate了一组生命周期API，包括：</strong></p>
<ul>
<li>componentWillReceiveProps</li>
<li>componentWillMount</li>
<li>componentWillUpdate</li>
</ul>
<hr>
<p><strong>按照官方说法，以前需要利用被deprecate的所有生命周期函数才能实现的功能，都可以通过getDerivedStateFromProps的帮助来实现。</strong></p>
<p><strong>这个getDerivedStateFromProps是一个静态函数，所以函数体内不能访问this，简单说，就是应该一个纯函数，纯函数是一个好东西啊，输出完全由输入决定。</strong></p>
<pre><code>static getDerivedStateFromProps(nextProps, prevState) &#123;
  //根据nextProps和prevState计算出预期的状态改变，返回结果会被送给setState
&#125;
</code></pre>
<p><strong>所有被deprecate的生命周期函数，目前还凑合着用，但是只要用了，开发模式下会有红色警告，在下一个大版本（也就是React v17)更新时会彻底废弃。</strong></p>
<hr>
<p><strong>getSnapshotBeforeUpdate，这函数会在render之后执行，而执行之时DOM元素还没有被更新，给了一个机会去获取DOM信息，计算得到一个snapshot，这个snapshot会作为componentDidUpdate的第三个参数传入。</strong></p>
<pre><code>getSnapshotBeforeUpdate(prevProps, prevState) &#123;
   console.log(&#39;#enter getSnapshotBeforeUpdate&#39;);
   return &#39;foo&#39;;
&#125;

 componentDidUpdate(prevProps, prevState, snapshot) &#123;
   console.log(&#39;#enter componentDidUpdate snapshot = &#39;, snapshot);
 &#125;.
</code></pre>
<p><strong>getDerivedStateFromProps无论是Mounting还是Updating，也无论是因为什么引起的Updating，全部都会被调用。</strong></p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><blockquote>
<p><strong>用一个静态函数getDerivedStateFromProps来取代被deprecate的几个生命周期函数，就是强制开发者在render之前只做无副作用的操作，而且能做的操作局限在根据props和state决定新的state，而已。</strong></p>
</blockquote>
<blockquote>
<p><strong>引用</strong></p>
</blockquote>
<p><a class="link"   href="https://zhuanlan.zhihu.com/p/38030418" >程墨Morgan老师的React v16.3之后的组件生命周期函数<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>对react-router的封装及api</title>
    <url>/2019/04/03/react-router/</url>
    <content><![CDATA[<h2 id="对react-router的封装"><a href="#对react-router的封装" class="headerlink" title="对react-router的封装"></a>对react-router的封装</h2><p><strong>直接上代码吧</strong></p>
<blockquote>
<p>config.js // 该文件是对路由的配置</p>
</blockquote>
<pre><code>//组件的引入
import Home from &#39;../contentais/home/index&#39;
import Login from &quot;../contentais/login/index&quot;
import Business from &#39;./../contentais/home/business/index&#39;;
import Finance from &#39;./../contentais/home/finance/index&#39;;
import Tissue from &#39;./../contentais/home/tissue/index&#39;;
import Statistics from &#39;./../contentais/home/statistics/index&#39;;
import Order from &#39;./../contentais/home/order/index&#39;;
import UserHome from &#39;./../contentais/home/userHome/index&#39;;
import Loans from &#39;./../contentais/home/order/loans/index&#39;;
import Transfer from &#39;./../contentais/home/order/transfer/index&#39;;
import Insurance from &#39;./../contentais/home/order/insurance/index&#39;;

const RouteConfig = [
    &#123;
        //title 
        title: &quot;首页&quot;,
        //路由地址
        path: &quot;/Home&quot;,
        //关键字重定向
        defaultRedirect: true,
        //组件
        component: Home,
        //二级路由
        children: [
            &#123;
                key: &quot;1&quot;,
                defaultRedirect: true,

                title: &quot;首页&quot;,
                path: &quot;/Home/one&quot;,
                component: UserHome,
            &#125;,
            &#123;
                key: &quot;sub1&quot;,
                title: &quot;订单管理&quot;,
                path: &quot;/Home/order&quot;,
                component: Order,
                //三级路由
                children: [
                    &#123;
                        defaultRedirect: true,

                        key: &quot;2&quot;,
                        title: &quot;贷款订单&quot;,
                        path: &quot;/Home/order/loans&quot;,
                        component: Loans,
                    &#125;,
                    &#123;
                        key: &quot;3&quot;,
                        title: &quot;转单订单&quot;,
                        path: &quot;/Home/order/transfer&quot;,
                        component: Transfer,
                    &#125;,
                    &#123;
                        key: &quot;4&quot;,
                        title: &quot;保险订单&quot;,
                        path: &quot;/Home/order/insurance&quot;,
                        component: Insurance,
                    &#125;,
                    //三级路由的重定向   默认显示的页面
                    &#123;
                        path: &quot;/Home/order&quot;,
                        redirect: &quot;/Home/order/loans&quot;
                    &#125;
                ]
            &#125;,
            &#123;
                key: &quot;5&quot;,
                title: &quot;财务管理&quot;,
                path: &quot;/Home/finance&quot;,
                component: Finance,
            &#125;
            ,
            &#123;
                key: &quot;6&quot;,
                title: &quot;组织架构&quot;,
                path: &quot;/Home/tissue&quot;,
                component: Tissue,
            &#125;,
            &#123;
                key: &quot;7&quot;,
                title: &quot;数据统计&quot;,
                path: &quot;/Home/statistics&quot;,
                component: Statistics,
            &#125;,
            &#123;
                key: &quot;8&quot;,
                title: &quot;商务管理&quot;,
                path: &quot;/Home/business&quot;,
                component: Business,
            &#125;,
            //二级路由的重定向   默认显示的页面
            &#123;
                path: &quot;/Home&quot;,
                redirect: &quot;/Home/one&quot;
            &#125;
        ]
    &#125;,
    &#123;
        title: &quot;登陆&quot;,
        path: &quot;/Login&quot;,
        component: Login,
    &#125;, &#123;
        //一级路由的重定向
        path: &quot;/&quot;,
        redirect: &quot;/Home&quot;
    &#125;
]
export default RouteConfig;
</code></pre>
<blockquote>
<p>routerView.js // 路由递归逻辑实现</p>
</blockquote>
<pre><code>import &#123; Route, Switch, Redirect &#125; from &quot;react-router-dom&quot;
import React, &#123; Component &#125; from &#39;react&#39;;
class RouteView extends Component &#123;
    render() &#123;

        // props接收配置文件
        // routers 下一级路由的参数
        // defaultConfig默认传参

        const &#123; routers, defaultConfig &#125; = this.props

        // 这里判断【下一级路由的参数】是否有值 ? 【使用下一级路由的参数】 ： 【默认路由参数】

        let routerDate = routers ? routers : defaultConfig;

        //数据二次处理

        //筛除没有重定向的
        let routerDatepath = routerDate.filter((item) =&gt; &#123;
            return !item.redirect
        &#125;)

        //筛选重定向
        let defualtRouter = routerDate.filter((item) =&gt; &#123;
            return item.redirect
        &#125;)

        //重定向
        let defualtRedirect = defualtRouter.map((item, i) =&gt; &#123;
            return &lt;Redirect key=&#123;i&#125; path=&#123;item.path&#125; to=&#123;item.redirect&#125;&gt;&lt;/Redirect&gt;
        &#125;)

        return (&lt;Switch&gt;
            &#123;
                routerDatepath &amp;&amp; routerDatepath.map((item, index) =&gt; &#123;
                    const Comp = item.component
                    // 一个大坑 要用render 不然用component会导致页面的回流
                    return &lt;Route path=&#123;item.path&#125; render=&#123;
                        //api 路由相关参数参数及其它
                        (api) =&gt; &#123;
                            //动态的title
                            document.title = item.title || &quot;路由配置&quot;
                            //把下一级路由参数存入props中
                            return &lt;Comp routers=&#123;item.children&#125; &#123;...api&#125;&gt;&lt;/Comp&gt;
                        &#125;
                    &#125; key=&#123;&quot;key&quot; + item.key&#125;&gt;&lt;/Route&gt;
                    //重定向
                &#125;).concat(defualtRedirect)
            &#125;
        &lt;/Switch&gt;)
    &#125;
&#125;
export default RouteView;
</code></pre>
<blockquote>
<p>app.js // 路由调用的使用方式</p>
</blockquote>
<pre><code>import React, &#123; Component &#125; from &#39;react&#39;;
import &#123; BrowserRouter as Router &#125; from &quot;react-router-dom&quot;
import RouteConfig from &#39;./config.js&#39;; // 引入路由的配置信息
import RouteView from &#39;./routeView,js&#39;; // 引入路由的逻辑实现
class App extends Component &#123;
    render() &#123;
        return &lt;div className=&quot;wrapper&quot;&gt;
            &lt;Router&gt;
                //传入默认路由配置文件
                &lt;RouteView defaultConfig=&#123;RouteConfig&#125;&gt;&lt;/RouteView&gt;
            &lt;/Router&gt;
        &lt;/div&gt;
    &#125;
&#125;
export default App;
</code></pre>
<blockquote>
<p>二级路由的调用</p>
</blockquote>
<pre><code>import React, &#123; Component &#125; from &#39;react&#39;;
import RouteView from &#39;./../../router/RouteView&#39;;
import SiderMenu from &#39;./../../components/SiderMenu/index&#39;;
import &quot;./index.css&quot;
class Home extends Component &#123;
    render() &#123;
        //接收路由配置
        const &#123; routers &#125; = this.props
        return &lt;div className=&quot;home-wrapper&quot;&gt;
            &lt;div className=&quot;left&quot;&gt;
                &lt;div className=&quot;user&quot;&gt;
                    &lt;div className=&quot;user-img&quot;&gt;
                    &lt;/div&gt;
                    &lt;p className=&quot;mt12&quot;&gt;你瞅啥&lt;/p&gt;
                    &lt;b className=&quot;mt12 radius&quot;&gt;&lt;/b&gt;
                &lt;/div&gt;
                //侧边栏的组件
                &lt;SiderMenu style=&#123;&#123; background:"#2F3B4C"&#125;&#125; &#123;...this.props&#125;&gt;&lt;/SiderMenu&gt;
            &lt;div className=&quot;ri
            &lt;/div&gt;ght&quot;&gt;
                //传入RouteView当中进行处理
                &lt;RouteView routers=&#123;routers&#125;&gt;&lt;/RouteView&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &#125;

&#125;
export default Home;
</code></pre>
<h2 id="‘react-router-dom的api"><a href="#‘react-router-dom的api" class="headerlink" title="‘react-router-dom的api"></a>‘react-router-dom的api</h2><p><strong>react-router-dom提供了BrowserRouter, Route, Link等api,我们可以通过dom的事件控制路由。例如点击一个按钮进行跳转，大多数情况下我们是这种情况，所以在开发过程中，我们更多是使用React-router-dom。安装很简单npm i react-router-dom –save,安装了淘宝镜像的就用cnpm吧。</strong></p>
<h3 id="常用的路由api"><a href="#常用的路由api" class="headerlink" title="常用的路由api"></a>常用的路由api</h3><hr>
<ul>
<li>HashRouter和BrowserRouter</li>
</ul>
<p><strong>它们两个是路由的基本，就像盖房子必须有地基一样，我们需要将它们包裹在最外层，我们只要选择其一就可以了。现在讲它们的不同：</strong></p>
<blockquote>
<p>HashRouter</p>
</blockquote>
<p><strong>如果你使用过react-router2或3或者vue-router，你经常会发现一个现象就是url中会有个#，例如localhost:3000/#，HashRouter就会出现这种情况，它是通过hash值来对路由进行控制。如果你使用HashRouter，你的路由就会默认有这个#。</strong></p>
<blockquote>
<p>BrowserRouter</p>
</blockquote>
<p><strong>很多情况下我们则不是这种情况，我们不需要这个#，因为它看起来很怪，这时我们就需要用到BrowserRouter。</strong></p>
<hr>
<ul>
<li>Route</li>
</ul>
<p><strong>Route是路由的一个原材料，它是控制路径对应显示的组件。我们经常用的是exact、path以及component属性。</strong></p>
<pre><code>&lt;Route path=&#39;/&#39; component=&#39;&#39; exact&gt;&lt;/Route&gt;
</code></pre>
<blockquote>
<p>exact控制匹配到/路径时不会再继续向下匹配，</p>
<p>path标识路由的路径</p>
<p>component表示路径对应显示的组件</p>
</blockquote>
<hr>
<ul>
<li>Link和NavLink的选择</li>
</ul>
<p><strong>两者都是可以控制路由跳转的，不同点是NavLink的api更多，更加满足你的需求。</strong></p>
<blockquote>
<p>Link</p>
</blockquote>
<p><strong>主要api是to，to可以接受string或者一个object，来控制url。使用方法如下</strong></p>
<Link to='/api'>

<blockquote>
<p>NavLink</p>
</blockquote>
<p><strong>它可以为当前选中的路由设置类名、样式以及回调函数等。使用如下</strong></p>
<pre><code>&lt;Navlink to=&#39;&#39; activeClassName=&#39;actived&#39;&gt;
</code></pre>
<p><strong>activeClassName是选中状态的类名，我们可以为其添加样式</strong></p>
<hr>
<ul>
<li>Switch</li>
</ul>
<p><strong>Switch常常会用来包裹Route，它里面不能放其他元素，用来只显示一个路由。</strong></p>
<hr>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react组件优化及组件通讯</title>
    <url>/2019/04/03/react-optimization/</url>
    <content><![CDATA[<h2 id="react组件优化"><a href="#react组件优化" class="headerlink" title="react组件优化"></a>react组件优化</h2><h3 id="key值"><a href="#key值" class="headerlink" title="key值"></a>key值</h3><p><strong>在使用v-for的情况下，给每个变量的元素都加上key值，加key值得好处已经在上一文中提到过，主要为了提高渲染效率</strong></p>
<h3 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h3><p><strong>该生命周期可以决定数据改变的时候是否进行render，返回值为boolean，返回true即为渲染，返回false及不渲染，默认不写为true</strong></p>
<h3 id="纯函数组件"><a href="#纯函数组件" class="headerlink" title="纯函数组件"></a>纯函数组件</h3><p><strong>将单独的项封装成一个组件，已达到服用效果</strong></p>
<h2 id="组件通讯"><a href="#组件通讯" class="headerlink" title="组件通讯"></a>组件通讯</h2><h3 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h3><blockquote>
<p>使用props传值</p>
</blockquote>
<p><strong>父组件</strong></p>
<pre><code>import React,&#123; Component &#125; from &quot;react&quot;;
import Sub from &quot;./SubComponent.js&quot;;
import &quot;./App.css&quot;;

export default class App extends Component&#123;

    render()&#123;
        return(
            &lt;div&gt;
                &lt;Sub title = &quot;今年过节不收礼&quot; /&gt;
            &lt;/div&gt;
        )
    &#125;
&#125;
</code></pre>
<p><strong>子组件</strong></p>
<pre><code>import React from &quot;react&quot;;

const Sub = (props) =&gt; &#123;
    return(
        &lt;h1&gt;
            &#123; props.title &#125;
        &lt;/h1&gt;
    )
&#125;

export default Sub;
</code></pre>
<h3 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h3><p><strong>父组件</strong></p>
<pre><code>import React,&#123; Component &#125; from &quot;react&quot;;
import Sub from &quot;./SubComponent.js&quot;;
import &quot;./App.css&quot;;

export default class App extends Component&#123;
    callback(msg)&#123;
        console.log(msg);
    &#125;
    render()&#123;
        return(
            &lt;div&gt;
                &lt;Sub callback = &#123; this.callback.bind(this) &#125; /&gt;
            &lt;/div&gt;
        )
    &#125;
&#125;
</code></pre>
<p><strong>子组件</strong></p>
<pre><code>import React from &quot;react&quot;;

const Sub = (props) =&gt; &#123;
    const cb = (msg) =&gt; &#123;
        return () =&gt; &#123;
            props.callback(msg)
        &#125;
    &#125;
    return(
        &lt;div&gt;
            &lt;button onClick = &#123; cb(&quot;我们通信把&quot;) &#125;&gt;点击我&lt;/button&gt;
        &lt;/div&gt;
    )
&#125;

export default Sub;
</code></pre>
<h3 id="跨组件传值"><a href="#跨组件传值" class="headerlink" title="跨组件传值"></a>跨组件传值</h3><blockquote>
<p>16.3版本提供了新的context api,并且用了生产者消费者模式，</p>
</blockquote>
<pre><code>const &#123;Provider, Consumer&#125; = React.createContext(&#123;
    color: &#39;white&#39;
&#125;);
 
 
class Item extends Component &#123;
    static contextTypes = &#123;
        color: React.PropTypes.string,
    &#125;;
 
    render() &#123;
        const &#123;value&#125; = this.props;
        return (
            &lt;Consumer&gt;
                &#123;context =&gt; (
                    &lt;li style=&#123;&#123;background: context.color&#125;&#125;&gt;
                        &lt;span&gt;&#123;value&#125;&lt;/span&gt;
                    &lt;/li&gt;
                )&#125;
            &lt;/Consumer&gt;
        );
    &#125;
&#125;
 
 
class List extends Component &#123;
 
    render() &#123;
        const &#123;list&#125; = [&#123;id: &#39;1&#39;, text: 1&#125;, &#123;id: &#39;1&#39;, text: 2&#125;, &#123;id: &#39;1&#39;, text: 3&#125;]
        return (
            &lt;Provider value=&#123;&#123;color: 'green'&#125;&#125;&gt;
                &lt;div&gt;
                    &lt;ul&gt;
                        &#123;list.map((entry, index) =&gt; (
                            &lt;Item key=&#123;entry.id&#125; value=&#123;entry.text&#125;/&gt;
                        ))&#125;
                    &lt;/ul&gt;
                &lt;/div&gt;
            &lt;/Provider&gt;
        );
    &#125;
&#125;
</code></pre>
<p><strong>上面的代码通过React.createContext创建出一个上下文：Context对象，然后这个Context对象又包含两个属性，一个叫Provider，另一个叫Consumer，这两个属性都是纯种的React组件。</strong></p>
<p><strong>在父组件中运用Provider，在子组件中运用Consumer即可，Provider中通过value属性可以向Consumer传递参数，而Consumer的子组件则是一个函数，在这个子组件中定义一个函数，Consumer会向它传递一个context，这个context来自于Provider，达到通信的目的</strong></p>
<h3 id="非嵌套组件间通信"><a href="#非嵌套组件间通信" class="headerlink" title="非嵌套组件间通信"></a>非嵌套组件间通信</h3><p><strong>这里我们采用自定义事件的方式来实现非嵌套组件间的通信。</strong></p>
<pre><code>npm install events --save
</code></pre>
<blockquote>
<p>新建一个 ev.js，引入 events 包，并向外提供一个事件对象，供通信时使用：</p>
</blockquote>
<pre><code>import &#123; EventEmitter &#125; from &quot;events&quot;;
export default new EventEmitter();
</code></pre>
<blockquote>
<p>App.js：</p>
</blockquote>
<pre><code>import React, &#123; Component &#125; from &#39;react&#39;;

import Foo from &quot;./Foo&quot;;
import Boo from &quot;./Boo&quot;;

import &quot;./App.css&quot;;

export default class App extends Component&#123;
    render()&#123;
        return(
            &lt;div&gt;
                &lt;Foo /&gt;
                &lt;Boo /&gt;
            &lt;/div&gt;
        );
    &#125;
&#125;
</code></pre>
<blockquote>
<p>Foo.js：</p>
</blockquote>
<pre><code>import React,&#123; Component &#125; from &quot;react&quot;;
import emitter from &quot;./ev&quot;

export default class Foo extends Component&#123;
    constructor(props) &#123;
        super(props);
        this.state = &#123;
            msg:null,
        &#125;;
    &#125;
    componentDidMount()&#123;
        // 声明一个自定义事件
        // 在组件装载完成以后
        this.eventEmitter = emitter.addListener(&quot;callMe&quot;,(msg)=&gt;&#123;
            this.setState(&#123;
                msg
            &#125;)
        &#125;);
    &#125;
    // 组件销毁前移除事件监听
    componentWillUnmount()&#123;
        emitter.removeListener(this.eventEmitter);
    &#125;
    render()&#123;
        return(
            &lt;div&gt;
                &#123; this.state.msg &#125;
                我是非嵌套 1 号
            &lt;/div&gt;
        );
    &#125;
&#125;
</code></pre>
<blockquote>
<p>Boo.js：</p>
</blockquote>
<pre><code>import React,&#123; Component &#125; from &quot;react&quot;;
import emitter from &quot;./ev&quot;

export default class Boo extends Component&#123;
    render()&#123;
        const cb = (msg) =&gt; &#123;
            return () =&gt; &#123;
                // 触发自定义事件
                emitter.emit(&quot;callMe&quot;,&quot;Hello&quot;)
            &#125;
        &#125;
        return(
            &lt;div&gt;
                我是非嵌套 2 号
                &lt;button onClick = &#123; cb(&quot;blue&quot;) &#125;&gt;点击我&lt;/button&gt;
            &lt;/div&gt;
        );
    &#125;
&#125;
</code></pre>
<p><strong>自定义事件是典型的发布/订阅模式，通过向事件对象上添加监听器和触发事件来实现组件间通信。</strong></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul>
<li>父传子：通过props</li>
<li>子传父：通过回调</li>
<li>跨组件传值： 引入react.createContext()中的{provider, consumer}，使用生产者和消费者模式，在父组件中使用provider 传入值，子组件通consumer 接收一个对象的函数回调[<consumer>{context =&gt; (&lt;\li&gt;{context}&lt;/li&gt;)}]</li>
<li>同级组件通讯：使用events插件，通过发布订阅者模式执行</li>
</ul>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈React的最大亮点——虚拟DOM</title>
    <url>/2019/04/03/virtualDom1%20/</url>
    <content><![CDATA[<h2 id="浅谈React的最大亮点——虚拟DOM"><a href="#浅谈React的最大亮点——虚拟DOM" class="headerlink" title="浅谈React的最大亮点——虚拟DOM"></a>浅谈React的最大亮点——虚拟DOM</h2><p><strong>React非常快速是因为它从不直接操作DOM。</strong></p>
<p><strong>虚拟DOM是在DOM的基础上建立了一个抽象层，对数据和状态所做的任何改动，都会被自动且高效的同步到虚拟DOM，最后再批量同步到DOM中。</strong></p>
<p><strong>在React中，render执行的结果得到的并不是真正的DOM节点，而仅仅是JavaScript对象，称之为虚拟DOM。</strong></p>
<p><strong>虚拟DOM具有批处理和高效的Diff算法，可以无需担心性能问题而随时“刷新”整个页面，因为虚拟DOM可以确保只对界面上真正变化的部分进行实际的DOM操作。</strong></p>
<h2 id="虚拟DOM的原理："><a href="#虚拟DOM的原理：" class="headerlink" title="虚拟DOM的原理："></a>虚拟DOM的原理：</h2><p><strong>React会在内存中维护一个虚拟DOM树，对这个树进行读或写，实际上是对虚拟DOM进行。当数据变化时，React会自动更新虚拟DOM，然后将新的虚拟DOM和旧的虚拟DOM进行对比，找到变更的部分，得出一个diff，然后将diff放到一个队列里，最终批量更新这些diff到DOM中。</strong></p>
<h2 id="虚拟DOM的优点："><a href="#虚拟DOM的优点：" class="headerlink" title="虚拟DOM的优点："></a>虚拟DOM的优点：</h2><p><strong>最终表现在DOM上的修改只是变更的部分，可以保证非常高效的渲染。</strong></p>
<h2 id="虚拟DOM的缺点："><a href="#虚拟DOM的缺点：" class="headerlink" title="虚拟DOM的缺点："></a>虚拟DOM的缺点：</h2><p><strong>首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。</strong></p>
<h2 id="虚拟DOM的理解误区"><a href="#虚拟DOM的理解误区" class="headerlink" title="虚拟DOM的理解误区"></a>虚拟DOM的理解误区</h2><p><strong>对虚拟DOM的理解往往停留在：通过JavaScript对象模拟原生DOM，加上DOM Diff 极大提升了DOM操作的性能。然而，虚拟DOM最大的意义不在于性能的提升（JavaScript对象比DOM对象性能高），而在于抽象了DOM的具体实现（对DOM进行了一层抽象），这在浏览器中使用 React时不是特别明显，因为写的DOM标签跟原生的没有区别，并且最终都被渲染成了DOM，在React Native中将会有很好的说明。</strong></p>
<h2 id="模拟方法和渲染方法"><a href="#模拟方法和渲染方法" class="headerlink" title="模拟方法和渲染方法"></a>模拟方法和渲染方法</h2><blockquote>
<p>调用</p>
</blockquote>
<pre><code>let virtualDom1 = createElement(&#39;ul&#39;, &#123;class: &#39;list&#39;&#125;, [
    createElement(&#39;li&#39;, &#123;class: &#39;item&#39;&#125;, [&#39;a&#39;]),
    createElement(&#39;li&#39;, &#123;class: &#39;item&#39;&#125;, [&#39;b&#39;]),
    createElement(&#39;li&#39;, &#123;class: &#39;item&#39;&#125;, [&#39;c&#39;]),
])
let virtualDom2 = createElement(&#39;ul&#39;, &#123;class: &#39;list&#39;&#125;, [
    createElement(&#39;li&#39;, &#123;class: &#39;item&#39;&#125;, [&#39;1&#39;]),
    createElement(&#39;li&#39;, &#123;class: &#39;item&#39;&#125;, [&#39;2&#39;]),
    createElement(&#39;li&#39;, &#123;class: &#39;item&#39;&#125;, [&#39;3&#39;]),
])
let el = render(virtualDom);
renderDom(el, window.root);
let patchs = diff(virtualDom1, virtualDom2);
</code></pre>
<blockquote>
<p>生成虚拟对象的方法createElement</p>
</blockquote>
<pre><code>function createElement(type, props, children) &#123;
    return new Element(type, props, children)
&#125;
class Element&#123;
    constructor(type, props, children)&#123;
        this.type = type;
        this.props = props;
        this.children = children
    &#125;
&#125;
</code></pre>
<blockquote>
<p>将虚拟对象渲染成真实DOM的render方法</p>
</blockquote>
<pre><code>//render方法将vNode转化成真实DOM
function render(eleObj)&#123;
    //创建元素
    let el = document.createElement(eleObj.type);
    //设置属性
    for(let key in eleObj.props) &#123;
        setAttr(el, key, eleObj.props[key]);
    &#125;
    //递归渲染子元素
    eleObj.children.foEach(child =&gt; &#123;
        child = child instanceof Element ? render(child) : document.createTextNode(child);
        el.appendChild(child);
    &#125;)
&#125;
setAttr(node, key, value) &#123;
    switch(key) &#123;
        case &#39;value&#39;:
            if (node.tagName.toUpperCase() === &#39;INPUT&#39; || node.tagName.toUpperCase() === &#39;TEXTAREA&#39;) &#123;
                node.value = value;          
            &#125;else &#123;
                node.setAttribute(key, value);
            &#125;
            break;
        case &#39;style&#39;:
            node.style.cssText = value;
            break;
        default:
            node.setAttribute(key, value);
            break;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>渲染节点到页面的方法renderDom</p>
</blockquote>
<pre><code>//将真实DOM渲染到页面
function renderDom(el, target) &#123;
    target.appendChild(el);
&#125;
</code></pre>
<h2 id="DOM-DIFF-算法"><a href="#DOM-DIFF-算法" class="headerlink" title="DOM DIFF 算法"></a>DOM DIFF 算法</h2><p><strong>DOM DIFF 就是比较两个虚拟DOM的区别，实际上就是比较两个对象的区别。根据两个虚拟对象创建出补丁，描述改变的内容。将这个补丁用来更新DOM。</strong></p>
<blockquote>
<p>【注意】不会更改所有节点，只更改有改变的部分</p>
</blockquote>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><blockquote>
<p>差异计算：先序深度优先遍历</p>
</blockquote>
<h4 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h4><ol>
<li>若节点类型不相同，直接采用替换模式，{type:’REPLACE’,newNode:newNode}</li>
<li>当节点类型相同时，去看一下属性是否相同，产生一个属性的补丁包，比如{type:’ATTRS’,attrs:{class: ‘list-group’}</li>
<li>新的DOM节点不存在，也返回一个不存在的补丁包{type:’REMOVE’,index:XXX}</li>
<li>文本的变化{type:’TEXT’, text:1}</li>
</ol>
<hr>
<pre><code>//diff 算法
let Index = 0;
function diff(oldTree, newTree) &#123;
    let patches = &#123;&#125;;
    let index = 0;
    //递归数比较后的结果放到补丁包中
    walk(oldTree, newTree, index, patches);
    return patches;
&#125;
function walk(oldTree, newTree, index, patches)&#123;
    let currentPatch = [];//每个元素都有一个补丁对象
    if (!newTree) &#123;
        currentPatch.push(&#123;type:&#39;REMOVE&#39;, index&#125;)
    &#125; 
    if (isString(oldTree) &amp;&amp; isString(newTree)) &#123;
        // 判断文本是否一致
        if (oldTree !== newTree) &#123;
            currentPatch.push(&#123;type:&#39;TEXT&#39;,text:newTree&#125;); 
        &#125;
    &#125;else if(oldTree.type === newTree.type) &#123;
        //比较属性是否有更改
        let attrs = diffAttr(oldTree.props, newTree.props);
        if(Object.keys(attrs).length) &#123;
            currentPatch.push(&#123;type:&#39;ATTRS&#39;, attrs&#125;);
        &#125;
        // 如果有儿子节点，遍历子节点
          diffChildren(oldTree.children, newTree.children, index, patches);
    &#125; else &#123;
        // 节点类型不同的时候，直接替换
        currentPatch.push(&#123;type:&#39;REPLACE&#39;, newTree&#125;);
    &#125;
    // 当前元素有补丁的情况下，将元素和补丁对应起来，放到大补丁包中
    if(currentPatch.length) &#123;
        patches[index] = currentPatch; 
    &#125;
&#125;
function diffAttr(oldAttrs, newAttrs) &#123;
    let patch = &#123;&#125;;
    for(let key in oldAttrs) &#123;
        if(oldAttrs[key] !== newAttrs[key]) &#123;
            patch[key] = newAttrs[key];//有可能是undefined，新节点没有旧节点的属性      
        &#125;
    &#125;
    for(let key in newAttrs) &#123;
        //老节点没有新节点的属性
        if(! oldAttrs.hasOwnProperty(key)) &#123;
            patch[key] = newAttrs[key]
        &#125;
    &#125;
    return patch;
&#125;

function diffChildren(oldChildren, newChildren, index, patches)&#123;
    // 比较老的第一个和新的第一个
    oldChildren.forEach((child, idx) =&gt; &#123;
        // 记得索引得改
        // Index 每次传递给walk时，index是递增的，所有节点都基于一个序号实现，因此需要维护一个全局Index
        walk(child, newChildren[idx], ++Index, patches);
    &#125;) 
&#125;


function isString(node) &#123;
    return Object.prototype.toString.call(node) === &#39;[object string]&#39;;
&#125;


function patch(node, patches) &#123;
 // 给某个元素打补丁
 
&#125;
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>dom结构发生改变： 直接卸载并重新create</li>
<li>dom结构一样： 不会卸载，但是会更新</li>
<li>在同一层级的子节点，他们都可以通过key开区分【同时遵循上面两点】</li>
</ul>
<h2 id="衍生："><a href="#衍生：" class="headerlink" title="衍生："></a>衍生：</h2><h3 id="加了key的好处"><a href="#加了key的好处" class="headerlink" title="加了key的好处:"></a>加了key的好处:</h3><blockquote>
<p>加了key值可以具体确定哪些元素被修改，便于对比新旧dom树，加快虚拟dom的渲染速度</p>
</blockquote>
<h3 id="我们该不该把map的index作为key"><a href="#我们该不该把map的index作为key" class="headerlink" title="我们该不该把map的index作为key"></a>我们该不该把map的index作为key</h3><blockquote>
<p>最好将数据本身的id最为key值，如果使用index作为key值，如果前后两次两次arr分别为[1,2,3,4]和[5,6,7,8]和前后两次arr分别为[1,2,3,4]和[4,3,2,1]的情况,很明显前者可以认为是DOM改变了,后者可以认为是DOM节点的位移操作,那么对于第一种情况来说index作为key和没有key值无区别,但是第二种情况用index作为key值效果没有比用数据本身作为key值好</p>
</blockquote>
<h3 id="key值必须唯一且不重复么"><a href="#key值必须唯一且不重复么" class="headerlink" title="key值必须唯一且不重复么"></a>key值必须唯一且不重复么</h3><blockquote>
<p>前提条件是是否为同一父节点</p>
</blockquote>
<hr>
<blockquote>
<p><a class="link"   href="https://www.jianshu.com/p/8c1505ebcf0e" >参考文章：飞飞廉的简书<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>React组件销毁中清理异步操作和取消请求</title>
    <url>/2019/04/03/react-question/</url>
    <content><![CDATA[<h2 id="React组件销毁中清理异步操作和取消请求"><a href="#React组件销毁中清理异步操作和取消请求" class="headerlink" title="React组件销毁中清理异步操作和取消请求"></a>React组件销毁中清理异步操作和取消请求</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><strong>当我们在平时切换组件的时候，会遇到这种情况，如果组件中有异步请求任务，【当接口已经发出请求，但是组件已经销毁，那么接口返回数据后。。。】</strong></p>
<p><strong>会有这么一个警告</strong></p>
<blockquote>
<p>Warning: Can’t perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.</p>
</blockquote>
<hr>
<blockquote>
<p>翻译： 警告：无法对未安装的组件执行响应状态更新。这是一个禁止操作，但它表示应用程序内存泄漏。要修复，请取消componentwillunmount方法中的所有订阅和异步任务。</p>
</blockquote>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><blockquote>
<p>情况一: 阻止异步操作</p>
</blockquote>
<pre><code>componentWillUnmount() &#123;
  this.setState = (state, callback) =&gt; &#123;
    return
  &#125;
&#125;
</code></pre>
<blockquote>
<p>情况二: 清除定时</p>
</blockquote>
<pre><code>var timer;
...
componentDidMount = () =&gt; &#123;
     timer = setTimeout(() =&gt; &#123;
        this.setState(&#123;a:123&#125;)
    &#125;,1000)
&#125;
componentWillUnMount = () =&gt; &#123;
    clearTimeout(timer)
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react中的setState的使用和深入理解</title>
    <url>/2019/04/03/setState/</url>
    <content><![CDATA[<h2 id="react中的setState的使用和深入理解"><a href="#react中的setState的使用和深入理解" class="headerlink" title="react中的setState的使用和深入理解"></a>react中的setState的使用和深入理解</h2><p><strong>React通过管理状态实现对组件的管理，通过this.state()方法更新state。当this.setState()被调用的时候，React会重新调用render方法来重新渲染UI。</strong></p>
<p><strong>在使用state的时候， 如果我们企图直接修改state中的某一个值之后直接打印（使用）他，就会发现，他其实并没有改变。</strong></p>
<p><strong>就像下面的例子，企图通过点击事件之后就使用修改之后的state的值，但是会发state中的并没有被立即修改，还是原先的值，我们都知道那是因为setState就相当于是一个异步操作，不能立即被修改</strong></p>
<pre><code>ClickChangeState () &#123;
    this.setState(&#123;
        isActive: true,
    &#125;)
    console.log(this.state.isActive) // false
&#125;
</code></pre>
<p><strong>那么我们也都知道为了解决上面的问题会有很多方法例如：</strong></p>
<blockquote>
<p>方法一：</p>
</blockquote>
<pre><code>ClickChangeState () &#123;
    this.setState(&#123;
        isActive: true,
    &#125;, () =&gt; &#123;
        console.log(this.state.isActive) // true
    &#125;)
    
&#125;
</code></pre>
<p><strong>这个回调函数会在修改了state之后才会执行，这就就可以使用修改之后的state的值了</strong></p>
<blockquote>
<p>方法二：</p>
</blockquote>
<pre><code>async ClickChangeState () &#123;
    await this.setState(&#123;
        isActive: true,
    &#125;)
    console.log(this.state.isActive) // false
&#125;
</code></pre>
<p><strong>操作异步函数，用的最舒服的还是async / await</strong></p>
<h2 id="在使用setState的时候，有两种格式"><a href="#在使用setState的时候，有两种格式" class="headerlink" title="在使用setState的时候，有两种格式;"></a>在使用setState的时候，有两种格式;</h2><h3 id="第一种setstate（）格式-第一个参数是一个对象，第二个参数是一个回调函数，这个回调函数是在setstate执行完并页面渲染了之后再执行"><a href="#第一种setstate（）格式-第一个参数是一个对象，第二个参数是一个回调函数，这个回调函数是在setstate执行完并页面渲染了之后再执行" class="headerlink" title="第一种setstate（）格式  第一个参数是一个对象，第二个参数是一个回调函数，这个回调函数是在setstate执行完并页面渲染了之后再执行"></a>第一种setstate（）格式  第一个参数是一个对象，第二个参数是一个回调函数，这个回调函数是在setstate执行完并页面渲染了之后再执行</h3><pre><code>ClickChangeState () &#123;
    this.setState(&#123;
        isActive: true,
    &#125;, () =&gt; &#123;
        console.log(this.state.isActive) // true
    &#125;)
    
&#125;
</code></pre>
<p><strong>但是这种修改的方式不稳妥，因为是直接修改</strong></p>
<h3 id="setstate的第二种格式，接收一个回调函数，而不是一个对象，这个回调函数有两个参数，"><a href="#setstate的第二种格式，接收一个回调函数，而不是一个对象，这个回调函数有两个参数，" class="headerlink" title="setstate的第二种格式，接收一个回调函数，而不是一个对象，这个回调函数有两个参数，"></a>setstate的第二种格式，接收一个回调函数，而不是一个对象，这个回调函数有两个参数，</h3><p><strong>一个是接收前一个状态值作为第一个参数，并将更新后的值作为第二个参数</strong></p>
<pre><code>ClickChangeState () &#123;
    this.setState((prevState) =&gt; &#123;
        isActive: !prevState.isActive,
    &#125;, () =&gt; &#123;
        console.log(this.state.isActive) // true
    &#125;)
    
&#125;
</code></pre>
<h2 id="setState异步更新"><a href="#setState异步更新" class="headerlink" title="setState异步更新"></a>setState异步更新</h2><blockquote>
<p>setState通过一个队列机制实现state的更新。当执行setState时，会把需要更新的state合并后放入状态队列，而不会立刻更新this.state，利用这个队列机制可以高效的批量的更新state。</p>
</blockquote>
<hr>
<blockquote>
<p>React文档中对setState的说明</p>
</blockquote>
<pre><code>void setState(
  function|object nextState,
  [function callback]
)
</code></pre>
<blockquote>
<p>The second (optional) parameter is a callback function that will be executed once setState is completed and the component is re-rendered. </p>
</blockquote>
<hr>
<blockquote>
<p>翻译： 第二个（可选）参数是一个回调函数，它将在setstate完成并重新呈现组件后执行。</p>
<p>也就是说，我们可以通过这个回调来拿到更新的state的值。<br>React也正是利用状态队列机制实现了setState的异步更新，避免频繁地重复更新state(pending的意思是未定的</p>
</blockquote>
<pre><code>//将新的state合并到状态更新队列中
   var nextState =  this._processPendingState(nextProps, nextContext);
   //根据更新队列和shouldComponent的状态来判断是否需要更新组件
   var shouldUpdate = 
      this._pendingForceUpdate ||
      !inst.shouldComponentUpdate ||
      inst.shouldComponentUpdate(nextProps, nextState, nextContext);
</code></pre>
<h2 id="setState循环调用风险"><a href="#setState循环调用风险" class="headerlink" title="setState循环调用风险"></a>setState循环调用风险</h2><p><strong>如果在shouldComponentUpdate或者componentWillUpdate方法中调用setState，此时this._pending-StateQueue != null，就会造成循环调用，使得浏览器内存占满后崩溃</strong></p>
<h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><pre><code>import React, &#123; Component &#125; from &#39;react&#39;;
   class Example extends Component &#123;
       constructor()&#123;
           super();
           //在组件初始化可以直接操作this.state
           this.state = &#123;
               val: 0
           &#125;
       &#125;
       componentDidMount()&#123;
           this.setState(&#123;
              val: this.state.val + 1
           &#125;);
           //第一次输出
           console.log(this.state.val);
           this.setState(&#123;
              val: this.state.val + 1
           &#125;);
           //第二次输出
           console.log(this.state.val);
           setTimeout(()=&gt;&#123;
              this.setState(&#123;val: this.state.val + 1&#125;);
               //第三次输出
               console.log(this.state.val);
               this.setState(&#123;
                  val: this.state.val + 1
               &#125;);
               //第四次输出
               console.log(this.state.val);
           &#125;, 0);  
       &#125;
       render()&#123;
           return null;
       &#125;
   &#125;
</code></pre>
<p><strong>上述代码中，4次console.log打印出来的val分别是: 0，0，2 ，3</strong></p>
<p><strong>我们来看一个简化的setState的调用栈</strong></p>
<pre><code>this.setState(newState) =&gt;
   newState存入pending队列 =&gt;
   调用enqueueUpdate =&gt;
   是否处于批量更新模式 =&gt;
   是的话将组件保存到dirtyComponents
   不是的话遍历dirtyComponents，调用updateComponent,更新pending state or props
</code></pre>
<h2 id="事务-transaction"><a href="#事务-transaction" class="headerlink" title="事务(transaction)"></a>事务(transaction)</h2><p><strong>事务就是将需要执行的方法用wrapper封装起来，再通过事务提供的perform方法执行。而再perform之前，先执行所wrapeer中的initialize方法，执行完需要执行的方法后，再执行close方法。一组initialize和close方法称为一个wrapper，事务支持多个wrapper叠加。</strong></p>
<p><strong>我们可以将4次setState简单规成两类，componentDidMount是一类，setTimeOut中的又是一类，因为这两次在不同的调用栈中执行。</strong></p>
<blockquote>
<p><strong>我们先看看在componentDidMount中setState的调用栈：</strong></p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/3.0.png"
                     
                ></p>
<blockquote>
<p><strong>再看看在setTimeOut中的调用栈：</strong></p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/3.1.png"
                     
                ></p>
<p><strong>前两次是整个将React组件渲染到DOM的过程就处于一个大的事务中</strong></p>
<p><strong>componentDidMount中调用setState时,两次setState的结果并没有立即生效，而是被放进了dirtyComponents中。因为新的state还没被应用到组件中。</strong></p>
<p><strong>setTimeOut中的两次setState，因为没有跟随组件到渲染dom的一个流程，导致了新的state马上生效，也就是说，setTimeOut中的第一次执行，setState时，this.state.val为1，而setState完成后打印时this.state.val变成了2。第二次的setState同理。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="在执行setState并不是说他是异步的，官方给出的说明是"><a href="#在执行setState并不是说他是异步的，官方给出的说明是" class="headerlink" title="在执行setState并不是说他是异步的，官方给出的说明是"></a>在执行setState并不是说他是异步的，官方给出的说明是</h3><blockquote>
<p>不保证this.state会立即更新，所以在调用这个方法后存取this.state可能会回传旧的值。</p>
<p>不保证调用setState就会同步地执行，而它们也可能最终被被批量调用(多次调用的情况下)。你可以提供额外的回调，回调将会在setState实际被完成时被执行。</p>
</blockquote>
<h3 id="在执行setState，他是跟随将react组件渲染到dom这个流程走的，会将新的state值放入到一个更新队列中，事务（transaction）会进行下一步操作。在批量调用的情况下，会对多个setState进行合并。"><a href="#在执行setState，他是跟随将react组件渲染到dom这个流程走的，会将新的state值放入到一个更新队列中，事务（transaction）会进行下一步操作。在批量调用的情况下，会对多个setState进行合并。" class="headerlink" title="在执行setState，他是跟随将react组件渲染到dom这个流程走的，会将新的state值放入到一个更新队列中，事务（transaction）会进行下一步操作。在批量调用的情况下，会对多个setState进行合并。"></a>在执行setState，他是跟随将react组件渲染到dom这个流程走的，会将新的state值放入到一个更新队列中，事务（transaction）会进行下一步操作。在批量调用的情况下，会对多个setState进行合并。</h3><h3 id="setTimeout中setState和在生命周期里setState的区别在于，setTimeout中的setState会自己触发一个transaction，而生命周期中的setState已经处于React生命周期的transaction中了。"><a href="#setTimeout中setState和在生命周期里setState的区别在于，setTimeout中的setState会自己触发一个transaction，而生命周期中的setState已经处于React生命周期的transaction中了。" class="headerlink" title="setTimeout中setState和在生命周期里setState的区别在于，setTimeout中的setState会自己触发一个transaction，而生命周期中的setState已经处于React生命周期的transaction中了。"></a>setTimeout中setState和在生命周期里setState的区别在于，setTimeout中的setState会自己触发一个transaction，而生命周期中的setState已经处于React生命周期的transaction中了。</h3>]]></content>
      <tags>
        <tag>js</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>React.Component 与 React.PureComponent（React之性能优化）</title>
    <url>/2019/04/03/PureComponent/</url>
    <content><![CDATA[<h2 id="React-Component-与-React-PureComponent（React之性能优化）"><a href="#React-Component-与-React-PureComponent（React之性能优化）" class="headerlink" title="React.Component 与 React.PureComponent（React之性能优化）"></a>React.Component 与 React.PureComponent（React之性能优化）</h2><p><strong>提起React.PureComponent，首先要从一个生命周期函数【shouldComponentUpdate】说起，都知道这个函数是用来控制组件是否应该被渲染</strong></p>
<pre><code>shouldComponentUpdate
</code></pre>
<p><strong>这个生命周期返回的是一个布尔值，如果返回为false的，其实就是不执行render函数，不执行就不会重新渲染，返回为true的时候，就会执行，如果不写这个生命周期，默认返回true</strong></p>
<p><strong>写入shouldComponentUpdate，可以提高性能，你可以在该函数根据业务需求来判断是否重新渲染</strong></p>
<pre><code>class CounterButton extends React.Component &#123;
    constructor(props) &#123;
        super(props);
        this.state = &#123;count: 1&#125;;
    &#125;
    shouldComponentUpdate(nextProps, nextState) &#123;
        if (this.props.color !== nextProps.color) &#123;
            return true;
        &#125;
        if (this.state.count !== nextState.count) &#123;
            return true;
        &#125;
        return false;
    &#125;
    render() &#123;
        return (
            &lt;button
                color=&#123;this.props.color&#125;
                onClick=&#123;() =&gt; this.setState(state =&gt; (&#123;count: state.count + 1&#125;))&#125;
            &gt;
                Count: &#123;this.state.count&#125;
            &lt;/button&gt;
        );
    &#125;
&#125;
</code></pre>
<h2 id="React-Component-与-React-PureComponent"><a href="#React-Component-与-React-PureComponent" class="headerlink" title="React.Component 与 React.PureComponent"></a>React.Component 与 React.PureComponent</h2><p><strong>通常情况下，我们会使用ES6的class关键字来创建React组件：</strong></p>
<pre><code>class MyComponent extends React.Component &#123;
    // some codes here ...
&#125;
</code></pre>
<p><strong>但是，你也可以创建一个继承React.PureComponent的React组件，就像这样</strong></p>
<pre><code>class MyComponent extends React.PureComponent &#123;
    // some codes here
&#125;
</code></pre>
<h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><ul>
<li>继承PureComponent时，不能再重写shouldComponentUpdate，否则会引发警告</li>
</ul>
<hr>
<pre><code>Warning: ListOfWords has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.
</code></pre>
<blockquote>
<p>警告：ListOfWords有一个名为ShouldComponentUpdate（）的方法。扩展react.pureComponent时不应使用ShouldComponentUpdate。如果使用shouldComponentUpdate，请扩展react.component。</p>
</blockquote>
<ul>
<li>继承PureComponent时，进行的是浅比较，也就是说，如果是引用类型的数据，只会比较是不是同一个地址，而不会比较具体这个地址存的数据是否完全一致</li>
</ul>
<h3 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h4><p><strong>当组件更新时，如果组件的 props 和 state 都没发生改变， render 方法就不会触发，省去 Virtual DOM 的生成和比对过程，达到提升性能的目的。具体就是 React 自动帮我们做了一层浅比较：</strong></p>
<pre><code>if (this._compositeType === CompositeTypes.PureClass) &#123;
    shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
&#125;
</code></pre>
<p><strong>而 shallowEqual 又做了什么呢？会比较 Object.keys(state | props) 的长度是否一致，每一个 key 是否两者都有，并且是否是一个引用，也就是只比较了第一层的值，确实很浅，所以深层的嵌套数据是对比不出来的。</strong></p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h4><p><strong>大部分情况下，你可以使用React.PureComponent而不必写你自己的shouldComponentUpdate，它只做一个浅比较。但是由于浅比较会忽略属性或状态突变的情况，此时你不能使用它。</strong></p>
<pre><code>class ListOfWords extends React.PureComponent &#123;
  render() &#123;
    return &lt;div&gt;&#123;this.props.words.join(&#39;,&#39;)&#125;&lt;/div&gt;;
  &#125;
&#125;

class WordAdder extends React.Component &#123;
  constructor(props) &#123;
    super(props);
    this.state = &#123;
      words: [&#39;marklar&#39;]
    &#125;;
    this.handleClick = this.handleClick.bind(this);
  &#125;

  handleClick() &#123;
    // This section is bad style and causes a bug
    const words = this.state.words;
    words.push(&#39;marklar&#39;);
    this.setState(&#123;words: words&#125;);
  &#125;

  render() &#123;
    return (
      &lt;div&gt;
        &lt;button onClick=&#123;this.handleClick&#125; /&gt;
        &lt;ListOfWords words=&#123;this.state.words&#125; /&gt;
      &lt;/div&gt;
    );
  &#125;
&#125;
</code></pre>
<p><strong>在ListOfWords中，this.props.words是WordAdder中传入的其state的一个引用。虽然在WordAdder的handelClick方法中被改变了，但是对于ListOfWords来说，其引用是不变的，从而导致并没有被更新。</strong></p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p><strong>在上面的问题中可以发现，当一个数据是不变数据时，可以使用一个引用。但是对于一个易变数据来说，不能使用引用的方式给到PureComponent。简单来说，就是我们在PureComponent外层来修改其使用的数据时，应该给其赋值一个新的对象或者引用，从而才能确保其能够进行重新渲染。例如上面例子中的handleClick可以通过以下几种来进行修改从而确认正确的渲染：</strong></p>
<pre><code>handleClick() &#123;
  this.setState(prevState =&gt; (&#123;
    words: prevState.words.concat([&#39;marklar&#39;])
  &#125;));
&#125;

或者

handleClick() &#123;
  this.setState(prevState =&gt; (&#123;
    words: [...prevState.words, &#39;marklar&#39;],
  &#125;));
&#125;;

或者针对对象结构：

function updateColorMap(oldObj) &#123;
  return Object.assign(&#123;&#125;, oldObj, &#123;key: new value&#125;);
&#125;
</code></pre>
<h4 id="immutable-js"><a href="#immutable-js" class="headerlink" title="immutable.js"></a>immutable.js</h4><p><strong>是解决这个问题的另一种方法。它通过结构共享提供不可突变的，持久的集合：</strong></p>
<p>详情参考<a class="link"   href="https://github.com/immutable-js/immutable-js" >immutable.js<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p><strong>PureComponent 真正起作用的，只是在一些纯展示组件上，复杂组件使用的话shallowEqual 那一关基本就过不了。另外在使用的过程中为了确保能够正确的渲染，记得 props 和 state 不能使用同一个引用哦。</strong></p>
</blockquote>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>vue混入【mixins】</title>
    <url>/2019/04/02/minxins/</url>
    <content><![CDATA[<h2 id="vue混入【mixins】"><a href="#vue混入【mixins】" class="headerlink" title="vue混入【mixins】"></a>vue混入【mixins】</h2><p><strong>混入 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。</strong></p>
<pre><code>// 定义一个混入对象
var myMixin = &#123;
  created: function () &#123;
    this.hello()
  &#125;,
  methods: &#123;
    hello: function () &#123;
      console.log(&#39;hello from mixin!&#39;)
    &#125;
  &#125;
&#125;

// 定义一个使用混入对象的组件
var Component = Vue.extend(&#123;
  mixins: [myMixin]
&#125;)

var component = new Component() // =&gt; &quot;hello from mixin!&quot;
</code></pre>
<h2 id="选项合并"><a href="#选项合并" class="headerlink" title="选项合并"></a>选项合并</h2><p><strong>当组件和混入对象含有同名选项时，这些选项将以恰当的方式混合。</strong></p>
<p><strong>比如，数据对象在内部会进行递归合并，在和组件的数据发生冲突时以组件数据优先。</strong></p>
<pre><code>var mixin = &#123;
  data: function () &#123;
    return &#123;
      message: &#39;hello&#39;,
      foo: &#39;abc&#39;
    &#125;
  &#125;
&#125;

new Vue(&#123;
  mixins: [mixin],
  data: function () &#123;
    return &#123;
      message: &#39;goodbye&#39;,
      bar: &#39;def&#39;
    &#125;
  &#125;,
  created: function () &#123;
    console.log(this.$data)
    // =&gt; &#123; message: &quot;goodbye&quot;, foo: &quot;abc&quot;, bar: &quot;def&quot; &#125;
  &#125;
&#125;)
</code></pre>
<p><strong>同名钩子函数将混合为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。</strong></p>
<pre><code>var mixin = &#123;
  created: function () &#123;
    console.log(&#39;混入对象的钩子被调用&#39;)
  &#125;
&#125;

new Vue(&#123;
  mixins: [mixin],
  created: function () &#123;
    console.log(&#39;组件钩子被调用&#39;)
  &#125;
&#125;)

// =&gt; &quot;混入对象的钩子被调用&quot;
// =&gt; &quot;组件钩子被调用&quot;
</code></pre>
<p><strong>值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。</strong></p>
<pre><code>var mixin = &#123;
  methods: &#123;
    foo: function () &#123;
      console.log(&#39;foo&#39;)
    &#125;,
    conflicting: function () &#123;
      console.log(&#39;from mixin&#39;)
    &#125;
  &#125;
&#125;

var vm = new Vue(&#123;
  mixins: [mixin],
  methods: &#123;
    bar: function () &#123;
      console.log(&#39;bar&#39;)
    &#125;,
    conflicting: function () &#123;
      console.log(&#39;from self&#39;)
    &#125;
  &#125;
&#125;)

vm.foo() // =&gt; &quot;foo&quot;
vm.bar() // =&gt; &quot;bar&quot;
vm.conflicting() // =&gt; &quot;from self&quot;
</code></pre>
<p><strong>注意：Vue.extend() 也使用同样的策略进行合并。</strong></p>
<h2 id="全局混入"><a href="#全局混入" class="headerlink" title="全局混入"></a>全局混入</h2><p><strong>也可以全局注册混入对象。注意使用！ 一旦使用全局混入对象，将会影响到 所有 之后创建的 Vue 实例。使用恰当时，可以为自定义对象注入处理逻辑。</strong></p>
<pre><code>// 为自定义的选项 &#39;myOption&#39; 注入一个处理器。
Vue.mixin(&#123;
  created: function () &#123;
    var myOption = this.$options.myOption
    if (myOption) &#123;
      console.log(myOption)
    &#125;
  &#125;
&#125;)

new Vue(&#123;
  myOption: &#39;hello!&#39;
&#125;)
// =&gt; &quot;hello!&quot;
</code></pre>
<blockquote>
<p><strong>谨慎使用全局混入对象，因为会影响到每个单独创建的 Vue 实例 (包括第三方模板)。大多数情况下，只应当应用于自定义选项，就像上面示例一样。也可以将其用作 Plugins 以避免产生重复应用</strong></p>
</blockquote>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue自定义指令</title>
    <url>/2019/04/02/vue-directive/</url>
    <content><![CDATA[<h2 id="vue自定义指令"><a href="#vue自定义指令" class="headerlink" title="vue自定义指令"></a>vue自定义指令</h2><blockquote>
<p>注册全局指令</p>
</blockquote>
<pre><code>// 注册一个全局自定义指令 `v-focus`
Vue.directive(&#39;focus&#39;, &#123;
  // 当被绑定的元素插入到 DOM 中时……
  inserted: function (el) &#123;
    // 聚焦元素
    el.focus()
  &#125;
&#125;)
</code></pre>
<blockquote>
<p>注册局部指令</p>
</blockquote>
<pre><code>directives: &#123;
  focus: &#123;
    // 指令的定义
    inserted: function (el) &#123;
      el.focus()
    &#125;
  &#125;
&#125;
</code></pre>
<blockquote>
<p>使用方式</p>
</blockquote>
<pre><code>&lt;input v-focus&gt;
</code></pre>
<h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><p><strong>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</strong></p>
<blockquote>
<p>bind</p>
</blockquote>
<p><strong>只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</strong></p>
<blockquote>
<p>inserted</p>
</blockquote>
<p><strong>被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</strong></p>
<blockquote>
<p>update</p>
</blockquote>
<p><strong>所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</strong></p>
<blockquote>
<p>componentUpdated</p>
</blockquote>
<p><strong>指令所在组件的 VNode 及其子 VNode 全部更新后调用。</strong></p>
<blockquote>
<p>unbind</p>
</blockquote>
<p><strong>只调用一次，指令与元素解绑时调用。</strong></p>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue的路由导航守卫</title>
    <url>/2019/04/02/vue-router-beforeEach/</url>
    <content><![CDATA[<h2 id="vue的路由导航守卫"><a href="#vue的路由导航守卫" class="headerlink" title="vue的路由导航守卫"></a>vue的路由导航守卫</h2><p><strong>vue-router提供的导航守卫主要是用来通过跳转和取消的方式守卫导航。一共有三种植入路由导航的过程</strong></p>
<blockquote>
<p>全局前置(后置)守卫</p>
</blockquote>
<pre><code>const router = new VueRouter(&#123; ... &#125;)

router.beforeEach((to, from, next) =&gt; &#123; // 前置
  // ...
&#125;)

router.afterEach((to, from) =&gt; &#123; // 后置
  // ...
&#125;)
</code></pre>
<blockquote>
<p>路由独享守卫</p>
</blockquote>
<pre><code>const router = new VueRouter(&#123;
  routes: [
    &#123;
      path: &#39;/foo&#39;,
      component: Foo,
      beforeEnter: (to, from, next) =&gt; &#123;
        // ...
      &#125;
    &#125;
  ]
&#125;)
</code></pre>
<blockquote>
<p>组件内的守卫</p>
</blockquote>
<ul>
<li>beforeRouteEnter</li>
<li>beforeRouteUpdate</li>
<li>beforeRouteLeave</li>
</ul>
<hr>
<pre><code>const Foo = &#123;
  template: `...`,
  beforeRouteEnter (to, from, next) &#123;
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当守卫执行前，组件实例还没被创建
  &#125;,
  beforeRouteUpdate (to, from, next) &#123;
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
  &#125;,
  beforeRouteLeave (to, from, next) &#123;
    // 导航离开该组件的对应路由时调用
    // 可以访问组件实例 `this`
  &#125;
&#125;
</code></pre>
<p><strong>beforeRouteEnter 守卫 不能 访问 this，因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。</strong></p>
<p><strong>不过，你可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</strong></p>
<pre><code>beforeRouteEnter (to, from, next) &#123;
  next(vm =&gt; &#123;
    // 通过 `vm` 访问组件实例
  &#125;)
&#125;
</code></pre>
<p><strong>注意 beforeRouteEnter 是支持给 next 传递回调的唯一守卫。对于 beforeRouteUpdate 和 beforeRouteLeave 来说，this 已经可用了，所以不支持传递回调，因为没有必要了。</strong></p>
<pre><code>beforeRouteUpdate (to, from, next) &#123;
  // just use `this`
  this.name = to.params.name
  next()
&#125;
</code></pre>
<p><strong>这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消。</strong></p>
<pre><code>beforeRouteLeave (to, from , next) &#123;
  const answer = window.confirm(&#39;Do you really want to leave? you have unsaved changes!&#39;)
  if (answer) &#123;
    next()
  &#125; else &#123;
    next(false)
  &#125;
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue和react的区别</title>
    <url>/2019/04/01/vue-react-diff/</url>
    <content><![CDATA[<h2 id="vue和react的区别"><a href="#vue和react的区别" class="headerlink" title="vue和react的区别"></a>vue和react的区别</h2><blockquote>
<p>react和vue都是组件化，整体功能类似，但是设计思路有有所不同，</p>
</blockquote>
<h3 id="出身"><a href="#出身" class="headerlink" title="出身"></a>出身</h3><blockquote>
<p>react</p>
</blockquote>
<p><strong>React是由Facebook创建的JavaScript UI框架，它的诞生改变了JavaScript世界，最大的一个改变就是React推广了Virtual DOM， 并且创造了新的语法 – JSX，JSX 允许在JavaScript中写html代码。</strong></p>
<blockquote>
<p>vue</p>
</blockquote>
<p><strong>Vue是由尤大大开发的一个MVVM框架，它采用的是模板系统而不是JSX。</strong></p>
<h3 id="模板渲染方式不同"><a href="#模板渲染方式不同" class="headerlink" title="模板渲染方式不同"></a>模板渲染方式不同</h3><blockquote>
<p>react</p>
</blockquote>
<p><strong>React是通过JSX来渲染模板，React通过原生JS实现模板中的常见语法，比如说条件啊、循环啊、三元运算符啊等，都是通过JS语法实现</strong></p>
<blockquote>
<p>vue</p>
</blockquote>
<p><strong>vue是通过扩展的HTML来进行模板的渲染，Vue是在和组件代码分离的单独模板中，通过指令v-if、v-for等实现</strong></p>
<h3 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h3><blockquote>
<p>react</p>
</blockquote>
<p><strong>React默认是通过比较引用得方式进行，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。如果想避免不必要的子组件重新渲染，你需要在所有可能的地方使用PureComponent，或者手动实现shouldComponentUpdate方法。但是Vue中，你可以认定它是默认的优化。</strong></p>
<blockquote>
<p>vue</p>
</blockquote>
<p><strong>Vue可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，由于vue会跟踪每一个组件的依赖收集，通过setter / getter 以及一些函数的劫持，能够精确地知道变化，并在编译过程标记了static静态节点，在接下来新的Virtual DOM 并且和原来旧的 Virtual DOM进行比较时候，跳过static静态节点。所以不需要重新渲染整个组件树。</strong></p>
<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><h3 id="Vuex-和-Redux"><a href="#Vuex-和-Redux" class="headerlink" title="Vuex 和 Redux"></a>Vuex 和 Redux</h3><blockquote>
<p>react</p>
</blockquote>
<p><strong>在React中，我们需要每一个组件都引入connect，目的就是把props和dispatch连接起来。redux只能通过dispatch，然后在reducer里，接收到action，通过判断action的type，从而进行对应的操作，redux不能直接调用reducer进行修改！！</strong></p>
<blockquote>
<p>vue</p>
</blockquote>
<p><strong>在vuex中，我们可以通过在main.js中，引入 store文件夹，并把store挂载到new Vue实例中，这样我们可以直接通过$store灵活使用。</strong></p>
<blockquote>
<ul>
<li>你可以通过dispatch和commit进行更新数据，</li>
<li>通过this.$store.state.xx读取数据</li>
<li>你可以通过mapState / mapActions 进行vuex的操作</li>
</ul>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr>
<blockquote>
<ul>
<li>组件的创建方式不一样<ul>
<li>react使用class和函数创建组件【只有局部】</li>
<li>vue则使用vue的实例的components方法和components属性【有局部和全局一说】</li>
</ul>
</li>
<li>在react中没有指令，计算属性，watch监听，computed，这些内容</li>
<li>在react组件中只有几个概念，生命周期，state。props。合成事件</li>
<li>在vue中可以使用v-modle完成数据的双向绑定，而在react并没有指令的概念，所以使用受控组件代替</li>
<li>在vue中使用getter，setter拦截器，处理数据的绑定，而react则使用的是setState手动触发</li>
</ul>
</blockquote>
<hr>
]]></content>
      <tags>
        <tag>react</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue路由的实现原理</title>
    <url>/2019/04/01/vue-router-left/</url>
    <content><![CDATA[<h2 id="vue路由的实现原理"><a href="#vue路由的实现原理" class="headerlink" title="vue路由的实现原理"></a>vue路由的实现原理</h2><blockquote>
<p>在vue中路由主要有 hash与History interface两种方式实现前端路由，单页路由的特点就是采用前端路由系统，通过改变URL，在不重新请求页面的情况下，更新页面视图。目前在浏览器环境中这一功能的实现主要有两种方式</p>
</blockquote>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><blockquote>
<p>在浏览器的url中hash（“#”）符号的本来作用是加在URL中指示网页中的位置：#符号本身以及它后面的字符称之为hash，可通过window.location.hash属性读取。</p>
</blockquote>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><blockquote>
<p>hash虽然出现在URL中，但不会被包括在HTTP请求中。它是用来指导浏览器动作的，对服务器端完全无用，因此，改变hash不会重新加载页面，并且可以为hash的改变添加hashchange监听事件，在一个就是每一次改变hash（window.location.hash），都会在浏览器的访问历史中增加一个记录，我就可以通过他的这几个特点实现一个hash模式的单页路由，通过对location.hash的修改实现push方法（跳转页面），通过对location.href的修改实现replace()方法，通过对hashchange事件的监听实现页面跳转后的数据更新</p>
</blockquote>
<h3 id="History"><a href="#History" class="headerlink" title="History"></a>History</h3><blockquote>
<p>History模式则是完全采用了h5的新特性，从HTML5开始，History interface提供了两个新的方法：pushState(), replaceState()使得我们可以对浏览器历史记录栈进行修改，以及popState事件可以监听到状态的变更</p>
</blockquote>
<p><strong>不过history模式有一个问题就是</strong></p>
<blockquote>
<p>对于单页应用来讲，理想的使用场景是仅在进入应用时加载index.html，后续在的网络操作通过Ajax完成，不会根据URL重新请求页面，但是如果用户直接在地址栏中输入并回车，浏览器重启重新加载的时候history模式则会将URL修改得就和正常请求后端的URL一样，在此情况下重新向后端发送请求，如后端没有配置对应 的路由处理，则会返回404错误。这种问题的解决，一般情况下我们都是在后端进行配置，将所有的路由请求都指向index.html文件</p>
</blockquote>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue-router</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的几种数组排序算法JS实现</title>
    <url>/2019/04/01/Sortt/</url>
    <content><![CDATA[<h2 id="常见的几种数组排序算法JS实现"><a href="#常见的几种数组排序算法JS实现" class="headerlink" title="常见的几种数组排序算法JS实现"></a>常见的几种数组排序算法JS实现</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><blockquote>
<p>故名思意 ，就是一个个冒泡到最前端或者最后端，主要是通过两两依次比较，以升序为例，如果前一项比后一项大则交换顺序，一直比到最后一对 </p>
</blockquote>
<pre><code>    function bubbleSort(arr) &#123;
  　　var len = arr.length; // 定义该数组的长度
  　　for (var i = 0; i &lt; len; i++) &#123; // 遍历
        console.log(arr[i], arr[i+1])
  　　　　for (var j = 0; j &lt; len - 1 - i; j++) &#123;
              
  　　　　　　if (arr[j] &gt; arr[j+1]) &#123; //相邻元素两两对比
  　　　　　　　　var temp = arr[j+1]; //元素交换
  　　　　　　　　arr[j+1] = arr[j];
  　　　　　　　　arr[j] = temp;
  　　　　　　&#125;
  　　　　&#125;
  　　&#125;
  　　return arr;
  &#125;
  var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
  console.log(bubbleSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] ；
</code></pre>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><blockquote>
<p>获取到数组长度，遍历第一次【不遍历最后一个】，定义变量保存下标，遍历第二次【不遍历第一个】，将数组的第一个与数组的第二个值作比较，如果第二个值小于第一个值，将第一次保存的变量下标进行一个替换【替换成最小数的索引】，如果不小于就不做操作，</p>
</blockquote>
<pre><code>    function selectionSort(arr) &#123;
  　　var len = arr.length;
  　　var minIndex, temp;
  　　console.time(&#39;选择排序耗时&#39;);
  　　for (var i = 0; i &lt; len - 1; i++) &#123;
  　　　　minIndex = i;
  　　　　for (var j = i + 1; j &lt; len; j++) &#123;
  　　　　　　if (arr[j] &lt; arr[minIndex]) &#123; //寻找最小的数
  　　　　　　　　minIndex = j; //将最小数的索引保存
  　　　　　　&#125;
  　　　　&#125;
  　　　　temp = arr[i];
  　　　　arr[i] = arr[minIndex];
  　　　　arr[minIndex] = temp;
  　　&#125;
  　　console.timeEnd(&#39;选择排序耗时&#39;);
  　　return arr;
  &#125;
  var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
  console.log(selectionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]；
</code></pre>
<h3 id="二分法插入排序"><a href="#二分法插入排序" class="headerlink" title="二分法插入排序"></a>二分法插入排序</h3><blockquote>
<p>第一次遍历【不遍历第一个】，将遍历的第一个值保存起来，定义起始点</p>
</blockquote>
<pre><code>    function binaryInsertionSort(array) &#123;
  　　console.time(&#39;二分插入排序耗时：&#39;);
  　　for (var i = 1; i &lt; array.length; i++) &#123;
  　　　　var key = array[i], left = 0, right = i - 1;
          // key = 3 ,left = 0, right = 0
          // key = 44 ,left = 0, right = 1
  　　　　while (left &lt;= right) &#123; // 0 &lt;= -1   // 0 &lt;= 1
  　　　　　　var middle = parseInt((left + right) / 2); // 0 // 0
  　　　　　　if (key &lt; array[middle]) &#123; // 3 &lt; arr[0] = 44 44 &lt; 44
  　　　　　　　　right = middle - 1; // right = -1
  　　　　　　&#125; else &#123;
  　　　　　　　　left = middle + 1;  // left = 1
  　　　　　　&#125;
  　　　　&#125;
  　　　　for (var j = i - 1; j &gt;= left; j--) &#123; // 循环 
  　　　　　　array[j + 1] = array[j]; // arr[1] = arr[0]  arr [2] = 
  　　　　&#125;
  　　　　array[left] = key; // arr[0] = 44
  　　&#125;
  　　console.timeEnd(&#39;二分插入排序耗时：&#39;);
  　　return array;
  &#125;
  var arr=[44,3,38,5,47,15,36,26,27,2,46,4,19,50,48];
  console.log(binaryInsertionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50];
</code></pre>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <tags>
        <tag>js</tag>
        <tag>sort</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>什么叫优雅降级和渐进增强？</title>
    <url>/2019/03/29/Downgrade/</url>
    <content><![CDATA[<h2 id="什么叫优雅降级和渐进增强？"><a href="#什么叫优雅降级和渐进增强？" class="headerlink" title="什么叫优雅降级和渐进增强？"></a>什么叫优雅降级和渐进增强？</h2><h3 id="优雅降级"><a href="#优雅降级" class="headerlink" title="优雅降级:"></a>优雅降级:</h3><blockquote>
<p>Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。 </p>
<p>如：border-shadow </p>
</blockquote>
<p><strong>优雅降级写法</strong></p>
<pre><code>.transition &#123;
          transition: all .5s;
       -o-transition: all .5s;
     -moz-transition: all .5s;
  -webkit-transition: all .5s;
&#125;
</code></pre>
<h3 id="渐进增强"><a href="#渐进增强" class="headerlink" title="渐进增强:"></a>渐进增强:</h3><blockquote>
<p>从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 </p>
<p>如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验；</p>
</blockquote>
<p><strong>渐进增强写法</strong></p>
<pre><code>.transition &#123;
  -webkit-transition: all .5s;
     -moz-transition: all .5s;
       -o-transition: all .5s;
          transition: all .5s;
&#125;
</code></pre>
<h3 id="前缀CSS3（-webkit-moz-o-）和正常CSS3在浏览器中的支持情况是这样的："><a href="#前缀CSS3（-webkit-moz-o-）和正常CSS3在浏览器中的支持情况是这样的：" class="headerlink" title="前缀CSS3（-webkit- / -moz- / -o-）和正常CSS3在浏览器中的支持情况是这样的："></a>前缀CSS3（-webkit- / -moz- / -o-）和正常CSS3在浏览器中的支持情况是这样的：</h3><blockquote>
<ul>
<li><p>很久以前：浏览器前缀CSS3和正常CSS3都不支持；</p>
</li>
<li><p>不久之前：浏览器只支持前缀CSS3，不支持正常CSS3；</p>
</li>
<li><p>现在：浏览器既支持前缀CSS3，又支持正常CSS3；</p>
</li>
<li><p>未来：浏览器不支持前缀CSS3，仅支持正常CSS3.</p>
</li>
</ul>
</blockquote>
<hr>
<blockquote>
<p><strong>ps：从这里可以引申到其他有前缀的css3的属性，不要局限在这个属性里。</strong></p>
</blockquote>
<p><strong>优雅降级的例子：</strong></p>
<blockquote>
<p>假如你写了一个表单，没有用到input type=”submit”表单元素，用了一个a标签的click事件做提交，但如果Javascript被禁用了怎么办？<br>使用如下的文档结构，就可以在javascript被禁用时，依然可以提交。</p>
</blockquote>
<pre><code>&lt;form&gt;
    &lt;input type=&quot;text&quot;&gt;
    &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;
</code></pre>
<blockquote>
<p>优雅降级需要正确地体现HTML标签的语义，符合“浏览器的预期”。让你的网页在各种情况—下——包括降级（javascript被禁用，css传输失败等等）的情形都可以运作良好。这是我理解的优雅降级的意义。</p>
</blockquote>
<h3 id="在网页布局中如何选择？"><a href="#在网页布局中如何选择？" class="headerlink" title="在网页布局中如何选择？"></a>在网页布局中如何选择？</h3><blockquote>
<p>如果软件开发的预算和时间充足，就不存在抉择的问题，可以两者都调整到一个最佳状态，而不用权衡，做选择题了。然而现实很残酷，要么开发周期短，要么开发预算少，或者二者兼而有之，这个时候该如何抉择？就我个人而言，讲讲我的观点。</p>
</blockquote>
<h3 id="分析使用你客户端程序的版本比例。"><a href="#分析使用你客户端程序的版本比例。" class="headerlink" title="分析使用你客户端程序的版本比例。"></a>分析使用你客户端程序的版本比例。</h3><blockquote>
<p>如果低版本用户居多，当然优先采用渐进增强的开发流程；</p>
<p>如果高版本用户居多，为了提高大多数用户的使用体验，那当然优先采用优雅降级的开发流程。</p>
</blockquote>
<h3 id="大多数公司是怎么处理这个问题的："><a href="#大多数公司是怎么处理这个问题的：" class="headerlink" title="大多数公司是怎么处理这个问题的："></a>大多数公司是怎么处理这个问题的：</h3><blockquote>
<ul>
<li><p>绝大多数的大公司都是采用渐进增强的方式，因为业务优先，提升用户体验永远不会排在最前面。</p>
</li>
<li><p>例如：新浪微博网站前端的更新，拥有这种亿级用户的网站，绝对不可能追求某个特效而不考虑低版本用户可不可用，一定是确保低版本到高版本的可访问性，再去渐进增强，采用新功能给高版本用户提供更好的用户体验。</p>
</li>
<li><p>但也不是没有反例。如果你开发的是一款面向青少年的软件（或网站）</p>
</li>
<li><p>你知道这个群体的人总是喜欢尝试新事物，总是喜欢酷炫的特效，总是喜欢把它们的软件更新到最新版本。面对这种情况，渐进增强的开发流程实为上选。</p>
</li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>兼容与优化</tag>
      </tags>
  </entry>
  <entry>
    <title>页面重构如何操作？</title>
    <url>/2019/03/29/optimization/</url>
    <content><![CDATA[<h2 id="页面重构如何操作？"><a href="#页面重构如何操作？" class="headerlink" title="页面重构如何操作？"></a>页面重构如何操作？</h2><h3 id="网站重构："><a href="#网站重构：" class="headerlink" title="网站重构："></a>网站重构：</h3><blockquote>
<p>在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。 </p>
<p>也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。 </p>
</blockquote>
<h3 id="对于传统的网站来说重构通常是："><a href="#对于传统的网站来说重构通常是：" class="headerlink" title="对于传统的网站来说重构通常是："></a>对于传统的网站来说重构通常是：</h3><blockquote>
<p>表格(table)布局改为DIV+CSS </p>
<p>使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) </p>
<p>对于移动平台的优化 </p>
<p>针对于SEO进行优化 </p>
<p>深层次的网站重构应该考虑的方面 </p>
<p>减少代码间的耦合</p>
<p>让代码保持弹性 </p>
<p>严格按规范编写代码 </p>
<p>设计可扩展的API </p>
<p>代替旧有的框架、语言(如VB) </p>
<p>增强用户体验 </p>
<p>通常来说对于速度的优化也包含在重构中 </p>
<p>压缩JS、CSS、image等前端资源(通常是由服务器来解决) </p>
<p>程序的性能优化(如数据读写) </p>
<p>采用CDN来加速资源加载 </p>
<p>对于JS DOM的优化 </p>
<p>HTTP服务器的文件缓存 </p>
</blockquote>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>兼容与优化</tag>
      </tags>
  </entry>
  <entry>
    <title>js创建对象的几种方式</title>
    <url>/2019/03/29/CreatObject/</url>
    <content><![CDATA[<h2 id="js创建对象的几种方式"><a href="#js创建对象的几种方式" class="headerlink" title="js创建对象的几种方式"></a>js创建对象的几种方式</h2><h3 id="对象字面两的方式"><a href="#对象字面两的方式" class="headerlink" title="对象字面两的方式"></a>对象字面两的方式</h3><pre><code>person = &#123;
    firstname:&quot;Mark&quot;,
    lastname:&quot;Yun&quot;,
    age:25,
    eyecolor:&quot;black&quot;
&#125;
</code></pre>
<h3 id="用function来模拟无参的构造函数"><a href="#用function来模拟无参的构造函数" class="headerlink" title="用function来模拟无参的构造函数"></a>用function来模拟无参的构造函数</h3><pre><code>function Person () &#123;&#125; 
    //定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Class 
   var person=new Person();
   person.name=“Mark&quot;; 
   person.age=&quot;25&quot;; 
   person.work = function () &#123; 
       alert(person.name+&quot; hello...&quot;); 
  &#125; 
   person.work(); 
</code></pre>
<h3 id="用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）"><a href="#用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）" class="headerlink" title="用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）"></a>用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）</h3><pre><code>function Pet(name,age,hobby)&#123; 
   this.name=name; // this作用域：当前对象 
   this.age=age; 
   this.hobby=hobby; 
   this.eat=function()&#123; 
       alert(&quot;我叫&quot;+this.name+&quot;,我喜欢&quot;+this.hobby+&quot;,是个程序员&quot;); 
    &#125; 
&#125; 
var maidou =new Pet(&quot;麦兜&quot;,25,&quot;coding&quot;); // 实例化、创建对象 
maidou.eat();//调用eat方法 
</code></pre>
<h3 id="用工厂方式来创建（内置对象）"><a href="#用工厂方式来创建（内置对象）" class="headerlink" title="用工厂方式来创建（内置对象）"></a>用工厂方式来创建（内置对象）</h3><pre><code>var wcDog =new Object(); 
  wcDog.name=&quot;旺财&quot;; 
  wcDog.age=3; 
  wcDog.work=function()&#123; 
       alert(&quot;我是&quot;+wcDog.name+&quot;,汪汪汪......&quot;); 
  &#125; 
wcDog.work(); 
</code></pre>
<h3 id="用原型方式来创建"><a href="#用原型方式来创建" class="headerlink" title="用原型方式来创建"></a>用原型方式来创建</h3><pre><code>function Dog()&#123; &#125; 
Dog.prototype.name=&quot;旺财&quot;; 
Dog.prototype.eat=function()&#123;alert(this.name+&quot;是个吃货&quot;);&#125; 
var wangcai =new Dog(); 
wangcai.eat(); 
</code></pre>
<h3 id="用混合方式来创建"><a href="#用混合方式来创建" class="headerlink" title="用混合方式来创建"></a>用混合方式来创建</h3><pre><code>function Car(name,price)&#123; 
   this.name=name; 
   this.price=price; 
&#125; 
Car.prototype.sell=function()&#123; 
   alert(&quot;我是&quot;+this.name+&quot;，我现在卖&quot;+this.price+&quot;万元&quot;); 
&#125; 
var camry =new Car(&quot;凯美瑞&quot;,27); 
camry.sell(); 
</code></pre>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>object</tag>
      </tags>
  </entry>
  <entry>
    <title>js继承的几种方式</title>
    <url>/2019/03/29/extend/</url>
    <content><![CDATA[<h2 id="js继承的几种方式"><a href="#js继承的几种方式" class="headerlink" title="js继承的几种方式"></a>js继承的几种方式</h2><h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><blockquote>
<p>在构造函数内部调用被继承对象的构造函数，，使用call将this传入</p>
</blockquote>
<pre><code>function Parent() &#123;
  this.name = &#39;parent&#39;;
&#125;
function Child() &#123;
  Parent.call(this);
  this.type = &#39;child&#39;;
&#125;
</code></pre>
<p><strong>缺点：</strong></p>
<blockquote>
<p>只能实现部分继承。不能继承构造函数原型上的属性和方法，应为本身的原型对象没有被修改</p>
</blockquote>
<h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><blockquote>
<p>把原型修改为继承对象的实例化对象</p>
</blockquote>
<pre><code>function Parent() &#123;
  this.name = &#39;parent&#39;;
&#125;
function Child() &#123;
  this.type = &#39;child&#39;;
&#125;
Child.prototype = new Parent();
</code></pre>
<p><strong>缺点：</strong></p>
<blockquote>
<p>不能继承构造函数内部的属性和方法</p>
<p>不能像构造函数内部参数进行初始化</p>
</blockquote>
<h3 id="原型链-构造函数继承"><a href="#原型链-构造函数继承" class="headerlink" title="原型链+构造函数继承"></a>原型链+构造函数继承</h3><pre><code>function Parent() &#123;
  this.name = &#39;parent5&#39;;
  this.play = [1, 2, 3];
&#125;

function Child() &#123;
  Parent.call(this);
  this.type = &#39;child5&#39;;
&#125;
// 产生一个中间对象隔离`Child`的`prototype`属性和`Parent`的`prototype`属性引用的同一个原型。
Child.prototype = Object.create(Parent.prototype); 
// 给Child的原型对象重新写一个自己的constructor。
Child.prototype.constructor = Child;
</code></pre>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>extend</tag>
      </tags>
  </entry>
  <entry>
    <title>js事件机制</title>
    <url>/2019/03/29/JSevent/</url>
    <content><![CDATA[<h2 id="js事件机制"><a href="#js事件机制" class="headerlink" title="js事件机制"></a>js事件机制</h2><p><strong>、主要分为Dom0级事件和Dom2事件</strong></p>
<blockquote>
<p>Dom0级事件处理方式： </p>
</blockquote>
<pre><code>btn.onclick = func; 
   btn.onclick = null; 
</code></pre>
<blockquote>
<p>Dom2级事件处理方式：</p>
</blockquote>
<pre><code>// 非IE
btn.addEventListener(&#39;click&#39;, func, false); 
btn.removeEventListener(&#39;click&#39;, func, false); 
// IE
btn.attachEvent(&quot;onclick&quot;, func); 
btn.detachEvent(&quot;onclick&quot;, func); 
</code></pre>
<h2 id="事件的三个阶段"><a href="#事件的三个阶段" class="headerlink" title="事件的三个阶段"></a>事件的三个阶段</h2><ul>
<li>捕获</li>
<li>目标</li>
<li>冒泡</li>
</ul>
<blockquote>
<p><strong>js冒泡和捕获的的区别</strong></p>
</blockquote>
<p><strong>冒泡型事件：</strong></p>
<blockquote>
<p>事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。 </p>
</blockquote>
<p><strong>捕获型事件:</strong></p>
<blockquote>
<p>事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)。 </p>
</blockquote>
<p><strong>DOM事件流:</strong></p>
<blockquote>
<p>同时支持两种事件模型：捕获型事件和冒泡型事件，但是，捕获型事件先发生。两种事件流会触及DOM中的所有对象，从document对象开始，也在document对象结束。 </p>
</blockquote>
<p><strong>事件捕获:</strong></p>
<blockquote>
<p>当你使用事件捕获时，父级元素先触发，子级元素后触发，即div先触发，p后触发。 </p>
</blockquote>
<p><strong>事件冒泡:</strong></p>
<blockquote>
<p>当你使用事件冒泡时，子级元素先触发，父级元素后触发，即p先触发，div后触发。 </p>
</blockquote>
<h2 id="阻止冒泡"><a href="#阻止冒泡" class="headerlink" title="阻止冒泡"></a>阻止冒泡</h2><blockquote>
<p>非IE</p>
</blockquote>
<pre><code>e.stopPropagation()
</code></pre>
<blockquote>
<p>IE</p>
</blockquote>
<pre><code>cancelBubble = true
</code></pre>
<h2 id="阻止捕获"><a href="#阻止捕获" class="headerlink" title="阻止捕获"></a>阻止捕获</h2><blockquote>
<p>非IE</p>
</blockquote>
<pre><code>e.preventDefault()
</code></pre>
<blockquote>
<p>IE</p>
</blockquote>
<pre><code>returnValue = false
</code></pre>
<h2 id="事件“捕获”和“冒泡”执行顺序和事件的执行次数？"><a href="#事件“捕获”和“冒泡”执行顺序和事件的执行次数？" class="headerlink" title="事件“捕获”和“冒泡”执行顺序和事件的执行次数？"></a>事件“捕获”和“冒泡”执行顺序和事件的执行次数？</h2><p><strong>按照W3C标准流程如下：</strong></p>
<blockquote>
<p>进入捕获阶段 →→→ 到达目标元素 →→→ 进入到冒泡阶段</p>
</blockquote>
<p><strong>事件执行次数</strong></p>
<blockquote>
<p>元素上绑定事件的个数</p>
</blockquote>
<h3 id="在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？"><a href="#在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？" class="headerlink" title="在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？"></a>在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？</h3><blockquote>
<p>该DOM上的事件如果被触发，会执行两次（执行次数等于绑定次数）</p>
<p>如果该DOM是目标元素，则按事件绑定顺序执行，不区分冒泡/捕获</p>
<p>如果该DOM是处于事件流中的非目标元素，则先执行捕获，后执行冒泡 </p>
</blockquote>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>Event</tag>
      </tags>
  </entry>
  <entry>
    <title>浅拷贝与深拷贝</title>
    <url>/2019/03/29/clone/</url>
    <content><![CDATA[<h1 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h1><hr>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>###数据类型分为两种【基本数据类型，复杂数据类型】</p>
<blockquote>
<ul>
<li>基本数据类型：直接存储在栈(stack)中的数据<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Null</li>
<li>Undefined</li>
<li>Symbol</li>
</ul>
</li>
</ul>
</blockquote>
<hr>
<blockquote>
<ul>
<li>引用数据类型：存储的是该对象在栈中引用，真实的数据存放在堆内存里</li>
<li>对象数据类型【object，function】</li>
</ul>
</blockquote>
<h2 id="浅拷贝与深拷贝-1"><a href="#浅拷贝与深拷贝-1" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h2><h3 id="深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。"><a href="#深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。" class="headerlink" title="深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。"></a>深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。</h3><h4 id="浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。"><a href="#浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。" class="headerlink" title="浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。"></a>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</h4><h2 id="赋值和浅拷贝的区别"><a href="#赋值和浅拷贝的区别" class="headerlink" title="赋值和浅拷贝的区别"></a>赋值和浅拷贝的区别</h2><blockquote>
<ul>
<li><strong>当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。</strong></li>
</ul>
</blockquote>
<hr>
<blockquote>
<ul>
<li><strong>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。</strong></li>
</ul>
</blockquote>
<h2 id="浅拷贝的实现方式"><a href="#浅拷贝的实现方式" class="headerlink" title="浅拷贝的实现方式"></a>浅拷贝的实现方式</h2><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><blockquote>
<p><strong>Object.assign()进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。</strong></p>
<p><strong>当object只有一层的时候，是深拷贝</strong></p>
</blockquote>
<h3 id="Array-prototype-concat"><a href="#Array-prototype-concat" class="headerlink" title="Array.prototype.concat()"></a>Array.prototype.concat()</h3><pre><code>let arr = [1, 3, 
  &#123;
    username: &#39;kobe&#39;,
      childran: [
        &#123;
          username: &#39;kobe&#39;,
          childran: [
              &#123;
                username: &#39;kobe&#39;,
                  childran: [
                      
                  ]
              &#125;
          ]
        &#125;
    ]
    &#125;];
let arr2=arr.concat();    
console.log(arr);
</code></pre>
<blockquote>
<p>修改新对象会改到原对象:</p>
</blockquote>
<h3 id="Array-prototype-slice"><a href="#Array-prototype-slice" class="headerlink" title="Array.prototype.slice()"></a>Array.prototype.slice()</h3><pre><code>let arr = [1, 3, &#123;
    username: &#39; kobe&#39;
    &#125;];
let arr3 = arr.slice();
arr3[2].username = &#39;wade&#39;
console.log(arr);
</code></pre>
<blockquote>
<p>同样修改新对象会改到原对象:</p>
</blockquote>
<h3 id="关于Array的slice和concat方法的补充说明"><a href="#关于Array的slice和concat方法的补充说明" class="headerlink" title="关于Array的slice和concat方法的补充说明:"></a>关于Array的slice和concat方法的补充说明:</h3><p><strong>Array的slice和concat方法不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。</strong></p>
<h2 id="深拷贝的实现方式"><a href="#深拷贝的实现方式" class="headerlink" title="深拷贝的实现方式"></a>深拷贝的实现方式</h2><h3 id="JSON-parse-JSON-stringify"><a href="#JSON-parse-JSON-stringify" class="headerlink" title="JSON.parse(JSON.stringify())"></a>JSON.parse(JSON.stringify())</h3><pre><code>let arr = [1, 3, &#123;
    username: &#39; kobe&#39;
&#125;];
let arr4 = JSON.parse(JSON.stringify(arr));
arr4[2].username = &#39;duncan&#39;; 
console.log(arr, arr4)
</code></pre>
<blockquote>
<p>原理：</p>
</blockquote>
<p><strong>用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。</strong></p>
<blockquote>
<p>弊端：</p>
</blockquote>
<blockquote>
<p><strong>这种方法虽然可以实现数组或对象深拷贝,但不能处理函数</strong></p>
</blockquote>
<h3 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h3><blockquote>
<p>递归方法实现深度克隆原理:</p>
</blockquote>
<p><strong>遍历对象、数组直到里边都是基本数据类型，然后再去复制，就是深度拷贝</strong></p>
<pre><code>//定义检测数据类型的功能函数
function checkedType(target) &#123;
  return Object.prototype.toString.call(target).slice(8, -1)
&#125;
//实现深度克隆---对象/数组
function clone(target) &#123;
  //判断拷贝的数据类型
  //初始化变量result 成为最终克隆的数据
  let result,
    targetType = checkedType(target)
  if (targetType === &#39;Object&#39;) &#123;
    result = &#123;&#125;
  &#125; else if (targetType === &#39;Array&#39;) &#123;
    result = []
  &#125; else &#123;
    return target
  &#125;
  //遍历目标数据
  for (let i in target) &#123;
    //获取遍历数据结构的每一项值。
    let value = target[i]
    //判断目标结构里的每一值是否存在对象/数组
    if (checkedType(value) === &#39;Object&#39; || checkedType(value) === &#39;Array&#39;) &#123;
      //对象/数组里嵌套了对象/数组
      //继续遍历获取到value值
      result[i] = clone(value)
    &#125; else &#123;
      //获取到value值是基本的数据类型或者是函数。
      result[i] = value
    &#125;
  &#125;
  return result
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>开启nginx服务器压缩Gzip</title>
    <url>/2019/03/28/gzipmd/</url>
    <content><![CDATA[<h1 id="开启nginx服务器压缩"><a href="#开启nginx服务器压缩" class="headerlink" title="开启nginx服务器压缩"></a>开启nginx服务器压缩</h1><blockquote>
<p>nginx.conf(加入以下配置即可)</p>
</blockquote>
<pre><code>server&#123;
  listen       80;
  server_name  my.ignorantscholar.cn;
  
  gzip on;
  gzip_min_length 1k;
  gzip_buffers 4 16k;
  #gzip_http_version 1.0;
  gzip_comp_level 8;
  gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;
  gzip_vary off;
  gzip_disable &quot;MSIE [1-6]\.&quot;;

  location / &#123;
       proxy_pass http://127.0.0.1:3001;
  &#125;
&#125;
</code></pre>
<blockquote>
<p>在浏览器端查看是否开启可压缩</p>
</blockquote>
<h4 id="Network-查看请求的Headers头，"><a href="#Network-查看请求的Headers头，" class="headerlink" title="Network 查看请求的Headers头，"></a>Network 查看请求的Headers头，</h4><pre><code>Accept-Encoding: gzip
</code></pre>
<h4 id="即开启了压缩"><a href="#即开启了压缩" class="headerlink" title="即开启了压缩"></a>即开启了压缩</h4>]]></content>
      <tags>
        <tag>nginx</tag>
        <tag>gzip</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7中搭建nginx服务器</title>
    <url>/2019/03/28/ngsinx/</url>
    <content><![CDATA[<h1 id="centos7中搭建nginx服务器"><a href="#centos7中搭建nginx服务器" class="headerlink" title="centos7中搭建nginx服务器"></a>centos7中搭建nginx服务器</h1><blockquote>
<p><strong>nginx可以使用各平台的默认包来安装，本文是介绍使用源码编译安装，包括具体的编译参数信息。<br>正式开始前，编译环境gcc g++ 开发库之类的需要提前装好，这里默认你已经装好。</strong></p>
</blockquote>
<h3 id="centos平台编译环境使用如下指令"><a href="#centos平台编译环境使用如下指令" class="headerlink" title="centos平台编译环境使用如下指令"></a>centos平台编译环境使用如下指令</h3><blockquote>
<p>安装make：</p>
</blockquote>
<pre><code>yum -y install gcc automake autoconf libtool make
</code></pre>
<blockquote>
<p>安装g++:</p>
</blockquote>
<pre><code>yum install gcc gcc-c++
</code></pre>
<h2 id="下面正式开始："><a href="#下面正式开始：" class="headerlink" title="下面正式开始："></a>下面正式开始：</h2><h3 id="一般我们都需要先装pcre-zlib，前者为了重写rewrite，后者为了gzip压缩。"><a href="#一般我们都需要先装pcre-zlib，前者为了重写rewrite，后者为了gzip压缩。" class="headerlink" title="一般我们都需要先装pcre, zlib，前者为了重写rewrite，后者为了gzip压缩。"></a>一般我们都需要先装pcre, zlib，前者为了重写rewrite，后者为了gzip压缩。</h3><p><strong>注：下面所使用的所有版本均为截止2017年8月14号，最新版本</strong></p>
<blockquote>
<p>1.选定源码目录<br>可以是任何目录，本文选定的是/usr/local/src</p>
</blockquote>
<pre><code>cd /usr/local/src
</code></pre>
<blockquote>
<p>2.安装PCRE库<br><a class="link"   href="ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/" >ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/<i class="fas fa-external-link-alt"></i></a> 下载最新的 PCRE 源码包，使用下面命令下载编译和安装 PCRE 包：</p>
</blockquote>
<pre><code>cd /usr/local/src

wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.41.tar.gz

tar -zxvf pcre-8.41.tar.gz

cd pcre-8.41

./configure

make

make install
</code></pre>
<blockquote>
<p>3.安装zlib库<br><a class="link"   href="http://zlib.net/zlib-1.2.11.tar.gz" >http://zlib.net/zlib-1.2.11.tar.gz<i class="fas fa-external-link-alt"></i></a> 下载最新的 zlib 源码包，使用下面命令下载编译和安装 zlib包：</p>
</blockquote>
<pre><code>cd /usr/local/src

wget   http://zlib.net/zlib-1.2.11.tar.gz

tar -zxvf zlib-1.2.11.tar.gz

cd zlib-1.2.11

./configure

make

make install
</code></pre>
<blockquote>
<p>4.安装ssl（某些vps默认没装ssl)</p>
</blockquote>
<pre><code>cd /usr/local/src

wget https://www.openssl.org/source/openssl-1.0.2l.tar.gz

tar -zxvf openssl-1.0.2l.tar.gz
</code></pre>
<blockquote>
<p>5.安装nginx</p>
</blockquote>
<p><strong>Nginx 一般有两个版本，分别是稳定版和开发版，您可以根据您的目的来选择这两个版本的其中一个，下面是把 Nginx 安装到 /usr/local/nginx 目录下的详细步骤：</strong></p>
<pre><code>cd /usr/local/src

wget http://nginx.org/download/nginx-1.13.4.tar.gz

tar -zxvf nginx-1.13.4.tar.gz

cd nginx-1.13.4



./configure --sbin-path=/usr/local/nginx/nginx

--conf-path=/usr/local/nginx/nginx.conf

--pid-path=/usr/local/nginx/nginx.pid

--with-http_ssl_module

--with-pcre=/usr/local/src/pcre-8.41

--with-zlib=/usr/local/src/zlib-1.2.11

--with-openssl=/usr/local/src/openssl-1.0.2l



make

make install
</code></pre>
<blockquote>
<p> –with-pcre=/usr/local/src/pcre-8.41 指的是pcre-8.41 的源码路径。<br>–with-zlib=/usr/local/src/zlib-1.2.11 指的是zlib-1.2.11 的源码路径。</p>
</blockquote>
<blockquote>
<p>安装成功：</p>
</blockquote>
<p><strong>安装成功后 /usr/local/nginx 会有此目录</strong></p>
<blockquote>
<p>6.启动</p>
</blockquote>
<p><strong>确保系统的 80 端口没被其他程序占用，运行/usr/local/nginx/nginx 命令来启动 Nginx，</strong></p>
<blockquote>
<p>打开浏览器访问此机器的 IP，如果浏览器出现 Welcome to nginx! 则表示 Nginx 已经安装并运行成功。</p>
<p>到这里nginx就安装完成了，如果只是处理静态html就不用继续安装了</p>
<p>如果你需要处理php脚本的话，还需要安装php-fpm。</p>
</blockquote>
<h2 id="常见错误："><a href="#常见错误：" class="headerlink" title="常见错误："></a>常见错误：</h2><p>附：可能遇到的错误和一些帮助信息</p>
<p>1.1编译pcre错误</p>
<pre><code>make[1]: Leaving directory `/usr/local/src/pcre-8.34&#39;

make: *** [all] Error 2
</code></pre>
<blockquote>
<p>解决办法：安装g++,别忘了重新configure</p>
</blockquote>
<pre><code>apt-get install g++

apt-get install build-essential

make clean

./configure

make
</code></pre>
<blockquote>
<p>1.2 make出错</p>
</blockquote>
<pre><code>make: *** No targets specified and no makefile found.  Stop.
</code></pre>
<p><strong>按照下面安装方法</strong></p>
<pre><code>yum -y install openssl openssl-devel
</code></pre>
<blockquote>
<p>2.nginx编译选项（下面代码必须在一行）</p>
</blockquote>
<pre><code>./configure --sbin-path=/usr/local/nginx/nginx

--conf-path=/usr/local/nginx/nginx.conf

--pid-path=/usr/local/nginx/nginx.pid

--with-http_ssl_module

--with-pcre=/usr/local/src/pcre-8.41

--with-zlib=/usr/local/src/zlib-1.2.11

--with-openssl=/usr/local/src/openssl-1.0.2l
</code></pre>
]]></content>
      <tags>
        <tag>nginx</tag>
        <tag>linux服务器配置</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7中安装mysql的步骤</title>
    <url>/2019/03/28/mysql/</url>
    <content><![CDATA[<h1 id="centos7中安装mysql的步骤"><a href="#centos7中安装mysql的步骤" class="headerlink" title="centos7中安装mysql的步骤"></a>centos7中安装mysql的步骤</h1><h2 id="一、-安装："><a href="#一、-安装：" class="headerlink" title="一、   安装："></a>一、   安装：</h2><blockquote>
<ol>
<li>  下载源码包，一般将源码包放在/usr/local/中；</li>
</ol>
</blockquote>
<pre><code>cd /usr/local/

mkdir -p tools

cd tools

wget http://repo.mysql.com/mysql57-community-release-el7-8.noarch.rpm
</code></pre>
<p><strong>(这里的版本可以随时去mysql官网进行选择)</strong></p>
<blockquote>
<ol start="2">
<li>  查看系统中是否已安装 MySQL 服务</li>
</ol>
</blockquote>
<pre><code>rpm -qa | grep mysql
或
yum list installed | grep mysql
</code></pre>
<blockquote>
<ol start="3">
<li>  如果已安装则删除 MySQL 及其依赖的包：</li>
</ol>
</blockquote>
<pre><code>yum -y remove mysql-libs.x86_64
</code></pre>
<blockquote>
<ol start="4">
<li>  安装 mysql57-community-release-el7-8.noarch.rpm：</li>
</ol>
</blockquote>
<pre><code>rpm -ivh mysql57-community-release-el7-8.noarch.rpm
</code></pre>
<blockquote>
<p>安装完后，得到如下两个包：（在/etc/yum.repos.d/文件下）</p>
</blockquote>
<pre><code>mysql-community.repo
mysql-community-source.repo
</code></pre>
<blockquote>
<ol start="5">
<li>  安装mysql</li>
</ol>
</blockquote>
<pre><code>$ yum install mysql-server
</code></pre>
<p><strong>根据步骤安装就可以了，不过安装完成后，没有密码，需要重置密码。</strong></p>
<blockquote>
<p>6.重置密码：</p>
</blockquote>
<pre><code>mysql -u root；
</code></pre>
<blockquote>
<p>报错：ERROR 2002 (HY000): Can‘t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock‘ (2)，原因是/var/lib/mysql的访问权限问题。下面的命令把/var/lib/mysql的拥有者改为当前用户：</p>
</blockquote>
<pre><code>sudo chown -R openscanner:openscanner /var/lib/mysql
</code></pre>
<blockquote>
<p>重启服务：</p>
</blockquote>
<pre><code> service mysqld restart
</code></pre>
<blockquote>
<p>再次登录:</p>
</blockquote>
<pre><code>mysql -u root
</code></pre>
<blockquote>
<p>报错：</p>
</blockquote>
<blockquote>
<p>error 1045 (28000):Access denied for user ‘root’ @ ‘localhost’ (using password: NO）</p>
</blockquote>
<p><strong>此种情况是因为存在了默认密码问题，解决：（最保险的是重置root密码）</strong></p>
<blockquote>
<p>1、修改 /etc/my.cnf，在 [mysqld] 小节下添加一行：skip-grant-tables=1</p>
<p>这一行配置让 mysqld 启动时不对密码进行验证</p>
<p>2、重启 mysqld 服务：systemctl restart mysqld</p>
<p>3、使用 root 用户登录到 mysql：mysql -u root </p>
<p>4、切换到mysql数据库，更新 user 表：</p>
</blockquote>
<pre><code>update user set authentication_string = password(&#39;root&#39;),host=&#39;%&#39;,password_expired = &#39;N&#39;, password_last_changed = now() where user = &#39;root&#39;;
</code></pre>
<blockquote>
<p>在之前的版本中，密码字段的字段名是 password，5.7版本改为了 authentication_string</p>
</blockquote>
<blockquote>
<p>5、退出 mysql，编辑 /etc/my.cnf 文件，删除 skip-grant-tables=1 的内容</p>
<p>6、重启 mysqld 服务，再用新密码登录即可</p>
</blockquote>
<blockquote>
<ol start="7">
<li>  开放防火墙：</li>
</ol>
</blockquote>
<pre><code>vim /etc/sysconfig/iptables
</code></pre>
<blockquote>
<p>添加以下内容：</p>
</blockquote>
<pre><code>-A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT
</code></pre>
<blockquote>
<p>保存后重启防火墙：</p>
</blockquote>
<pre><code>$ sudo service iptables restart
</code></pre>
<blockquote>
<p>这样从其它客户机也可以连接上mysql服务了。</p>
</blockquote>
<hr>
<blockquote>
<ol start="8">
<li>  阿里云安全组设置：</li>
</ol>
</blockquote>
<p><strong>如果此时在其他客户机上还是链接不上mysql，登录阿里云，查看实例的安全组有没有为3306端口开启规则；</strong></p>
]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>linux服务器配置</tag>
      </tags>
  </entry>
  <entry>
    <title>node配置</title>
    <url>/2019/03/28/nodemd/</url>
    <content><![CDATA[<h1 id="node配置"><a href="#node配置" class="headerlink" title="node配置"></a>node配置</h1><h2 id="一、安装node："><a href="#一、安装node：" class="headerlink" title="一、安装node："></a>一、安装node：</h2><blockquote>
<p>1.下载并安装NVM脚本</p>
</blockquote>
<pre><code>curl https://raw.githubusercontent.com/creationix/nvm/v0.13.1/install.sh | bash
source ~/.bash_profile
</code></pre>
<blockquote>
<p>2.列出所需要的版本</p>
</blockquote>
<pre><code>nvm list-remote
</code></pre>
<blockquote>
<p>3.安装相应的版本</p>
</blockquote>
<pre><code>nvm install v8.3.0
</code></pre>
<blockquote>
<p>4.查看已安装的版本</p>
</blockquote>
<pre><code>nvm list
</code></pre>
<blockquote>
<p>5.切换版本</p>
</blockquote>
<pre><code>nvm use v8.3.0
</code></pre>
<blockquote>
<p>6.设置默认版本</p>
</blockquote>
<pre><code>nvm alias default v8.3.0
</code></pre>
]]></content>
      <tags>
        <tag>node</tag>
        <tag>linux服务器配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统基础命令</title>
    <url>/2019/03/27/Linux/</url>
    <content><![CDATA[<h1 id="Linux系统基础命令"><a href="#Linux系统基础命令" class="headerlink" title="Linux系统基础命令"></a>Linux系统基础命令</h1><h2 id="连接远程服务器：ssh-root-公网ip"><a href="#连接远程服务器：ssh-root-公网ip" class="headerlink" title="连接远程服务器：ssh root@公网ip"></a>连接远程服务器：ssh root@公网ip</h2><blockquote>
<p>ls 查看目录<br>cd 切换目录 （用户目录root~ 系统根目录 /）</p>
</blockquote>
<blockquote>
<p>创建文件 touch 文件名字<br>删除文件 rm 文件路径<br>移动文件 mv 要移动的文件 移动后的路径<br>创建文件夹 mkdir 目录名称<br>拷贝文件 cp 文件 目标路径</p>
</blockquote>
<blockquote>
<p>vim 编辑文件<br>i 开始编辑<br>esc :wq 退出并保存</p>
</blockquote>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序实现瀑布流</title>
    <url>/2019/03/24/wpy-cascade/</url>
    <content><![CDATA[<h1 id="微信小程序实现瀑布流"><a href="#微信小程序实现瀑布流" class="headerlink" title="微信小程序实现瀑布流"></a>微信小程序实现瀑布流</h1><h3 id="简单，便捷"><a href="#简单，便捷" class="headerlink" title="简单，便捷"></a>简单，便捷</h3><blockquote>
<ul>
<li>无需知道图片宽高（当然要实现懒加载是必须的）</li>
<li>一个判断</li>
<li>一句css</li>
</ul>
</blockquote>
<hr>
<blockquote>
<ol>
<li>先用css3中的column-count属性把页面元素分为俩列及多列。</li>
</ol>
</blockquote>
<hr>
<h3 id="直接上代码"><a href="#直接上代码" class="headerlink" title="直接上代码"></a>直接上代码</h3><blockquote>
<p><strong>wxml</strong></p>
</blockquote>
<pre><code>&lt;view class=&quot;free-WaterfallFlow&quot;&gt;
  &lt;block&gt;
    &lt;view class=&quot;flex-wrap&quot; wx:for=&quot;&#123;&#123;images&#125;&#125;&quot; wx:key=&#39;&#123;&#123;item.src&#125;&#125;&#39; 
    wx:if=&quot;&#123;&#123;item.id%2!=''&#125;&#125;&quot;&gt;
      &lt;image mode=&quot;widthFix&quot; src=&quot;&#123;&#123;item.src&#125;&#125;&quot;&gt;&lt;/image&gt;
      &lt;view&gt;&#123;&#123;item.name&#125;&#125;&lt;/view&gt;
      &lt;view&gt;&#123;&#123;item.data&#125;&#125;&lt;/view&gt;
    &lt;/view&gt;
  &lt;/block&gt;
  &lt;block&gt;
    &lt;view class=&quot;flex-wrap&quot; wx:for=&quot;&#123;&#123;images&#125;&#125;&quot; wx:key=&#39;&#123;&#123;item.src&#125;&#125;&#39;
    wx:if=&quot;&#123;&#123;item.id%2==''&#125;&#125;&quot;&gt;
      &lt;image mode=&quot;widthFix&quot; src=&quot;&#123;&#123;item.src&#125;&#125;&quot;&gt;&lt;/image&gt;
      &lt;view&gt;&#123;&#123;item.name&#125;&#125;&lt;/view&gt;
      &lt;view&gt;&#123;&#123;item.data&#125;&#125;&lt;/view&gt;
    &lt;/view&gt;
  &lt;/block&gt;
&lt;/view&gt;
</code></pre>
<hr>
<blockquote>
<p><strong>wxss</strong></p>
</blockquote>
<pre><code>.free-WaterfallFlow&#123;
  width:94%;
  column-count:2;/*column-count 属性规定元素应该被分隔的列数：*/
&#125;
.free-WaterfallFlow .flex-wrap&#123;
  display: inline-block;
  width:98%;
  margin-bottom:2%;
  border:1px solid #ccc;
  padding:2%;
  padding-top:5%;
  margin-right:2%;
  box-shadow: 0 1px 2px rgba(34, 25, 25, 0.4);
  text-align: center;
&#125;
.flex-wrap image&#123;
  width:95%;
  margin:0 auto;
&#125;
.flex-wrap view:nth-child(2)&#123;
  font-size:15px;
  padding:2% 0;
  color:#717171;
&#125;
.flex-wrap view:nth-child(3)&#123;
  font-size:13px;
  padding:2% 0;
  color:#aaa;
  text-align: right;
&#125;
</code></pre>
<hr>
<blockquote>
<p><strong>js</strong></p>
</blockquote>
<pre><code>Page(&#123;
  data: &#123;
    images:[
      &#123; 
        id:&#39;1&#39;,
        src:&#39;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1531825645104&amp;di=0cfede1dd354581e22385b1862375a6a&amp;imgtype=0&amp;src=http%3A%2F%2Fpic.qiantucdn.com%2F58pic%2F13%2F71%2F35%2F24k58PICSiB_1024.jpg&#39;,
        name:&#39;照片01&#39;,
        data:&#39;2017/11/1&#39;
      &#125;, &#123;
        id: &#39;2&#39;,
        src: &#39;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1531825645032&amp;di=826b8cfa4f7c5a8765d5c2156913dcbb&amp;imgtype=0&amp;src=http%3A%2F%2Fimg382.ph.126.net%2Fp4dMCiiHoUGxf2N0VLspkg%3D%3D%2F37436171903673954.jpg&#39;,
        name: &#39;照片02&#39;,
        data: &#39;2017/11/2&#39;
      &#125;, &#123;
        id: &#39;3&#39;,
        src: &#39;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1531825645104&amp;di=2c9e1223e705806967640495e4bac26b&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.zcool.cn%2Fcommunity%2F0147a458783b1ba801219c77f9ec2e.jpg%402o.jpg&#39;,
        name: &#39;照片03&#39;,
        data: &#39;2017/11/3&#39;
      &#125;, &#123;
        id: &#39;4&#39;,
        src: &#39;http://t1.hxzdhn.com/uploads/tu/bj/slt/yezpvg0x23b.jpg&#39;,
        name: &#39;照片04&#39;,
        data: &#39;2017/11/4&#39;
      &#125;, &#123;
        id: &#39;5&#39;,
        src: &#39;http://t1.hxzdhn.com/uploads/tu/201807/9999/95ed87388b.jpg&#39;,
        name: &#39;照片05&#39;,
        data: &#39;2017/11/5&#39;
      &#125;, &#123;
        id: &#39;6&#39;,
        src: &#39;http://t1.hxzdhn.com/uploads/tu/201807/9999/99495c4cf4.jpg&#39;,
        name: &#39;照片06&#39;,
        data: &#39;2017/11/6&#39;
      &#125;, &#123;
        id: &#39;7&#39;,
        src: &#39;http://t1.hxzdhn.com/uploads/tu/201807/9999/f867c97e25.jpg&#39;,
        name: &#39;照片07&#39;,
        data: &#39;2017/11/7&#39;
      &#125;, &#123;
        id: &#39;8&#39;,
        src: &#39;http://t1.hxzdhn.com/uploads/tu/201807/9999/2cc7ab0bc5.jpg&#39;,
        name: &#39;照片08&#39;,
        data: &#39;2017/11/8&#39;
      &#125;, &#123;
        id: &#39;9&#39;,
        src: &#39;http://t1.hxzdhn.com/uploads/tu/201807/9999/2f4435caaf.jpg&#39;,
        name: &#39;照片09&#39;,
        data: &#39;2017/11/9&#39;
      &#125;, &#123;
        id: &#39;10&#39;,
        src: &#39;http://t1.hxzdhn.com/uploads/tu/201807/9999/ce76898540.jpg&#39;,
        name: &#39;照片10&#39;,
        data: &#39;2017/11/10&#39;
      &#125;, &#123;
        id: &#39;11&#39;,
        src: &#39;http://t1.hxzdhn.com/uploads/tu/201807/9999/a2ccc41e47.jpg&#39;,
        name: &#39;照片11&#39;,
        data: &#39;2017/11/11&#39;
      &#125;, &#123;
        id: &#39;12&#39;,
        src: &#39;http://t2.hddhhn.com/uploads/tu/201707/521/83.jpg&#39;,
        name: &#39;照片12&#39;,
        data: &#39;2017/11/12&#39;
      &#125;, &#123;
        id: &#39;13&#39;,
        src: &#39;http://t2.hddhhn.com/uploads/tu/20150700/2hndrjt0jxe.jpg&#39;,
        name: &#39;照片13&#39;,
        data: &#39;2017/11/13&#39;
      &#125;, &#123;
        id: &#39;14&#39;,
        src: &#39;http://t2.hddhhn.com/uploads/tu/20150700/2hndrjt0jxe.jpg&#39;,
        name: &#39;照片14&#39;,
        data: &#39;2017/11/14&#39;
      &#125;
    ]
  &#125;
&#125;)
</code></pre>
]]></content>
      <tags>
        <tag>wx</tag>
        <tag>瀑布流</tag>
      </tags>
  </entry>
  <entry>
    <title>fetch封装</title>
    <url>/2019/03/14/fetch/</url>
    <content><![CDATA[<h1 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h1><h2 id="fetch封装"><a href="#fetch封装" class="headerlink" title="fetch封装"></a>fetch封装</h2><hr>
<blockquote>
<ul>
<li>解决了fetch的get。post的传递参数不同</li>
<li>添加了fetch默认不携带cookie的配置</li>
<li>解决了fetch不能处理错误状态的问题</li>
<li>解决了fetch，response控制返回值json</li>
<li>添加公共参数token</li>
<li>统一错误出路</li>
<li>是否允许跨域</li>
</ul>
</blockquote>
<hr>
<pre><code>const objParseQuery = (data) =&gt; &#123;
  let paramsArray = [];
    let parameter = &#39;&#39;
    //拼接参数
    Object.keys(data).forEach(key =&gt; &#123;
            if (data[key]) &#123;
                    paramsArray.push(key + &#39;=&#39; + data[key])
            &#125;
    &#125;)
    if (parameter.search(/\?/) === -1) &#123;
            parameter += &#39;?&#39; + paramsArray.join(&#39;&amp;&#39;)
    &#125; else &#123;
            parameter += &#39;&amp;&#39; + paramsArray.join(&#39;&amp;&#39;)
  &#125;
  return parameter
&#125;
let fetchs = &#123;
  /**
    * 基于 fetch 封装的 GET请求
    * @param url
    * @param params &#123;&#125;
    * @param headers
    * @returns &#123;Promise&#125;
    */
   get: (url, params) =&gt; &#123;
     
     var fetchConfig = &#123;
         method: &#39;get&#39;,
         headers: &#123;
           authorization: window.sessionStorage.getItem(&#39;token&#39;) ? window.sessionStorage.getItem(&#39;token&#39;) : null,
           &#39;Content-Type&#39;: &#39;application/json; charset=utf-8&#39;
         &#125;,
         credentials: &quot;include&quot;,
         mode: &#39;cors&#39;,
     &#125;
     if(params)&#123;
      url += objParseQuery(params.data);
     &#125;
     console.log(url)
     return fetch(url, fetchConfig).then(response =&gt; &#123;
       return response.json().then((res) =&gt; &#123;
         console.log(res)
         if (response.ok &amp;&amp; res.code === 1) &#123;
           return Promise.resolve(res)
         &#125; else &#123;
           return Promise.reject(res)
         &#125;
       &#125;)
     &#125;)
     &#125;,
     post: (url, options) =&gt; &#123;
       return fetch(url, &#123;
         method: &#39;post&#39;,
         headers: &#123;
           authorization: window.sessionStorage.getItem(&#39;token&#39;) ? window.sessionStorage.getItem(&#39;token&#39;) : null,
           &#39;Content-Type&#39;: &#39;application/json; charset=utf-8&#39;
         &#125;,
         credentials: &quot;include&quot;,
         mode: &#39;cors&#39;,
         body: JSON.stringify(options)
       &#125;).then(response =&gt; &#123;
         return response.json().then((res) =&gt; &#123;
           if (response.ok &amp;&amp; res.code === 1) &#123;
             console.log(window.sessionStorage.getItem(&#39;token&#39;))
             return Promise.resolve(res)
           &#125; else &#123;
             return Promise.reject(res)
           &#125;
         &#125;)
       &#125;)
     &#125;,
     put: (url, options) =&gt; &#123;
      return fetch(url, &#123;
        method: &#39;post&#39;,
        headers: &#123;
          authorization: window.sessionStorage.getItem(&#39;token&#39;) ? window.sessionStorage.getItem(&#39;token&#39;) : null,
          &#39;Content-Type&#39;: &#39;application/json; charset=utf-8&#39;
        &#125;,
        credentials: &quot;include&quot;,
        mode: &#39;cors&#39;,
        body: JSON.stringify(options)
      &#125;).then(response =&gt; &#123;
        return response.json().then((res) =&gt; &#123;
          if (response.ok &amp;&amp; res.code === 1) &#123;
            console.log(window.sessionStorage.getItem(&#39;token&#39;))
            return Promise.resolve(res)
          &#125; else &#123;
            return Promise.reject(res)
          &#125;
        &#125;)
      &#125;)
    &#125;
&#125;

export default fetchs
</code></pre>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>fetch</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 堆&amp;栈</title>
    <url>/2019/03/04/stack%20heap/</url>
    <content><![CDATA[<h2 id="JS-堆-amp-栈"><a href="#JS-堆-amp-栈" class="headerlink" title="JS 堆&amp;栈"></a>JS 堆&amp;栈</h2><h3 id="两者都是存放临时数据的地方"><a href="#两者都是存放临时数据的地方" class="headerlink" title="两者都是存放临时数据的地方"></a>两者都是存放临时数据的地方</h3><h3 id="⊙-栈是先进后出的，就像一个桶，后进去的先出来，它下面本来有的东西要等其他出来之后才能出来。"><a href="#⊙-栈是先进后出的，就像一个桶，后进去的先出来，它下面本来有的东西要等其他出来之后才能出来。" class="headerlink" title="⊙ 栈是先进后出的，就像一个桶，后进去的先出来，它下面本来有的东西要等其他出来之后才能出来。"></a>⊙ 栈是先进后出的，就像一个桶，后进去的先出来，它下面本来有的东西要等其他出来之后才能出来。</h3><h3 id="⊙-堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。对于堆，我们可以随心所欲的进行增加变量和删除变量，不用遵循次序。"><a href="#⊙-堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。对于堆，我们可以随心所欲的进行增加变量和删除变量，不用遵循次序。" class="headerlink" title="⊙ 堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。对于堆，我们可以随心所欲的进行增加变量和删除变量，不用遵循次序。"></a>⊙ 堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。对于堆，我们可以随心所欲的进行增加变量和删除变量，不用遵循次序。</h3><h3 id="◎-栈区（stack）-由编译器自动分配释放-，存放函数的参数值，局部变量的值等。"><a href="#◎-栈区（stack）-由编译器自动分配释放-，存放函数的参数值，局部变量的值等。" class="headerlink" title="◎ 栈区（stack） 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。"></a>◎ 栈区（stack） 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。</h3><h3 id="◎-堆区（heap）-一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。"><a href="#◎-堆区（heap）-一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。" class="headerlink" title="◎ 堆区（heap） 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。"></a>◎ 堆区（heap） 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。</h3><hr>
<blockquote>
<p><strong>堆是动态分配内存，内存大小不一，也不会自动释放。栈是自动分配相对固定大小的内存空间，并由系统自动释放.</strong></p>
</blockquote>
<hr>
<h2 id="JS数据类型访问"><a href="#JS数据类型访问" class="headerlink" title="JS数据类型访问"></a>JS数据类型访问</h2><ul>
<li>基本数据类型</li>
</ul>
<blockquote>
<p>Undefined、Null、Boolean、String、Number、Symbol都是直接按值直接存在栈中，每种类型的数据占用的内存空间大小都是固定的，并且由系统自动分配自动释放</p>
</blockquote>
<ul>
<li>引用数据类型</li>
</ul>
<blockquote>
<p>Object，Array，Function这样的数据存在堆内存中，但是数据指针是存放在栈内存中的，当我们访问引用数据时，先从栈内存中获取指针，通过指针在堆内存中找到数据</p>
</blockquote>
<pre><code>var a = 2;
</code></pre>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/4.0.png"
                     
                ></p>
<pre><code>var b = new Object();
</code></pre>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/4.1.png"
                     
                ></p>
<h2 id="传值和传址"><a href="#传值和传址" class="headerlink" title="传值和传址"></a>传值和传址</h2><blockquote>
<p><strong>从一个向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终指向同一个对象。即复制的是栈中的地址而不是堆中的对象。</strong></p>
</blockquote>
<blockquote>
<p><strong>从一个变量复向另一个变量复制基本类型的值，会创建这个值的副本。</strong></p>
</blockquote>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>堆&amp;栈</tag>
      </tags>
  </entry>
  <entry>
    <title>mvvm原理</title>
    <url>/2019/03/03/MVVM/</url>
    <content><![CDATA[<h2 id="mvvm模式"><a href="#mvvm模式" class="headerlink" title="mvvm模式"></a>mvvm模式</h2><h3 id="MVVM-是Model-View-ViewModel-的缩写，它是一种基于前端开发的架构模式，其核心是提供对View-和-ViewModel-的双向数据绑定，这使得ViewModel-的状态改变可以自动传递给-View，即所谓的数据双向绑定。"><a href="#MVVM-是Model-View-ViewModel-的缩写，它是一种基于前端开发的架构模式，其核心是提供对View-和-ViewModel-的双向数据绑定，这使得ViewModel-的状态改变可以自动传递给-View，即所谓的数据双向绑定。" class="headerlink" title="MVVM 是Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式，其核心是提供对View 和 ViewModel 的双向数据绑定，这使得ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定。"></a>MVVM 是Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式，其核心是提供对View 和 ViewModel 的双向数据绑定，这使得ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定。</h3><blockquote>
<p><strong><a class="link"   href="https://github.com/Ignorance-of-Dong/mvvm" >mvvm原理源码地址<i class="fas fa-external-link-alt"></i></a></strong></p>
</blockquote>
<blockquote>
<p>Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。</p>
</blockquote>
<h2 id="为什么会出现-MVVM-呢？"><a href="#为什么会出现-MVVM-呢？" class="headerlink" title="为什么会出现 MVVM 呢？"></a>为什么会出现 MVVM 呢？</h2><p>###MVC 即 Model-View-Controller 的缩写，就是 模型—视图—控制器，也就是说一个标准的Web 应用程式是由这三部分组成的：</p>
<blockquote>
<ul>
<li>View ：用来把数据以某种方式呈现给用户</li>
<li>Model ：其实就是数据</li>
<li>Controller ：接收并处理来自用户的请求，并将 Model 返回给用户</li>
</ul>
</blockquote>
<h3 id="随着H5-的不断发展，人们更希望使用H5-开发的应用能和Native-媲美，或者接近于原生App-的体验效果，于是前端应用的复杂程度已不同往日，今非昔比。这时前端开发就暴露出了三个痛点问题："><a href="#随着H5-的不断发展，人们更希望使用H5-开发的应用能和Native-媲美，或者接近于原生App-的体验效果，于是前端应用的复杂程度已不同往日，今非昔比。这时前端开发就暴露出了三个痛点问题：" class="headerlink" title="随着H5 的不断发展，人们更希望使用H5 开发的应用能和Native 媲美，或者接近于原生App 的体验效果，于是前端应用的复杂程度已不同往日，今非昔比。这时前端开发就暴露出了三个痛点问题："></a>随着H5 的不断发展，人们更希望使用H5 开发的应用能和Native 媲美，或者接近于原生App 的体验效果，于是前端应用的复杂程度已不同往日，今非昔比。这时前端开发就暴露出了三个<strong>痛点</strong>问题：</h3><blockquote>
<ul>
<li>开发者在代码中大量调用相同的 DOM API，处理繁琐 ，操作冗余，使得代码难以维护。</li>
<li>大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。</li>
<li>当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致 Model 发生变化，开发者同样需要将变化的数据同步到Model 中，这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。</li>
</ul>
</blockquote>
<h2 id="MVVM-的出现，完美解决了以上三个问题。"><a href="#MVVM-的出现，完美解决了以上三个问题。" class="headerlink" title="MVVM 的出现，完美解决了以上三个问题。"></a>MVVM 的出现，完美解决了以上三个问题。</h2><h3 id="MVVM-由-Model、View、ViewModel-三部分构成，Model-层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View-代表UI-组件，它负责将数据模型转化成UI-展现出来，ViewModel-是一个同步View-和-Model的对象。"><a href="#MVVM-由-Model、View、ViewModel-三部分构成，Model-层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View-代表UI-组件，它负责将数据模型转化成UI-展现出来，ViewModel-是一个同步View-和-Model的对象。" class="headerlink" title="MVVM 由 Model、View、ViewModel 三部分构成，Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。"></a>MVVM 由 Model、View、ViewModel 三部分构成，Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。</h3><blockquote>
<p>在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。</p>
</blockquote>
<h3 id="ViewModel-通过双向数据绑定把-View-层和-Model-层连接了起来，而View-和-Model-之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM，-不需要关注数据状态的同步问题，复杂的数据状态维护完全由-MVVM-来统一管理。"><a href="#ViewModel-通过双向数据绑定把-View-层和-Model-层连接了起来，而View-和-Model-之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM，-不需要关注数据状态的同步问题，复杂的数据状态维护完全由-MVVM-来统一管理。" class="headerlink" title="ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM， 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。"></a>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM， 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</h3><h2 id="Vue-js-的细节"><a href="#Vue-js-的细节" class="headerlink" title="Vue.js 的细节"></a><strong>Vue.js 的细节</strong></h2><h4 id="Vue-js-可以说是MVVM-架构的最佳实践，专注于-MVVM-中的-ViewModel，不仅做到了数据双向绑定，而且也是一款相对来比较轻量级的JS-库，API-简洁，很容易上手。Vue的基础知识网上有现成的教程，此处不再赘述，-下面简单了解一下-Vue-js-关于双向绑定的一些实现细节："><a href="#Vue-js-可以说是MVVM-架构的最佳实践，专注于-MVVM-中的-ViewModel，不仅做到了数据双向绑定，而且也是一款相对来比较轻量级的JS-库，API-简洁，很容易上手。Vue的基础知识网上有现成的教程，此处不再赘述，-下面简单了解一下-Vue-js-关于双向绑定的一些实现细节：" class="headerlink" title="Vue.js 可以说是MVVM 架构的最佳实践，专注于 MVVM 中的 ViewModel，不仅做到了数据双向绑定，而且也是一款相对来比较轻量级的JS 库，API 简洁，很容易上手。Vue的基础知识网上有现成的教程，此处不再赘述， 下面简单了解一下 Vue.js 关于双向绑定的一些实现细节："></a>Vue.js 可以说是MVVM 架构的最佳实践，专注于 MVVM 中的 ViewModel，不仅做到了数据双向绑定，而且也是一款相对来比较轻量级的JS 库，API 简洁，很容易上手。Vue的基础知识网上有现成的教程，此处不再赘述， 下面简单了解一下 Vue.js 关于双向绑定的一些实现细节：</h4><blockquote>
<p>Vue.js 是采用 Object.defineProperty 的 getter 和 setter，并结合观察者模式来实现数据绑定的。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/1.0.png"
                     
                ></p>
<ul>
<li>Observer ：数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用Object.defineProperty的getter和setter来实现</li>
<li>Compile  ：指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数</li>
<li>Watcher  ：订阅者，作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数</li>
<li>Dep ：消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法</li>
</ul>
<blockquote>
<p>从图中可以看出，当执行 new Vue() 时，Vue 就进入了初始化阶段，一方面Vue 会遍历 data 选项中的属性，并用 Object.defineProperty 将它们转为 getter/setter，实现数据变化监听功能；另一方面，Vue 的指令编译器Compile 对元素节点的指令进行扫描和解析，初始化视图，并订阅 Watcher 来更新视图， 此时Wather 会将自己添加到消息订阅器中(Dep)，初始化完毕。</p>
</blockquote>
<hr>
<blockquote>
<p>当数据发生变化时，Observer 中的 setter 方法被触发，setter 会立即调用Dep.notify()，Dep 开始遍历所有的订阅者，并调用订阅者的 update 方法，订阅者收到通知后对视图进行相应的更新。</p>
</blockquote>
<h2 id="MVVM？比之-MVC-有什么区别？"><a href="#MVVM？比之-MVC-有什么区别？" class="headerlink" title="MVVM？比之 MVC 有什么区别？"></a>MVVM？比之 MVC 有什么区别？</h2><h3 id="首先先来说下-View-和-Model"><a href="#首先先来说下-View-和-Model" class="headerlink" title="首先先来说下 View 和 Model"></a>首先先来说下 View 和 Model</h3><ul>
<li>View 很简单，就是用户看到的视图</li>
<li>Model 同样很简单，一般就是本地数据和数据库中的数据</li>
</ul>
<h3 id="基本上，我们写的产品就是通过接口从数据库中读取数据，然后将数据经过处理展现到用户看到的视图上。当然我们还可以从视图上读取用户的输入，然后又将用户的输入通过接口写入到数据库中。但是，如何将数据展示到视图上，然后又如何将用户的输入写入到数据中，不同的人就产生了不同的看法，从此出现了很多种架构设计。"><a href="#基本上，我们写的产品就是通过接口从数据库中读取数据，然后将数据经过处理展现到用户看到的视图上。当然我们还可以从视图上读取用户的输入，然后又将用户的输入通过接口写入到数据库中。但是，如何将数据展示到视图上，然后又如何将用户的输入写入到数据中，不同的人就产生了不同的看法，从此出现了很多种架构设计。" class="headerlink" title="基本上，我们写的产品就是通过接口从数据库中读取数据，然后将数据经过处理展现到用户看到的视图上。当然我们还可以从视图上读取用户的输入，然后又将用户的输入通过接口写入到数据库中。但是，如何将数据展示到视图上，然后又如何将用户的输入写入到数据中，不同的人就产生了不同的看法，从此出现了很多种架构设计。"></a>基本上，我们写的产品就是通过接口从数据库中读取数据，然后将数据经过处理展现到用户看到的视图上。当然我们还可以从视图上读取用户的输入，然后又将用户的输入通过接口写入到数据库中。但是，如何将数据展示到视图上，然后又如何将用户的输入写入到数据中，不同的人就产生了不同的看法，从此出现了很多种架构设计。</h3><h4 id="传统的-MVC-架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。"><a href="#传统的-MVC-架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。" class="headerlink" title="传统的 MVC 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。"></a>传统的 MVC 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/1.1.png"
                     
                ></p>
<p>####但是 MVC 有一个巨大的缺陷就是控制器承担的责任太大了，随着项目愈加复杂，控制器中的代码会越来越臃肿，导致出现不利于维护的情况。</p>
<h3 id="在-MVVM-架构中，引入了-ViewModel-的概念。ViewModel-只关心数据和业务的处理，不关心-View-如何处理数据，在这种情况下，View-和-Model-都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个-ViewModel-中，让多个-View-复用这个-ViewModel。"><a href="#在-MVVM-架构中，引入了-ViewModel-的概念。ViewModel-只关心数据和业务的处理，不关心-View-如何处理数据，在这种情况下，View-和-Model-都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个-ViewModel-中，让多个-View-复用这个-ViewModel。" class="headerlink" title="在 MVVM 架构中，引入了 ViewModel 的概念。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。"></a>在 MVVM 架构中，引入了 ViewModel 的概念。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/1.2.png"
                     
                ></p>
<h3 id="以-Vue-框架来举例，ViewModel-就是组件的实例。View-就是模板，Model-的话在引入-Vuex-的情况下是完全可以和组件分离的。"><a href="#以-Vue-框架来举例，ViewModel-就是组件的实例。View-就是模板，Model-的话在引入-Vuex-的情况下是完全可以和组件分离的。" class="headerlink" title="以 Vue 框架来举例，ViewModel 就是组件的实例。View 就是模板，Model 的话在引入 Vuex 的情况下是完全可以和组件分离的。"></a>以 Vue 框架来举例，ViewModel 就是组件的实例。View 就是模板，Model 的话在引入 Vuex 的情况下是完全可以和组件分离的。</h3><p>####除了以上三个部分，其实在 MVVM 中还引入了一个隐式的 Binder 层，实现了 View 和 ViewModel 的绑定。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/1.3.png"
                     
                ></p>
<h5 id="同样以-Vue-框架来举例，这个隐式的-Binder-层就是-Vue-通过解析模板中的插值和指令从而实现-View-与-ViewModel-的绑定。"><a href="#同样以-Vue-框架来举例，这个隐式的-Binder-层就是-Vue-通过解析模板中的插值和指令从而实现-View-与-ViewModel-的绑定。" class="headerlink" title="同样以 Vue 框架来举例，这个隐式的 Binder 层就是 Vue 通过解析模板中的插值和指令从而实现 View 与 ViewModel 的绑定。"></a>同样以 Vue 框架来举例，这个隐式的 Binder 层就是 Vue 通过解析模板中的插值和指令从而实现 View 与 ViewModel 的绑定。</h5><p>对于 MVVM 来说，其实最重要的并不是通过双向绑定或者其他的方式将 View 与 ViewModel 绑定起来，<strong>而是通过 ViewModel 将视图中的状态和用户的行为分离出一个抽象，这才是 MVVM 的精髓。</strong></p>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>mvvm</tag>
      </tags>
  </entry>
  <entry>
    <title>json web token【跨域认证的解决方案】</title>
    <url>/2019/02/25/json%20web%20token/</url>
    <content><![CDATA[<h2 id="json-web-token【跨域认证的解决方案】"><a href="#json-web-token【跨域认证的解决方案】" class="headerlink" title="json web token【跨域认证的解决方案】"></a>json web token【跨域认证的解决方案】</h2><h4 id="一般互联网认证用户流程"><a href="#一般互联网认证用户流程" class="headerlink" title="一般互联网认证用户流程"></a>一般互联网认证用户流程</h4><blockquote>
<p>1.<strong>用户向服务器发送用户名和密码。</strong></p>
</blockquote>
<blockquote>
<p>2、<strong>服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</strong></p>
<p>3、<strong>服务器向用户返回一个 session_id，写入用户的 Cookie。</strong></p>
<p>4、<strong>用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</strong></p>
<p>5、<strong>服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</strong></p>
</blockquote>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><blockquote>
<p>扩展性不够好单机当然没有问题，如果是服务器集群，就要求 session 数据共享，每台服务器都能够读取 session。</p>
</blockquote>
<h2 id="JWT以及具体实现"><a href="#JWT以及具体实现" class="headerlink" title="JWT以及具体实现"></a>JWT以及具体实现</h2><h3 id="JWT鉴权的简单流程"><a href="#JWT鉴权的简单流程" class="headerlink" title="JWT鉴权的简单流程"></a>JWT鉴权的简单流程</h3><h3 id="JWT分为三部分"><a href="#JWT分为三部分" class="headerlink" title="JWT分为三部分"></a>JWT分为三部分</h3><blockquote>
<p>Header（包含加密方式等）</p>
</blockquote>
<pre><code>&#123;
  &quot;alg&quot;: &quot;HS256&quot;,// 默认签名算法
  &quot;typ&quot;: &quot;JWT&quot; // 类型
&#125;
</code></pre>
<blockquote>
<p>Payload（包含用户必要信息，以及过期时间等）</p>
</blockquote>
<pre><code>iss (issuer)：签发人
exp (expiration time)：过期时间
sub (subject)：主题
aud (audience)：受众
nbf (Not Before)：生效时间
iat (Issued At)：签发时间
jti (JWT ID)：编号

用来存放需要传递的实际数据
</code></pre>
<blockquote>
<p>Signature（针对前两部分生成，防止数据篡改）。</p>
</blockquote>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><pre><code>用户登录成功后，后台根据用户信息加上一个用户唯一的密钥值，生成一串字符串，即Token串，将其设置
在Cookie中；
用户下次带Token访问，系统会先根据前两部分以及密钥值，对Token进行有效性以及正确性的验证，如果       
验证通过的话，再执行下一步操作...
</code></pre>
<h4 id="如果要写入私密数据时需要加密"><a href="#如果要写入私密数据时需要加密" class="headerlink" title="如果要写入私密数据时需要加密"></a>如果要写入私密数据时需要加密</h4><pre><code>const token = jwt.sign(&#123;...getu&#125;,&quot;usermessag&quot;,&#123;
    expiresIn: 60*60*1  // 1小时过期
  &#125;)
</code></pre>
<h4 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h4><pre><code>jwt.verify(token,&#39;usermessag&#39;,(err, decode) =&gt; &#123;
    console.log(decode) // n拿到解密的值
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
        <tag>json web token</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中使用高德地图定位</title>
    <url>/2019/02/22/gao%20de%20map/</url>
    <content><![CDATA[<h2 id="高德地图API"><a href="#高德地图API" class="headerlink" title="高德地图API"></a>高德地图API</h2><h3 id="javascript-API高德地图官网链接"><a href="#javascript-API高德地图官网链接" class="headerlink" title="javascript API高德地图官网链接"></a>javascript API<a class="link"   href="https://lbs.amap.com/api/javascript-api/guide/services/geolocation" >高德地图官网链接<i class="fas fa-external-link-alt"></i></a></h3><h4 id="首先注册成为开发者"><a href="#首先注册成为开发者" class="headerlink" title="首先注册成为开发者"></a>首先注册成为开发者</h4><blockquote>
<p>为项目添加key</p>
</blockquote>
<h3 id="在vue中使用高德地图定位"><a href="#在vue中使用高德地图定位" class="headerlink" title="在vue中使用高德地图定位"></a>在vue中使用高德地图定位</h3><blockquote>
<p><strong>/index.html</strong></p>
</blockquote>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;https://webapi.amap.com/maps?v=1.4.12&amp;key=添加你自己的key&quot;&gt;&lt;/script&gt;
</code></pre>
<blockquote>
<p><strong>/build/webpack.base.conf.js</strong></p>
</blockquote>
<pre><code>module.exports = &#123;
    externals: &#123;
        AMap: &#39;AMap&#39;
      &#125;,
&#125;
</code></pre>
<h3 id="以模块的形式引入"><a href="#以模块的形式引入" class="headerlink" title="以模块的形式引入"></a>以模块的形式引入</h3><blockquote>
<p><strong>/map.js</strong></p>
</blockquote>
<pre><code>import AMap from &#39;AMap&#39;
/* eslint-disable */
let maps
const map = &#123; // 定位
  geolocation () &#123;
    return new Promise((resolve, reject) =&gt; &#123;
      AMap.plugin(&#39;AMap.Geolocation&#39;, () =&gt; &#123;
        var geolocation = new AMap.Geolocation(&#123;
          // 是否使用高精度定位，默认：true
          enableHighAccuracy: true,
          // 设置定位超时时间，默认：无穷大
          timeout: 10000
        &#125;)
        geolocation.getCurrentPosition() // 执行定位
        AMap.event.addListener(geolocation, &#39;complete&#39;, (data) =&gt; &#123;
          resolve(data)
        &#125;) // 成功的回调
        AMap.event.addListener(geolocation, &#39;error&#39;, (data) =&gt; &#123;
          reject(data)
        &#125;) // 失败的回调
      &#125;)
    &#125;)
  &#125;,
  citySearch () &#123; // 当前所在城市信息
    return new Promise((resolve, reject) =&gt; &#123;
      AMap.plugin(&#39;AMap.CitySearch&#39;, () =&gt; &#123;
        const citySearch = new AMap.CitySearch()
        citySearch.getLocalCity(function (status, result) &#123;
          if (status === &#39;complete&#39; &amp;&amp; result.info === &#39;OK&#39;) &#123;
            // 查询成功，result即为当前所在城市信息
            resolve(result)
          &#125;
        &#125;)
      &#125;)
    &#125;)
  &#125;,
  search (key, city) &#123; // 根据城市搜索附近地区
    return new Promise((resolve, reject) =&gt; &#123;
      AMap.plugin([&#39;AMap.PlaceSearch&#39;], () =&gt; &#123;
        var placeSearch = new AMap.PlaceSearch(&#123;
          city: city
        &#125;)
        placeSearch.search(key, (status, result) =&gt; &#123;
          if (result.poiList) &#123;
            resolve(result.poiList.pois)
          &#125;
        &#125;)
      &#125;)
    &#125;)
  &#125;,
  renderMap (el) &#123; // 渲染一张地图
    console.log(el)
    maps = new AMap.Map(el, &#123;
      resizeEnable: true, // 是否监控地图容器尺寸变化
      zoom: 17,
      center: [116.408075, 39.950187],
      features: [&#39;bg&#39;, &#39;road&#39;, &#39;building&#39;, &#39;point&#39;]
    &#125;)
    // AMap.plugin([&#39;AMap.ToolBar&#39;, &#39;AMap.Scale&#39;], function () &#123;
    //   maps.addControl(new AMap.ToolBar())
    //   maps.addControl(new AMap.Scale())
    // &#125;)
  &#125;
&#125;

export default map
</code></pre>
<blockquote>
<p><strong>使用的时候直接调用即可</strong></p>
</blockquote>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
        <tag>定位</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 防抖（debouce）与节流（throttle）</title>
    <url>/2019/02/21/debouce/</url>
    <content><![CDATA[<h2 id="JS-防抖（debouce）与节流（throttle）"><a href="#JS-防抖（debouce）与节流（throttle）" class="headerlink" title="JS 防抖（debouce）与节流（throttle）"></a>JS 防抖（debouce）与节流（throttle）</h2><h3 id="防抖和节流是针对响应跟不上触发频率这类问题的两种解决方案。-在给DOM绑定事件时，有些事件我们是无法控制触发频率的。-如鼠标移动事件onmousemove-滚动滚动条事件onscroll，窗口大小改变事件onresize，瞬间的操作都会导致这些事件会被高频触发。-如果事件的回调函数较为复杂，就会导致响应跟不上触发，出现页面卡顿，假死现象。-在实时检查输入时，如果我们绑定onkeyup事件发请求去服务端检查，用户输入过程中，事件的触发频率也会很高，会导致大量的请求发出，响应速度会大大跟不上触发。"><a href="#防抖和节流是针对响应跟不上触发频率这类问题的两种解决方案。-在给DOM绑定事件时，有些事件我们是无法控制触发频率的。-如鼠标移动事件onmousemove-滚动滚动条事件onscroll，窗口大小改变事件onresize，瞬间的操作都会导致这些事件会被高频触发。-如果事件的回调函数较为复杂，就会导致响应跟不上触发，出现页面卡顿，假死现象。-在实时检查输入时，如果我们绑定onkeyup事件发请求去服务端检查，用户输入过程中，事件的触发频率也会很高，会导致大量的请求发出，响应速度会大大跟不上触发。" class="headerlink" title="防抖和节流是针对响应跟不上触发频率这类问题的两种解决方案。 在给DOM绑定事件时，有些事件我们是无法控制触发频率的。 如鼠标移动事件onmousemove, 滚动滚动条事件onscroll，窗口大小改变事件onresize，瞬间的操作都会导致这些事件会被高频触发。 如果事件的回调函数较为复杂，就会导致响应跟不上触发，出现页面卡顿，假死现象。 在实时检查输入时，如果我们绑定onkeyup事件发请求去服务端检查，用户输入过程中，事件的触发频率也会很高，会导致大量的请求发出，响应速度会大大跟不上触发。"></a>防抖和节流是针对响应跟不上触发频率这类问题的两种解决方案。 在给DOM绑定事件时，有些事件我们是无法控制触发频率的。 如鼠标移动事件onmousemove, 滚动滚动条事件onscroll，窗口大小改变事件onresize，瞬间的操作都会导致这些事件会被高频触发。 如果事件的回调函数较为复杂，就会导致响应跟不上触发，出现页面卡顿，假死现象。 在实时检查输入时，如果我们绑定onkeyup事件发请求去服务端检查，用户输入过程中，事件的触发频率也会很高，会导致大量的请求发出，响应速度会大大跟不上触发。</h3><blockquote>
<h4 id="针对此类快速连续触发和不可控的高频触发问题，debounce-和-throttling-给出了两种解决策略；"><a href="#针对此类快速连续触发和不可控的高频触发问题，debounce-和-throttling-给出了两种解决策略；" class="headerlink" title="针对此类快速连续触发和不可控的高频触发问题，debounce 和 throttling 给出了两种解决策略；"></a>针对此类快速连续触发和不可控的高频触发问题，debounce 和 throttling 给出了两种解决策略；</h4></blockquote>
<h2 id="防抖-debouce"><a href="#防抖-debouce" class="headerlink" title="防抖(debouce)"></a>防抖(debouce)</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>函数防抖的含义就是在一定时间段内只有一个同类的事件触发并执行；如果该时间段有同类的事件触发，则重新开始响应该事件</p>
</blockquote>
<hr>
<blockquote>
<p><strong>实例</strong></p>
</blockquote>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Test&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;input type=&quot;text&quot; name=&quot;input&quot; onkeyup=&quot;debouce(inputHandler);&quot;&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
         let i = 0;
        function inputHandler () &#123;
            console.log(i++); 
        &#125;
        let timer;
        function debouce (fn) &#123;
            clearTimeout(timer); 
            timer = setTimeout(() =&gt; &#123;
                fn();
            &#125;, 500)
        &#125;
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="节流（throttle）"><a href="#节流（throttle）" class="headerlink" title="节流（throttle）"></a>节流（throttle）</h2><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p><strong>函数节流的含义就是在一定的时间段内相应的事件只能被触发一次；如果某段有已经有相应的事件在执行，则在该时间段内不再触发，直到本次事件执行结束；</strong></p>
</blockquote>
<hr>
<blockquote>
<p>实例</p>
</blockquote>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Test&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;input type=&quot;text&quot; name=&quot;input&quot; onkeyup=&quot;debouce(inputHandler);&quot;&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
         let i = 0;
        function inputHandler () &#123;
            console.log(i++); 
        &#125;
        let timer;
        function throttle (fn) &#123;
            if (timer) &#123;
                return;
            &#125;
            timer = setTimeout(() =&gt; &#123;
                fn();
            &#125;, 200);
        &#125;
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><blockquote>
<p>   <strong>——— 函数去抖和函数节流都是密集型操作中避免事件频繁出发造成性能损耗的解决方案；函数节流，顾名思义就是节约流量，所以每个时间段内只会执行一次，并在此时间段内屏蔽触发的同类事件；而函数去抖则是在用户连续操作中避免事件处理的处理效率不及时间触发速度，从而导致画面卡顿，操作不畅等不良用户体验，所以在很短的时间段内只响应最近触发的事件；</strong></p>
</blockquote>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
        <tag>debouce</tag>
        <tag>throttle</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中封装axios方法</title>
    <url>/2019/02/20/axios/</url>
    <content><![CDATA[<h2 id="vue中封装axios方法"><a href="#vue中封装axios方法" class="headerlink" title="vue中封装axios方法"></a>vue中封装axios方法</h2><h3 id="axios基本配置"><a href="#axios基本配置" class="headerlink" title="axios基本配置"></a><a class="link"   href="https://www.kancloud.cn/yunye/axios/234845" >axios基本配置<i class="fas fa-external-link-alt"></i></a></h3><blockquote>
<p><strong>/src/util/axios.js</strong></p>
</blockquote>
<pre><code>import axios from &#39;axios&#39; // 引入axios
import vm from &#39;@/main&#39;    // 引入vue实例化


// 创建axios实例
var instance = axios.create(&#123;
  // 设置默认请求头，使post请求发送的是formdata格式数据// axios的header默认的Content-Type好像是&#39;application/json;charset=UTF-8&#39;
    headers: &#123;  
      &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;,
      &#39;token&#39;: &#39;asdasdasdasdasdasd&#39; // 也可以自定义请求头
    &#125;,
    withCredentials: true // 允许携带cookie
&#125;)

// 添加响应拦截器
instance.interceptors.response.use(function (response) &#123;
  // 对响应数据做点什么
  return response.data
&#125;, function (error) &#123;
  // 统一的错误处理
  console.log(error.response.status)
  if (error.response.status !== 401) &#123;
    vm.$error(error.response.data.message)
  &#125;
  // 对响应错误做点什么
  return Promise.reject(error)
&#125;)

export const get = (url, data) =&gt; instance.get(url, &#123;
  params: data
&#125;) // get方式

export const post = (url, data) =&gt; instance.post(url, data) //post方式
export const put = (url, data) =&gt; instance.put(url, data) //put方式
</code></pre>
<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a><strong>调用</strong></h3><blockquote>
<p><strong>api/index.js</strong></p>
</blockquote>
<pre><code>import &#123;get, post&#125; from &#39;@/utils/axios&#39;

getCityList: () =&gt; get(&#39;/api/cityList&#39;)
</code></pre>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title>session和cookie</title>
    <url>/2019/02/18/session/</url>
    <content><![CDATA[<h2 id="无状态的http"><a href="#无状态的http" class="headerlink" title="无状态的http"></a>无状态的http</h2><h3 id="http的请求和响应都是对应的，客户端向服务器发送请求数据，服务器端不会记录状态-因此服务器端想知道是哪个客户端提交的请求，通常使用cookie和session来完成"><a href="#http的请求和响应都是对应的，客户端向服务器发送请求数据，服务器端不会记录状态-因此服务器端想知道是哪个客户端提交的请求，通常使用cookie和session来完成" class="headerlink" title="http的请求和响应都是对应的，客户端向服务器发送请求数据，服务器端不会记录状态,因此服务器端想知道是哪个客户端提交的请求，通常使用cookie和session来完成"></a>http的请求和响应都是对应的，客户端向服务器发送请求数据，服务器端不会记录状态,因此服务器端想知道是哪个客户端提交的请求，通常使用cookie和session来完成</h3><h2 id="Cookie【req-cookies】"><a href="#Cookie【req-cookies】" class="headerlink" title="Cookie【req.cookies】"></a>Cookie【req.cookies】</h2><h3 id="cookie是从服务端发送的，服务端给不同的客户端发送不同的标识，这个标识标识该用户的身份，服务器通过这个标识来识别用户的身份，从而将数据发送到该客户端【express使用cookie-parser-】，但是客户端的cookie具有局限性"><a href="#cookie是从服务端发送的，服务端给不同的客户端发送不同的标识，这个标识标识该用户的身份，服务器通过这个标识来识别用户的身份，从而将数据发送到该客户端【express使用cookie-parser-】，但是客户端的cookie具有局限性" class="headerlink" title="cookie是从服务端发送的，服务端给不同的客户端发送不同的标识，这个标识标识该用户的身份，服务器通过这个标识来识别用户的身份，从而将数据发送到该客户端【express使用cookie-parser 】，但是客户端的cookie具有局限性"></a>cookie是从服务端发送的，服务端给不同的客户端发送不同的标识，这个标识标识该用户的身份，服务器通过这个标识来识别用户的身份，从而将数据发送到该客户端【express使用cookie-parser 】，但是客户端的cookie具有局限性</h3><h2 id="局限性："><a href="#局限性：" class="headerlink" title="局限性："></a>局限性：</h2><h3 id="cookie的数量长度限制，每个cookie长度不能超过4kb，最多只能有20条"><a href="#cookie的数量长度限制，每个cookie长度不能超过4kb，最多只能有20条" class="headerlink" title="cookie的数量长度限制，每个cookie长度不能超过4kb，最多只能有20条"></a>cookie的数量长度限制，每个cookie长度不能超过4kb，最多只能有20条</h3><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h3 id="express-session是express的一个中间件来创建session，服务端生成了一个session-id，客户端使用cookie保存了session-id这个请求的信息，而将用户的请求信息保存到客户端，session记录的客户端与服务端之间的会话状态，该状态是用来确定客户端的身份【req-session】"><a href="#express-session是express的一个中间件来创建session，服务端生成了一个session-id，客户端使用cookie保存了session-id这个请求的信息，而将用户的请求信息保存到客户端，session记录的客户端与服务端之间的会话状态，该状态是用来确定客户端的身份【req-session】" class="headerlink" title="express-session是express的一个中间件来创建session，服务端生成了一个session id，客户端使用cookie保存了session id这个请求的信息，而将用户的请求信息保存到客户端，session记录的客户端与服务端之间的会话状态，该状态是用来确定客户端的身份【req.session】"></a>express-session是express的一个中间件来创建session，服务端生成了一个session id，客户端使用cookie保存了session id这个请求的信息，而将用户的请求信息保存到客户端，session记录的客户端与服务端之间的会话状态，该状态是用来确定客户端的身份【req.session】</h3><h2 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h2><h4 id="1、最大的区别应该在于存储的地方不一样，cookie存储在客户端，session存储在服务器；"><a href="#1、最大的区别应该在于存储的地方不一样，cookie存储在客户端，session存储在服务器；" class="headerlink" title="1、最大的区别应该在于存储的地方不一样，cookie存储在客户端，session存储在服务器；"></a>1、最大的区别应该在于存储的地方不一样，cookie存储在客户端，session存储在服务器；</h4><h4 id="2、从安全性方面来说，cookie存储在客户端，很容易被窃取，暴露用户信息，而session存储在服务器，被窃取的机会小很多，故session的安全性比cookie高；"><a href="#2、从安全性方面来说，cookie存储在客户端，很容易被窃取，暴露用户信息，而session存储在服务器，被窃取的机会小很多，故session的安全性比cookie高；" class="headerlink" title="2、从安全性方面来说，cookie存储在客户端，很容易被窃取，暴露用户信息，而session存储在服务器，被窃取的机会小很多，故session的安全性比cookie高；"></a>2、从安全性方面来说，cookie存储在客户端，很容易被窃取，暴露用户信息，而session存储在服务器，被窃取的机会小很多，故session的安全性比cookie高；</h4><h4 id="3、从性能方面来说，cookie存储在浏览器端消耗的是用户的资源，相对比较分散，而session消耗的服务器的内存，会造成服务器端的压力；"><a href="#3、从性能方面来说，cookie存储在浏览器端消耗的是用户的资源，相对比较分散，而session消耗的服务器的内存，会造成服务器端的压力；" class="headerlink" title="3、从性能方面来说，cookie存储在浏览器端消耗的是用户的资源，相对比较分散，而session消耗的服务器的内存，会造成服务器端的压力；"></a>3、从性能方面来说，cookie存储在浏览器端消耗的是用户的资源，相对比较分散，而session消耗的服务器的内存，会造成服务器端的压力；</h4><h4 id="4、cookie可以长期的存储在客户端，但是数量和大小都是有限制的；session存在服务器的时间较短，但是没有大小的限制。"><a href="#4、cookie可以长期的存储在客户端，但是数量和大小都是有限制的；session存在服务器的时间较短，但是没有大小的限制。" class="headerlink" title="4、cookie可以长期的存储在客户端，但是数量和大小都是有限制的；session存在服务器的时间较短，但是没有大小的限制。"></a>4、cookie可以长期的存储在客户端，但是数量和大小都是有限制的；session存在服务器的时间较短，但是没有大小的限制。</h4>]]></content>
      <tags>
        <tag>js</tag>
        <tag>session</tag>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Mvc.</title>
    <url>/2019/02/17/mvc/</url>
    <content><![CDATA[<h2 id="浅谈mvc"><a href="#浅谈mvc" class="headerlink" title="浅谈mvc"></a>浅谈mvc</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><blockquote>
<p>MVC即Model、View、Controller即模型、视图、控制器。我在和同行讨论技术，阅读别人的代码时发现，很多程序员倾向于将软件的业务逻辑放在Controller里，将数据库访问操作的代码放在Model里。</p>
<p>####最终网站的代码结构是，View层是界面，Controller层是业务逻辑，Model层是数据库访问。     </p>
</blockquote>
<p>###MVC要实现的目标是将软件用户界面和业务逻辑分离以使代码可扩展性、可复用性、可维护性、灵活性加强。</p>
<blockquote>
<p>View层是界面，Model层是业务逻辑，Controller层用来调度View层和Model层，将用户界面和业务逻辑合理的组织在一起，起粘合剂的效果。所以Controller中的内容能少则少，这样才能提供最大的灵活性。</p>
</blockquote>
<hr>
<blockquote>
<h4 id="比方说，有一个View会提交数据给Model进行处理以实现具体的行为，View通常不会直接提交数据给Model，它会先把数据提交给Controller，然后Controller再将数据转发给Model。假如此时程序业务逻辑的处理方式有变化，那么只需要在Controller中将原来的Model换成新实现的Model就可以了，控制器的作用就是这么简单，-用来将不同的View和不同的Model组织在一起，顺便替双方传递消息，仅此而已。"><a href="#比方说，有一个View会提交数据给Model进行处理以实现具体的行为，View通常不会直接提交数据给Model，它会先把数据提交给Controller，然后Controller再将数据转发给Model。假如此时程序业务逻辑的处理方式有变化，那么只需要在Controller中将原来的Model换成新实现的Model就可以了，控制器的作用就是这么简单，-用来将不同的View和不同的Model组织在一起，顺便替双方传递消息，仅此而已。" class="headerlink" title="比方说，有一个View会提交数据给Model进行处理以实现具体的行为，View通常不会直接提交数据给Model，它会先把数据提交给Controller，然后Controller再将数据转发给Model。假如此时程序业务逻辑的处理方式有变化，那么只需要在Controller中将原来的Model换成新实现的Model就可以了，控制器的作用就是这么简单， 用来将不同的View和不同的Model组织在一起，顺便替双方传递消息，仅此而已。"></a>比方说，有一个View会提交数据给Model进行处理以实现具体的行为，View通常不会直接提交数据给Model，它会先把数据提交给Controller，然后Controller再将数据转发给Model。假如此时程序业务逻辑的处理方式有变化，那么只需要在Controller中将原来的Model换成新实现的Model就可以了，控制器的作用就是这么简单， 用来将不同的View和不同的Model组织在一起，顺便替双方传递消息，仅此而已。</h4></blockquote>
<hr>
<blockquote>
<p>各Model之间是可以相互调用的， Controller也可以无障碍的调用Model，因此将业务逻辑放在Model中可以灵活的使用组合的方式复用代码。</p>
</blockquote>
<h2 id="MVC的优缺点"><a href="#MVC的优缺点" class="headerlink" title="MVC的优缺点"></a>MVC的优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>耦合性低（ MVC设计模式可以说实现了分层开发。各个层都有各个层的作用。 ）</li>
<li>重用性高</li>
<li>部署快，生命周期成本低</li>
<li>可维护性高（修改模型不会影响到视图，反过来，修改视图，也不会影响到模型。 ）</li>
</ul>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li><p>完全理解MVC比较复杂。</p>
</li>
<li><p>调试困难。</p>
</li>
<li><p>不适合小型，中等规模的应用程序（对于简单页面，严格遵循mvc，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。 ）</p>
</li>
<li><p>增加系统结构和实现的复杂性</p>
</li>
</ul>
<h2 id="总结一下，关于MVC各层之间关系所对应的设计模式"><a href="#总结一下，关于MVC各层之间关系所对应的设计模式" class="headerlink" title="总结一下，关于MVC各层之间关系所对应的设计模式"></a>总结一下，关于MVC各层之间关系所对应的设计模式</h2><ul>
<li>View层，单独实现了组合模式</li>
<li>Model层和View层，实现了观察者模式</li>
<li>View层和Controller层，实现了策咯模式</li>
</ul>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>mvc</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域</title>
    <url>/2019/02/13/cors/</url>
    <content><![CDATA[<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>###<a class="link"   href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" >浏览器同源政策及其规避方法<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="跨域是由于浏览器的同源策略限制，而产生的一种安全模式。"><a href="#跨域是由于浏览器的同源策略限制，而产生的一种安全模式。" class="headerlink" title="跨域是由于浏览器的同源策略限制，而产生的一种安全模式。"></a>跨域是由于浏览器的同源策略限制，而产生的一种安全模式。</h3><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><h3 id="同源是指同协议，同域名，同端口，三者相同就是同源，如有一项不同就是跨域，而在浏览器中静态资源不受同源策略的影响（img-link，script-iframe）"><a href="#同源是指同协议，同域名，同端口，三者相同就是同源，如有一项不同就是跨域，而在浏览器中静态资源不受同源策略的影响（img-link，script-iframe）" class="headerlink" title="同源是指同协议，同域名，同端口，三者相同就是同源，如有一项不同就是跨域，而在浏览器中静态资源不受同源策略的影响（img,link，script,iframe）"></a>同源是指同协议，同域名，同端口，三者相同就是同源，如有一项不同就是跨域，而在浏览器中静态资源不受同源策略的影响（img,link，script,iframe）</h3><h2 id="解决跨域"><a href="#解决跨域" class="headerlink" title="解决跨域"></a>解决跨域</h2><h3 id="利用同源策略的特点解决跨域问题"><a href="#利用同源策略的特点解决跨域问题" class="headerlink" title="利用同源策略的特点解决跨域问题"></a>利用同源策略的特点解决跨域问题</h3><h2 id="方式一-jsonp请求"><a href="#方式一-jsonp请求" class="headerlink" title="方式一: jsonp请求"></a>方式一: jsonp请求</h2><h3 id="利用静态资源不受跨域的限制解决跨域"><a href="#利用静态资源不受跨域的限制解决跨域" class="headerlink" title="利用静态资源不受跨域的限制解决跨域"></a>利用静态资源不受跨域的限制解决跨域</h3><blockquote>
<p>####封装jsonp</p>
</blockquote>
<pre><code>const getParams = (data) =&gt; &#123; // 创建一个函数，接收一个参数
  console.log(data, &#39;444&#39;)
  let params = &#39;&#39;
  for (let key in data) &#123;
    console.log(key)
    params += &#39;&amp;&#39; + key + &#39;=&#39; + data[key]
  &#125;
  return params
&#125;
const jsonp = (url, data) =&gt; &#123; // 创建函数接收需要跨域请求的地址
  return new Promise((resolve, reject) =&gt; &#123;
    const script = document.createElement(&#39;script&#39;) // 动态创建script标签
    const callbackName = &#39;a&#39; + (+new Date()) // 随机定义callback函数名
    const params = getParams(data) // 拼接参数
    script.src = url + &#39;?callback=&#39; + callbackName + &#39;&amp;&#39; + params // 设置src属性为接口地址
    console.log(script)
    document.body.appendChild(script) // 动态插入到页面中
    window[callbackName] = function (res) &#123; // 动态设置callback函数到window上
      resolve(res) // 成功后
      document.body.removeChild(script) // 删除script标签
      window[callbackName] = null // 清空window上的callback函数
    &#125;
    console.log(&#39;aaa&#39;)
  &#125;)
&#125;
export default jsonp
</code></pre>
<blockquote>
<p>###后端【使用express来说】</p>
</blockquote>
<pre><code>router.get(&#39;/list&#39;, function(req,res)&#123;
  console.log(req.query)
  let &#123;callback&#125; = req.query
  res.send(`$&#123;callback&#125;(&#39;sssss&#39;)`)
&#125;)
</code></pre>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><blockquote>
<p>可以解决跨域，并且兼容所有浏览器</p>
</blockquote>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><blockquote>
<p>只能get请求，不能post请求</p>
</blockquote>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><blockquote>
<p>利用了静态资源不受同源策略影响</p>
</blockquote>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><blockquote>
<p>动态生成script标签，并且设置src属性为接口地址，动态插入到页面中，发出请求，后端接到请求，需要获取callback的参数，而callback的参数<br>动态生成script标签的时候，动态生成函数名称</p>
</blockquote>
<h2 id="方式二：cors"><a href="#方式二：cors" class="headerlink" title="方式二：cors"></a>方式二：cors</h2><p>cors跨域资源共享，这是浏览器的新增特性，只需要操作服务即可，客户端不变，常用场景就是小程序</p>
<p>Cors是一个w3c标准，全称是“跨域资源共享”（Corss-origin rsource sharing）</p>
<p>他允许浏览器向跨域服务器，发出XMLrequrest请求，从而克服了AJAX只能同源使用的限制</p>
<p>前端不需要做任何修改，只需要服务端设置允许的header头即可</p>
<pre><code>app.use((req, res, next) =&gt; &#123;
  res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;); // 允许所有跨域请求
  res.header(&#39;Access-Control-Allow-Credentials&#39;, true) // 允许携带cookie
  res.header(&#39;Access-Control-Allow-Headers&#39;, &#39;Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild&#39;); //允许的header内容
  res.header(&#39;Access-Control-Allow-Methods&#39;, &#39;PUT, POST, GET, DELETE, OPTIONS&#39;); // 允许的请求方法

  next()
&#125;)
</code></pre>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><blockquote>
<h4 id="前端不需要做任何处理，支持get，post任何请求"><a href="#前端不需要做任何处理，支持get，post任何请求" class="headerlink" title="前端不需要做任何处理，支持get，post任何请求"></a>前端不需要做任何处理，支持get，post任何请求</h4></blockquote>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><blockquote>
<h4 id="浏览器兼容，不兼容IE10以下浏览器"><a href="#浏览器兼容，不兼容IE10以下浏览器" class="headerlink" title="浏览器兼容，不兼容IE10以下浏览器"></a>浏览器兼容，不兼容IE10以下浏览器</h4></blockquote>
<h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><blockquote>
<h4 id="浏览器新特性"><a href="#浏览器新特性" class="headerlink" title="浏览器新特性"></a>浏览器新特性</h4></blockquote>
<h2 id="方式三：代理"><a href="#方式三：代理" class="headerlink" title="方式三：代理"></a>方式三：代理</h2><p>一般情况下跨域产生的原因域名端口不一样，因为在开发环境中，前端启动的是自己的服务，后端启动也是自己的服务，而在后面上线了就不存在跨域了，这种情况下我们一般使用代理的形式（后端不需要做任何调整，只需要前端添加反向代理即可）</p>
<p>客户端发出去请求 – 本地服务器拦截 – 发现是api开头 – 本地服务发出请求请求(localhost:3000) – 跨域服务器返回数据 – 本地服务器接收数据 – 将数据返回给客户端</p>
<h2 id="方式四：window-name-iframe"><a href="#方式四：window-name-iframe" class="headerlink" title="方式四：window.name+iframe"></a>方式四：window.name+iframe</h2><h3 id="window-name通过在iframe（一般动态创建i）中加载跨域HTML文件来起作用。然后，HTML文件将传递给请求者的字符串内容赋值给window-name。然后，请求者可以检索window-name值作为响应。"><a href="#window-name通过在iframe（一般动态创建i）中加载跨域HTML文件来起作用。然后，HTML文件将传递给请求者的字符串内容赋值给window-name。然后，请求者可以检索window-name值作为响应。" class="headerlink" title="window.name通过在iframe（一般动态创建i）中加载跨域HTML文件来起作用。然后，HTML文件将传递给请求者的字符串内容赋值给window.name。然后，请求者可以检索window.name值作为响应。"></a>window.name通过在iframe（一般动态创建i）中加载跨域HTML文件来起作用。然后，HTML文件将传递给请求者的字符串内容赋值给window.name。然后，请求者可以检索window.name值作为响应。</h3><ul>
<li>iframe标签的跨域能力；</li>
<li>window.name属性值在文档刷新后依旧存在的能力（且最大允许2M左右）。</li>
</ul>
<blockquote>
<h4 id="每个iframe都有包裹它的window，而这个window是top-window的子窗口。contentWindow属性返回iframe元素的Window对象。你可以使用这个Window对象来访问iframe的文档及其内部DOM。"><a href="#每个iframe都有包裹它的window，而这个window是top-window的子窗口。contentWindow属性返回iframe元素的Window对象。你可以使用这个Window对象来访问iframe的文档及其内部DOM。" class="headerlink" title="每个iframe都有包裹它的window，而这个window是top window的子窗口。contentWindow属性返回iframe元素的Window对象。你可以使用这个Window对象来访问iframe的文档及其内部DOM。"></a>每个iframe都有包裹它的window，而这个window是top window的子窗口。contentWindow属性返回iframe元素的Window对象。你可以使用这个Window对象来访问iframe的文档及其内部DOM。</h4></blockquote>
<pre><code>&lt;!-- 
 下述用端口 
 10000表示：domainA
 10001表示：domainB
--&gt;

&lt;!-- localhost:10000 --&gt;
&lt;script&gt;
  var iframe = document.createElement(&#39;iframe&#39;);
  iframe.style.display = &#39;none&#39;; // 隐藏

  var state = 0; // 防止页面无限刷新
  iframe.onload = function() &#123;
      if(state === 1) &#123;
          console.log(JSON.parse(iframe.contentWindow.name));
          // 清除创建的iframe
          iframe.contentWindow.document.write(&#39;&#39;);
          iframe.contentWindow.close();
          document.body.removeChild(iframe);
      &#125; else if(state === 0) &#123;
          state = 1;
          // 加载完成，指向当前域，防止错误(proxy.html为空白页面)
          // Blocked a frame with origin &quot;http://localhost:10000&quot; from accessing a cross-origin frame.
          iframe.contentWindow.location = &#39;http://localhost:10000/proxy.html&#39;;
      &#125;
  &#125;;

  iframe.src = &#39;http://localhost:10001&#39;;
  document.body.appendChild(iframe);
&lt;/script&gt;

&lt;!-- localhost:10001 --&gt;
&lt;!DOCTYPE html&gt;
...
&lt;script&gt;
  window.name = JSON.stringify(&#123;a: 1, b: 2&#125;);
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><blockquote>
<ol>
<li><p>直接嵌入其他域（localhots:10001）下的URL会报错，所以需要加载完成替换为当前域的URL(localhots:10000)，proxy.html为空白页面，只为解决该问题； </p>
</li>
<li><p>重新设置src（<a class="link"   href="http://localhost:10000/proxy.html%EF%BC%89%E5%90%8E%E5%AF%BC%E8%87%B4%E9%A1%B5%E9%9D%A2%E4%B8%8D%E6%96%AD%E5%88%B7%E6%96%B0%EF%BC%8C%E6%89%80%E4%BB%A5%E9%80%9A%E8%BF%87state%E6%9D%A5%E6%8E%A7%E5%88%B6%EF%BC%9B" >http://localhost:10000/proxy.html）后导致页面不断刷新，所以通过state来控制；<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p>全部获取完结果后，清除该iframe。</p>
</li>
</ol>
</blockquote>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>cors</tag>
        <tag>跨域</tag>
        <tag>jsonp</tag>
      </tags>
  </entry>
  <entry>
    <title>RESTful API</title>
    <url>/2019/02/12/web%20server/</url>
    <content><![CDATA[<h2 id="前后端交互？"><a href="#前后端交互？" class="headerlink" title="前后端交互？"></a>前后端交互？</h2><blockquote>
<h4 id="以前前后端是不分离的，随着ajax的出现，可以实现异步获取数据，不需要一直刷新页面，可以通过异步的形式获取数据，提升用户体验，后来随着一些前端框架的出现，开始有了前后端分离的开发模式，前端负责页面结构，样式，效果，数据渲染、（逻辑处理）后端只需要提供数据接口，提升了开发效率"><a href="#以前前后端是不分离的，随着ajax的出现，可以实现异步获取数据，不需要一直刷新页面，可以通过异步的形式获取数据，提升用户体验，后来随着一些前端框架的出现，开始有了前后端分离的开发模式，前端负责页面结构，样式，效果，数据渲染、（逻辑处理）后端只需要提供数据接口，提升了开发效率" class="headerlink" title="以前前后端是不分离的，随着ajax的出现，可以实现异步获取数据，不需要一直刷新页面，可以通过异步的形式获取数据，提升用户体验，后来随着一些前端框架的出现，开始有了前后端分离的开发模式，前端负责页面结构，样式，效果，数据渲染、（逻辑处理）后端只需要提供数据接口，提升了开发效率"></a>以前前后端是不分离的，随着ajax的出现，可以实现异步获取数据，不需要一直刷新页面，可以通过异步的形式获取数据，提升用户体验，后来随着一些前端框架的出现，开始有了前后端分离的开发模式，前端负责页面结构，样式，效果，数据渲染、（逻辑处理）后端只需要提供数据接口，提升了开发效率</h4></blockquote>
<h2 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h2><blockquote>
<h4 id="前后端分离之后出现的问题，数据结构有时候不会特别便利（不太方便），接口报错的时候，接口描述不清晰，这个时候都需要前端和后台沟通，为了提升开发效率，现在所有的后端需要提供接口文档，描述每一个接口是干什么的，每一个参数是干什么的，但是还是避免不了又不清晰的地方，后端也有可能发生错误，所以现在一般接口都会有接口规范（最常用的RESTful-API）"><a href="#前后端分离之后出现的问题，数据结构有时候不会特别便利（不太方便），接口报错的时候，接口描述不清晰，这个时候都需要前端和后台沟通，为了提升开发效率，现在所有的后端需要提供接口文档，描述每一个接口是干什么的，每一个参数是干什么的，但是还是避免不了又不清晰的地方，后端也有可能发生错误，所以现在一般接口都会有接口规范（最常用的RESTful-API）" class="headerlink" title="前后端分离之后出现的问题，数据结构有时候不会特别便利（不太方便），接口报错的时候，接口描述不清晰，这个时候都需要前端和后台沟通，为了提升开发效率，现在所有的后端需要提供接口文档，描述每一个接口是干什么的，每一个参数是干什么的，但是还是避免不了又不清晰的地方，后端也有可能发生错误，所以现在一般接口都会有接口规范（最常用的RESTful API）"></a>前后端分离之后出现的问题，数据结构有时候不会特别便利（不太方便），接口报错的时候，接口描述不清晰，这个时候都需要前端和后台沟通，为了提升开发效率，现在所有的后端需要提供接口文档，描述每一个接口是干什么的，每一个参数是干什么的，但是还是避免不了又不清晰的地方，后端也有可能发生错误，所以现在一般接口都会有接口规范（最常用的<a class="link"   href="http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html" >RESTful API<i class="fas fa-external-link-alt"></i></a>）</h4></blockquote>
<h2 id="后端开发语言？"><a href="#后端开发语言？" class="headerlink" title="后端开发语言？"></a>后端开发语言？</h2><p>####php,java,.net,…. 这些语言都可以输出html语言</p>
<blockquote>
<p>php循环</p>
</blockquote>
<pre><code>&lt;div&gt;
    &lt;?php
        for ($x=0; $x&lt;=10; $x++) &#123;
            exho &quot;&lt;li&gt; $x &lt;/li&gt;&quot;;
        &#125;
    ?&gt;
&lt;/div&gt;
</code></pre>
<h3 id="在这个时候前后端的职责就是前端只做页面布局-js效果，写静态页面，将静态页面给后端作为模板，后端开始嵌套数据，这时候前后交互是前端需要协助后端做页面调试，前端会一直配合后台做样式，结构处理，造成工作效率低下的问题"><a href="#在这个时候前后端的职责就是前端只做页面布局-js效果，写静态页面，将静态页面给后端作为模板，后端开始嵌套数据，这时候前后交互是前端需要协助后端做页面调试，前端会一直配合后台做样式，结构处理，造成工作效率低下的问题" class="headerlink" title="在这个时候前后端的职责就是前端只做页面布局+js效果，写静态页面，将静态页面给后端作为模板，后端开始嵌套数据，这时候前后交互是前端需要协助后端做页面调试，前端会一直配合后台做样式，结构处理，造成工作效率低下的问题"></a>在这个时候前后端的职责就是前端只做页面布局+js效果，写静态页面，将静态页面给后端作为模板，后端开始嵌套数据，这时候前后交互是前端需要协助后端做页面调试，前端会一直配合后台做样式，结构处理，造成工作效率低下的问题</h3><h2 id="全栈工程师"><a href="#全栈工程师" class="headerlink" title="全栈工程师"></a>全栈工程师</h2><h4 id="有了node的出现，前端也可以做数据库的操作呢，接口的开发，node开发接口一般用两个框架express。-koa-，数据库mysql-，mongdb-（CRUD-现在一般常用node做中间层处理【就是原有接口的转换】，node在企业开发中也会做一些提升开发效率的工具，node也可以用作桌面应用程序额的开发"><a href="#有了node的出现，前端也可以做数据库的操作呢，接口的开发，node开发接口一般用两个框架express。-koa-，数据库mysql-，mongdb-（CRUD-现在一般常用node做中间层处理【就是原有接口的转换】，node在企业开发中也会做一些提升开发效率的工具，node也可以用作桌面应用程序额的开发" class="headerlink" title="有了node的出现，前端也可以做数据库的操作呢，接口的开发，node开发接口一般用两个框架express。 koa ，数据库mysql ，mongdb （CRUD); 现在一般常用node做中间层处理【就是原有接口的转换】，node在企业开发中也会做一些提升开发效率的工具，node也可以用作桌面应用程序额的开发"></a>有了node的出现，前端也可以做数据库的操作呢，接口的开发，node开发接口一般用两个框架express。 koa ，数据库mysql ，mongdb （CRUD); 现在一般常用node做中间层处理【就是原有接口的转换】，node在企业开发中也会做一些提升开发效率的工具，node也可以用作桌面应用程序额的开发</h4><h2 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h2><h3 id="起源："><a href="#起源：" class="headerlink" title="起源："></a>起源：</h3><blockquote>
<p>REST这个词，是Roy Thomas Fielding在他2000年的博士论文中提出的。</p>
</blockquote>
<h3 id="名称："><a href="#名称：" class="headerlink" title="名称："></a>名称：</h3><blockquote>
<p>Fielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer的缩写（表现层状态转化）。</p>
</blockquote>
<h3 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h3><blockquote>
<p>RE:(表现层)：指的就是资源（把资源呈现出来就叫表现层）    </p>
<p>ST:(转态转换)：访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</p>
</blockquote>
<hr>
<blockquote>
<p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：</p>
</blockquote>
<pre><code>GET、POST、PUT、DELETE。
</code></pre>
<p>它们分别对应四种基本操作：</p>
<blockquote>
</blockquote>
<ul>
<li>GET用来获取资源，<blockquote>
</blockquote>
</li>
<li>POST用来新建资源（也可以用于更新资源），<blockquote>
</blockquote>
</li>
<li>PUT用来更新资源，<blockquote>
</blockquote>
</li>
<li>DELETE用来删除资源。</li>
</ul>
<h3 id="总结RESTful"><a href="#总结RESTful" class="headerlink" title="总结RESTful"></a>总结RESTful</h3><blockquote>
<p><strong>看Url就知道要什么</strong></p>
</blockquote>
<blockquote>
<p>** 看http method就知道干什么**</p>
<p><strong>看http status code就知道结果如何</strong></p>
</blockquote>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>前后端交互</tag>
        <tag>Restful</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex简单概述</title>
    <url>/2019/01/30/vuex/</url>
    <content><![CDATA[<h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><hr>
<h2 id="Vuex是什么？"><a href="#Vuex是什么？" class="headerlink" title="Vuex是什么？"></a>Vuex是什么？</h2><blockquote>
<p><strong>引入官方提供的解释，vuex 是专门为 vue.js 设计的一套 状态管理模式 。什么是状态管理模式？说白了就是数据的集中管理。我们在使用 vue.js 时所用到的数据全部抽取出来放在一个state对象下，这样我们在任何组件内都可以访问得到该数据。下面我们通过一个例子来看下 vuex 是如何管理我们的数据的。</strong></p>
</blockquote>
<h3 id="首先先通过npm来安装一下vuex："><a href="#首先先通过npm来安装一下vuex：" class="headerlink" title="首先先通过npm来安装一下vuex："></a>首先先通过npm来安装一下vuex：</h3><pre><code>npm install vuex --save
</code></pre>
<h2 id="state状态属性"><a href="#state状态属性" class="headerlink" title="state状态属性"></a>state状态属性</h2><h3 id="在项目src目录下新建一个store文件夹-该文件夹不是必须的，你也可以直接新建一个store-js，只要你引入的路径正确即可-，在该文件夹下新建一个-index-js。store文件夹主要是单独管理我们的数据状态，包括行为触发等等。"><a href="#在项目src目录下新建一个store文件夹-该文件夹不是必须的，你也可以直接新建一个store-js，只要你引入的路径正确即可-，在该文件夹下新建一个-index-js。store文件夹主要是单独管理我们的数据状态，包括行为触发等等。" class="headerlink" title="在项目src目录下新建一个store文件夹(该文件夹不是必须的，你也可以直接新建一个store.js，只要你引入的路径正确即可)，在该文件夹下新建一个 index.js。store文件夹主要是单独管理我们的数据状态，包括行为触发等等。"></a>在项目src目录下新建一个store文件夹(该文件夹不是必须的，你也可以直接新建一个store.js，只要你引入的路径正确即可)，在该文件夹下新建一个 index.js。store文件夹主要是单独管理我们的数据状态，包括行为触发等等。</h3><blockquote>
<h4 id="store-index-js"><a href="#store-index-js" class="headerlink" title="store/index.js"></a>store/index.js</h4></blockquote>
<pre><code>import Vue from &#39;vue&#39;
import Vuex from &#39;vuex&#39;
Vue.use(Vuex)
let store = new Vuex.Store(&#123;
    state: &#123;  //要设置的全局访问的state对象
        name: &quot;vuex&quot;
    &#125;
&#125;)

export default store
</code></pre>
<h3 id="为了能在所有的组件中共享我们的数据，我们有必要给根实例下注入我们的store对象，所以我们在main-js文件中"><a href="#为了能在所有的组件中共享我们的数据，我们有必要给根实例下注入我们的store对象，所以我们在main-js文件中" class="headerlink" title="为了能在所有的组件中共享我们的数据，我们有必要给根实例下注入我们的store对象，所以我们在main.js文件中"></a>为了能在所有的组件中共享我们的数据，我们有必要给根实例下注入我们的store对象，所以我们在main.js文件中</h3><blockquote>
<h4 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h4></blockquote>
<pre><code>import Vue from &#39;vue&#39;
import App from &#39;./App.vue&#39;
import &quot;./commcss/index.scss&quot;
import store from &#39;./store/index&#39;
new Vue(&#123;
  el: &#39;#app&#39;,
  render: h =&gt; h(App),
  store // 全局注册
&#125;)
</code></pre>
<blockquote>
<h4 id="App-vue"><a href="#App-vue" class="headerlink" title="App.vue"></a>App.vue</h4></blockquote>
<pre><code>&lt;template&gt;
      &lt;div class=&quot;app&quot;&gt;
        &#123;&#123;name&#125;&#125;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import &#123; mapState&#125; from &#39;vuex&#39;
/*
 *1.mapState 辅助函数
 *当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。
 *为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键：
 */
export default &#123;
  computde: &#123;
    ...mapState([&#39;name&#39;])
    &#125;
&#125;
&lt;/script&gt;
</code></pre>
<h2 id="Getter-store的计算属性，例如对列表进行过滤"><a href="#Getter-store的计算属性，例如对列表进行过滤" class="headerlink" title="Getter(store的计算属性，例如对列表进行过滤)"></a>Getter(store的计算属性，例如对列表进行过滤)</h2><blockquote>
<h4 id="store-index-js-1"><a href="#store-index-js-1" class="headerlink" title="store/index.js"></a>store/index.js</h4></blockquote>
<pre><code>state: &#123;
    count: 1,
    arr: [
      &#123;
        sex: &#39;男&#39;,
        id: 1
      &#125;,
      &#123;
        sex: &#39;男&#39;,
        id: 2
      &#125;,
      &#123;
        sex: &#39;男&#39;,
        id: 3
      &#125;,
      &#123;
        sex: &#39;男&#39;,
        id: 4
      &#125;,
      &#123;
        sex: &#39;女&#39;,
        id: 5
      &#125;,
      &#123;
        sex: &#39;男&#39;,
        id: 6
      &#125;,
      &#123;
        sex: &#39;男&#39;,
        id: 7
      &#125;
    ]
  &#125;,
getters: &#123;
    man (state) &#123;
      return state.arr.filter(item=&gt;&#123;return item.sex===&#39;男&#39;&#125;)
    &#125;
  &#125;,
</code></pre>
<blockquote>
<h4 id="App-vue-1"><a href="#App-vue-1" class="headerlink" title="App.vue"></a>App.vue</h4></blockquote>
<pre><code>&lt;template&gt;
      &lt;div class=&quot;app&quot;&gt;
        &lt;ul&gt;
            &lt;li v-for=&quot;(item,index) in man&quot; :key=&quot;item.id&quot;&gt;&#123;&#123;item.sex&#125;&#125;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import &#123; mapGetters &#125; from &#39;vuex&#39; //mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：
export default &#123;
  computde: &#123;
    ...mapGetters([&#39;man&#39;])
    &#125;
&#125;
&lt;/script&gt;
</code></pre>
<h2 id="mutation-更新state的唯一方法"><a href="#mutation-更新state的唯一方法" class="headerlink" title="mutation(更新state的唯一方法)"></a>mutation(更新state的唯一方法)</h2><blockquote>
<h4 id="store-index-js-2"><a href="#store-index-js-2" class="headerlink" title="store/index.js"></a>store/index.js</h4></blockquote>
<pre><code>mutation: &#123;
    change (state) &#123;
        state.name = &#39;vue&#39;
    &#125;
&#125;
</code></pre>
<blockquote>
<h4 id="App-vue-2"><a href="#App-vue-2" class="headerlink" title="App.vue"></a>App.vue</h4></blockquote>
<pre><code>&lt;template&gt;
      &lt;div class=&quot;app&quot; @click=&quot;change&quot;&gt;
        &#123;&#123;name&#125;&#125;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default &#123;
  method: &#123;
    change () &#123;
        this.$store.commit(&#39;change&#39;)
    &#125;
  &#125;
&#125;
&lt;/script&gt;    
</code></pre>
<h2 id="一条重要的原则就是要记住-mutation-必须是同步函数"><a href="#一条重要的原则就是要记住-mutation-必须是同步函数" class="headerlink" title="一条重要的原则就是要记住 mutation 必须是同步函数"></a>一条重要的原则就是要记住 mutation 必须是同步函数</h2><h3 id="原因：-为什么不能执行一步操作"><a href="#原因：-为什么不能执行一步操作" class="headerlink" title="原因：(为什么不能执行一步操作)"></a>原因：(为什么不能执行一步操作)</h3><blockquote>
<p><strong>现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。</strong></p>
</blockquote>
<h3 id="因此：【我们需要一个action来进行异步操作】"><a href="#因此：【我们需要一个action来进行异步操作】" class="headerlink" title="因此：【我们需要一个action来进行异步操作】"></a>因此：【我们需要一个action来进行异步操作】</h3><h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><h3 id="Action-类似于-mutation，不同在于："><a href="#Action-类似于-mutation，不同在于：" class="headerlink" title="Action 类似于 mutation，不同在于："></a>Action 类似于 mutation，不同在于：</h3><ul>
<li><strong>Action 提交的是 mutation，而不是直接变更状态。</strong></li>
<li><strong>Action 可以包含任意异步操作。</strong></li>
</ul>
<blockquote>
<h4 id="store-index-js-3"><a href="#store-index-js-3" class="headerlink" title="store/index.js"></a>store/index.js</h4></blockquote>
<pre><code>state: &#123;
    count: 0
&#125;,
mutations: &#123;
    addcount (state) &#123;
      state.count++
    &#125;
  &#125;,
actions: &#123;
    getInfo (context) &#123;
      setTimeout(()=&gt;&#123;
        context.commit(&#39;addcount&#39;)
      &#125;,2000)
    &#125;
  &#125;
</code></pre>
<blockquote>
<h4 id="App-vue-3"><a href="#App-vue-3" class="headerlink" title="App.vue"></a>App.vue</h4></blockquote>
<pre><code>&lt;template&gt;
      &lt;div class=&quot;app&quot; @click=&quot;change&quot;&gt;
        &#123;&#123;count&#125;&#125;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default &#123;
  computed: &#123;
    ...mapState([&#39;count&#39;])
  &#125;,
  method: &#123;
    change () &#123;
        this.$store.dispatch(&#39;getInfo&#39;)
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<h6 id="乍一眼看上去感觉多此一举，我们直接分发-mutation-岂不更方便？实际上并非如此，还记得-mutation-必须同步执行这个限制么？Action-就不受约束！我们可以在-action-内部执行异步操作："><a href="#乍一眼看上去感觉多此一举，我们直接分发-mutation-岂不更方便？实际上并非如此，还记得-mutation-必须同步执行这个限制么？Action-就不受约束！我们可以在-action-内部执行异步操作：" class="headerlink" title="乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 mutation 必须同步执行这个限制么？Action 就不受约束！我们可以在 action 内部执行异步操作："></a>乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 mutation 必须同步执行这个限制么？Action 就不受约束！我们可以在 action 内部执行异步操作：</h6><h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><h3 id="由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store-对象就有可能变得相当臃肿。"><a href="#由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store-对象就有可能变得相当臃肿。" class="headerlink" title="由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。"></a>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</h3><hr>
<h4 id="为了解决以上问题，Vuex-允许我们将-store-分割成模块（module）。每个模块拥有自己的-state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割："><a href="#为了解决以上问题，Vuex-允许我们将-store-分割成模块（module）。每个模块拥有自己的-state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：" class="headerlink" title="为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割："></a>为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</h4><p>首先创建module/todo.js</p>
<blockquote>
<p><strong>module/todo.js</strong></p>
</blockquote>
<pre><code>export default &#123;
  namespaced: true,
  state: &#123;
    count: 0
  &#125;,
  mutations: &#123;
    addcount (state) &#123;
      state.count++
    &#125;
  &#125;,
&#125;
</code></pre>
<blockquote>
<h4 id="store-index-js-4"><a href="#store-index-js-4" class="headerlink" title="store/index.js"></a>store/index.js</h4></blockquote>
<pre><code>import todo from &quot;./modules/todo&quot;

modules: &#123;
    todo
  &#125;
</code></pre>
<blockquote>
<h4 id="App-vue-4"><a href="#App-vue-4" class="headerlink" title="App.vue"></a>App.vue</h4></blockquote>
<pre><code>&lt;template&gt;
      &lt;div class=&quot;app&quot; @click=&quot;change&quot;&gt;
        &#123;&#123;count&#125;&#125;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default &#123;
  computed: &#123;
    ...mapState(&#39;todo&#39;,[&#39;count&#39;])
  &#125;,
  method: &#123;
    change () &#123;
        this.$store.commit(&#39;todo/addcount&#39;)
    &#125;
  &#125;
&#125;
&lt;/script&gt;    
</code></pre>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-router路由</title>
    <url>/2019/01/28/New%20Router/</url>
    <content><![CDATA[<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><h2 id="路由传参-query-params"><a href="#路由传参-query-params" class="headerlink" title="路由传参(query,params)"></a>路由传参(query,params)</h2><h4 id="在单页面应用中路由的传递方式常用的两种方法、-query-params"><a href="#在单页面应用中路由的传递方式常用的两种方法、-query-params" class="headerlink" title="在单页面应用中路由的传递方式常用的两种方法、(query,params)"></a>在单页面应用中路由的传递方式常用的两种方法、(query,params)</h4><blockquote>
<h3 id="query"><a href="#query" class="headerlink" title="query"></a>query</h3></blockquote>
<h4 id="包含在路径后面以？作为分割符，多参数直接使用-amp-分割开发，名字和值使用-分隔，这种方式适合传递不必须的值，传递和不传递都不会影响页面的加载"><a href="#包含在路径后面以？作为分割符，多参数直接使用-amp-分割开发，名字和值使用-分隔，这种方式适合传递不必须的值，传递和不传递都不会影响页面的加载" class="headerlink" title="包含在路径后面以？作为分割符，多参数直接使用&amp;分割开发，名字和值使用=分隔，这种方式适合传递不必须的值，传递和不传递都不会影响页面的加载"></a>包含在路径后面以？作为分割符，多参数直接使用&amp;分割开发，名字和值使用=分隔，这种方式适合传递不必须的值，传递和不传递都不会影响页面的加载</h4><blockquote>
<h3 id="params"><a href="#params" class="headerlink" title="params"></a>params</h3></blockquote>
<h4 id="包含在路由路径之中，这种方式是框架内部的参数传递实现的，这种方式适合传递必须传递的值-detail-id-detail-11213-可以出现在路径中的任何位置"><a href="#包含在路由路径之中，这种方式是框架内部的参数传递实现的，这种方式适合传递必须传递的值-detail-id-detail-11213-可以出现在路径中的任何位置" class="headerlink" title="包含在路由路径之中，这种方式是框架内部的参数传递实现的，这种方式适合传递必须传递的值(/detail/:id) (/detail/11213),可以出现在路径中的任何位置"></a>包含在路由路径之中，这种方式是框架内部的参数传递实现的，这种方式适合传递必须传递的值(/detail/:id) (/detail/11213),可以出现在路径中的任何位置</h4><blockquote>
<h3 id="如何获取-router"><a href="#如何获取-router" class="headerlink" title="如何获取($router)"></a>如何获取($router)</h3></blockquote>
<h4 id="在vue中路由参数通过，-route获取，-route-params获取params传递的参数，-route-query获取query传递的参数，而-route就是代表的是当前页面的路由信息对象"><a href="#在vue中路由参数通过，-route获取，-route-params获取params传递的参数，-route-query获取query传递的参数，而-route就是代表的是当前页面的路由信息对象" class="headerlink" title="在vue中路由参数通过，$route获取，$route.params获取params传递的参数，$route.query获取query传递的参数，而$route就是代表的是当前页面的路由信息对象"></a>在vue中路由参数通过，$route获取，$route.params获取params传递的参数，$route.query获取query传递的参数，而$route就是代表的是当前页面的路由信息对象</h4><p>###而$router是获取的是路由实例，$route只是$router中一个参数的指针而已（）</p>
<h2 id="常识："><a href="#常识：" class="headerlink" title="常识："></a>常识：</h2><ul>
<li><p><strong>1.router-link组件是用来跳转路由的，to属性是将要跳转的路由页地址。</strong></p>
</li>
<li><p><strong>2.router-view组件是用来展示组件页的。</strong></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>vue-router</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue构造器及其实例化概念</title>
    <url>/2019/01/28/vue%20extend/</url>
    <content><![CDATA[<h1 id="Vue构造器及其实例化概念"><a href="#Vue构造器及其实例化概念" class="headerlink" title="Vue构造器及其实例化概念"></a>Vue构造器及其实例化概念</h1><hr>
<h2 id="Vue构造器"><a href="#Vue构造器" class="headerlink" title="Vue构造器"></a>Vue构造器</h2><h2 id="附官方文档"><a href="#附官方文档" class="headerlink" title="附官方文档"></a><a class="link"   href="https://cn.vuejs.org/v2/api/#Vue-extend" >附官方文档<i class="fas fa-external-link-alt"></i></a></h2><blockquote>
<h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3></blockquote>
<h3 id="Vue-extend-options"><a href="#Vue-extend-options" class="headerlink" title="Vue.extend(options)"></a>Vue.extend(options)</h3><h4 id="参数-对象"><a href="#参数-对象" class="headerlink" title="参数: 对象"></a><strong>参数</strong>: 对象</h4><h4 id="用法-使用Vue构造器，创建一个“子类”，参数是一个包含组件选项的对象，其中-data选项中必须是函数"><a href="#用法-使用Vue构造器，创建一个“子类”，参数是一个包含组件选项的对象，其中-data选项中必须是函数" class="headerlink" title="用法: 使用Vue构造器，创建一个“子类”，参数是一个包含组件选项的对象，其中,data选项中必须是函数"></a><strong>用法</strong>: 使用Vue构造器，创建一个“子类”，参数是一个包含组件选项的对象，其中,data选项中必须是函数</h4><h4 id="描述：Vue-extend返回的是一个“扩展实例构造器”，也就是预设了部分选项的Vue的实例构造器，它常常服务于Vue-component用来生成组件，可以简单理解为当在模板中遇到该组件作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂在到自定义元素上"><a href="#描述：Vue-extend返回的是一个“扩展实例构造器”，也就是预设了部分选项的Vue的实例构造器，它常常服务于Vue-component用来生成组件，可以简单理解为当在模板中遇到该组件作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂在到自定义元素上" class="headerlink" title="描述：Vue.extend返回的是一个“扩展实例构造器”，也就是预设了部分选项的Vue的实例构造器，它常常服务于Vue.component用来生成组件，可以简单理解为当在模板中遇到该组件作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂在到自定义元素上"></a><strong>描述</strong>：Vue.extend返回的是一个“扩展实例构造器”，也就是预设了部分选项的Vue的实例构造器，它常常服务于Vue.component用来生成组件，可以简单理解为当在模板中遇到该组件作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂在到自定义元素上</h4><blockquote>
<h3 id="简单举例"><a href="#简单举例" class="headerlink" title="简单举例"></a>简单举例</h3></blockquote>
<h4 id="自定义无参数标签"><a href="#自定义无参数标签" class="headerlink" title="自定义无参数标签"></a>自定义无参数标签</h4><p>下面的代码中的author就是返回的“扩展实例构造器”</p>
<pre><code>var author = Vue.extend(&#123;
 template: &quot;&lt;p&gt;&lt;a :href=&#39;url&#39;&gt;&#123;&#123;author&#125;&#125;&lt;/a&gt;&lt;/p&gt;&quot;,
 data : function() &#123;
  return &#123;
   author : &#39;vamous&#39;,
   url : &#39;http://blog.csdn.net/Dear_Mr/article/details/72614370&#39;
  &#125;
 &#125;
&#125;);
</code></pre>
<p>###对应的html如下：</p>
<pre><code>&lt;author&gt;&lt;/author&gt;
</code></pre>
<h3 id="此时的页面必然是没有任何效果的，因为扩展实例构造器还需要挂载，如下"><a href="#此时的页面必然是没有任何效果的，因为扩展实例构造器还需要挂载，如下" class="headerlink" title="此时的页面必然是没有任何效果的，因为扩展实例构造器还需要挂载，如下"></a>此时的页面必然是没有任何效果的，因为扩展实例构造器还需要挂载，如下</h3><pre><code>new author().$mount(&#39;author&#39;);
</code></pre>
<h3 id="使用propsData"><a href="#使用propsData" class="headerlink" title="使用propsData"></a>使用propsData</h3><pre><code>var author = Vue.extend(&#123;
 template: &quot;&lt;p&gt;&lt;a :href=&#39;url&#39;&gt;&#123;&#123;author&#125;&#125; &amp; &#123;&#123;name&#125;&#125;&lt;/a&gt;&lt;/p&gt;&quot;,
 data : function() &#123;
  return &#123;
   author : &#39;vamous&#39;,
   url : &#39;http://blog.csdn.net/Dear_Mr/article/details/72614370&#39;
  &#125;
 &#125;,
 props : [&#39;name&#39;]
&#125;);
 
new author(&#123;propsData: &#123;name : &#39;dear_mr&#39;&#125;&#125;).$mount(&#39;#author&#39;);
</code></pre>
<h3 id="可以利用propsData传递参数"><a href="#可以利用propsData传递参数" class="headerlink" title="可以利用propsData传递参数"></a>可以利用propsData传递参数</h3><p><strong>挂载在普通标签上</strong></p>
<p>返回的扩展实例构造器的方式和上面还是一样的，只是html里不再是自定义标签，而是一个普通标签，比如div</p>
<pre><code>&lt;div id=&quot;author&quot;&gt;&lt;/div&gt;

new author().$mount(&#39;author&#39;);
</code></pre>
<p>其实对于同一个扩展构造器而言，它的每一个实例其实是可以挂载到不同的标签上的，比如我可以这样</p>
<pre><code>new author().$mount(&#39;#author&#39;);

new author().$mount(&#39;author&#39;);
</code></pre>
<p>这两个标签的内容会一同显示，结果一样</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p><strong>Vue。extend(object)//扩展的子类需要Vue实例化才能使用，如果需要传递props，需要在new的时候通过propsData传递</strong></p>
</blockquote>
<hr>
<blockquote>
<p>$mount()手动执行组件的渲染，如果传递一个选择器，就会渲染选择器内部，如果传递只会生成dom不会执行渲染，需要手动将el挂载到页面</p>
</blockquote>
<hr>
<blockquote>
<p><strong>$destroy()手动销毁组件，但是如果将dom移动将不会销毁dom，需要手动销毁</strong></p>
</blockquote>
<hr>
<blockquote>
<p><strong>$nextTick()生命周期updated的替代方案，因为在updated中只是得知组件需要重新渲染，但并不知道是哪个属性改变了，而nextTick()当属性改变并且渲染完成的回调，类似于react中的setState的回调函数</strong></p>
</blockquote>
<hr>
<pre><code>适用场景

使用扩展子类方式创建的组件适合开发使用api的方法调用
</code></pre>
<h2 id="以上就是对Vue-extend构造器的实例详解"><a href="#以上就是对Vue-extend构造器的实例详解" class="headerlink" title="以上就是对Vue.extend构造器的实例详解"></a>以上就是对Vue.extend构造器的实例详解</h2>]]></content>
      <tags>
        <tag>vue</tag>
        <tag>vue构造器</tag>
        <tag>vue extend</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Vue全局的扩展</title>
    <url>/2019/01/28/vue%20block/</url>
    <content><![CDATA[<h1 id="关于Vue全局的扩展"><a href="#关于Vue全局的扩展" class="headerlink" title="关于Vue全局的扩展"></a>关于Vue全局的扩展</h1><hr>
<h2 id="Vue的全局组件"><a href="#Vue的全局组件" class="headerlink" title="Vue的全局组件"></a>Vue的全局组件</h2><h3 id="我们平时使用组件，需要经过引入，绑定两个步骤。那么，如果我们需要使用一些全局组件或者第三方的组件库怎么办呢？"><a href="#我们平时使用组件，需要经过引入，绑定两个步骤。那么，如果我们需要使用一些全局组件或者第三方的组件库怎么办呢？" class="headerlink" title="我们平时使用组件，需要经过引入，绑定两个步骤。那么，如果我们需要使用一些全局组件或者第三方的组件库怎么办呢？"></a>我们平时使用组件，需要经过引入，绑定两个步骤。那么，如果我们需要使用一些全局组件或者第三方的组件库怎么办呢？</h3><h4 id="在Vue官方文档中介绍的是使用Vue-component-tagName-options-来创建一个全局组件。但是这种方法是与根实例写在同一个文件中，如果要同时注册多个全局组件，就会使根实例文件过重，因此使用Vue-use-来“安装”全局组件，就显得更轻一些。"><a href="#在Vue官方文档中介绍的是使用Vue-component-tagName-options-来创建一个全局组件。但是这种方法是与根实例写在同一个文件中，如果要同时注册多个全局组件，就会使根实例文件过重，因此使用Vue-use-来“安装”全局组件，就显得更轻一些。" class="headerlink" title="在Vue官方文档中介绍的是使用Vue.component(tagName, options)来创建一个全局组件。但是这种方法是与根实例写在同一个文件中，如果要同时注册多个全局组件，就会使根实例文件过重，因此使用Vue.use()来“安装”全局组件，就显得更轻一些。"></a>在Vue官方文档中介绍的是使用Vue.component(tagName, options)来创建一个全局组件。但是这种方法是与根实例写在同一个文件中，如果要同时注册多个全局组件，就会使根实例文件过重，因此使用Vue.use()来“安装”全局组件，就显得更轻一些。</h4><h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><ul>
<li>1.新建一个plugins文件夹 </li>
<li>2.在文件夹中创建放置全局组件的文件components.js </li>
<li>3.在components.js文件中引入所有要注册的全局组件 </li>
<li>4.在app.js根实例文件中，引入components.js</li>
</ul>
<h3 id="以login组件为例"><a href="#以login组件为例" class="headerlink" title="以login组件为例"></a>以login组件为例</h3><h3 id="login-js"><a href="#login-js" class="headerlink" title="login.js"></a>login.js</h3><pre><code>import Login from &#39;../components/eg.vue&#39;;
export default (Vue)=&gt;&#123;
    Vue.component(&quot;Login&quot;,Login);
&#125;
</code></pre>
<h3 id="app-js"><a href="#app-js" class="headerlink" title="app.js"></a>app.js</h3><pre><code>import components from &#39;./plugins/components.js&#39;;
Vue.use(components);
</code></pre>
<h3 id="经过上述编写后，就注册了全局组件Login。"><a href="#经过上述编写后，就注册了全局组件Login。" class="headerlink" title="经过上述编写后，就注册了全局组件Login。"></a>经过上述编写后，就注册了全局组件Login。</h3><h2 id="Vue全局指令"><a href="#Vue全局指令" class="headerlink" title="Vue全局指令"></a>Vue全局指令</h2><h3 id="对于全局指令的注册，官方文档给出的方法是使用Vue-directive-，位置同样是在根实例文件下，那么问题来了，如果多个全局指令，再加上多个全局组件，那么app-js文件将变得臃肿无比。"><a href="#对于全局指令的注册，官方文档给出的方法是使用Vue-directive-，位置同样是在根实例文件下，那么问题来了，如果多个全局指令，再加上多个全局组件，那么app-js文件将变得臃肿无比。" class="headerlink" title="对于全局指令的注册，官方文档给出的方法是使用Vue.directive()，位置同样是在根实例文件下，那么问题来了，如果多个全局指令，再加上多个全局组件，那么app.js文件将变得臃肿无比。"></a>对于全局指令的注册，官方文档给出的方法是使用Vue.directive()，位置同样是在根实例文件下，那么问题来了，如果多个全局指令，再加上多个全局组件，那么app.js文件将变得臃肿无比。</h3><h4 id="因此，同上面的注册全局组件方法相似，也是使用Vue-use-来“安装”全局指令。"><a href="#因此，同上面的注册全局组件方法相似，也是使用Vue-use-来“安装”全局指令。" class="headerlink" title="因此，同上面的注册全局组件方法相似，也是使用Vue.use()来“安装”全局指令。"></a>因此，同上面的注册全局组件方法相似，也是使用Vue.use()来“安装”全局指令。</h4><h4 id="方法：-1"><a href="#方法：-1" class="headerlink" title="方法："></a>方法：</h4><ul>
<li>1.新建一个plugins文件夹 </li>
<li>2.在文件夹中创建放置全局组件的文件directives.js </li>
<li>3.在directives.js文件中引入所有要注册的全局指令 </li>
<li>4.在app.js根实例文件中，引入directives.js</li>
</ul>
<h4 id="以v-focus指令为例："><a href="#以v-focus指令为例：" class="headerlink" title="以v-focus指令为例："></a>以v-focus指令为例：</h4><h4 id="directives-js"><a href="#directives-js" class="headerlink" title="directives.js:"></a>directives.js:</h4><pre><code>    export default (Vue)=&gt;&#123;
        Vue.directive(&quot;focus&quot;,&#123;
            inserted:function(el)&#123;
                el.focus();
            &#125;
        &#125;)
    &#125;
</code></pre>
<h4 id="app-js-1"><a href="#app-js-1" class="headerlink" title="app.js"></a>app.js</h4><pre><code>import directives from &quot;./plugins/directives.js&quot;
Vue.use(directives);
</code></pre>
<h3 id="这样就注册了全局指令"><a href="#这样就注册了全局指令" class="headerlink" title="这样就注册了全局指令"></a>这样就注册了全局指令</h3><h2 id="扩展Vue类方法"><a href="#扩展Vue类方法" class="headerlink" title="扩展Vue类方法"></a>扩展Vue类方法</h2><h3 id="很简单再此不做更多描述…"><a href="#很简单再此不做更多描述…" class="headerlink" title="很简单再此不做更多描述….."></a>很简单再此不做更多描述…..</h3><h4 id="直接看代码。》-。"><a href="#直接看代码。》-。" class="headerlink" title="直接看代码。》 。"></a>直接看代码。》 。</h4><pre><code>Vue.coke = function () &#123;
    console.log(&quot;扩展了coke类方法&quot;)
&#125;
</code></pre>
<h3 id="简单吧！！！！！"><a href="#简单吧！！！！！" class="headerlink" title="简单吧！！！！！"></a>简单吧！！！！！</h3><h2 id="扩展Vue原型，在vue组件中就可以通过this来访问"><a href="#扩展Vue原型，在vue组件中就可以通过this来访问" class="headerlink" title="扩展Vue原型，在vue组件中就可以通过this来访问"></a>扩展Vue原型，在vue组件中就可以通过this来访问</h2><h3 id="废话不多说上代码"><a href="#废话不多说上代码" class="headerlink" title="废话不多说上代码"></a>废话不多说上代码</h3><pre><code>Vue.prototype.$api = function () &#123;
    console.log(&quot;扩展了$api方法&quot;)
&#125;
</code></pre>
<h3 id="………………"><a href="#………………" class="headerlink" title="………………."></a>……………….</h3><h2 id="Vue过滤器"><a href="#Vue过滤器" class="headerlink" title="Vue过滤器"></a>Vue过滤器</h2><h3 id="Vue-js允许自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和v-bind表达式。过滤器应该被添加在JavaScript表达式的尾部，由“管道”符号指示："><a href="#Vue-js允许自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和v-bind表达式。过滤器应该被添加在JavaScript表达式的尾部，由“管道”符号指示：" class="headerlink" title="Vue.js允许自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和v-bind表达式。过滤器应该被添加在JavaScript表达式的尾部，由“管道”符号指示：|"></a>Vue.js允许自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和v-bind表达式。过滤器应该被添加在JavaScript表达式的尾部，由“管道”符号指示：|</h3><pre><code>&lt;!-- 在双花括号中 --&gt;
&#123;&#123; message | capitalize &#125;&#125;

&lt;!-- 在 `v-bind` 中 --&gt;
&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;
</code></pre>
<h3 id="可以在一个组件的选项中定义本地的过滤器："><a href="#可以在一个组件的选项中定义本地的过滤器：" class="headerlink" title="可以在一个组件的选项中定义本地的过滤器："></a>可以在一个组件的选项中定义本地的过滤器：</h3><h3 id="以截取手机为例"><a href="#以截取手机为例" class="headerlink" title="以截取手机为例"></a>以截取手机为例</h3><pre><code>filters: &#123;
      phones (num) &#123;
        let phoneStr = num.toString()
        let res = /(\d&#123;1,&#125;)(\d&#123;4&#125;)/
        while (reg.test(phoneStr.replace)) &#123;
            phoneStr = phoneStr.replace(reg, &#39;$1-$2&#39;)
        &#125;
        return phoneStr
    &#125;
&#125;


//调用

&#123;&#123;17603446842 | phones&#125;&#125;

//返回结果

176-0344-6842
</code></pre>
<h3 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h3><pre><code>Vue.filter(&quot;phones&quot;,function(num)&#123;
      let phoneStr = num.toString()
    let res = /(\d&#123;1,&#125;)(\d&#123;4&#125;)/
    while (reg.test(phoneStr.replace)) &#123;
        phoneStr = phoneStr.replace(reg, &#39;$1-$2&#39;)
    &#125;
    return phoneStr
&#125;)
</code></pre>
<h3 id="来吧，举一个实用一点的例子"><a href="#来吧，举一个实用一点的例子" class="headerlink" title="来吧，举一个实用一点的例子"></a>来吧，举一个实用一点的例子</h3><h3 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h3><pre><code>var app5 = new Vue(&#123;
    el: &#39;#app5&#39;,
    data: &#123;
        shoppingList: [
            &quot;Milk&quot;, &quot;Donuts&quot;, &quot;Cookies&quot;, &quot;Chocolate&quot;, &quot;Peanut Butter&quot;, &quot;Pepto Bismol&quot;, &quot;Pepto Bismol (Chocolate flavor)&quot;, &quot;Pepto Bismol (Cookie flavor)&quot;
        ],
        key: &quot;&quot;
    &#125;,
    computed: &#123;
        filterShoppingList: function () &#123;
            // `this` points to the vm instance
            var key = this.key;
            var shoppingList = this.shoppingList;
            //在使用filter时需要注意的是，前面调用的是需要使用filter的数组，而给filter函数传入的是数组中的每个item，也就是说filter里面的函数，是每个item要去做的，并将每个结果返回。
            return shoppingList.filter(function (item) &#123;
                return item.toLowerCase().indexOf(key.toLowerCase()) != -1
            &#125;);;
        &#125;
    &#125;
&#125;)
</code></pre>
<h3 id="template"><a href="#template" class="headerlink" title="template"></a>template</h3><pre><code>    &lt;ul&gt;
        Filter Key
        &lt;input type=&quot;text&quot; v-model=&quot;key&quot;&gt;   
           &lt;li v-for=&quot;item in filterShoppingList&quot;&gt;
           &#123;&#123; item &#125;&#125;
           &lt;/li&gt;
       &lt;/ul&gt; 
</code></pre>
<h3 id="最终效果实现了根据关键字来过滤列表的功能。"><a href="#最终效果实现了根据关键字来过滤列表的功能。" class="headerlink" title="最终效果实现了根据关键字来过滤列表的功能。"></a>最终效果实现了根据关键字来过滤列表的功能。</h3>]]></content>
      <tags>
        <tag>vue</tag>
        <tag>vue全局组件</tag>
        <tag>vue指令</tag>
        <tag>vue过滤器</tag>
        <tag>directive</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue transfrom属性</title>
    <url>/2019/01/27/transition/</url>
    <content><![CDATA[<h1 id="Vue-transfrom属性"><a href="#Vue-transfrom属性" class="headerlink" title="Vue transfrom属性"></a>Vue transfrom属性</h1><h2 id="vue中的动画可以使用transfrom组件完成"><a href="#vue中的动画可以使用transfrom组件完成" class="headerlink" title="vue中的动画可以使用transfrom组件完成"></a>vue中的动画可以使用transfrom组件完成</h2><h3 id="transfrom组件提供两个过渡状态"><a href="#transfrom组件提供两个过渡状态" class="headerlink" title="transfrom组件提供两个过渡状态"></a>transfrom组件提供两个过渡状态</h3><blockquote>
<p>进入 enter</p>
</blockquote>
<blockquote>
<p>离开 leave</p>
</blockquote>
<h3 id="每个状态有三个步骤【自动添加类名-v代表的是transfrom组件上的name属性指定的值】"><a href="#每个状态有三个步骤【自动添加类名-v代表的是transfrom组件上的name属性指定的值】" class="headerlink" title="每个状态有三个步骤【自动添加类名 v代表的是transfrom组件上的name属性指定的值】"></a>每个状态有三个步骤【自动添加类名 v代表的是transfrom组件上的name属性指定的值】</h3><ul>
<li>v-enter v-enter-active v-enter-to</li>
<li>v-leave v-leave-active v-leave-to</li>
</ul>
<blockquote>
<h3 id="通过结合css过渡动画和关键帧动画可以实现切换动画"><a href="#通过结合css过渡动画和关键帧动画可以实现切换动画" class="headerlink" title="通过结合css过渡动画和关键帧动画可以实现切换动画"></a>通过结合css过渡动画和关键帧动画可以实现切换动画</h3></blockquote>
<h3 id="动画触发场景"><a href="#动画触发场景" class="headerlink" title="动画触发场景"></a>动画触发场景</h3><ol>
<li>跟组件初始化渲染</li>
<li>v-show，v-if，component动态组件切换的时候</li>
<li>router-view 路由切换的时候</li>
</ol>
<h3 id="transfrom-组件还可以通过属性去改变不同状态自动添加的class类名"><a href="#transfrom-组件还可以通过属性去改变不同状态自动添加的class类名" class="headerlink" title="transfrom 组件还可以通过属性去改变不同状态自动添加的class类名"></a>transfrom 组件还可以通过属性去改变不同状态自动添加的class类名</h3><ul>
<li>enter-active-class=”animated slideInDown”</li>
<li>leave-active-class=”animated bounceOutDown”</li>
</ul>
<h3 id="这种方式适合配合第三方动画库实现动画"><a href="#这种方式适合配合第三方动画库实现动画" class="headerlink" title="这种方式适合配合第三方动画库实现动画"></a>这种方式适合配合第三方动画库实现动画</h3><pre><code>&lt;transition
v-on:before-enter=&quot;berforeEnter&quot;            //可以做一些初始化样式设置
v-on:enter=&quot;enter&quot;                            //执行js操作dom完成的动画效果
v-on:after-enter=&quot;afterEnter&quot;                //动画执行结束（也就是在enter中调用了done函数）
v-on:enter-cancelled=&quot;enterCancelled&quot;        动画还没有结束，就执行下一次动画了，这时候不会触发动画结束，而是触发这个时间（取消）
v-on:before-leave=&quot;beforeLeave&quot;
v-on:leave=&quot;leave&quot;
v-on:after-leave=&quot;afterLeave&quot;
v-on:leave-cancelled=&quot;leaveCancelled&quot;    
&gt;
&lt;!--...--&gt;
&lt;/transition&gt;
</code></pre>
]]></content>
      <tags>
        <tag>vue</tag>
        <tag>transfrom</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中的Dom操作</title>
    <url>/2019/01/27/vue-dom/</url>
    <content><![CDATA[<h2 id="vue中的Dom操作"><a href="#vue中的Dom操作" class="headerlink" title="vue中的Dom操作"></a>vue中的Dom操作</h2><h3 id="在vue，react，。。。。以数据驱动视图的框架，都是通过数据更新视图，一般不使用dom操作，但是也有一些特定的时候需要用到dom操作"><a href="#在vue，react，。。。。以数据驱动视图的框架，都是通过数据更新视图，一般不使用dom操作，但是也有一些特定的时候需要用到dom操作" class="headerlink" title="在vue，react，。。。。以数据驱动视图的框架，都是通过数据更新视图，一般不使用dom操作，但是也有一些特定的时候需要用到dom操作"></a>在vue，react，。。。。以数据驱动视图的框架，都是通过数据更新视图，一般不使用dom操作，但是也有一些特定的时候需要用到dom操作</h3><h2 id="dom操作的方法"><a href="#dom操作的方法" class="headerlink" title="dom操作的方法"></a>dom操作的方法</h2><hr>
<blockquote>
</blockquote>
<ol>
<li>transition:组件中的钩子函数可以接受一个el属性，作用动画的dom，可以多dom添加实现动画效果</li>
<li>ref：ref可以作用在dom元素和组件元素上，作用在dom元素上通过refs获取到就是dom节点，作用在组件元素上获取到组件实例</li>
<li>在mounted生命周期中我们可以使用document的dom的操作方法，比如添加一些滚动事件…</li>
<li>#el：可以获取组件的根节点元素</li>
<li>￥mount()：可以手动渲染组件，成为真实的dom节点</li>
<li>事件中的e.target可以获取都绑定事件的dom，但不准确，因为获取到的是点击最内层的元素，当然如果作用在表单元素就无所谓</li>
<li>指令也可以操作dom的<blockquote>
</blockquote>
</li>
</ol>
<hr>
]]></content>
      <tags>
        <tag>vue</tag>
        <tag>dom</tag>
      </tags>
  </entry>
  <entry>
    <title>知识点总汇</title>
    <url>/2019/01/25/all/</url>
    <content><![CDATA[<h2 id="react-总汇图片查看"><a href="#react-总汇图片查看" class="headerlink" title="react 总汇图片查看"></a>react 总汇图片查看</h2><h3 id="下载下来进行查看"><a href="#下载下来进行查看" class="headerlink" title="下载下来进行查看 ********"></a>下载下来进行查看 <strong>**</strong>****<strong>**</strong></h3><blockquote>
<p><strong><a class="link"   href="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/react.png" >react 知识点总汇图片查看<i class="fas fa-external-link-alt"></i></a></strong></p>
</blockquote>
<h2 id="js-基本知识总汇图片查看"><a href="#js-基本知识总汇图片查看" class="headerlink" title="js 基本知识总汇图片查看"></a>js 基本知识总汇图片查看</h2><h3 id="下载下来进行查看-1"><a href="#下载下来进行查看-1" class="headerlink" title="下载下来进行查看 ********"></a>下载下来进行查看 <strong>**</strong>****<strong>**</strong></h3><blockquote>
<p><strong><a class="link"   href="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/js.png" >js 基本知识总汇图片查看<i class="fas fa-external-link-alt"></i></a></strong></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>代码整洁之道：程序员的职业素养</title>
    <url>/2019/01/25/index/</url>
    <content><![CDATA[<hr>
<h1 id="代码整洁之道：程序员的职业素养"><a href="#代码整洁之道：程序员的职业素养" class="headerlink" title="代码整洁之道：程序员的职业素养"></a>代码整洁之道：程序员的职业素养</h1><hr>
<blockquote>
<p>我们并非是因为喜欢和其他人在一起工作才选择做程序员的。我们都认为人际关系难以应付而且毫无规律。编程用的机器则整洁，行为也可预见。如果可以一个人待在房间里数个小时沉浸在一些真正有趣的问题上，那将会是最开心的时光。</p>
</blockquote>
<hr>
<blockquote>
<p><strong>以下全部内容均为本人 2019 年读书过程中所喜欢或者有感触的片段的摘录，来自于不同的书目，每本书标注了书名，书籍排序仅仅是阅读顺序（倒时间顺序），版权归原作者所有，这里仅作摘录整理。</strong></p>
</blockquote>
<h1 id="阿加莎·克里斯蒂的真实人生"><a href="#阿加莎·克里斯蒂的真实人生" class="headerlink" title="阿加莎·克里斯蒂的真实人生"></a>阿加莎·克里斯蒂的真实人生</h1><hr>
<blockquote>
<p>你无法创作命运，命运会不请自来，就是这么回事。<br>人人都做梦，但他们的梦不一样。<br>那些夜里在脏兮兮的脑袋瓜里做梦的人，<br>白天一觉醒来发现不过是虚幻一场；<br>要小心那些在白天做梦的人，<br>因为他们会睁大眼睛做梦，<br>用行动让梦想变成现实。<br>天真是一种罪过，冷漠是一种爱。律师以为自己操纵着游戏，但不过是他想加害的人手中的玩偶。</p>
</blockquote>
<hr>
<h1 id="牧羊少年奇幻之旅"><a href="#牧羊少年奇幻之旅" class="headerlink" title="牧羊少年奇幻之旅"></a>牧羊少年奇幻之旅</h1><hr>
<blockquote>
<p>不管是牧羊人、海员，还是推销员，总会有一个地方令他们魂牵梦萦，那里会有一个人让他们忘记自由自在周游世界的快乐。<br>当总是面对同样的面孔，像在神学院里那样，就会渐渐让那些人成为生活的一部分。而由于他们是你生活的一部分，当然就想改变你的生活。如果你不像他们所期望的那样，他们就会不高兴。因为，对于该怎样生活，所有人都有固定的观念。但是他们对于自己该怎样生活却一头雾水，就像那个给人解梦、却不会把梦变成现实的老妇人。<br>男孩心想，人总会说一些刁钻古怪的事情。有的时候，最好与羊群为伴，羊群不声不响，只顾吃草和水晶。与书为伴也行，书总是在人们最想听故事的时候，告诉你一些意想不到的事情。但是，当人与人交谈的时候，有些人说的话会让我们无所适从，不知该怎样把谈话继续下去。<br>「天命就是你一直期望去做的事情。人一旦步入青年时期，就知道什么是自己的天命了。在人生的这个阶段，一切都那么明朗，没有做不到的事情。人们敢于梦想，期待完成他们一生中喜欢做的一切事情。但是，随着时光的流逝，一股神秘的力量开始企图证明，根本不可能实现天命。」<br>实际上，每天都一成不变，是因为人们已经失去了对美好事物的敏锐感觉。<br>我和别人没什么两样：总是以理想的眼光看待世界，以为事情会按理想的方式发展，而不会用现实的眼光看待世界，看不到事情真相。<br>「因为麦加是支撑我活下去的希望，使我能够忍受平庸的岁月，忍受橱柜里那些不会说话的水晶，忍受那间糟糕透顶的餐厅里的午饭和晚饭。我害怕实现我的梦想，实现之后，我就没有活下去的动力了。」<br>「你的梦想是羊群和金字塔。你与我不同，因为你希望实现你的梦想，而我只是想保有去麦加的梦想。我曾无数次地想象过，如何穿过沙漠，到达安放着圣石的广场，在触摸圣石之前，围着它绕行七圈。我曾想象过有些人站在我身旁，有些人站在我前面，还有我们的谈话和共同的祈祷。可是，我担心会大失所望，所以我宁愿只保留一个梦想。」<br>「你一度成为我的福音。而今天我明白了一个道理，任何不被接纳的福音，都会变成诅咒。我对生活没有更多的要求。而你正迫使我盯着从未见过的财富和前景。现在，我知道了这些财富和前景，也知道了我完全有可能拥有它们。可是我的感觉却比以前糟糕了。因为我知道我自己可以拥有这一切，却不愿拥有它们。」<br>别的事情不好说，但在这件事上，男孩坚信不疑，尽管他的父母以及先辈都说过，必须在恋爱、订婚、相互了解和有了钱之后才可以结婚。说这话的人大概从来不了解宇宙的语言，因为如果掌握了这种语言，很容易就能理解，世上总有人在等待着另外一个人，无论是在大沙漠还是在大城市。当这两个人最终相遇，四目相对的时候，过去的一切和将来的一切全都变得无足轻重了，只有眼前的这一刻最重要。<br>因为生活永远是，也仅仅是我们现在经历的这一刻。<br>这正是需要爱发挥力量的地方，因为当我们有爱的时候，总是希望自己变得更好。</p>
</blockquote>
<hr>
<h1 id="且听风吟"><a href="#且听风吟" class="headerlink" title="且听风吟"></a>且听风吟</h1><hr>
<blockquote>
<p>说到底，写文章并非自我诊治的手段，充其量不过是自我疗养的一种小小的尝试。<br>问题是，直言不讳是件极为困难的事。甚至越是想直言不讳，直率的言语越是遁入黑暗的深处。<br>死去的祖母常说「心情抑郁的人只能做抑郁的梦，要是更加抑郁的，连梦都不做的。」<br>如果你志在追求艺术追求文学，那么去读一读希腊人写的东西好了。因为要诞生真正的艺术，奴隶制度是必不可少的。而古希腊人便是这样：奴隶们耕种、烧饭、划船，而市民们则在地中海的阳光下陶醉于吟诗作赋，埋头于数学解析。所谓艺术便是这么一种玩意儿。<br>至于半夜三点半在悄无声息的厨房寻找电冰箱里的食品的人，只能写出这等模样的文章。<br>而那就是我。<br>「我时常想：假如活着不给任何人添麻烦该有多好！你说能做到吗？」<br>「怎么说呢，大概因为厌烦了吧。可我也在尽我的努力——就连自己都难以置信。我也在考虑别人，像考虑自己的事一样，也因此挨过警察的揍。但到时候人们终究要各归其位，唯独我无处可归，就像玩『抢椅子』游戏没了椅子。」<br>「不过你认真想想看：条件大伙都一样，就像同坐一架出了故障的飞机。诚然，有的运气好些，有的运气差些，有的坚强些有的懦弱些，有的有钱有的没钱。但没有一个家伙怀有超乎常人的自信，大家一个样，拥有什么的家伙生怕一旦失去，一无所有的家伙担心永远一无所有，大家一个样。所以，早些察觉到这一点的人 应该力争使自己多少怀有自信，哪怕装模做样也好，对吧？什么自信之人，那样的人根本没有，有的不过是能够装出自信的人。」<br>「把谁都知道的事写成小说，那究竟有何意味可言？」<br>我有时说谎。<br>最后一次说谎是在去年。<br>说谎是非常令人讨厌的勾当。不妨说，说谎与沉默是现代人类中流行的两大罪过。我们实际上经常说谎，也往往沉默不语。<br>然而，倘若我们一年四季都喋喋不休，而且喋喋不休的无不真实，那么真实的价值必然荡然无存。</p>
</blockquote>
<hr>
<h1 id="超能力侦探事务所"><a href="#超能力侦探事务所" class="headerlink" title="超能力侦探事务所"></a>超能力侦探事务所</h1><hr>
<blockquote>
<p>和事件无关的人，只要时间够久，或有新的事件发生，就会很快忘记过往的事。<br>世界上永远没有「感同身受」这件事，因为没有亲身经历，无法体会到当事人的痛苦。</p>
</blockquote>
<hr>
]]></content>
  </entry>
  <entry>
    <title>px2rem 移动端自适应方案</title>
    <url>/2019/01/25/px2rem/</url>
    <content><![CDATA[<hr>
<p>1/25/2019 4:36:42 PM</p>
<hr>
<h1 id="px2rem"><a href="#px2rem" class="headerlink" title="px2rem"></a>px2rem</h1><h2 id="vue-cli中如何使用px2rem"><a href="#vue-cli中如何使用px2rem" class="headerlink" title="vue-cli中如何使用px2rem"></a>vue-cli中如何使用px2rem</h2><h3 id="实际开发中，我们通过设计稿得到的值单位是-px，所以要将-px-转换成-rem-再写进样式中。将-px-转换成-rem-我们将使用-px2rem-这个工具，它有-webpack-的-loader：px2rem-loader"><a href="#实际开发中，我们通过设计稿得到的值单位是-px，所以要将-px-转换成-rem-再写进样式中。将-px-转换成-rem-我们将使用-px2rem-这个工具，它有-webpack-的-loader：px2rem-loader" class="headerlink" title="实际开发中，我们通过设计稿得到的值单位是 px，所以要将 px 转换成 rem 再写进样式中。将 px 转换成 rem 我们将使用 px2rem 这个工具，它有 webpack 的 loader：px2rem-loader"></a>实际开发中，我们通过设计稿得到的值单位是 px，所以要将 px 转换成 rem 再写进样式中。将 px 转换成 rem 我们将使用 px2rem 这个工具，它有 webpack 的 loader：px2rem-loader</h3><h2 id="安装-px2rem-loader"><a href="#安装-px2rem-loader" class="headerlink" title="安装 px2rem-loader"></a>安装 px2rem-loader</h2><h3 id="在命令行中运行如下安装："><a href="#在命令行中运行如下安装：" class="headerlink" title="在命令行中运行如下安装："></a>在命令行中运行如下安装：</h3><pre><code>npm i px2rem-loader --save-dev
</code></pre>
<h2 id="配置-px2rem-loader"><a href="#配置-px2rem-loader" class="headerlink" title="配置 px2rem-loader"></a>配置 px2rem-loader</h2><p>1/25/2019 4:36:17 PM </p>
<h3 id="在-vue-cli-生成的-webpack-配置中，vue-loader-的-options-和其他样式文件-loader-最终是都是由-build-utils-js-里的一个方法生成的。"><a href="#在-vue-cli-生成的-webpack-配置中，vue-loader-的-options-和其他样式文件-loader-最终是都是由-build-utils-js-里的一个方法生成的。" class="headerlink" title="在 vue-cli 生成的 webpack 配置中，vue-loader 的 options 和其他样式文件 loader 最终是都是由 build/utils.js 里的一个方法生成的。"></a>在 vue-cli 生成的 webpack 配置中，vue-loader 的 options 和其他样式文件 loader 最终是都是由 build/utils.js 里的一个方法生成的。</h3><h3 id="我们只需在-cssLoader-后再加上一个-px2remLoader-即可，px2rem-loader-的-remUnit-选项意思是-1rem-多少像素，结合-lib-flexible-的方案，我们将-px2remLoader-的-options-remUnit-设置成设计稿宽度的-1-10，这里我们假设设计稿宽为-750px。"><a href="#我们只需在-cssLoader-后再加上一个-px2remLoader-即可，px2rem-loader-的-remUnit-选项意思是-1rem-多少像素，结合-lib-flexible-的方案，我们将-px2remLoader-的-options-remUnit-设置成设计稿宽度的-1-10，这里我们假设设计稿宽为-750px。" class="headerlink" title="我们只需在 cssLoader 后再加上一个 px2remLoader 即可，px2rem-loader 的 remUnit 选项意思是 1rem=多少像素，结合 lib-flexible 的方案，我们将 px2remLoader 的 options.remUnit 设置成设计稿宽度的 1/10，这里我们假设设计稿宽为 750px。"></a>我们只需在 cssLoader 后再加上一个 px2remLoader 即可，px2rem-loader 的 remUnit 选项意思是 1rem=多少像素，结合 lib-flexible 的方案，我们将 px2remLoader 的 options.remUnit 设置成设计稿宽度的 1/10，这里我们假设设计稿宽为 750px。</h3><pre><code>// utils.js
var cssLoader = &#123;
loader: &#39;css-loader&#39;,
    options: &#123;
    sourceMap: options.sourceMap
  &#125;
&#125;
var px2remLoader = &#123;
loader: &#39;px2rem-loader&#39;,
    options: &#123;
    remUnit: 75
  &#125;
&#125;
</code></pre>
<h2 id="并放进-loaders-数组中"><a href="#并放进-loaders-数组中" class="headerlink" title="并放进 loaders 数组中"></a>并放进 loaders 数组中</h2><pre><code>// utils.js
function generateLoaders(loader, loaderOptions) &#123;
    var loaders = [cssLoader, px2remLoader]
&#125;
</code></pre>
<h2 id="也可以动态的根据可视窗口的大小来设置-在这里写一个计算"><a href="#也可以动态的根据可视窗口的大小来设置-在这里写一个计算" class="headerlink" title="也可以动态的根据可视窗口的大小来设置[在这里写一个计算]"></a>也可以动态的根据可视窗口的大小来设置[在这里写一个计算]</h2><pre><code>const size = 200
const screen = 375
const flexFn = () =&gt; &#123;
    const windowWidth = window.outerWidth
    const ratio = windowWidth / screen
    const newSize = ratio * (size / 2)

    document.querySelector(&#39;html&#39;).style.fontSize = newSize + &quot;px&quot;
&#125;

flexFn()

window.addEventListener(&quot;resize&quot;, () =&gt; &#123;
    flexFn()
&#125;,false)
</code></pre>
<p>直接将该js引入到main.js中即可</p>
<h2 id="修改配置后需要重启，然后我们在组件中写单位直接写-px，设计稿量多少就可以写多少了，舒服多了。"><a href="#修改配置后需要重启，然后我们在组件中写单位直接写-px，设计稿量多少就可以写多少了，舒服多了。" class="headerlink" title="修改配置后需要重启，然后我们在组件中写单位直接写 px，设计稿量多少就可以写多少了，舒服多了。"></a>修改配置后需要重启，然后我们在组件中写单位直接写 px，设计稿量多少就可以写多少了，舒服多了。</h2>]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
        <tag>vue-cli</tag>
        <tag>px2rem</tag>
      </tags>
  </entry>
  <entry>
    <title>vue概述</title>
    <url>/2019/01/25/vue/</url>
    <content><![CDATA[<hr>
<p>1/25/2019 4:34:55 PM</p>
<h3 id="此文章只是对VUE常用的知识进行了一个简述，详情请访问官方文档"><a href="#此文章只是对VUE常用的知识进行了一个简述，详情请访问官方文档" class="headerlink" title="此文章只是对VUE常用的知识进行了一个简述，详情请访问官方文档"></a>此文章只是对VUE常用的知识进行了一个简述，详情请<a class="link"   href="https://cn.vuejs.org/" >访问官方文档<i class="fas fa-external-link-alt"></i></a></h3><hr>
<h1 id="什么是vue？"><a href="#什么是vue？" class="headerlink" title="什么是vue？"></a>什么是vue？</h1><h3 id="vue是一个框架-渐进式开发框架-其实就是一个框架的名称，其特点是-数据双向绑定，组件开发，单页面路由，指令，插件"><a href="#vue是一个框架-渐进式开发框架-其实就是一个框架的名称，其特点是-数据双向绑定，组件开发，单页面路由，指令，插件" class="headerlink" title="vue是一个框架(渐进式开发框架),其实就是一个框架的名称，其特点是(数据双向绑定，组件开发，单页面路由，指令，插件)"></a>vue是一个框架(<code>渐进式开发框架</code>),其实就是一个框架的名称，其特点是(数据双向绑定，组件开发，单页面路由，指令，插件)</h3><h2 id="什么叫渐进式框架"><a href="#什么叫渐进式框架" class="headerlink" title="什么叫渐进式框架"></a>什么叫渐进式框架</h2><h3 id="通过开发组件的形式，进行组件的组件的组合，来组合出来的一个页面而已"><a href="#通过开发组件的形式，进行组件的组件的组合，来组合出来的一个页面而已" class="headerlink" title="通过开发组件的形式，进行组件的组件的组合，来组合出来的一个页面而已"></a>通过开发组件的形式，进行组件的组件的组合，来组合出来的一个页面而已</h3><h2 id="最重要的特性就是组件"><a href="#最重要的特性就是组件" class="headerlink" title="最重要的特性就是组件"></a>最重要的特性就是组件</h2><h3 id="组件类似于模块，设计组建的目的是为了更好的解耦业务，和模块化的区别就在于-组件的组成包含了-结构，逻辑，样式-而模块只是逻辑"><a href="#组件类似于模块，设计组建的目的是为了更好的解耦业务，和模块化的区别就在于-组件的组成包含了-结构，逻辑，样式-而模块只是逻辑" class="headerlink" title="组件类似于模块，设计组建的目的是为了更好的解耦业务，和模块化的区别就在于(组件的组成包含了(结构，逻辑，样式))而模块只是逻辑"></a>组件类似于模块，设计组建的目的是为了更好的解耦业务，和模块化的区别就在于(组件的组成包含了(结构，逻辑，样式))而模块只是逻辑</h3><h2 id="组件的特性"><a href="#组件的特性" class="headerlink" title="组件的特性"></a>组件的特性</h2><ul>
<li>组建的状态(data,props)</li>
<li>组件和组件的通讯</li>
<li>自己的生命周期</li>
<li>组件的渲染和组件的创建方式</li>
</ul>
<h2 id="设计组件"><a href="#设计组件" class="headerlink" title="设计组件"></a>设计组件</h2><p><strong>组件一般分为，展示组件和受控组件</strong></p>
<hr>
<blockquote>
<p>展示组件：纯粹的展示功能</p>
</blockquote>
<hr>
<blockquote>
<p>业务组件：单个的业务功能独立出来的组件</p>
</blockquote>
<hr>
<blockquote>
<p>控件：内置表单元素不能满足网页开发，有一些特殊需要自定义的表单组件，称为控制，一般需要结合v-model去做数据双向绑定的控制</p>
</blockquote>
<hr>
<blockquote>
<p>容器组件：作为页面的容器，用来管理当前页面的数据，通过数据去控制展示组件的显示</p>
</blockquote>
<hr>
<blockquote>
<p>api组件：通过api形式调用的组件（提示，loading，验证等之类的需要通过js调用方法控制的组件。vue.extend创建）</p>
</blockquote>
<hr>
<blockquote>
<p>组合式组件：组件和组件之间有特定关系的组件（slot元素作为插槽）</p>
</blockquote>
<hr>
<h2 id="如何拆分组件"><a href="#如何拆分组件" class="headerlink" title="如何拆分组件"></a>如何拆分组件</h2><blockquote>
<p>按照设计ui提供的ui图，提取公共展示功能，作为展示组件的提取，在页面开发过程中提取页面中独立业务单独出来业务组件，在表单页面提取公共的非内置表单元素作为控件处理（地区选择，选择日期，选择…..）</p>
</blockquote>
<h2 id="组件的创建方式"><a href="#组件的创建方式" class="headerlink" title="组件的创建方式"></a>组件的创建方式</h2><ul>
<li>vue.component(componnetName,option)           (自动渲染)</li>
<li>在每一个组件中都有component选项，用来注册局部组件    (自动渲染)</li>
<li>通过Vue.extends()扩展子类的形式创建                (手动渲染)</li>
</ul>
<h2 id="组建的实例选项"><a href="#组建的实例选项" class="headerlink" title="组建的实例选项"></a>组建的实例选项</h2><ul>
<li><p>@[function] data</p>
</li>
<li><p>@[object] method</p>
</li>
<li><p>@[object] compoted</p>
</li>
<li><p>@[object] watch</p>
</li>
<li><p>@[object] conponents</p>
</li>
<li><p>@[function] 生命周期 </p>
<pre><code>  beforeCreated () &#123;&#125;        // 初始化数据之前
  created () &#123;&#125;             // 数据初始化之后
  beforeMout () &#123;&#125;         // 开始渲染
  mounted () &#123;&#125;             // 渲染完成
  beforeUpdate () &#123;&#125;         // 开始更新 当一个数据的改变引起了视图的重新的渲染才会执行，单独的一个数据改变是不会执行的
  uppdated () &#123;&#125;             // 更新完成

  //当使用keep-alive组件时才会 执行
  activated () &#123;&#125;         // 组件启用时
  deactivated () &#123;&#125;         // 组件停用时

  //组件销毁 v-if销毁组件，或者切换路由(在没有启用缓存的前提)，或者手动执行this.$destroy () &#123;&#125;            // 清理组件中绑定的data，通过v-on绑定事件，如果有手动绑定的内容需要，在这个生命周期中手动销毁
  beforeDestroy () &#123;&#125;
  destroyed () &#123;&#125;

  
  errorCaptured () &#123;&#125;        // 当组件中发生错误时
</code></pre>
</li>
</ul>
<h2 id="组件的通讯方式"><a href="#组件的通讯方式" class="headerlink" title="组件的通讯方式"></a>组件的通讯方式</h2><h3 id="通讯创建：父子，子父，同级，跨级"><a href="#通讯创建：父子，子父，同级，跨级" class="headerlink" title="通讯创建：父子，子父，同级，跨级"></a>通讯创建：父子，子父，同级，跨级</h3><h3 id="通讯其实就是谁用谁的数据"><a href="#通讯其实就是谁用谁的数据" class="headerlink" title="通讯其实就是谁用谁的数据"></a>通讯其实就是谁用谁的数据</h3><ul>
<li>父子：子组件使用父组件数据，props(常用)，子组件内部通过$parent</li>
<li>子父：父组件使用子组件数据，通过自定事件，子组件通过$emit(事件名称，发送数据)给父组件传递数据(常用)$children $refs</li>
<li>同级：代理(一个子组件将数据发送到父级，父在发送到另一个子级)，eventBus vuex</li>
<li>跨级：逐层传递，vuex eventsBus</li>
</ul>
<h2 id="组件的嵌套"><a href="#组件的嵌套" class="headerlink" title="组件的嵌套"></a>组件的嵌套</h2><h3 id="组件内部通过slot内置组件，可以用来承载嵌套组件-单个slot，和命名slot"><a href="#组件内部通过slot内置组件，可以用来承载嵌套组件-单个slot，和命名slot" class="headerlink" title="组件内部通过slot内置组件，可以用来承载嵌套组件(单个slot，和命名slot)"></a>组件内部通过slot内置组件，可以用来承载嵌套组件(单个slot，和命名slot)</h3><h2 id="内置组件"><a href="#内置组件" class="headerlink" title="内置组件"></a>内置组件</h2><ul>
<li>template 单文件组件中代替了template选项，可以用作一个包裹元素，不会被渲染</li>
<li>component 动态组件，通过is属性动态渲染某一个组件</li>
<li>slot 插槽，用来承载组件潜逃的子组件</li>
<li>transition vue用来实现动画的组件(提供了，进入和离开两个状态)</li>
<li>transitions-group 用来实现多动画(列表动画，排序，添加，删除)</li>
<li>keep-alive 用来启动vue缓存功能，缓存组件的状态</li>
</ul>
<h2 id="vue的实例属性"><a href="#vue的实例属性" class="headerlink" title="vue的实例属性"></a>vue的实例属性</h2><pre><code>实例属性
vm.$data                 // 访问定义的data
vm.$props                 // 访问props对象
vm.$el                     // 访问组件的根节点
vm.$options             // 访问所有配置项
vm.$parent                 // 访问父组件实例
vm.$root
vm.$children
vm.$slots
vm.$scopedSlots
vm.$refs
vm.$isServer
vm.$attrs
vm.$listeners
实例方法 / 数据
vm.$watch
vm.$set
vm.$delete
实例方法 / 事件
vm.$on
vm.$once
vm.$off
vm.$emit
实例方法 / 生命周期
vm.$mount
vm.$forceUpdate
vm.$nextTick    //数据改变后回调
vm.$destroy //手动渲染
</code></pre>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>sass基本语法使用</title>
    <url>/2018/08/04/sass/</url>
    <content><![CDATA[<h2 id="1-26-2019-10-54-49-AM"><a href="#1-26-2019-10-54-49-AM" class="headerlink" title="1/26/2019 10:54:49 AM "></a>1/26/2019 10:54:49 AM </h2><h1 id="sass"><a href="#sass" class="headerlink" title="sass"></a>sass</h1><h3 id="学过CSS的人都知道，它不是一种编程语言。"><a href="#学过CSS的人都知道，它不是一种编程语言。" class="headerlink" title="学过CSS的人都知道，它不是一种编程语言。"></a>学过CSS的人都知道，它不是一种编程语言。</h3><h4 id="你可以用它开发网页样式，但是没法用它编程。也就是说，CSS基本上是设计师的工具，不是程序员的工具。在程序员眼里，CSS是一件很麻烦的东西。它没有变量，也没有条件语句，只是一行行单纯的描述，写起来相当费事。"><a href="#你可以用它开发网页样式，但是没法用它编程。也就是说，CSS基本上是设计师的工具，不是程序员的工具。在程序员眼里，CSS是一件很麻烦的东西。它没有变量，也没有条件语句，只是一行行单纯的描述，写起来相当费事。" class="headerlink" title="你可以用它开发网页样式，但是没法用它编程。也就是说，CSS基本上是设计师的工具，不是程序员的工具。在程序员眼里，CSS是一件很麻烦的东西。它没有变量，也没有条件语句，只是一行行单纯的描述，写起来相当费事。"></a>你可以用它开发网页样式，但是没法用它编程。也就是说，CSS基本上是设计师的工具，不是程序员的工具。在程序员眼里，CSS是一件很麻烦的东西。它没有变量，也没有条件语句，只是一行行单纯的描述，写起来相当费事。</h4><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul>
<li><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h4 id="SASS允许使用变量，所有变量以-开头。"><a href="#SASS允许使用变量，所有变量以-开头。" class="headerlink" title="SASS允许使用变量，所有变量以$开头。"></a>SASS允许使用变量，所有变量以$开头。</h4><pre><code>  $blue : #1875e7;　

  　　div &#123;
  　　　color : $blue;
  　　&#125;
</code></pre>
<h4 id="如果变量需要镶嵌在字符串之中，就必须需要写在-之中。"><a href="#如果变量需要镶嵌在字符串之中，就必须需要写在-之中。" class="headerlink" title="如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。"></a>如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。</h4><pre><code>  $side : left;
  　　.rounded &#123;
  　　　　border-#&#123;$side&#125;-radius: 5px;
  　　&#125;
</code></pre>
</li>
<li><h2 id="计算功能"><a href="#计算功能" class="headerlink" title="计算功能"></a>计算功能</h2><h4 id="SASS允许在代码中使用算式："><a href="#SASS允许在代码中使用算式：" class="headerlink" title="SASS允许在代码中使用算式："></a>SASS允许在代码中使用算式：</h4><pre><code>  body &#123;
  　　　　margin: (14px/2);
  　　　　top: 50px + 100px;
  　　　　right: $var * 10%;
  　　&#125;
</code></pre>
</li>
<li><h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><h4 id="SASS允许选择器嵌套。比如，下面的CSS代码："><a href="#SASS允许选择器嵌套。比如，下面的CSS代码：" class="headerlink" title="SASS允许选择器嵌套。比如，下面的CSS代码："></a>SASS允许选择器嵌套。比如，下面的CSS代码：</h4><pre><code>  div h1 &#123;
  　　　　color : red;
  　　&#125;
</code></pre>
<p>  可以写成：</p>
<pre><code>  div &#123;
  　　　　hi &#123;
  　　　　　　color:red;
  　　　　&#125;
  　　&#125;
</code></pre>
</li>
<li><h2 id="代码的重用"><a href="#代码的重用" class="headerlink" title="代码的重用"></a>代码的重用</h2></li>
</ul>
<hr>
<p>【继承】</p>
<h4 id="SASS允许一个选择器，继承另一个选择器。比如，现有class1："><a href="#SASS允许一个选择器，继承另一个选择器。比如，现有class1：" class="headerlink" title="SASS允许一个选择器，继承另一个选择器。比如，现有class1："></a>SASS允许一个选择器，继承另一个选择器。比如，现有class1：</h4><pre><code>    .class1 &#123;
    　　　　border: 1px solid #ddd;
    　　&#125;
</code></pre>
<h4 id="class2要继承class1，就要使用-extend命令："><a href="#class2要继承class1，就要使用-extend命令：" class="headerlink" title="class2要继承class1，就要使用@extend命令："></a>class2要继承class1，就要使用@extend命令：</h4><pre><code>    .class2 &#123;
    　　　　@extend .class1;
    　　　　font-size:120%;
    　　&#125;
</code></pre>
<ul>
<li><h2 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h2><h4 id="Mixin有点像C语言的宏（macro），是可以重用的代码块。"><a href="#Mixin有点像C语言的宏（macro），是可以重用的代码块。" class="headerlink" title="Mixin有点像C语言的宏（macro），是可以重用的代码块。"></a>Mixin有点像C语言的宏（macro），是可以重用的代码块。</h4><h4 id="使用-mixin命令，定义一个代码块。"><a href="#使用-mixin命令，定义一个代码块。" class="headerlink" title="使用@mixin命令，定义一个代码块。"></a>使用@mixin命令，定义一个代码块。</h4><pre><code>  @mixin left &#123;
  　　　　float: left;
  　　　　margin-left: 10px;
  　　&#125;
</code></pre>
<h4 id="使用-include命令，调用这个mixin。"><a href="#使用-include命令，调用这个mixin。" class="headerlink" title="使用@include命令，调用这个mixin。"></a>使用@include命令，调用这个mixin。</h4><pre><code>  div &#123;
  　　　　@include left;
  　　&#125;
</code></pre>
<h4 id="mixin的强大之处，在于可以指定参数和缺省值。"><a href="#mixin的强大之处，在于可以指定参数和缺省值。" class="headerlink" title="mixin的强大之处，在于可以指定参数和缺省值。"></a>mixin的强大之处，在于可以指定参数和缺省值。</h4><pre><code>  @mixin left($value: 10px) &#123;
  　　　　float: left;
  　　　　margin-right: $value;
  　　&#125;
</code></pre>
<h4 id="使用的时候，根据需要加入参数："><a href="#使用的时候，根据需要加入参数：" class="headerlink" title="使用的时候，根据需要加入参数："></a>使用的时候，根据需要加入参数：</h4><pre><code>  div &#123;
  　　　　@include left(20px);
  　　&#125;
</code></pre>
<h4 id="下面是一个mixin的实例，用来生成浏览器前缀。"><a href="#下面是一个mixin的实例，用来生成浏览器前缀。" class="headerlink" title="下面是一个mixin的实例，用来生成浏览器前缀。"></a>下面是一个mixin的实例，用来生成浏览器前缀。</h4><pre><code>  @mixin rounded($vert, $horz, $radius: 10px) &#123;
  　　　　border-#&#123;$vert&#125;-#&#123;$horz&#125;-radius: $radius;
  　　　　-moz-border-radius-#&#123;$vert&#125;#&#123;$horz&#125;: $radius;
  　　　　-webkit-border-#&#123;$vert&#125;-#&#123;$horz&#125;-radius: $radius;
  　　&#125;
</code></pre>
<h4 id="使用的时候，可以像下面这样调用："><a href="#使用的时候，可以像下面这样调用：" class="headerlink" title="使用的时候，可以像下面这样调用："></a>使用的时候，可以像下面这样调用：</h4><pre><code>      .navbar li &#123; @include rounded(top, left); &#125;

      .footer &#123; @include rounded(top, left, 5px); &#125;
</code></pre>
</li>
<li><h2 id="插入文件"><a href="#插入文件" class="headerlink" title="插入文件"></a>插入文件</h2><h4 id="import命令，用来插入外部文件。"><a href="#import命令，用来插入外部文件。" class="headerlink" title="@import命令，用来插入外部文件。"></a>@import命令，用来插入外部文件。</h4><pre><code>  @import &quot;path/filename.scss&quot;;
</code></pre>
<h4 id="如果插入的是-css文件，则等同于css的import命令。"><a href="#如果插入的是-css文件，则等同于css的import命令。" class="headerlink" title="如果插入的是.css文件，则等同于css的import命令。"></a>如果插入的是.css文件，则等同于css的import命令。</h4><pre><code>  @import &quot;foo.css&quot;;
</code></pre>
</li>
<li><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><h3 id="1-条件语句"><a href="#1-条件语句" class="headerlink" title="1. 条件语句"></a>1. 条件语句</h3><h4 id="if可以用来判断："><a href="#if可以用来判断：" class="headerlink" title="@if可以用来判断："></a>@if可以用来判断：</h4><pre><code>  p &#123;
  　　　　@if 1 + 1 == 2 &#123; border: 1px solid; &#125;
  　　　　@if 5 &lt; 3 &#123; border: 2px dotted; &#125;
  　　&#125;
</code></pre>
<h4 id="配套的还有-else命令："><a href="#配套的还有-else命令：" class="headerlink" title="配套的还有@else命令："></a>配套的还有@else命令：</h4><pre><code>  @if lightness($color) &gt; 30% &#123;
  　　　　background-color: #000;
  　　&#125; @else &#123;
  　　　　background-color: #fff;
  　　&#125;
</code></pre>
<h3 id="2-循环语句"><a href="#2-循环语句" class="headerlink" title="2. 循环语句"></a>2. 循环语句</h3><h4 id="SASS支持for循环："><a href="#SASS支持for循环：" class="headerlink" title="SASS支持for循环："></a>SASS支持for循环：</h4><pre><code>  @for $i from 1 to 10 &#123;
  　　　　.border-#&#123;$i&#125; &#123;
  　　　　　　border: #&#123;$i&#125;px solid blue;
  　　　　&#125;
  　　&#125;
</code></pre>
<h4 id="也支持while循环："><a href="#也支持while循环：" class="headerlink" title="也支持while循环："></a>也支持while循环：</h4><pre><code>  $i: 6;

  　　@while $i &gt; 0 &#123;
  　　　　.item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;
  　　　　$i: $i - 2;
  　　&#125;
</code></pre>
<h4 id="each命令，作用与for类似："><a href="#each命令，作用与for类似：" class="headerlink" title="each命令，作用与for类似："></a>each命令，作用与for类似：</h4><pre><code>  @each $member in a, b, c, d &#123;
  　　　　.#&#123;$member&#125; &#123;
  　　　　　　background-image: url(&quot;/image/#&#123;$member&#125;.jpg&quot;);
  　　　　&#125;
  　　&#125;
</code></pre>
<h3 id="3-自定义函数"><a href="#3-自定义函数" class="headerlink" title="3. 自定义函数"></a>3. 自定义函数</h3><h4 id="SASS允许用户编写自己的函数。"><a href="#SASS允许用户编写自己的函数。" class="headerlink" title="SASS允许用户编写自己的函数。"></a>SASS允许用户编写自己的函数。</h4><pre><code>  @function double($n) &#123;
  　　　　@return $n * 2;
  　　&#125;
  
  　　#sidebar &#123;
  　　　　width: double(5px);
  　　&#125;
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>css</tag>
        <tag>scss</tag>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue slot-scope的理解（适合初学者）</title>
    <url>/2018/08/04/vue%20slot-scope/</url>
    <content><![CDATA[<h1 id="Vue-slot-scope的理解（适合初学者）"><a href="#Vue-slot-scope的理解（适合初学者）" class="headerlink" title="Vue slot-scope的理解（适合初学者）"></a>Vue slot-scope的理解（适合初学者）</h1><blockquote>
<p>1/26/2019 2:58:04 PM </p>
</blockquote>
<hr>
<blockquote>
<h5 id="Vue中关于插槽的文档说明很短，语言又写的很凝练，再加上其和方法，数据，计算机等常用选项在使用频率，使用先后上的差别，这就有可能造成初次接触插槽的开发者容易产生“算了吧，回头再学，反正已经可以写基础组件了”的想法，于是就关闭了VUE的说明文档。"><a href="#Vue中关于插槽的文档说明很短，语言又写的很凝练，再加上其和方法，数据，计算机等常用选项在使用频率，使用先后上的差别，这就有可能造成初次接触插槽的开发者容易产生“算了吧，回头再学，反正已经可以写基础组件了”的想法，于是就关闭了VUE的说明文档。" class="headerlink" title="Vue中关于插槽的文档说明很短，语言又写的很凝练，再加上其和方法，数据，计算机等常用选项在使用频率，使用先后上的差别，这就有可能造成初次接触插槽的开发者容易产生“算了吧，回头再学，反正已经可以写基础组件了”的想法，于是就关闭了VUE的说明文档。"></a>Vue中关于插槽的文档说明很短，语言又写的很凝练，再加上其和方法，数据，计算机等常用选项在使用频率，使用先后上的差别，这就有可能造成初次接触插槽的开发者容易产生“算了吧，回头再学，反正已经可以写基础组件了”的想法，于是就关闭了VUE的说明文档。</h5></blockquote>
<blockquote>
<h3 id="实际上，插槽的概念很简单"><a href="#实际上，插槽的概念很简单" class="headerlink" title="实际上，插槽的概念很简单"></a>实际上，插槽的概念很简单</h3></blockquote>
<h3 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h3><ul>
<li><strong>概念：插槽，也就是槽，是组件的一块HTML模板，这块模板显示不显示，以及怎样显示由父组件来决定。</strong></li>
</ul>
<h3 id="插槽可以分为3部分来说"><a href="#插槽可以分为3部分来说" class="headerlink" title="插槽可以分为3部分来说"></a>插槽可以分为3部分来说</h3><ul>
<li><p><strong>单个插槽</strong></p>
<hr>
<ul>
<li><h4 id="首先是单个插槽，单个插槽的英文VUE的官方叫法，但是其实也可以叫它默认插槽，或者与具名插槽相对，我们可以叫它匿名插槽。因为它不用设置名称属性。"><a href="#首先是单个插槽，单个插槽的英文VUE的官方叫法，但是其实也可以叫它默认插槽，或者与具名插槽相对，我们可以叫它匿名插槽。因为它不用设置名称属性。" class="headerlink" title="首先是单个插槽，单个插槽的英文VUE的官方叫法，但是其实也可以叫它默认插槽，或者与具名插槽相对，我们可以叫它匿名插槽。因为它不用设置名称属性。"></a>首先是单个插槽，单个插槽的英文VUE的官方叫法，但是其实也可以叫它默认插槽，或者与具名插槽相对，我们可以叫它匿名插槽。因为它不用设置名称属性。</h4></li>
<li><h4 id="单个插槽可以放置在组件的任意位置，但是就像它的名字一样，一个组件中只能有一个该类插槽。相对应的，具名插槽就可以有很多个，只要名字（名称属性）不同就可以了。"><a href="#单个插槽可以放置在组件的任意位置，但是就像它的名字一样，一个组件中只能有一个该类插槽。相对应的，具名插槽就可以有很多个，只要名字（名称属性）不同就可以了。" class="headerlink" title="单个插槽可以放置在组件的任意位置，但是就像它的名字一样，一个组件中只能有一个该类插槽。相对应的，具名插槽就可以有很多个，只要名字（名称属性）不同就可以了。"></a>单个插槽可以放置在组件的任意位置，但是就像它的名字一样，一个组件中只能有一个该类插槽。相对应的，具名插槽就可以有很多个，只要名字（名称属性）不同就可以了。</h4></li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>下面通过一个例子来展示。
</code></pre>
</blockquote>
<p><strong>父组件：</strong></p>
<pre><code>    &lt;div class=&quot;slot-righ&quot;&gt;
                &lt;p&gt;22222&lt;/p&gt;
                &lt;Slo&gt;
                    &lt;div class=&quot;con&quot;&gt;
                        111111
                    &lt;/div&gt;
                &lt;/Slo&gt;
            &lt;/div&gt;
</code></pre>
<p><strong>子组件：</strong></p>
<pre><code>    &lt;div class=&quot;sol&quot;&gt;
        &lt;p&gt;11111&lt;/p&gt;
        &lt;slot&gt;&lt;/slot&gt;
      &lt;/div&gt;
</code></pre>
<ul>
<li><strong>具名插槽</strong><ul>
<li>匿名插槽没有名称属性，所以是匿名插槽，那么，插槽加了名称属性，就变成了具名插槽。具名插槽可以在一个组件中出现Ñ次，出现在不同的位置。下面的例子，一个就是有两个具名插槽状语从句：单个插槽的组件，这三个插槽被父组件用同一套的CSS样式显示了出来，不同的是内容上略有区别。</li>
</ul>
</li>
</ul>
<blockquote>
<p>下面通过一个例子来展示。</p>
</blockquote>
<p><strong>父组件：</strong>    </p>
<pre><code>&lt;div class=&quot;slot-righ&quot;&gt;
            &lt;p&gt;22222&lt;/p&gt;
            &lt;Slo&gt;
                &lt;div class=&quot;con&quot; slot=&quot;up&quot;&gt;
                    111111
                &lt;/div&gt;
            &lt;/Slo&gt;
        &lt;/div&gt;
    
</code></pre>
<p><strong>子组件：</strong></p>
<pre><code>&lt;div class=&quot;sol&quot;&gt;
    &lt;p&gt;11111&lt;/p&gt;
    &lt;slot name=&quot;up&quot;&gt;&lt;/slot&gt;//具名插槽
  &lt;/div&gt;
</code></pre>
<ul>
<li><p><strong>作用域插槽| 带数据的插槽</strong></p>
<ul>
<li>最后，就是我们的作用域插槽。这个稍微难理解一点。官方叫它作用域插槽，实际上，对比前面两种插槽，我们可以叫它带数据的插槽。什么意思呢，就是前面两种，都是在组件的模板里面写</li>
</ul>
</li>
</ul>
<blockquote>
<p>下面通过一个例子来展示。</p>
</blockquote>
<p><strong>父组件：</strong>    </p>
<pre><code>&lt;div class=&quot;slot-righ&quot;&gt;
                &lt;p&gt;22222&lt;/p&gt;
                &lt;Slo&gt;
                    &lt;div class=&quot;con&quot; slot-scope=&quot;user&quot;&gt;//父组件拿到数据
                        &#123;&#123;user.data&#125;&#125;
                    &lt;/div&gt;
                &lt;/Slo&gt;
            &lt;/div&gt;
</code></pre>
<p><strong>子组件：</strong></p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;sol&quot;&gt;
    &lt;p&gt;11111&lt;/p&gt;
    &lt;slot :data=&quot;data&quot;&gt;&lt;/slot&gt;//这里再插槽上绑定数据
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default &#123;
      data()&#123;
        return &#123;
          data:11111111
        &#125;
      &#125;
    &#125;
&lt;/script&gt;
</code></pre>
<blockquote>
<h4 id="正因为作用域插槽绑定了一套数据，父组件可以拿来用于是，情况就变成了这样：样式父组件说了算，但内容可以显示子组件插槽绑定的。"><a href="#正因为作用域插槽绑定了一套数据，父组件可以拿来用于是，情况就变成了这样：样式父组件说了算，但内容可以显示子组件插槽绑定的。" class="headerlink" title="正因为作用域插槽绑定了一套数据，父组件可以拿来用于是，情况就变成了这样：样式父组件说了算，但内容可以显示子组件插槽绑定的。"></a>正因为作用域插槽绑定了一套数据，父组件可以拿来用于是，情况就变成了这样：样式父组件说了算，但内容可以显示子组件插槽绑定的。</h4></blockquote>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
        <tag>slot</tag>
      </tags>
  </entry>
</search>
