<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="Hexo Theme Keep"><meta name="author" content="小鱼仙倌"><title>Vuex简单概述 | 小鱼仙倌</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/favicon-32x32-next.png"><link rel="stylesheet" href="/css/font-awesome.min.css"><script id="hexo-configurations">let KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"example.com",root:"/",language:"zh-CN",path:"search.xml"},KEEP.theme_config={toc:{enable:!0,number:!0,expand_all:!0,init_open:!0},style:{primary_color:"#0066CC",avatar:"/images/headers.png",favicon:"/images/favicon-32x32-next.png",article_img_align:"left",left_side_width:"260px",content_max_width:"920px",hover:{shadow:!0,scale:!0},first_screen:{enable:!0,background_img:"/images/bg.svg",description:"天官赐福 百无禁忌"},scroll:{progress_bar:{enable:!0},percent:{enable:!0}}},local_search:{enable:!0,preload:!0},code_copy:{enable:!0,style:"mac"},pjax:{enable:!1},lazyload:{enable:!0},version:"3.4.2"},KEEP.language_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 月前",year:"%s 年前"}</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-title" href="/">小鱼仙倌</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">首页</a></li><li class="menu-item"><a href="/archives">归档</a></li><li class="menu-item"><a href="/tags">标签</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">首页</a></li><li class="drawer-menu-item flex-center"><a href="/archives">归档</a></li><li class="drawer-menu-item flex-center"><a href="/tags">标签</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">Vuex简单概述</span></div><div class="article-header"><div class="avatar"><img src="/images/headers.png"></div><div class="info"><div class="author"><span class="name">小鱼仙倌</span> <span class="author-label">Lv5</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fas fa-edit"></i>&nbsp;2019-01-30 19:49:45 </span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/js/">js</a>&nbsp;</li><li>| <a href="/tags/vue/">vue</a>&nbsp;</li><li>| <a href="/tags/vuex/">vuex</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>1.4k 字</span> </span><span class="article-min2read article-meta-item"><i class="fas fa-clock"></i>&nbsp;<span>6 分钟</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body"><h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><hr><h2 id="Vuex是什么？"><a href="#Vuex是什么？" class="headerlink" title="Vuex是什么？"></a>Vuex是什么？</h2><blockquote><p><strong>引入官方提供的解释，vuex 是专门为 vue.js 设计的一套 状态管理模式 。什么是状态管理模式？说白了就是数据的集中管理。我们在使用 vue.js 时所用到的数据全部抽取出来放在一个state对象下，这样我们在任何组件内都可以访问得到该数据。下面我们通过一个例子来看下 vuex 是如何管理我们的数据的。</strong></p></blockquote><h3 id="首先先通过npm来安装一下vuex："><a href="#首先先通过npm来安装一下vuex：" class="headerlink" title="首先先通过npm来安装一下vuex："></a>首先先通过npm来安装一下vuex：</h3><pre><code>npm install vuex --save
</code></pre><h2 id="state状态属性"><a href="#state状态属性" class="headerlink" title="state状态属性"></a>state状态属性</h2><h3 id="在项目src目录下新建一个store文件夹-该文件夹不是必须的，你也可以直接新建一个store-js，只要你引入的路径正确即可-，在该文件夹下新建一个-index-js。store文件夹主要是单独管理我们的数据状态，包括行为触发等等。"><a href="#在项目src目录下新建一个store文件夹-该文件夹不是必须的，你也可以直接新建一个store-js，只要你引入的路径正确即可-，在该文件夹下新建一个-index-js。store文件夹主要是单独管理我们的数据状态，包括行为触发等等。" class="headerlink" title="在项目src目录下新建一个store文件夹(该文件夹不是必须的，你也可以直接新建一个store.js，只要你引入的路径正确即可)，在该文件夹下新建一个 index.js。store文件夹主要是单独管理我们的数据状态，包括行为触发等等。"></a>在项目src目录下新建一个store文件夹(该文件夹不是必须的，你也可以直接新建一个store.js，只要你引入的路径正确即可)，在该文件夹下新建一个 index.js。store文件夹主要是单独管理我们的数据状态，包括行为触发等等。</h3><blockquote><h4 id="store-index-js"><a href="#store-index-js" class="headerlink" title="store/index.js"></a>store/index.js</h4></blockquote><pre><code>import Vue from &#39;vue&#39;
import Vuex from &#39;vuex&#39;
Vue.use(Vuex)
let store = new Vuex.Store(&#123;
    state: &#123;  //要设置的全局访问的state对象
        name: &quot;vuex&quot;
    &#125;
&#125;)

export default store
</code></pre><h3 id="为了能在所有的组件中共享我们的数据，我们有必要给根实例下注入我们的store对象，所以我们在main-js文件中"><a href="#为了能在所有的组件中共享我们的数据，我们有必要给根实例下注入我们的store对象，所以我们在main-js文件中" class="headerlink" title="为了能在所有的组件中共享我们的数据，我们有必要给根实例下注入我们的store对象，所以我们在main.js文件中"></a>为了能在所有的组件中共享我们的数据，我们有必要给根实例下注入我们的store对象，所以我们在main.js文件中</h3><blockquote><h4 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h4></blockquote><pre><code>import Vue from &#39;vue&#39;
import App from &#39;./App.vue&#39;
import &quot;./commcss/index.scss&quot;
import store from &#39;./store/index&#39;
new Vue(&#123;
  el: &#39;#app&#39;,
  render: h =&gt; h(App),
  store // 全局注册
&#125;)
</code></pre><blockquote><h4 id="App-vue"><a href="#App-vue" class="headerlink" title="App.vue"></a>App.vue</h4></blockquote><pre><code>&lt;template&gt;
      &lt;div class=&quot;app&quot;&gt;
        &#123;&#123;name&#125;&#125;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import &#123; mapState&#125; from &#39;vuex&#39;
/*
 *1.mapState 辅助函数
 *当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。
 *为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键：
 */
export default &#123;
  computde: &#123;
    ...mapState([&#39;name&#39;])
    &#125;
&#125;
&lt;/script&gt;
</code></pre><h2 id="Getter-store的计算属性，例如对列表进行过滤"><a href="#Getter-store的计算属性，例如对列表进行过滤" class="headerlink" title="Getter(store的计算属性，例如对列表进行过滤)"></a>Getter(store的计算属性，例如对列表进行过滤)</h2><blockquote><h4 id="store-index-js-1"><a href="#store-index-js-1" class="headerlink" title="store/index.js"></a>store/index.js</h4></blockquote><pre><code>state: &#123;
    count: 1,
    arr: [
      &#123;
        sex: &#39;男&#39;,
        id: 1
      &#125;,
      &#123;
        sex: &#39;男&#39;,
        id: 2
      &#125;,
      &#123;
        sex: &#39;男&#39;,
        id: 3
      &#125;,
      &#123;
        sex: &#39;男&#39;,
        id: 4
      &#125;,
      &#123;
        sex: &#39;女&#39;,
        id: 5
      &#125;,
      &#123;
        sex: &#39;男&#39;,
        id: 6
      &#125;,
      &#123;
        sex: &#39;男&#39;,
        id: 7
      &#125;
    ]
  &#125;,
getters: &#123;
    man (state) &#123;
      return state.arr.filter(item=&gt;&#123;return item.sex===&#39;男&#39;&#125;)
    &#125;
  &#125;,
</code></pre><blockquote><h4 id="App-vue-1"><a href="#App-vue-1" class="headerlink" title="App.vue"></a>App.vue</h4></blockquote><pre><code>&lt;template&gt;
      &lt;div class=&quot;app&quot;&gt;
        &lt;ul&gt;
            &lt;li v-for=&quot;(item,index) in man&quot; :key=&quot;item.id&quot;&gt;&#123;&#123;item.sex&#125;&#125;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import &#123; mapGetters &#125; from &#39;vuex&#39; //mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：
export default &#123;
  computde: &#123;
    ...mapGetters([&#39;man&#39;])
    &#125;
&#125;
&lt;/script&gt;
</code></pre><h2 id="mutation-更新state的唯一方法"><a href="#mutation-更新state的唯一方法" class="headerlink" title="mutation(更新state的唯一方法)"></a>mutation(更新state的唯一方法)</h2><blockquote><h4 id="store-index-js-2"><a href="#store-index-js-2" class="headerlink" title="store/index.js"></a>store/index.js</h4></blockquote><pre><code>mutation: &#123;
    change (state) &#123;
        state.name = &#39;vue&#39;
    &#125;
&#125;
</code></pre><blockquote><h4 id="App-vue-2"><a href="#App-vue-2" class="headerlink" title="App.vue"></a>App.vue</h4></blockquote><pre><code>&lt;template&gt;
      &lt;div class=&quot;app&quot; @click=&quot;change&quot;&gt;
        &#123;&#123;name&#125;&#125;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default &#123;
  method: &#123;
    change () &#123;
        this.$store.commit(&#39;change&#39;)
    &#125;
  &#125;
&#125;
&lt;/script&gt;    
</code></pre><h2 id="一条重要的原则就是要记住-mutation-必须是同步函数"><a href="#一条重要的原则就是要记住-mutation-必须是同步函数" class="headerlink" title="一条重要的原则就是要记住 mutation 必须是同步函数"></a>一条重要的原则就是要记住 mutation 必须是同步函数</h2><h3 id="原因：-为什么不能执行一步操作"><a href="#原因：-为什么不能执行一步操作" class="headerlink" title="原因：(为什么不能执行一步操作)"></a>原因：(为什么不能执行一步操作)</h3><blockquote><p><strong>现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。</strong></p></blockquote><h3 id="因此：【我们需要一个action来进行异步操作】"><a href="#因此：【我们需要一个action来进行异步操作】" class="headerlink" title="因此：【我们需要一个action来进行异步操作】"></a>因此：【我们需要一个action来进行异步操作】</h3><h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><h3 id="Action-类似于-mutation，不同在于："><a href="#Action-类似于-mutation，不同在于：" class="headerlink" title="Action 类似于 mutation，不同在于："></a>Action 类似于 mutation，不同在于：</h3><ul><li><strong>Action 提交的是 mutation，而不是直接变更状态。</strong></li><li><strong>Action 可以包含任意异步操作。</strong></li></ul><blockquote><h4 id="store-index-js-3"><a href="#store-index-js-3" class="headerlink" title="store/index.js"></a>store/index.js</h4></blockquote><pre><code>state: &#123;
    count: 0
&#125;,
mutations: &#123;
    addcount (state) &#123;
      state.count++
    &#125;
  &#125;,
actions: &#123;
    getInfo (context) &#123;
      setTimeout(()=&gt;&#123;
        context.commit(&#39;addcount&#39;)
      &#125;,2000)
    &#125;
  &#125;
</code></pre><blockquote><h4 id="App-vue-3"><a href="#App-vue-3" class="headerlink" title="App.vue"></a>App.vue</h4></blockquote><pre><code>&lt;template&gt;
      &lt;div class=&quot;app&quot; @click=&quot;change&quot;&gt;
        &#123;&#123;count&#125;&#125;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default &#123;
  computed: &#123;
    ...mapState([&#39;count&#39;])
  &#125;,
  method: &#123;
    change () &#123;
        this.$store.dispatch(&#39;getInfo&#39;)
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre><h6 id="乍一眼看上去感觉多此一举，我们直接分发-mutation-岂不更方便？实际上并非如此，还记得-mutation-必须同步执行这个限制么？Action-就不受约束！我们可以在-action-内部执行异步操作："><a href="#乍一眼看上去感觉多此一举，我们直接分发-mutation-岂不更方便？实际上并非如此，还记得-mutation-必须同步执行这个限制么？Action-就不受约束！我们可以在-action-内部执行异步操作：" class="headerlink" title="乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 mutation 必须同步执行这个限制么？Action 就不受约束！我们可以在 action 内部执行异步操作："></a>乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 mutation 必须同步执行这个限制么？Action 就不受约束！我们可以在 action 内部执行异步操作：</h6><h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><h3 id="由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store-对象就有可能变得相当臃肿。"><a href="#由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store-对象就有可能变得相当臃肿。" class="headerlink" title="由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。"></a>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</h3><hr><h4 id="为了解决以上问题，Vuex-允许我们将-store-分割成模块（module）。每个模块拥有自己的-state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割："><a href="#为了解决以上问题，Vuex-允许我们将-store-分割成模块（module）。每个模块拥有自己的-state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：" class="headerlink" title="为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割："></a>为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</h4><p>首先创建module/todo.js</p><blockquote><p><strong>module/todo.js</strong></p></blockquote><pre><code>export default &#123;
  namespaced: true,
  state: &#123;
    count: 0
  &#125;,
  mutations: &#123;
    addcount (state) &#123;
      state.count++
    &#125;
  &#125;,
&#125;
</code></pre><blockquote><h4 id="store-index-js-4"><a href="#store-index-js-4" class="headerlink" title="store/index.js"></a>store/index.js</h4></blockquote><pre><code>import todo from &quot;./modules/todo&quot;

modules: &#123;
    todo
  &#125;
</code></pre><blockquote><h4 id="App-vue-4"><a href="#App-vue-4" class="headerlink" title="App.vue"></a>App.vue</h4></blockquote><pre><code>&lt;template&gt;
      &lt;div class=&quot;app&quot; @click=&quot;change&quot;&gt;
        &#123;&#123;count&#125;&#125;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default &#123;
  computed: &#123;
    ...mapState(&#39;todo&#39;,[&#39;count&#39;])
  &#125;,
  method: &#123;
    change () &#123;
        this.$store.commit(&#39;todo/addcount&#39;)
    &#125;
  &#125;
&#125;
&lt;/script&gt;    
</code></pre></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul><li>本文标题：Vuex简单概述</li><li>本文作者：小鱼仙倌</li><li>创建时间：2019-01-30 19:49:45</li><li>本文链接：http://fishfairy.cn/2019/01/30/vuex/</li><li>版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></div><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2019/02/12/web%20server/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">RESTful API</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2019/01/28/New%20Router/"><span class="title flex-center"><span class="post-nav-title-item">vue-router路由</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2018</span>&nbsp;-&nbsp; 2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">小鱼仙倌</a></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item"><span id="busuanzi_container_site_uv">访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; </span><span id="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></span></div><div class="icp-info info-item"><a target="_blank" rel="nofollow" href="https://beian.miit.gov.cn">晋ICP备18012867号-2</a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item page-aside-toggle"><i class="fas fa-outdent"></i></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-expand-width flex-center"><i class="fas fa-arrows-alt-h"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><aside class="page-aside"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Vuex"><span class="nav-number">1.</span> <span class="nav-text">Vuex</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Vuex%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">Vuex是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A6%96%E5%85%88%E5%85%88%E9%80%9A%E8%BF%87npm%E6%9D%A5%E5%AE%89%E8%A3%85%E4%B8%80%E4%B8%8Bvuex%EF%BC%9A"><span class="nav-number">1.1.1.</span> <span class="nav-text">首先先通过npm来安装一下vuex：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#state%E7%8A%B6%E6%80%81%E5%B1%9E%E6%80%A7"><span class="nav-number">1.2.</span> <span class="nav-text">state状态属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E9%A1%B9%E7%9B%AEsrc%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AAstore%E6%96%87%E4%BB%B6%E5%A4%B9-%E8%AF%A5%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8D%E6%98%AF%E5%BF%85%E9%A1%BB%E7%9A%84%EF%BC%8C%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AAstore-js%EF%BC%8C%E5%8F%AA%E8%A6%81%E4%BD%A0%E5%BC%95%E5%85%A5%E7%9A%84%E8%B7%AF%E5%BE%84%E6%AD%A3%E7%A1%AE%E5%8D%B3%E5%8F%AF-%EF%BC%8C%E5%9C%A8%E8%AF%A5%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA-index-js%E3%80%82store%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%BB%E8%A6%81%E6%98%AF%E5%8D%95%E7%8B%AC%E7%AE%A1%E7%90%86%E6%88%91%E4%BB%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%8A%B6%E6%80%81%EF%BC%8C%E5%8C%85%E6%8B%AC%E8%A1%8C%E4%B8%BA%E8%A7%A6%E5%8F%91%E7%AD%89%E7%AD%89%E3%80%82"><span class="nav-number">1.2.1.</span> <span class="nav-text">在项目src目录下新建一个store文件夹(该文件夹不是必须的，你也可以直接新建一个store.js，只要你引入的路径正确即可)，在该文件夹下新建一个 index.js。store文件夹主要是单独管理我们的数据状态，包括行为触发等等。</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#store-index-js"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">store&#x2F;index.js</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BA%86%E8%83%BD%E5%9C%A8%E6%89%80%E6%9C%89%E7%9A%84%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%85%B1%E4%BA%AB%E6%88%91%E4%BB%AC%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%88%91%E4%BB%AC%E6%9C%89%E5%BF%85%E8%A6%81%E7%BB%99%E6%A0%B9%E5%AE%9E%E4%BE%8B%E4%B8%8B%E6%B3%A8%E5%85%A5%E6%88%91%E4%BB%AC%E7%9A%84store%E5%AF%B9%E8%B1%A1%EF%BC%8C%E6%89%80%E4%BB%A5%E6%88%91%E4%BB%AC%E5%9C%A8main-js%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="nav-number">1.2.2.</span> <span class="nav-text">为了能在所有的组件中共享我们的数据，我们有必要给根实例下注入我们的store对象，所以我们在main.js文件中</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#main-js"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">main.js</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#App-vue"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">App.vue</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Getter-store%E7%9A%84%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%EF%BC%8C%E4%BE%8B%E5%A6%82%E5%AF%B9%E5%88%97%E8%A1%A8%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4"><span class="nav-number">1.3.</span> <span class="nav-text">Getter(store的计算属性，例如对列表进行过滤)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#store-index-js-1"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">store&#x2F;index.js</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#App-vue-1"><span class="nav-number">1.3.0.2.</span> <span class="nav-text">App.vue</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mutation-%E6%9B%B4%E6%96%B0state%E7%9A%84%E5%94%AF%E4%B8%80%E6%96%B9%E6%B3%95"><span class="nav-number">1.4.</span> <span class="nav-text">mutation(更新state的唯一方法)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#store-index-js-2"><span class="nav-number">1.4.0.1.</span> <span class="nav-text">store&#x2F;index.js</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#App-vue-2"><span class="nav-number">1.4.0.2.</span> <span class="nav-text">App.vue</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E6%9D%A1%E9%87%8D%E8%A6%81%E7%9A%84%E5%8E%9F%E5%88%99%E5%B0%B1%E6%98%AF%E8%A6%81%E8%AE%B0%E4%BD%8F-mutation-%E5%BF%85%E9%A1%BB%E6%98%AF%E5%90%8C%E6%AD%A5%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.</span> <span class="nav-text">一条重要的原则就是要记住 mutation 必须是同步函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%9B%A0%EF%BC%9A-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AD%A5%E6%93%8D%E4%BD%9C"><span class="nav-number">1.5.1.</span> <span class="nav-text">原因：(为什么不能执行一步操作)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%A0%E6%AD%A4%EF%BC%9A%E3%80%90%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AAaction%E6%9D%A5%E8%BF%9B%E8%A1%8C%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E3%80%91"><span class="nav-number">1.5.2.</span> <span class="nav-text">因此：【我们需要一个action来进行异步操作】</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Action"><span class="nav-number">1.6.</span> <span class="nav-text">Action</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Action-%E7%B1%BB%E4%BC%BC%E4%BA%8E-mutation%EF%BC%8C%E4%B8%8D%E5%90%8C%E5%9C%A8%E4%BA%8E%EF%BC%9A"><span class="nav-number">1.6.1.</span> <span class="nav-text">Action 类似于 mutation，不同在于：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#store-index-js-3"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">store&#x2F;index.js</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#App-vue-3"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">App.vue</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B9%8D%E4%B8%80%E7%9C%BC%E7%9C%8B%E4%B8%8A%E5%8E%BB%E6%84%9F%E8%A7%89%E5%A4%9A%E6%AD%A4%E4%B8%80%E4%B8%BE%EF%BC%8C%E6%88%91%E4%BB%AC%E7%9B%B4%E6%8E%A5%E5%88%86%E5%8F%91-mutation-%E5%B2%82%E4%B8%8D%E6%9B%B4%E6%96%B9%E4%BE%BF%EF%BC%9F%E5%AE%9E%E9%99%85%E4%B8%8A%E5%B9%B6%E9%9D%9E%E5%A6%82%E6%AD%A4%EF%BC%8C%E8%BF%98%E8%AE%B0%E5%BE%97-mutation-%E5%BF%85%E9%A1%BB%E5%90%8C%E6%AD%A5%E6%89%A7%E8%A1%8C%E8%BF%99%E4%B8%AA%E9%99%90%E5%88%B6%E4%B9%88%EF%BC%9FAction-%E5%B0%B1%E4%B8%8D%E5%8F%97%E7%BA%A6%E6%9D%9F%EF%BC%81%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%9C%A8-action-%E5%86%85%E9%83%A8%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="nav-number">1.6.1.2.0.1.</span> <span class="nav-text">乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 mutation 必须同步执行这个限制么？Action 就不受约束！我们可以在 action 内部执行异步操作：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Module"><span class="nav-number">1.7.</span> <span class="nav-text">Module</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%B1%E4%BA%8E%E4%BD%BF%E7%94%A8%E5%8D%95%E4%B8%80%E7%8A%B6%E6%80%81%E6%A0%91%EF%BC%8C%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%80%E6%9C%89%E7%8A%B6%E6%80%81%E4%BC%9A%E9%9B%86%E4%B8%AD%E5%88%B0%E4%B8%80%E4%B8%AA%E6%AF%94%E8%BE%83%E5%A4%A7%E7%9A%84%E5%AF%B9%E8%B1%A1%E3%80%82%E5%BD%93%E5%BA%94%E7%94%A8%E5%8F%98%E5%BE%97%E9%9D%9E%E5%B8%B8%E5%A4%8D%E6%9D%82%E6%97%B6%EF%BC%8Cstore-%E5%AF%B9%E8%B1%A1%E5%B0%B1%E6%9C%89%E5%8F%AF%E8%83%BD%E5%8F%98%E5%BE%97%E7%9B%B8%E5%BD%93%E8%87%83%E8%82%BF%E3%80%82"><span class="nav-number">1.7.1.</span> <span class="nav-text">由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BA%86%E8%A7%A3%E5%86%B3%E4%BB%A5%E4%B8%8A%E9%97%AE%E9%A2%98%EF%BC%8CVuex-%E5%85%81%E8%AE%B8%E6%88%91%E4%BB%AC%E5%B0%86-store-%E5%88%86%E5%89%B2%E6%88%90%E6%A8%A1%E5%9D%97%EF%BC%88module%EF%BC%89%E3%80%82%E6%AF%8F%E4%B8%AA%E6%A8%A1%E5%9D%97%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84-state%E3%80%81mutation%E3%80%81action%E3%80%81getter%E3%80%81%E7%94%9A%E8%87%B3%E6%98%AF%E5%B5%8C%E5%A5%97%E5%AD%90%E6%A8%A1%E5%9D%97%E2%80%94%E2%80%94%E4%BB%8E%E4%B8%8A%E8%87%B3%E4%B8%8B%E8%BF%9B%E8%A1%8C%E5%90%8C%E6%A0%B7%E6%96%B9%E5%BC%8F%E7%9A%84%E5%88%86%E5%89%B2%EF%BC%9A"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#store-index-js-4"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">store&#x2F;index.js</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#App-vue-4"><span class="nav-number">1.7.1.3.</span> <span class="nav-text">App.vue</span></a></li></ol></li></ol></li></div></div></aside><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/header-shrink.js"></script><script src="/js/back2top.js"></script><script src="/js/dark-light-toggle.js"></script><script src="/js/local-search.js"></script><script src="/js/code-copy.js"></script><script src="/js/lazyload.js"></script><div class="post-scripts"><script src="/js/left-side-toggle.js"></script><script src="/js/libs/anime.min.js"></script><script src="/js/toc.js"></script></div></body></html>