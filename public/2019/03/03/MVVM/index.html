<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="Hexo Theme Keep"><meta name="author" content="小鱼仙倌"><title>mvvm原理 | 小鱼仙倌</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/favicon-32x32-next.png"><link rel="stylesheet" href="/css/font-awesome.min.css"><script id="hexo-configurations">let KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"example.com",root:"/",language:"zh-CN",path:"search.xml"},KEEP.theme_config={toc:{enable:!0,number:!0,expand_all:!0,init_open:!0},style:{primary_color:"#0066CC",avatar:"/images/headers.png",favicon:"/images/favicon-32x32-next.png",article_img_align:"left",left_side_width:"260px",content_max_width:"920px",hover:{shadow:!0,scale:!0},first_screen:{enable:!0,background_img:"/images/bg.svg",description:"天官赐福 百无禁忌"},scroll:{progress_bar:{enable:!0},percent:{enable:!0}}},local_search:{enable:!0,preload:!0},code_copy:{enable:!0,style:"mac"},pjax:{enable:!1},lazyload:{enable:!0},version:"3.4.2"},KEEP.language_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 月前",year:"%s 年前"}</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-title" href="/">小鱼仙倌</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">首页</a></li><li class="menu-item"><a href="/archives">归档</a></li><li class="menu-item"><a href="/tags">标签</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">首页</a></li><li class="drawer-menu-item flex-center"><a href="/archives">归档</a></li><li class="drawer-menu-item flex-center"><a href="/tags">标签</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">mvvm原理</span></div><div class="article-header"><div class="avatar"><img src="/images/headers.png"></div><div class="info"><div class="author"><span class="name">小鱼仙倌</span> <span class="author-label">Lv5</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fas fa-edit"></i>&nbsp;2019-03-03 11:18:38 </span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/js/">js</a>&nbsp;</li><li>| <a href="/tags/mvvm/">mvvm</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>1.9k 字</span> </span><span class="article-min2read article-meta-item"><i class="fas fa-clock"></i>&nbsp;<span>6 分钟</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body"><h2 id="mvvm模式"><a href="#mvvm模式" class="headerlink" title="mvvm模式"></a>mvvm模式</h2><h3 id="MVVM-是Model-View-ViewModel-的缩写，它是一种基于前端开发的架构模式，其核心是提供对View-和-ViewModel-的双向数据绑定，这使得ViewModel-的状态改变可以自动传递给-View，即所谓的数据双向绑定。"><a href="#MVVM-是Model-View-ViewModel-的缩写，它是一种基于前端开发的架构模式，其核心是提供对View-和-ViewModel-的双向数据绑定，这使得ViewModel-的状态改变可以自动传递给-View，即所谓的数据双向绑定。" class="headerlink" title="MVVM 是Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式，其核心是提供对View 和 ViewModel 的双向数据绑定，这使得ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定。"></a>MVVM 是Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式，其核心是提供对View 和 ViewModel 的双向数据绑定，这使得ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定。</h3><blockquote><p><strong><a class="link" target="_blank" rel="noopener" href="https://github.com/Ignorance-of-Dong/mvvm">mvvm原理源码地址<i class="fas fa-external-link-alt"></i></a></strong></p></blockquote><blockquote><p>Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。</p></blockquote><h2 id="为什么会出现-MVVM-呢？"><a href="#为什么会出现-MVVM-呢？" class="headerlink" title="为什么会出现 MVVM 呢？"></a>为什么会出现 MVVM 呢？</h2><p>###MVC 即 Model-View-Controller 的缩写，就是 模型—视图—控制器，也就是说一个标准的Web 应用程式是由这三部分组成的：</p><blockquote><ul><li>View ：用来把数据以某种方式呈现给用户</li><li>Model ：其实就是数据</li><li>Controller ：接收并处理来自用户的请求，并将 Model 返回给用户</li></ul></blockquote><h3 id="随着H5-的不断发展，人们更希望使用H5-开发的应用能和Native-媲美，或者接近于原生App-的体验效果，于是前端应用的复杂程度已不同往日，今非昔比。这时前端开发就暴露出了三个痛点问题："><a href="#随着H5-的不断发展，人们更希望使用H5-开发的应用能和Native-媲美，或者接近于原生App-的体验效果，于是前端应用的复杂程度已不同往日，今非昔比。这时前端开发就暴露出了三个痛点问题：" class="headerlink" title="随着H5 的不断发展，人们更希望使用H5 开发的应用能和Native 媲美，或者接近于原生App 的体验效果，于是前端应用的复杂程度已不同往日，今非昔比。这时前端开发就暴露出了三个痛点问题："></a>随着H5 的不断发展，人们更希望使用H5 开发的应用能和Native 媲美，或者接近于原生App 的体验效果，于是前端应用的复杂程度已不同往日，今非昔比。这时前端开发就暴露出了三个<strong>痛点</strong>问题：</h3><blockquote><ul><li>开发者在代码中大量调用相同的 DOM API，处理繁琐 ，操作冗余，使得代码难以维护。</li><li>大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。</li><li>当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致 Model 发生变化，开发者同样需要将变化的数据同步到Model 中，这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。</li></ul></blockquote><h2 id="MVVM-的出现，完美解决了以上三个问题。"><a href="#MVVM-的出现，完美解决了以上三个问题。" class="headerlink" title="MVVM 的出现，完美解决了以上三个问题。"></a>MVVM 的出现，完美解决了以上三个问题。</h2><h3 id="MVVM-由-Model、View、ViewModel-三部分构成，Model-层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View-代表UI-组件，它负责将数据模型转化成UI-展现出来，ViewModel-是一个同步View-和-Model的对象。"><a href="#MVVM-由-Model、View、ViewModel-三部分构成，Model-层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View-代表UI-组件，它负责将数据模型转化成UI-展现出来，ViewModel-是一个同步View-和-Model的对象。" class="headerlink" title="MVVM 由 Model、View、ViewModel 三部分构成，Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。"></a>MVVM 由 Model、View、ViewModel 三部分构成，Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。</h3><blockquote><p>在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。</p></blockquote><h3 id="ViewModel-通过双向数据绑定把-View-层和-Model-层连接了起来，而View-和-Model-之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM，-不需要关注数据状态的同步问题，复杂的数据状态维护完全由-MVVM-来统一管理。"><a href="#ViewModel-通过双向数据绑定把-View-层和-Model-层连接了起来，而View-和-Model-之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM，-不需要关注数据状态的同步问题，复杂的数据状态维护完全由-MVVM-来统一管理。" class="headerlink" title="ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM， 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。"></a>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM， 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</h3><h2 id="Vue-js-的细节"><a href="#Vue-js-的细节" class="headerlink" title="Vue.js 的细节"></a><strong>Vue.js 的细节</strong></h2><h4 id="Vue-js-可以说是MVVM-架构的最佳实践，专注于-MVVM-中的-ViewModel，不仅做到了数据双向绑定，而且也是一款相对来比较轻量级的JS-库，API-简洁，很容易上手。Vue的基础知识网上有现成的教程，此处不再赘述，-下面简单了解一下-Vue-js-关于双向绑定的一些实现细节："><a href="#Vue-js-可以说是MVVM-架构的最佳实践，专注于-MVVM-中的-ViewModel，不仅做到了数据双向绑定，而且也是一款相对来比较轻量级的JS-库，API-简洁，很容易上手。Vue的基础知识网上有现成的教程，此处不再赘述，-下面简单了解一下-Vue-js-关于双向绑定的一些实现细节：" class="headerlink" title="Vue.js 可以说是MVVM 架构的最佳实践，专注于 MVVM 中的 ViewModel，不仅做到了数据双向绑定，而且也是一款相对来比较轻量级的JS 库，API 简洁，很容易上手。Vue的基础知识网上有现成的教程，此处不再赘述， 下面简单了解一下 Vue.js 关于双向绑定的一些实现细节："></a>Vue.js 可以说是MVVM 架构的最佳实践，专注于 MVVM 中的 ViewModel，不仅做到了数据双向绑定，而且也是一款相对来比较轻量级的JS 库，API 简洁，很容易上手。Vue的基础知识网上有现成的教程，此处不再赘述， 下面简单了解一下 Vue.js 关于双向绑定的一些实现细节：</h4><blockquote><p>Vue.js 是采用 Object.defineProperty 的 getter 和 setter，并结合观察者模式来实现数据绑定的。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。</p></blockquote><p><img src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/1.0.png"></p><ul><li>Observer ：数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用Object.defineProperty的getter和setter来实现</li><li>Compile ：指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数</li><li>Watcher ：订阅者，作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数</li><li>Dep ：消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法</li></ul><blockquote><p>从图中可以看出，当执行 new Vue() 时，Vue 就进入了初始化阶段，一方面Vue 会遍历 data 选项中的属性，并用 Object.defineProperty 将它们转为 getter/setter，实现数据变化监听功能；另一方面，Vue 的指令编译器Compile 对元素节点的指令进行扫描和解析，初始化视图，并订阅 Watcher 来更新视图， 此时Wather 会将自己添加到消息订阅器中(Dep)，初始化完毕。</p></blockquote><hr><blockquote><p>当数据发生变化时，Observer 中的 setter 方法被触发，setter 会立即调用Dep.notify()，Dep 开始遍历所有的订阅者，并调用订阅者的 update 方法，订阅者收到通知后对视图进行相应的更新。</p></blockquote><h2 id="MVVM？比之-MVC-有什么区别？"><a href="#MVVM？比之-MVC-有什么区别？" class="headerlink" title="MVVM？比之 MVC 有什么区别？"></a>MVVM？比之 MVC 有什么区别？</h2><h3 id="首先先来说下-View-和-Model"><a href="#首先先来说下-View-和-Model" class="headerlink" title="首先先来说下 View 和 Model"></a>首先先来说下 View 和 Model</h3><ul><li>View 很简单，就是用户看到的视图</li><li>Model 同样很简单，一般就是本地数据和数据库中的数据</li></ul><h3 id="基本上，我们写的产品就是通过接口从数据库中读取数据，然后将数据经过处理展现到用户看到的视图上。当然我们还可以从视图上读取用户的输入，然后又将用户的输入通过接口写入到数据库中。但是，如何将数据展示到视图上，然后又如何将用户的输入写入到数据中，不同的人就产生了不同的看法，从此出现了很多种架构设计。"><a href="#基本上，我们写的产品就是通过接口从数据库中读取数据，然后将数据经过处理展现到用户看到的视图上。当然我们还可以从视图上读取用户的输入，然后又将用户的输入通过接口写入到数据库中。但是，如何将数据展示到视图上，然后又如何将用户的输入写入到数据中，不同的人就产生了不同的看法，从此出现了很多种架构设计。" class="headerlink" title="基本上，我们写的产品就是通过接口从数据库中读取数据，然后将数据经过处理展现到用户看到的视图上。当然我们还可以从视图上读取用户的输入，然后又将用户的输入通过接口写入到数据库中。但是，如何将数据展示到视图上，然后又如何将用户的输入写入到数据中，不同的人就产生了不同的看法，从此出现了很多种架构设计。"></a>基本上，我们写的产品就是通过接口从数据库中读取数据，然后将数据经过处理展现到用户看到的视图上。当然我们还可以从视图上读取用户的输入，然后又将用户的输入通过接口写入到数据库中。但是，如何将数据展示到视图上，然后又如何将用户的输入写入到数据中，不同的人就产生了不同的看法，从此出现了很多种架构设计。</h3><h4 id="传统的-MVC-架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。"><a href="#传统的-MVC-架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。" class="headerlink" title="传统的 MVC 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。"></a>传统的 MVC 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。</h4><p><img src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/1.1.png"></p><p>####但是 MVC 有一个巨大的缺陷就是控制器承担的责任太大了，随着项目愈加复杂，控制器中的代码会越来越臃肿，导致出现不利于维护的情况。</p><h3 id="在-MVVM-架构中，引入了-ViewModel-的概念。ViewModel-只关心数据和业务的处理，不关心-View-如何处理数据，在这种情况下，View-和-Model-都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个-ViewModel-中，让多个-View-复用这个-ViewModel。"><a href="#在-MVVM-架构中，引入了-ViewModel-的概念。ViewModel-只关心数据和业务的处理，不关心-View-如何处理数据，在这种情况下，View-和-Model-都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个-ViewModel-中，让多个-View-复用这个-ViewModel。" class="headerlink" title="在 MVVM 架构中，引入了 ViewModel 的概念。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。"></a>在 MVVM 架构中，引入了 ViewModel 的概念。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。</h3><p><img src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/1.2.png"></p><h3 id="以-Vue-框架来举例，ViewModel-就是组件的实例。View-就是模板，Model-的话在引入-Vuex-的情况下是完全可以和组件分离的。"><a href="#以-Vue-框架来举例，ViewModel-就是组件的实例。View-就是模板，Model-的话在引入-Vuex-的情况下是完全可以和组件分离的。" class="headerlink" title="以 Vue 框架来举例，ViewModel 就是组件的实例。View 就是模板，Model 的话在引入 Vuex 的情况下是完全可以和组件分离的。"></a>以 Vue 框架来举例，ViewModel 就是组件的实例。View 就是模板，Model 的话在引入 Vuex 的情况下是完全可以和组件分离的。</h3><p>####除了以上三个部分，其实在 MVVM 中还引入了一个隐式的 Binder 层，实现了 View 和 ViewModel 的绑定。</p><p><img src="https://raw.githubusercontent.com/Ignorance-of-Dong/GraphBed/master/images/1.3.png"></p><h5 id="同样以-Vue-框架来举例，这个隐式的-Binder-层就是-Vue-通过解析模板中的插值和指令从而实现-View-与-ViewModel-的绑定。"><a href="#同样以-Vue-框架来举例，这个隐式的-Binder-层就是-Vue-通过解析模板中的插值和指令从而实现-View-与-ViewModel-的绑定。" class="headerlink" title="同样以 Vue 框架来举例，这个隐式的 Binder 层就是 Vue 通过解析模板中的插值和指令从而实现 View 与 ViewModel 的绑定。"></a>同样以 Vue 框架来举例，这个隐式的 Binder 层就是 Vue 通过解析模板中的插值和指令从而实现 View 与 ViewModel 的绑定。</h5><p>对于 MVVM 来说，其实最重要的并不是通过双向绑定或者其他的方式将 View 与 ViewModel 绑定起来，<strong>而是通过 ViewModel 将视图中的状态和用户的行为分离出一个抽象，这才是 MVVM 的精髓。</strong></p></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul><li>本文标题：mvvm原理</li><li>本文作者：小鱼仙倌</li><li>创建时间：2019-03-03 11:18:38</li><li>本文链接：http://fishfairy.cn/2019/03/03/MVVM/</li><li>版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></div><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2019/03/04/stack%20heap/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">JS 堆&amp;栈</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2019/02/25/json%20web%20token/"><span class="title flex-center"><span class="post-nav-title-item">json web token【跨域认证的解决方案】</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2018</span>&nbsp;-&nbsp; 2021&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">小鱼仙倌</a></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item"><span id="busuanzi_container_site_uv">访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; </span><span id="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></span></div><div class="icp-info info-item"><a target="_blank" rel="nofollow" href="https://beian.miit.gov.cn">晋ICP备18012867号-2</a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item page-aside-toggle"><i class="fas fa-outdent"></i></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-expand-width flex-center"><i class="fas fa-arrows-alt-h"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><aside class="page-aside"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#mvvm%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.</span> <span class="nav-text">mvvm模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MVVM-%E6%98%AFModel-View-ViewModel-%E7%9A%84%E7%BC%A9%E5%86%99%EF%BC%8C%E5%AE%83%E6%98%AF%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%85%B6%E6%A0%B8%E5%BF%83%E6%98%AF%E6%8F%90%E4%BE%9B%E5%AF%B9View-%E5%92%8C-ViewModel-%E7%9A%84%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%EF%BC%8C%E8%BF%99%E4%BD%BF%E5%BE%97ViewModel-%E7%9A%84%E7%8A%B6%E6%80%81%E6%94%B9%E5%8F%98%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%8A%A8%E4%BC%A0%E9%80%92%E7%BB%99-View%EF%BC%8C%E5%8D%B3%E6%89%80%E8%B0%93%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E3%80%82"><span class="nav-number">1.1.</span> <span class="nav-text">MVVM 是Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式，其核心是提供对View 和 ViewModel 的双向数据绑定，这使得ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0-MVVM-%E5%91%A2%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">为什么会出现 MVVM 呢？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%8F%E7%9D%80H5-%E7%9A%84%E4%B8%8D%E6%96%AD%E5%8F%91%E5%B1%95%EF%BC%8C%E4%BA%BA%E4%BB%AC%E6%9B%B4%E5%B8%8C%E6%9C%9B%E4%BD%BF%E7%94%A8H5-%E5%BC%80%E5%8F%91%E7%9A%84%E5%BA%94%E7%94%A8%E8%83%BD%E5%92%8CNative-%E5%AA%B2%E7%BE%8E%EF%BC%8C%E6%88%96%E8%80%85%E6%8E%A5%E8%BF%91%E4%BA%8E%E5%8E%9F%E7%94%9FApp-%E7%9A%84%E4%BD%93%E9%AA%8C%E6%95%88%E6%9E%9C%EF%BC%8C%E4%BA%8E%E6%98%AF%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E7%9A%84%E5%A4%8D%E6%9D%82%E7%A8%8B%E5%BA%A6%E5%B7%B2%E4%B8%8D%E5%90%8C%E5%BE%80%E6%97%A5%EF%BC%8C%E4%BB%8A%E9%9D%9E%E6%98%94%E6%AF%94%E3%80%82%E8%BF%99%E6%97%B6%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B0%B1%E6%9A%B4%E9%9C%B2%E5%87%BA%E4%BA%86%E4%B8%89%E4%B8%AA%E7%97%9B%E7%82%B9%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="nav-number">2.1.</span> <span class="nav-text">随着H5 的不断发展，人们更希望使用H5 开发的应用能和Native 媲美，或者接近于原生App 的体验效果，于是前端应用的复杂程度已不同往日，今非昔比。这时前端开发就暴露出了三个痛点问题：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MVVM-%E7%9A%84%E5%87%BA%E7%8E%B0%EF%BC%8C%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%A5%E4%B8%8A%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98%E3%80%82"><span class="nav-number">3.</span> <span class="nav-text">MVVM 的出现，完美解决了以上三个问题。</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MVVM-%E7%94%B1-Model%E3%80%81View%E3%80%81ViewModel-%E4%B8%89%E9%83%A8%E5%88%86%E6%9E%84%E6%88%90%EF%BC%8CModel-%E5%B1%82%E4%BB%A3%E8%A1%A8%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%9C%A8Model%E4%B8%AD%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E4%BF%AE%E6%94%B9%E5%92%8C%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%EF%BC%9BView-%E4%BB%A3%E8%A1%A8UI-%E7%BB%84%E4%BB%B6%EF%BC%8C%E5%AE%83%E8%B4%9F%E8%B4%A3%E5%B0%86%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E8%BD%AC%E5%8C%96%E6%88%90UI-%E5%B1%95%E7%8E%B0%E5%87%BA%E6%9D%A5%EF%BC%8CViewModel-%E6%98%AF%E4%B8%80%E4%B8%AA%E5%90%8C%E6%AD%A5View-%E5%92%8C-Model%E7%9A%84%E5%AF%B9%E8%B1%A1%E3%80%82"><span class="nav-number">3.1.</span> <span class="nav-text">MVVM 由 Model、View、ViewModel 三部分构成，Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ViewModel-%E9%80%9A%E8%BF%87%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E6%8A%8A-View-%E5%B1%82%E5%92%8C-Model-%E5%B1%82%E8%BF%9E%E6%8E%A5%E4%BA%86%E8%B5%B7%E6%9D%A5%EF%BC%8C%E8%80%8CView-%E5%92%8C-Model-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%90%8C%E6%AD%A5%E5%B7%A5%E4%BD%9C%E5%AE%8C%E5%85%A8%E6%98%AF%E8%87%AA%E5%8A%A8%E7%9A%84%EF%BC%8C%E6%97%A0%E9%9C%80%E4%BA%BA%E4%B8%BA%E5%B9%B2%E6%B6%89%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%BC%80%E5%8F%91%E8%80%85%E5%8F%AA%E9%9C%80%E5%85%B3%E6%B3%A8%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%EF%BC%8C%E4%B8%8D%E9%9C%80%E8%A6%81%E6%89%8B%E5%8A%A8%E6%93%8D%E4%BD%9CDOM%EF%BC%8C-%E4%B8%8D%E9%9C%80%E8%A6%81%E5%85%B3%E6%B3%A8%E6%95%B0%E6%8D%AE%E7%8A%B6%E6%80%81%E7%9A%84%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A4%8D%E6%9D%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%8A%B6%E6%80%81%E7%BB%B4%E6%8A%A4%E5%AE%8C%E5%85%A8%E7%94%B1-MVVM-%E6%9D%A5%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86%E3%80%82"><span class="nav-number">3.2.</span> <span class="nav-text">ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM， 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-js-%E7%9A%84%E7%BB%86%E8%8A%82"><span class="nav-number">4.</span> <span class="nav-text">Vue.js 的细节</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Vue-js-%E5%8F%AF%E4%BB%A5%E8%AF%B4%E6%98%AFMVVM-%E6%9E%B6%E6%9E%84%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%8C%E4%B8%93%E6%B3%A8%E4%BA%8E-MVVM-%E4%B8%AD%E7%9A%84-ViewModel%EF%BC%8C%E4%B8%8D%E4%BB%85%E5%81%9A%E5%88%B0%E4%BA%86%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%EF%BC%8C%E8%80%8C%E4%B8%94%E4%B9%9F%E6%98%AF%E4%B8%80%E6%AC%BE%E7%9B%B8%E5%AF%B9%E6%9D%A5%E6%AF%94%E8%BE%83%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84JS-%E5%BA%93%EF%BC%8CAPI-%E7%AE%80%E6%B4%81%EF%BC%8C%E5%BE%88%E5%AE%B9%E6%98%93%E4%B8%8A%E6%89%8B%E3%80%82Vue%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%BD%91%E4%B8%8A%E6%9C%89%E7%8E%B0%E6%88%90%E7%9A%84%E6%95%99%E7%A8%8B%EF%BC%8C%E6%AD%A4%E5%A4%84%E4%B8%8D%E5%86%8D%E8%B5%98%E8%BF%B0%EF%BC%8C-%E4%B8%8B%E9%9D%A2%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B-Vue-js-%E5%85%B3%E4%BA%8E%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82%EF%BC%9A"><span class="nav-number">4.0.1.</span> <span class="nav-text">Vue.js 可以说是MVVM 架构的最佳实践，专注于 MVVM 中的 ViewModel，不仅做到了数据双向绑定，而且也是一款相对来比较轻量级的JS 库，API 简洁，很容易上手。Vue的基础知识网上有现成的教程，此处不再赘述， 下面简单了解一下 Vue.js 关于双向绑定的一些实现细节：</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#MVVM%EF%BC%9F%E6%AF%94%E4%B9%8B-MVC-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">MVVM？比之 MVC 有什么区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A6%96%E5%85%88%E5%85%88%E6%9D%A5%E8%AF%B4%E4%B8%8B-View-%E5%92%8C-Model"><span class="nav-number">5.1.</span> <span class="nav-text">首先先来说下 View 和 Model</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%B8%8A%EF%BC%8C%E6%88%91%E4%BB%AC%E5%86%99%E7%9A%84%E4%BA%A7%E5%93%81%E5%B0%B1%E6%98%AF%E9%80%9A%E8%BF%87%E6%8E%A5%E5%8F%A3%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%EF%BC%8C%E7%84%B6%E5%90%8E%E5%B0%86%E6%95%B0%E6%8D%AE%E7%BB%8F%E8%BF%87%E5%A4%84%E7%90%86%E5%B1%95%E7%8E%B0%E5%88%B0%E7%94%A8%E6%88%B7%E7%9C%8B%E5%88%B0%E7%9A%84%E8%A7%86%E5%9B%BE%E4%B8%8A%E3%80%82%E5%BD%93%E7%84%B6%E6%88%91%E4%BB%AC%E8%BF%98%E5%8F%AF%E4%BB%A5%E4%BB%8E%E8%A7%86%E5%9B%BE%E4%B8%8A%E8%AF%BB%E5%8F%96%E7%94%A8%E6%88%B7%E7%9A%84%E8%BE%93%E5%85%A5%EF%BC%8C%E7%84%B6%E5%90%8E%E5%8F%88%E5%B0%86%E7%94%A8%E6%88%B7%E7%9A%84%E8%BE%93%E5%85%A5%E9%80%9A%E8%BF%87%E6%8E%A5%E5%8F%A3%E5%86%99%E5%85%A5%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E3%80%82%E4%BD%86%E6%98%AF%EF%BC%8C%E5%A6%82%E4%BD%95%E5%B0%86%E6%95%B0%E6%8D%AE%E5%B1%95%E7%A4%BA%E5%88%B0%E8%A7%86%E5%9B%BE%E4%B8%8A%EF%BC%8C%E7%84%B6%E5%90%8E%E5%8F%88%E5%A6%82%E4%BD%95%E5%B0%86%E7%94%A8%E6%88%B7%E7%9A%84%E8%BE%93%E5%85%A5%E5%86%99%E5%85%A5%E5%88%B0%E6%95%B0%E6%8D%AE%E4%B8%AD%EF%BC%8C%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%BA%E5%B0%B1%E4%BA%A7%E7%94%9F%E4%BA%86%E4%B8%8D%E5%90%8C%E7%9A%84%E7%9C%8B%E6%B3%95%EF%BC%8C%E4%BB%8E%E6%AD%A4%E5%87%BA%E7%8E%B0%E4%BA%86%E5%BE%88%E5%A4%9A%E7%A7%8D%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E3%80%82"><span class="nav-number">5.2.</span> <span class="nav-text">基本上，我们写的产品就是通过接口从数据库中读取数据，然后将数据经过处理展现到用户看到的视图上。当然我们还可以从视图上读取用户的输入，然后又将用户的输入通过接口写入到数据库中。但是，如何将数据展示到视图上，然后又如何将用户的输入写入到数据中，不同的人就产生了不同的看法，从此出现了很多种架构设计。</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E7%9A%84-MVC-%E6%9E%B6%E6%9E%84%E9%80%9A%E5%B8%B8%E6%98%AF%E4%BD%BF%E7%94%A8%E6%8E%A7%E5%88%B6%E5%99%A8%E6%9B%B4%E6%96%B0%E6%A8%A1%E5%9E%8B%EF%BC%8C%E8%A7%86%E5%9B%BE%E4%BB%8E%E6%A8%A1%E5%9E%8B%E4%B8%AD%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%8E%BB%E6%B8%B2%E6%9F%93%E3%80%82%E5%BD%93%E7%94%A8%E6%88%B7%E6%9C%89%E8%BE%93%E5%85%A5%E6%97%B6%EF%BC%8C%E4%BC%9A%E9%80%9A%E8%BF%87%E6%8E%A7%E5%88%B6%E5%99%A8%E5%8E%BB%E6%9B%B4%E6%96%B0%E6%A8%A1%E5%9E%8B%EF%BC%8C%E5%B9%B6%E4%B8%94%E9%80%9A%E7%9F%A5%E8%A7%86%E5%9B%BE%E8%BF%9B%E8%A1%8C%E6%9B%B4%E6%96%B0%E3%80%82"><span class="nav-number">5.2.1.</span> <span class="nav-text">传统的 MVC 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8-MVVM-%E6%9E%B6%E6%9E%84%E4%B8%AD%EF%BC%8C%E5%BC%95%E5%85%A5%E4%BA%86-ViewModel-%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%82ViewModel-%E5%8F%AA%E5%85%B3%E5%BF%83%E6%95%B0%E6%8D%AE%E5%92%8C%E4%B8%9A%E5%8A%A1%E7%9A%84%E5%A4%84%E7%90%86%EF%BC%8C%E4%B8%8D%E5%85%B3%E5%BF%83-View-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%9C%A8%E8%BF%99%E7%A7%8D%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8CView-%E5%92%8C-Model-%E9%83%BD%E5%8F%AF%E4%BB%A5%E7%8B%AC%E7%AB%8B%E5%87%BA%E6%9D%A5%EF%BC%8C%E4%BB%BB%E4%BD%95%E4%B8%80%E6%96%B9%E6%94%B9%E5%8F%98%E4%BA%86%E4%B9%9F%E4%B8%8D%E4%B8%80%E5%AE%9A%E9%9C%80%E8%A6%81%E6%94%B9%E5%8F%98%E5%8F%A6%E4%B8%80%E6%96%B9%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%8F%AF%E4%BB%A5%E5%B0%86%E4%B8%80%E4%BA%9B%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E9%80%BB%E8%BE%91%E6%94%BE%E5%9C%A8%E4%B8%80%E4%B8%AA-ViewModel-%E4%B8%AD%EF%BC%8C%E8%AE%A9%E5%A4%9A%E4%B8%AA-View-%E5%A4%8D%E7%94%A8%E8%BF%99%E4%B8%AA-ViewModel%E3%80%82"><span class="nav-number">5.3.</span> <span class="nav-text">在 MVVM 架构中，引入了 ViewModel 的概念。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A5-Vue-%E6%A1%86%E6%9E%B6%E6%9D%A5%E4%B8%BE%E4%BE%8B%EF%BC%8CViewModel-%E5%B0%B1%E6%98%AF%E7%BB%84%E4%BB%B6%E7%9A%84%E5%AE%9E%E4%BE%8B%E3%80%82View-%E5%B0%B1%E6%98%AF%E6%A8%A1%E6%9D%BF%EF%BC%8CModel-%E7%9A%84%E8%AF%9D%E5%9C%A8%E5%BC%95%E5%85%A5-Vuex-%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%98%AF%E5%AE%8C%E5%85%A8%E5%8F%AF%E4%BB%A5%E5%92%8C%E7%BB%84%E4%BB%B6%E5%88%86%E7%A6%BB%E7%9A%84%E3%80%82"><span class="nav-number">5.4.</span> <span class="nav-text">以 Vue 框架来举例，ViewModel 就是组件的实例。View 就是模板，Model 的话在引入 Vuex 的情况下是完全可以和组件分离的。</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8C%E6%A0%B7%E4%BB%A5-Vue-%E6%A1%86%E6%9E%B6%E6%9D%A5%E4%B8%BE%E4%BE%8B%EF%BC%8C%E8%BF%99%E4%B8%AA%E9%9A%90%E5%BC%8F%E7%9A%84-Binder-%E5%B1%82%E5%B0%B1%E6%98%AF-Vue-%E9%80%9A%E8%BF%87%E8%A7%A3%E6%9E%90%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84%E6%8F%92%E5%80%BC%E5%92%8C%E6%8C%87%E4%BB%A4%E4%BB%8E%E8%80%8C%E5%AE%9E%E7%8E%B0-View-%E4%B8%8E-ViewModel-%E7%9A%84%E7%BB%91%E5%AE%9A%E3%80%82"><span class="nav-number">5.4.0.1.</span> <span class="nav-text">同样以 Vue 框架来举例，这个隐式的 Binder 层就是 Vue 通过解析模板中的插值和指令从而实现 View 与 ViewModel 的绑定。</span></a></li></ol></li></ol></li></div></div></aside><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/header-shrink.js"></script><script src="/js/back2top.js"></script><script src="/js/dark-light-toggle.js"></script><script src="/js/local-search.js"></script><script src="/js/code-copy.js"></script><script src="/js/lazyload.js"></script><div class="post-scripts"><script src="/js/left-side-toggle.js"></script><script src="/js/libs/anime.min.js"></script><script src="/js/toc.js"></script></div></body></html>