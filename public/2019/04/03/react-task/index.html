<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="Hexo Theme Keep"><meta name="author" content="小鱼仙倌"><title>react的概述 | 小鱼仙倌</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/favicon-32x32-next.png"><link rel="stylesheet" href="/css/font-awesome.min.css"><script id="hexo-configurations">let KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"example.com",root:"/",language:"zh-CN",path:"search.xml"},KEEP.theme_config={toc:{enable:!0,number:!0,expand_all:!0,init_open:!0},style:{primary_color:"#0066CC",avatar:"/images/headers.png",favicon:"/images/favicon-32x32-next.png",article_img_align:"left",left_side_width:"260px",content_max_width:"920px",hover:{shadow:!0,scale:!0},first_screen:{enable:!0,background_img:"/images/bg.svg",description:"天官赐福 百无禁忌"},scroll:{progress_bar:{enable:!0},percent:{enable:!0}}},local_search:{enable:!0,preload:!0},code_copy:{enable:!0,style:"mac"},pjax:{enable:!1},lazyload:{enable:!0},version:"3.4.2"},KEEP.language_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 月前",year:"%s 年前"}</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-title" href="/">小鱼仙倌</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">首页</a></li><li class="menu-item"><a href="/archives">归档</a></li><li class="menu-item"><a href="/tags">标签</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">首页</a></li><li class="drawer-menu-item flex-center"><a href="/archives">归档</a></li><li class="drawer-menu-item flex-center"><a href="/tags">标签</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">react的概述</span></div><div class="article-header"><div class="avatar"><img src="/images/headers.png"></div><div class="info"><div class="author"><span class="name">小鱼仙倌</span> <span class="author-label">Lv5</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fas fa-edit"></i>&nbsp;2019-04-03 19:28:59 </span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/js/">js</a>&nbsp;</li><li>| <a href="/tags/react/">react</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>2k 字</span> </span><span class="article-min2read article-meta-item"><i class="fas fa-clock"></i>&nbsp;<span>7 分钟</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body"><h2 id="react的概述"><a href="#react的概述" class="headerlink" title="react的概述"></a>react的概述</h2><h3 id="什么是react"><a href="#什么是react" class="headerlink" title="什么是react"></a>什么是react</h3><blockquote><p>react是一个前端的js库，用于构建用户界面，尤其是单页面应用程序</p></blockquote><h3 id="react的特点："><a href="#react的特点：" class="headerlink" title="react的特点："></a>react的特点：</h3><blockquote><p>单向数据流，组件化开发，虚拟dom，jsx，只关注mv*中的m这一层，渲染性能好</p></blockquote><h3 id="react组件的划分"><a href="#react组件的划分" class="headerlink" title="react组件的划分"></a>react组件的划分</h3><ul><li>业务组件</li></ul><p><strong>每个功能对应的业务逻辑划分</strong></p><ul><li>展示组件</li></ul><p><strong>列表，按钮表单。。。ui组件</strong></p><ul><li>容器组件</li></ul><p><strong>包装的盒子，页面组件</strong></p><ul><li>木偶组件</li></ul><p><strong>展示组件，功能组件【一些效果】</strong></p><blockquote><p>components[业务组件]（展示组件，木偶组件，容器组件）<br>views[页面组件]</p></blockquote><h3 id="创建组件方式"><a href="#创建组件方式" class="headerlink" title="创建组件方式"></a>创建组件方式</h3><blockquote><p><strong>class组件创建：业务组件，页面组件</strong></p><p><strong>函数式创建：展示组件，包装类型组件</strong></p></blockquote><h3 id="render用法"><a href="#render用法" class="headerlink" title="render用法"></a>render用法</h3><ul><li>在react中有两个render，一个是组件内部的render，一个是reactdom的render</li><li>组建的render用来返回一个虚拟dom，在里面不能修改state，只能读取</li><li>虚拟dom是通过编译器，将jsx转化为react.createElement()的方法调用，这个方法的返回结果就是一个jsx对象【虚拟dom】</li><li>每一个组件都必须有render这个方法</li><li>reactdom的render只是将虚拟dom渲染到页面中</li></ul><h3 id="react中的state"><a href="#react中的state" class="headerlink" title="react中的state"></a>react中的state</h3><p><strong>state只能定义在construct中的this.state中，函数式的组件没有state</strong></p><p><strong>修改state只能通过setState方法，只能修改一级属性，不能修改索引数组，不能通过属性修改对象</strong></p><p><strong>读取使用this.state.xxx，this.props.xxx</strong></p><p><strong>定义props默认值使用static defaultProps</strong></p><h3 id="react的生明周期"><a href="#react的生明周期" class="headerlink" title="react的生明周期"></a>react的生明周期</h3><blockquote><p><strong>组件初始化阶段</strong></p></blockquote><pre><code>import React, &#123; Component &#125; from &#39;react&#39;;

class Test extends Component &#123;
  constructor(props) &#123;
    super(props);
  &#125;
&#125;
</code></pre><blockquote><p><strong>组件挂载阶段</strong></p></blockquote><pre><code>componentWillMount:
</code></pre><p><strong>在组件挂载到DOM前调用，且只会被调用一次，在这边调用this.setState不会引起组件重新渲染，也可以把写在这边的内容提前到constructor()中，所以项目中很少用。</strong></p><pre><code>render:
</code></pre><p><strong>根据组件的props和state（无两者的重传递和重赋值，论值是否有变化，都可以引起组件重新render） ，return 一个React元素（描述组件，即UI），不负责组件实际渲染工作，之后由React自身根据此元素去渲染出页面DOM。render是纯函数（Pure function：函数的返回结果只依赖于它的参数；函数执行过程里面没有副作用），不能在里面执行this.setState，会有改变组件状态的副作用。</strong></p><pre><code>componentDidMount:
</code></pre><p><strong>组件挂载到DOM后调用，且只会被调用一次</strong></p><blockquote><p><strong>组件更新阶段</strong></p></blockquote><p><strong>setState引起的state更新或父组件重新render引起的props更新，更新后的state和props相对之前无论是否有变化，都将引起子组件的重新render。</strong></p><h4 id="造成组件更新有两类（三种）情况："><a href="#造成组件更新有两类（三种）情况：" class="headerlink" title="造成组件更新有两类（三种）情况："></a>造成组件更新有两类（三种）情况：</h4><ul><li>父组件重新render</li></ul><p><strong>每当父组件重新render的导致的重传props，子组件将直接跟着重新渲染，可以通过shouldComponentUpdate方法进行优化</strong></p><pre><code>class Child extends Component &#123;
   shouldComponentUpdate(nextProps)&#123; // 应该使用这个方法，否则无论props是否有变化都将会导致组件跟着重新渲染
        if(nextProps.someThings === this.props.someThings)&#123;
          return false
        &#125;
    &#125;
    render() &#123;
        return &lt;div&gt;&#123;this.props.someThings&#125;&lt;/div&gt;
    &#125;
&#125;
</code></pre><p><strong>在componentWillReceiveProps方法中，将props转换成自己的state</strong></p><pre><code>class Child extends Component &#123;
    constructor(props) &#123;
        super(props);
        this.state = &#123;
            someThings: props.someThings
        &#125;;
    &#125;
    componentWillReceiveProps(nextProps) &#123; // 父组件重传props时就会调用这个方法
        this.setState(&#123;someThings: nextProps.someThings&#125;);
    &#125;
    render() &#123;
        return &lt;div&gt;&#123;this.state.someThings&#125;&lt;/div&gt;
    &#125;
&#125;
</code></pre><ul><li>. 组件本身调用setState，无论state有没有变化。可通过shouldComponentUpdate方法优化。</li></ul><hr><pre><code>class Child extends Component &#123;
   constructor(props) &#123;
        super(props);
        this.state = &#123;
          someThings:1
        &#125;
   &#125;
   shouldComponentUpdate(nextStates)&#123; // 应该使用这个方法，否则无论state是否有变化都将会导致组件重新渲染
        if(nextStates.someThings === this.state.someThings)&#123;
          return false
        &#125;
    &#125;

   handleClick = () =&gt; &#123; // 虽然调用了setState ，但state并无变化
        const preSomeThings = this.state.someThings
         this.setState(&#123;
            someThings: preSomeThings
         &#125;)
   &#125;

    render() &#123;
        return &lt;div onClick = &#123;this.handleClick&#125;&gt;&#123;this.state.someThings&#125;&lt;/div&gt;
    &#125;
&#125;
</code></pre><hr><h2 id="执行顺序："><a href="#执行顺序：" class="headerlink" title="执行顺序："></a><strong>执行顺序：</strong></h2><pre><code>componentWillReceiveProps

shouldComponentUpdate

componentWillUpdate

render

componentDidUpdate
</code></pre><hr><pre><code>componentWillReceiveProps(nextProps)
</code></pre><p><strong>此方法只调用于props引起的组件更新过程中，参数nextProps是父组件传给当前组件的新props。但父组件render方法的调用不能保证重传给当前组件的props是有变化的，所以在此方法中根据nextProps和this.props来查明重传的props是否改变，以及如果改变了要执行啥，比如根据新的props调用this.setState出发当前组件的重新render</strong></p><pre><code>shouldComponentUpdate(nextProps, nextState)
</code></pre><p><strong>此方法通过比较nextProps，nextState及当前组件的this.props，this.state，返回true时当前组件将继续执行更新过程，返回false则当前组件更新停止，以此可用来减少组件的不必要渲染，优化组件性能。</strong></p><pre><code>componentWillUpdate(nextProps, nextState)
</code></pre><p><strong>此方法在调用render方法前执行，在这边可执行一些组件更新发生前的工作，一般较少用。</strong></p><pre><code>render
</code></pre><p><strong>只是重新调用。</strong></p><pre><code>componentDidUpdate(prevProps, prevState)
</code></pre><p><strong>此方法在组件更新后被调用，可以操作组件更新的DOM，prevProps和prevState这两个参数指的是组件更新前的props和state</strong></p><blockquote><p><strong>卸载阶段</strong></p></blockquote><pre><code>componentWillUnmount
</code></pre><p><strong>此方法在组件被卸载前调用，可以在这里执行一些清理工作，比如清楚组件中使用的定时器，清楚componentDidMount中手动创建的DOM元素等，以避免引起内存泄漏。</strong></p><h2 id="React-v16-4-的生命周期"><a href="#React-v16-4-的生命周期" class="headerlink" title="React v16.4 的生命周期"></a>React v16.4 的生命周期</h2><h3 id="变更缘由"><a href="#变更缘由" class="headerlink" title="变更缘由"></a>变更缘由</h3><p><strong>原来（React v16.0前）的生命周期在React v16推出的Fiber之后就不合适了，因为如果要开启async rendering，在render函数之前的所有函数，都有可能被执行多次。</strong></p><p><strong>原来（React v16.0前）的生命周期有哪些是在render前执行的呢？</strong></p><ul><li>componentWillMount</li><li>componentWillReceiveProps</li><li>shouldComponentUpdate</li><li>componentWillUpdate</li></ul><p><strong>如果开发者开了async rendering，而且又在以上这些render前执行的生命周期方法做AJAX请求的话，那AJAX将被无谓地多次调用。。。明显不是我们期望的结果。而且在componentWillMount里发起AJAX，不管多快得到结果也赶不上首次render，而且componentWillMount在服务器端渲染也会被调用到（当然，也许这是预期的结果），这样的IO操作放在componentDidMount里更合适。</strong></p><p><strong>因此引入两个新增的生命周期函数</strong></p><pre><code>getDerivedStateFromProps

getSnapshotBeforeUpdate
</code></pre><p><strong>随着getDerivedStateFromProps的推出，同时deprecate了一组生命周期API，包括：</strong></p><ul><li>componentWillReceiveProps</li><li>componentWillMount</li><li>componentWillUpdate</li></ul><hr><p><strong>按照官方说法，以前需要利用被deprecate的所有生命周期函数才能实现的功能，都可以通过getDerivedStateFromProps的帮助来实现。</strong></p><p><strong>这个getDerivedStateFromProps是一个静态函数，所以函数体内不能访问this，简单说，就是应该一个纯函数，纯函数是一个好东西啊，输出完全由输入决定。</strong></p><pre><code>static getDerivedStateFromProps(nextProps, prevState) &#123;
  //根据nextProps和prevState计算出预期的状态改变，返回结果会被送给setState
&#125;
</code></pre><p><strong>所有被deprecate的生命周期函数，目前还凑合着用，但是只要用了，开发模式下会有红色警告，在下一个大版本（也就是React v17)更新时会彻底废弃。</strong></p><hr><p><strong>getSnapshotBeforeUpdate，这函数会在render之后执行，而执行之时DOM元素还没有被更新，给了一个机会去获取DOM信息，计算得到一个snapshot，这个snapshot会作为componentDidUpdate的第三个参数传入。</strong></p><pre><code>getSnapshotBeforeUpdate(prevProps, prevState) &#123;
   console.log(&#39;#enter getSnapshotBeforeUpdate&#39;);
   return &#39;foo&#39;;
&#125;

 componentDidUpdate(prevProps, prevState, snapshot) &#123;
   console.log(&#39;#enter componentDidUpdate snapshot = &#39;, snapshot);
 &#125;.
</code></pre><p><strong>getDerivedStateFromProps无论是Mounting还是Updating，也无论是因为什么引起的Updating，全部都会被调用。</strong></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><blockquote><p><strong>用一个静态函数getDerivedStateFromProps来取代被deprecate的几个生命周期函数，就是强制开发者在render之前只做无副作用的操作，而且能做的操作局限在根据props和state决定新的state，而已。</strong></p></blockquote><blockquote><p><strong>引用</strong></p></blockquote><p><a class="link" target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/38030418">程墨Morgan老师的React v16.3之后的组件生命周期函数<i class="fas fa-external-link-alt"></i></a></p></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul><li>本文标题：react的概述</li><li>本文作者：小鱼仙倌</li><li>创建时间：2019-04-03 19:28:59</li><li>本文链接：http://fishfairy.cn/2019/04/03/react-task/</li><li>版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></div><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2019/04/05/redux/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">react-redux</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2019/04/03/react-router/"><span class="title flex-center"><span class="post-nav-title-item">对react-router的封装及api</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2018</span>&nbsp;-&nbsp; 2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">小鱼仙倌</a></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item"><span id="busuanzi_container_site_uv">访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; </span><span id="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></span></div><div class="icp-info info-item"><a target="_blank" rel="nofollow" href="https://beian.miit.gov.cn">晋ICP备18012867号-2</a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item page-aside-toggle"><i class="fas fa-outdent"></i></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-expand-width flex-center"><i class="fas fa-arrows-alt-h"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><aside class="page-aside"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#react%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">react的概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFreact"><span class="nav-number">1.1.</span> <span class="nav-text">什么是react</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#react%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="nav-number">1.2.</span> <span class="nav-text">react的特点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#react%E7%BB%84%E4%BB%B6%E7%9A%84%E5%88%92%E5%88%86"><span class="nav-number">1.3.</span> <span class="nav-text">react组件的划分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BB%84%E4%BB%B6%E6%96%B9%E5%BC%8F"><span class="nav-number">1.4.</span> <span class="nav-text">创建组件方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#render%E7%94%A8%E6%B3%95"><span class="nav-number">1.5.</span> <span class="nav-text">render用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#react%E4%B8%AD%E7%9A%84state"><span class="nav-number">1.6.</span> <span class="nav-text">react中的state</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#react%E7%9A%84%E7%94%9F%E6%98%8E%E5%91%A8%E6%9C%9F"><span class="nav-number">1.7.</span> <span class="nav-text">react的生明周期</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%A0%E6%88%90%E7%BB%84%E4%BB%B6%E6%9B%B4%E6%96%B0%E6%9C%89%E4%B8%A4%E7%B1%BB%EF%BC%88%E4%B8%89%E7%A7%8D%EF%BC%89%E6%83%85%E5%86%B5%EF%BC%9A"><span class="nav-number">1.7.1.</span> <span class="nav-text">造成组件更新有两类（三种）情况：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9A"><span class="nav-number">2.</span> <span class="nav-text">执行顺序：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#React-v16-4-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">3.</span> <span class="nav-text">React v16.4 的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E6%9B%B4%E7%BC%98%E7%94%B1"><span class="nav-number">3.1.</span> <span class="nav-text">变更缘由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="nav-number">3.2.</span> <span class="nav-text">总结：</span></a></li></ol></li></ol></div></div></aside><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/header-shrink.js"></script><script src="/js/back2top.js"></script><script src="/js/dark-light-toggle.js"></script><script src="/js/local-search.js"></script><script src="/js/code-copy.js"></script><script src="/js/lazyload.js"></script><div class="post-scripts"><script src="/js/left-side-toggle.js"></script><script src="/js/libs/anime.min.js"></script><script src="/js/toc.js"></script></div></body></html>